"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[5997],{8046:(t,e,n)=>{n.d(e,{Z:()=>r});var o=n(7896),p=n(2784);function r(t){let{width:e=24,height:n=24,...r}=t;return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0,fill:"currentColor"},r),p.createElement("path",{d:"M19.8,18.4L14,10.67V6.5l1.35-1.69C15.61,4.48,15.38,4,14.96,4H9.04C8.62,4,8.39,4.48,8.65,4.81L10,6.5v4.17L4.2,18.4 C3.71,19.06,4.18,20,5,20h14C19.82,20,20.29,19.06,19.8,18.4z"}))}},2665:(t,e,n)=>{n.d(e,{Z:()=>u});var o=n(1263),p=n(6277),r=n(2784),s=n(9817),c=n(7896);function a(t){let{width:e=24,height:n=24,...o}=t;return r.createElement("svg",(0,c.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},o),r.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}const i={container:"container_lQCo",small:"small_As57",banner:"banner_A4QS",player:"player_tELG",link:"link_BTzN",icon:"icon_wSGd"};function l(t){let{name:e}=t;const n=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${e}.tsx`;return r.createElement(s.Z,{to:n,className:(0,p.Z)("padding--sm",i.link)},r.createElement("span",null,"View source code"),r.createElement(a,{className:i.icon}))}function u(t){let{name:e,banner:n,small:o,link:s}=t;return r.createElement("div",{className:(0,p.Z)(i.container,n&&i.banner,o&&i.small)},r.createElement("motion-canvas-player",{class:i.player,src:`/examples/${e}.js`,auto:n}),r.createElement(l,{name:s||e}))}o.Z.canUseDOM&&n.e(4730).then(n.bind(n,4730))},2072:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(2830),p=n(8617),r=n(2784);function s(t){let{url:e}=t;const n=(0,p.rG)()(e);return r.createElement(o.Z,{reflection:n,headless:!0})}},8588:(t,e,n)=>{n.d(e,{Z:()=>wCr});var o={};n.r(o),n.d(o,{content_0_0:()=>i,content_0_10:()=>C,content_0_100:()=>$e,content_0_1000:()=>tv,content_0_1002:()=>ov,content_0_1004:()=>sv,content_0_1006:()=>iv,content_0_1008:()=>mv,content_0_1010:()=>fv,content_0_1012:()=>Dv,content_0_1014:()=>_v,content_0_1016:()=>Cv,content_0_1018:()=>vv,content_0_102:()=>tn,content_0_1020:()=>bv,content_0_1022:()=>Av,content_0_1024:()=>Wv,content_0_1026:()=>Bv,content_0_1028:()=>Ov,content_0_1030:()=>Vv,content_0_1032:()=>Hv,content_0_1034:()=>$v,content_0_1036:()=>tL,content_0_1038:()=>oL,content_0_104:()=>on,content_0_1040:()=>sL,content_0_1042:()=>iL,content_0_1044:()=>mL,content_0_1046:()=>fL,content_0_1048:()=>DL,content_0_1050:()=>_L,content_0_1052:()=>CL,content_0_1054:()=>vL,content_0_1056:()=>bL,content_0_1058:()=>AL,content_0_106:()=>sn,content_0_1060:()=>WL,content_0_1062:()=>BL,content_0_1064:()=>OL,content_0_1066:()=>VL,content_0_1068:()=>HL,content_0_1070:()=>$L,content_0_1072:()=>tZ,content_0_1074:()=>oZ,content_0_1076:()=>sZ,content_0_1078:()=>iZ,content_0_108:()=>ln,content_0_1080:()=>mZ,content_0_1082:()=>fZ,content_0_1084:()=>DZ,content_0_1086:()=>_Z,content_0_1088:()=>CZ,content_0_1090:()=>vZ,content_0_1092:()=>bZ,content_0_1094:()=>AZ,content_0_1096:()=>WZ,content_0_1098:()=>BZ,content_0_110:()=>dn,content_0_1100:()=>OZ,content_0_1102:()=>VZ,content_0_1104:()=>HZ,content_0_1106:()=>$Z,content_0_1108:()=>tb,content_0_1110:()=>ob,content_0_1112:()=>sb,content_0_1114:()=>ib,content_0_1116:()=>mb,content_0_1118:()=>fb,content_0_112:()=>kn,content_0_1120:()=>Db,content_0_1122:()=>_b,content_0_1124:()=>Cb,content_0_1126:()=>vb,content_0_1128:()=>bb,content_0_1130:()=>Ab,content_0_1132:()=>Wb,content_0_1134:()=>Bb,content_0_1136:()=>Ob,content_0_1138:()=>Vb,content_0_114:()=>Mn,content_0_1140:()=>Hb,content_0_1142:()=>$b,content_0_1144:()=>tN,content_0_1146:()=>oN,content_0_1148:()=>sN,content_0_1150:()=>iN,content_0_1152:()=>mN,content_0_1154:()=>fN,content_0_1156:()=>DN,content_0_1158:()=>_N,content_0_116:()=>wn,content_0_1160:()=>CN,content_0_1162:()=>vN,content_0_1164:()=>bN,content_0_1166:()=>AN,content_0_1168:()=>WN,content_0_1170:()=>BN,content_0_1172:()=>ON,content_0_1174:()=>VN,content_0_1176:()=>HN,content_0_1178:()=>$N,content_0_118:()=>gn,content_0_1180:()=>tz,content_0_1182:()=>oz,content_0_1184:()=>sz,content_0_1186:()=>iz,content_0_1188:()=>mz,content_0_1190:()=>fz,content_0_1192:()=>Dz,content_0_1194:()=>_z,content_0_1196:()=>Cz,content_0_1198:()=>vz,content_0_12:()=>v,content_0_120:()=>Ln,content_0_1200:()=>bz,content_0_1202:()=>Az,content_0_1204:()=>Wz,content_0_1206:()=>Bz,content_0_1208:()=>Oz,content_0_1210:()=>Vz,content_0_1212:()=>Hz,content_0_1214:()=>$z,content_0_1216:()=>tA,content_0_1218:()=>oA,content_0_122:()=>Nn,content_0_1220:()=>sA,content_0_1222:()=>iA,content_0_1224:()=>mA,content_0_1226:()=>fA,content_0_1228:()=>DA,content_0_1230:()=>_A,content_0_1232:()=>CA,content_0_1234:()=>vA,content_0_1236:()=>bA,content_0_1238:()=>AA,content_0_124:()=>Pn,content_0_1240:()=>WA,content_0_1242:()=>BA,content_0_1244:()=>OA,content_0_1246:()=>VA,content_0_1248:()=>HA,content_0_1250:()=>$A,content_0_1252:()=>tP,content_0_1254:()=>oP,content_0_1256:()=>sP,content_0_1258:()=>iP,content_0_126:()=>Rn,content_0_1260:()=>mP,content_0_1262:()=>fP,content_0_1264:()=>DP,content_0_1266:()=>_P,content_0_1268:()=>CP,content_0_1270:()=>vP,content_0_1272:()=>bP,content_0_1274:()=>AP,content_0_1276:()=>WP,content_0_1278:()=>BP,content_0_128:()=>Gn,content_0_1280:()=>OP,content_0_1282:()=>VP,content_0_1284:()=>HP,content_0_1286:()=>$P,content_0_1288:()=>tI,content_0_1290:()=>oI,content_0_1292:()=>sI,content_0_1294:()=>iI,content_0_1296:()=>mI,content_0_1298:()=>fI,content_0_130:()=>Un,content_0_1300:()=>DI,content_0_1302:()=>_I,content_0_1304:()=>CI,content_0_1306:()=>vI,content_0_1308:()=>bI,content_0_1310:()=>AI,content_0_1312:()=>WI,content_0_1314:()=>BI,content_0_1316:()=>OI,content_0_1318:()=>VI,content_0_132:()=>qn,content_0_1320:()=>HI,content_0_1322:()=>$I,content_0_1324:()=>tW,content_0_1326:()=>oW,content_0_1328:()=>sW,content_0_1330:()=>iW,content_0_1332:()=>mW,content_0_1334:()=>fW,content_0_1336:()=>DW,content_0_1338:()=>_W,content_0_134:()=>Yn,content_0_1340:()=>CW,content_0_1342:()=>vW,content_0_1344:()=>bW,content_0_1346:()=>AW,content_0_1348:()=>WW,content_0_1350:()=>BW,content_0_1352:()=>OW,content_0_1354:()=>VW,content_0_1356:()=>HW,content_0_1358:()=>$W,content_0_136:()=>Kn,content_0_1360:()=>tR,content_0_1362:()=>oR,content_0_1364:()=>sR,content_0_1366:()=>iR,content_0_1368:()=>mR,content_0_1370:()=>fR,content_0_1372:()=>DR,content_0_1374:()=>_R,content_0_1376:()=>CR,content_0_1378:()=>vR,content_0_138:()=>eo,content_0_1380:()=>bR,content_0_1382:()=>AR,content_0_1384:()=>WR,content_0_1386:()=>BR,content_0_1388:()=>OR,content_0_1390:()=>VR,content_0_1392:()=>HR,content_0_1394:()=>$R,content_0_1396:()=>tS,content_0_1398:()=>oS,content_0_14:()=>b,content_0_140:()=>po,content_0_1400:()=>sS,content_0_1402:()=>iS,content_0_1404:()=>mS,content_0_1406:()=>fS,content_0_1408:()=>DS,content_0_1410:()=>_S,content_0_1412:()=>CS,content_0_1414:()=>vS,content_0_1416:()=>bS,content_0_1418:()=>AS,content_0_142:()=>co,content_0_1420:()=>WS,content_0_1422:()=>BS,content_0_1424:()=>OS,content_0_1426:()=>VS,content_0_1428:()=>HS,content_0_1430:()=>$S,content_0_1432:()=>tB,content_0_1434:()=>oB,content_0_1436:()=>sB,content_0_1438:()=>iB,content_0_144:()=>lo,content_0_1440:()=>mB,content_0_1442:()=>fB,content_0_1444:()=>DB,content_0_1446:()=>_B,content_0_1448:()=>CB,content_0_1450:()=>vB,content_0_1452:()=>bB,content_0_1454:()=>AB,content_0_1456:()=>WB,content_0_1458:()=>BB,content_0_146:()=>ho,content_0_1460:()=>OB,content_0_1462:()=>VB,content_0_1464:()=>HB,content_0_1466:()=>$B,content_0_1468:()=>tG,content_0_1470:()=>oG,content_0_1472:()=>sG,content_0_1474:()=>iG,content_0_1476:()=>mG,content_0_1478:()=>fG,content_0_148:()=>yo,content_0_1480:()=>DG,content_0_1482:()=>_G,content_0_1484:()=>CG,content_0_1486:()=>vG,content_0_1488:()=>bG,content_0_1490:()=>AG,content_0_1492:()=>WG,content_0_1494:()=>BG,content_0_1496:()=>OG,content_0_1498:()=>VG,content_0_150:()=>Xo,content_0_1500:()=>HG,content_0_1502:()=>$G,content_0_1504:()=>tE,content_0_1506:()=>oE,content_0_1508:()=>sE,content_0_1510:()=>iE,content_0_1512:()=>mE,content_0_1514:()=>fE,content_0_1516:()=>DE,content_0_1518:()=>_E,content_0_152:()=>To,content_0_1520:()=>CE,content_0_1522:()=>vE,content_0_1524:()=>bE,content_0_1526:()=>AE,content_0_1528:()=>WE,content_0_1530:()=>BE,content_0_1532:()=>OE,content_0_1534:()=>VE,content_0_1536:()=>HE,content_0_1538:()=>$E,content_0_154:()=>xo,content_0_1540:()=>tO,content_0_1542:()=>oO,content_0_1544:()=>sO,content_0_1546:()=>iO,content_0_1548:()=>mO,content_0_1550:()=>fO,content_0_1552:()=>DO,content_0_1554:()=>_O,content_0_1556:()=>CO,content_0_1558:()=>vO,content_0_156:()=>Zo,content_0_1560:()=>bO,content_0_1562:()=>AO,content_0_1564:()=>WO,content_0_1566:()=>BO,content_0_1568:()=>OO,content_0_1570:()=>VO,content_0_1572:()=>HO,content_0_1574:()=>$O,content_0_1576:()=>tU,content_0_1578:()=>oU,content_0_158:()=>zo,content_0_1580:()=>sU,content_0_1582:()=>iU,content_0_1584:()=>mU,content_0_1586:()=>fU,content_0_1588:()=>DU,content_0_1590:()=>_U,content_0_1592:()=>CU,content_0_1594:()=>vU,content_0_1596:()=>bU,content_0_1598:()=>AU,content_0_16:()=>A,content_0_160:()=>Io,content_0_1600:()=>WU,content_0_1602:()=>BU,content_0_1604:()=>OU,content_0_1606:()=>VU,content_0_1608:()=>HU,content_0_1610:()=>$U,content_0_1612:()=>tF,content_0_1614:()=>oF,content_0_1616:()=>sF,content_0_1618:()=>iF,content_0_162:()=>So,content_0_1620:()=>mF,content_0_1622:()=>fF,content_0_1624:()=>DF,content_0_1626:()=>_F,content_0_1628:()=>CF,content_0_1630:()=>vF,content_0_1632:()=>bF,content_0_1634:()=>AF,content_0_1636:()=>WF,content_0_1638:()=>BF,content_0_164:()=>Eo,content_0_1640:()=>OF,content_0_1642:()=>VF,content_0_1644:()=>HF,content_0_1646:()=>$F,content_0_1648:()=>tV,content_0_1650:()=>oV,content_0_1652:()=>sV,content_0_1654:()=>iV,content_0_1656:()=>mV,content_0_1658:()=>fV,content_0_166:()=>Fo,content_0_1660:()=>DV,content_0_1662:()=>_V,content_0_1664:()=>CV,content_0_1666:()=>vV,content_0_1668:()=>bV,content_0_1670:()=>AV,content_0_1672:()=>WV,content_0_1674:()=>BV,content_0_1676:()=>OV,content_0_1678:()=>VV,content_0_168:()=>jo,content_0_1680:()=>HV,content_0_1682:()=>$V,content_0_1684:()=>tq,content_0_1686:()=>oq,content_0_1688:()=>sq,content_0_1690:()=>iq,content_0_1692:()=>mq,content_0_1694:()=>fq,content_0_1696:()=>Dq,content_0_1698:()=>_q,content_0_170:()=>Qo,content_0_1700:()=>Cq,content_0_1702:()=>vq,content_0_1704:()=>bq,content_0_1706:()=>Aq,content_0_1708:()=>Wq,content_0_1710:()=>Bq,content_0_1712:()=>Oq,content_0_1714:()=>Vq,content_0_1716:()=>Hq,content_0_1718:()=>$q,content_0_172:()=>Jo,content_0_1720:()=>tj,content_0_1722:()=>oj,content_0_1724:()=>sj,content_0_1726:()=>ij,content_0_1728:()=>mj,content_0_1730:()=>fj,content_0_1732:()=>Dj,content_0_1734:()=>_j,content_0_1736:()=>Cj,content_0_1738:()=>vj,content_0_174:()=>np,content_0_1740:()=>bj,content_0_1742:()=>Aj,content_0_1744:()=>Wj,content_0_1746:()=>Bj,content_0_1748:()=>Oj,content_0_1750:()=>Vj,content_0_1752:()=>Hj,content_0_1754:()=>$j,content_0_1756:()=>tH,content_0_1758:()=>oH,content_0_176:()=>rp,content_0_1760:()=>sH,content_0_1762:()=>iH,content_0_1764:()=>mH,content_0_1766:()=>fH,content_0_1768:()=>DH,content_0_1770:()=>_H,content_0_1772:()=>CH,content_0_1774:()=>vH,content_0_1776:()=>bH,content_0_1778:()=>AH,content_0_178:()=>ap,content_0_1780:()=>WH,content_0_1782:()=>BH,content_0_1784:()=>OH,content_0_1786:()=>VH,content_0_1788:()=>HH,content_0_1790:()=>$H,content_0_1792:()=>tY,content_0_1794:()=>oY,content_0_1796:()=>sY,content_0_1798:()=>iY,content_0_18:()=>W,content_0_180:()=>up,content_0_1800:()=>mY,content_0_1802:()=>fY,content_0_1804:()=>DY,content_0_1806:()=>_Y,content_0_1808:()=>CY,content_0_1810:()=>vY,content_0_1812:()=>bY,content_0_1814:()=>AY,content_0_1816:()=>WY,content_0_1818:()=>BY,content_0_182:()=>hp,content_0_1820:()=>OY,content_0_1822:()=>VY,content_0_1824:()=>HY,content_0_1826:()=>$Y,content_0_1828:()=>tQ,content_0_1830:()=>oQ,content_0_1832:()=>sQ,content_0_1834:()=>iQ,content_0_1836:()=>mQ,content_0_1838:()=>fQ,content_0_184:()=>yp,content_0_1840:()=>DQ,content_0_1842:()=>_Q,content_0_1844:()=>CQ,content_0_1846:()=>vQ,content_0_1848:()=>bQ,content_0_1850:()=>AQ,content_0_1852:()=>WQ,content_0_1854:()=>BQ,content_0_1856:()=>OQ,content_0_1858:()=>VQ,content_0_186:()=>Xp,content_0_1860:()=>HQ,content_0_1862:()=>$Q,content_0_1864:()=>t$,content_0_1866:()=>o$,content_0_1868:()=>s$,content_0_1870:()=>i$,content_0_1872:()=>m$,content_0_1874:()=>f$,content_0_1876:()=>D$,content_0_1878:()=>_$,content_0_188:()=>Tp,content_0_1880:()=>C$,content_0_1882:()=>v$,content_0_1884:()=>b$,content_0_1886:()=>A$,content_0_1888:()=>W$,content_0_190:()=>xp,content_0_192:()=>Zp,content_0_194:()=>zp,content_0_196:()=>Ip,content_0_198:()=>Sp,content_0_2:()=>m,content_0_20:()=>B,content_0_200:()=>Ep,content_0_202:()=>Fp,content_0_204:()=>jp,content_0_206:()=>Qp,content_0_208:()=>Jp,content_0_210:()=>nr,content_0_212:()=>rr,content_0_214:()=>ar,content_0_216:()=>ur,content_0_218:()=>hr,content_0_22:()=>O,content_0_220:()=>yr,content_0_222:()=>Xr,content_0_224:()=>Tr,content_0_226:()=>xr,content_0_228:()=>Zr,content_0_230:()=>zr,content_0_232:()=>Ir,content_0_234:()=>Sr,content_0_236:()=>Er,content_0_238:()=>Fr,content_0_24:()=>V,content_0_240:()=>jr,content_0_242:()=>Qr,content_0_244:()=>Jr,content_0_246:()=>ns,content_0_248:()=>rs,content_0_250:()=>as,content_0_252:()=>us,content_0_254:()=>hs,content_0_256:()=>ys,content_0_258:()=>Xs,content_0_26:()=>H,content_0_260:()=>Ts,content_0_262:()=>xs,content_0_264:()=>Zs,content_0_266:()=>zs,content_0_268:()=>Is,content_0_270:()=>Ss,content_0_272:()=>Es,content_0_274:()=>Fs,content_0_276:()=>js,content_0_278:()=>Qs,content_0_28:()=>$,content_0_280:()=>Js,content_0_282:()=>nc,content_0_284:()=>rc,content_0_286:()=>ac,content_0_288:()=>uc,content_0_290:()=>hc,content_0_292:()=>yc,content_0_294:()=>Xc,content_0_296:()=>Tc,content_0_298:()=>xc,content_0_30:()=>tt,content_0_300:()=>Zc,content_0_302:()=>zc,content_0_304:()=>Ic,content_0_306:()=>Sc,content_0_308:()=>Ec,content_0_310:()=>Fc,content_0_312:()=>jc,content_0_314:()=>Qc,content_0_316:()=>Jc,content_0_318:()=>na,content_0_32:()=>ot,content_0_320:()=>ra,content_0_322:()=>aa,content_0_324:()=>ua,content_0_326:()=>ha,content_0_328:()=>ya,content_0_330:()=>Xa,content_0_332:()=>Ta,content_0_334:()=>xa,content_0_336:()=>Za,content_0_338:()=>za,content_0_34:()=>st,content_0_340:()=>Ia,content_0_342:()=>Sa,content_0_344:()=>Ea,content_0_346:()=>Fa,content_0_348:()=>ja,content_0_350:()=>Qa,content_0_352:()=>Ja,content_0_354:()=>ni,content_0_356:()=>ri,content_0_358:()=>ai,content_0_36:()=>it,content_0_360:()=>ui,content_0_362:()=>hi,content_0_364:()=>yi,content_0_366:()=>Xi,content_0_368:()=>Ti,content_0_370:()=>xi,content_0_372:()=>Zi,content_0_374:()=>zi,content_0_376:()=>Ii,content_0_378:()=>Si,content_0_38:()=>mt,content_0_380:()=>Ei,content_0_382:()=>Fi,content_0_384:()=>ji,content_0_386:()=>Qi,content_0_388:()=>Ji,content_0_390:()=>nl,content_0_392:()=>rl,content_0_394:()=>al,content_0_396:()=>ul,content_0_398:()=>hl,content_0_4:()=>f,content_0_40:()=>ft,content_0_400:()=>yl,content_0_402:()=>Xl,content_0_404:()=>Tl,content_0_406:()=>xl,content_0_408:()=>Zl,content_0_410:()=>zl,content_0_412:()=>Il,content_0_414:()=>Sl,content_0_416:()=>El,content_0_418:()=>Fl,content_0_42:()=>Dt,content_0_420:()=>jl,content_0_422:()=>Ql,content_0_424:()=>Jl,content_0_426:()=>nu,content_0_428:()=>ru,content_0_430:()=>au,content_0_432:()=>uu,content_0_434:()=>hu,content_0_436:()=>yu,content_0_438:()=>Xu,content_0_44:()=>_t,content_0_440:()=>Tu,content_0_442:()=>xu,content_0_444:()=>Zu,content_0_446:()=>zu,content_0_448:()=>Iu,content_0_450:()=>Su,content_0_452:()=>Eu,content_0_454:()=>Fu,content_0_456:()=>ju,content_0_458:()=>Qu,content_0_46:()=>Ct,content_0_460:()=>Ju,content_0_462:()=>nm,content_0_464:()=>rm,content_0_466:()=>am,content_0_468:()=>um,content_0_470:()=>hm,content_0_472:()=>ym,content_0_474:()=>Xm,content_0_476:()=>Tm,content_0_478:()=>xm,content_0_48:()=>vt,content_0_480:()=>Zm,content_0_482:()=>zm,content_0_484:()=>Im,content_0_486:()=>Sm,content_0_488:()=>Em,content_0_490:()=>Fm,content_0_492:()=>jm,content_0_494:()=>Qm,content_0_496:()=>Jm,content_0_498:()=>nd,content_0_50:()=>bt,content_0_500:()=>rd,content_0_502:()=>ad,content_0_504:()=>ud,content_0_506:()=>hd,content_0_508:()=>yd,content_0_510:()=>Xd,content_0_512:()=>Td,content_0_514:()=>xd,content_0_516:()=>Zd,content_0_518:()=>zd,content_0_52:()=>At,content_0_520:()=>Id,content_0_522:()=>Sd,content_0_524:()=>Ed,content_0_526:()=>Fd,content_0_528:()=>jd,content_0_530:()=>Qd,content_0_532:()=>Jd,content_0_534:()=>nh,content_0_536:()=>rh,content_0_538:()=>ah,content_0_54:()=>Wt,content_0_540:()=>uh,content_0_542:()=>hh,content_0_544:()=>yh,content_0_546:()=>Xh,content_0_548:()=>Th,content_0_550:()=>xh,content_0_552:()=>Zh,content_0_554:()=>zh,content_0_556:()=>Ih,content_0_558:()=>Sh,content_0_56:()=>Bt,content_0_560:()=>Eh,content_0_562:()=>Fh,content_0_564:()=>jh,content_0_566:()=>Qh,content_0_568:()=>Jh,content_0_570:()=>nf,content_0_572:()=>rf,content_0_574:()=>af,content_0_576:()=>mf,content_0_578:()=>ff,content_0_58:()=>Ot,content_0_580:()=>Df,content_0_582:()=>_f,content_0_584:()=>Cf,content_0_586:()=>vf,content_0_588:()=>bf,content_0_590:()=>Af,content_0_592:()=>Wf,content_0_594:()=>Bf,content_0_596:()=>Of,content_0_598:()=>Vf,content_0_6:()=>D,content_0_60:()=>Vt,content_0_600:()=>Hf,content_0_602:()=>$f,content_0_604:()=>tk,content_0_606:()=>ok,content_0_608:()=>sk,content_0_610:()=>ik,content_0_612:()=>mk,content_0_614:()=>fk,content_0_616:()=>Dk,content_0_618:()=>_k,content_0_62:()=>Ht,content_0_620:()=>Ck,content_0_622:()=>vk,content_0_624:()=>bk,content_0_626:()=>Ak,content_0_628:()=>Wk,content_0_630:()=>Bk,content_0_632:()=>Ok,content_0_634:()=>Vk,content_0_636:()=>Hk,content_0_638:()=>$k,content_0_64:()=>$t,content_0_640:()=>ty,content_0_642:()=>oy,content_0_644:()=>sy,content_0_646:()=>iy,content_0_648:()=>my,content_0_650:()=>fy,content_0_652:()=>Dy,content_0_654:()=>_y,content_0_656:()=>Cy,content_0_658:()=>vy,content_0_66:()=>te,content_0_660:()=>by,content_0_662:()=>Ay,content_0_664:()=>Wy,content_0_666:()=>By,content_0_668:()=>Oy,content_0_670:()=>Vy,content_0_672:()=>Hy,content_0_674:()=>$y,content_0_676:()=>tD,content_0_678:()=>oD,content_0_68:()=>oe,content_0_680:()=>sD,content_0_682:()=>iD,content_0_684:()=>mD,content_0_686:()=>fD,content_0_688:()=>DD,content_0_690:()=>_D,content_0_692:()=>CD,content_0_694:()=>vD,content_0_696:()=>bD,content_0_698:()=>AD,content_0_70:()=>se,content_0_700:()=>WD,content_0_702:()=>BD,content_0_704:()=>OD,content_0_706:()=>VD,content_0_708:()=>HD,content_0_710:()=>$D,content_0_712:()=>tM,content_0_714:()=>oM,content_0_716:()=>sM,content_0_718:()=>iM,content_0_72:()=>ie,content_0_720:()=>mM,content_0_722:()=>fM,content_0_724:()=>DM,content_0_726:()=>_M,content_0_728:()=>CM,content_0_730:()=>vM,content_0_732:()=>bM,content_0_734:()=>AM,content_0_736:()=>WM,content_0_738:()=>BM,content_0_74:()=>me,content_0_740:()=>OM,content_0_742:()=>VM,content_0_744:()=>HM,content_0_746:()=>$M,content_0_748:()=>tX,content_0_750:()=>oX,content_0_752:()=>sX,content_0_754:()=>iX,content_0_756:()=>mX,content_0_758:()=>fX,content_0_76:()=>fe,content_0_760:()=>DX,content_0_762:()=>_X,content_0_764:()=>CX,content_0_766:()=>vX,content_0_768:()=>bX,content_0_770:()=>AX,content_0_772:()=>WX,content_0_774:()=>BX,content_0_776:()=>OX,content_0_778:()=>VX,content_0_78:()=>De,content_0_780:()=>HX,content_0_782:()=>$X,content_0_784:()=>t_,content_0_786:()=>o_,content_0_788:()=>s_,content_0_790:()=>i_,content_0_792:()=>m_,content_0_794:()=>f_,content_0_796:()=>D_,content_0_798:()=>__,content_0_8:()=>_,content_0_80:()=>_e,content_0_800:()=>C_,content_0_802:()=>v_,content_0_804:()=>b_,content_0_806:()=>A_,content_0_808:()=>W_,content_0_810:()=>B_,content_0_812:()=>O_,content_0_814:()=>V_,content_0_816:()=>H_,content_0_818:()=>$_,content_0_82:()=>Ce,content_0_820:()=>tw,content_0_822:()=>ow,content_0_824:()=>sw,content_0_826:()=>iw,content_0_828:()=>mw,content_0_830:()=>fw,content_0_832:()=>Dw,content_0_834:()=>_w,content_0_836:()=>Cw,content_0_838:()=>vw,content_0_84:()=>ve,content_0_840:()=>bw,content_0_842:()=>Aw,content_0_844:()=>Ww,content_0_846:()=>Bw,content_0_848:()=>Ow,content_0_850:()=>Vw,content_0_852:()=>Hw,content_0_854:()=>$w,content_0_856:()=>tT,content_0_858:()=>oT,content_0_86:()=>be,content_0_860:()=>sT,content_0_862:()=>iT,content_0_864:()=>mT,content_0_866:()=>fT,content_0_868:()=>DT,content_0_870:()=>_T,content_0_872:()=>CT,content_0_874:()=>vT,content_0_876:()=>bT,content_0_878:()=>AT,content_0_88:()=>Ae,content_0_880:()=>WT,content_0_882:()=>BT,content_0_884:()=>OT,content_0_886:()=>VT,content_0_888:()=>HT,content_0_890:()=>$T,content_0_892:()=>tC,content_0_894:()=>oC,content_0_896:()=>sC,content_0_898:()=>iC,content_0_90:()=>We,content_0_900:()=>mC,content_0_902:()=>fC,content_0_904:()=>DC,content_0_906:()=>_C,content_0_908:()=>CC,content_0_910:()=>vC,content_0_912:()=>bC,content_0_914:()=>AC,content_0_916:()=>WC,content_0_918:()=>BC,content_0_92:()=>Be,content_0_920:()=>OC,content_0_922:()=>VC,content_0_924:()=>HC,content_0_926:()=>$C,content_0_928:()=>tg,content_0_930:()=>og,content_0_932:()=>sg,content_0_934:()=>ig,content_0_936:()=>mg,content_0_938:()=>fg,content_0_94:()=>Oe,content_0_940:()=>Dg,content_0_942:()=>_g,content_0_944:()=>Cg,content_0_946:()=>vg,content_0_948:()=>bg,content_0_950:()=>Ag,content_0_952:()=>Wg,content_0_954:()=>Bg,content_0_956:()=>Og,content_0_958:()=>Vg,content_0_96:()=>Ve,content_0_960:()=>Hg,content_0_962:()=>$g,content_0_964:()=>tx,content_0_966:()=>ox,content_0_968:()=>sx,content_0_970:()=>ix,content_0_972:()=>mx,content_0_974:()=>fx,content_0_976:()=>Dx,content_0_978:()=>_x,content_0_98:()=>He,content_0_980:()=>Cx,content_0_982:()=>vx,content_0_984:()=>bx,content_0_986:()=>Ax,content_0_988:()=>Wx,content_0_990:()=>Bx,content_0_992:()=>Ox,content_0_994:()=>Vx,content_0_996:()=>Hx,content_0_998:()=>$x,content_3813_0:()=>B$,content_3813_10:()=>tK,content_3813_100:()=>v0,content_3813_1000:()=>Lft,content_3813_10000:()=>Lip,content_3813_10002:()=>Nip,content_3813_10004:()=>Pip,content_3813_10006:()=>Rip,content_3813_10008:()=>Gip,content_3813_10010:()=>Uip,content_3813_10012:()=>qip,content_3813_10014:()=>Yip,content_3813_10016:()=>Kip,content_3813_10018:()=>elp,content_3813_1002:()=>Nft,content_3813_10020:()=>plp,content_3813_10022:()=>clp,content_3813_10024:()=>llp,content_3813_10026:()=>dlp,content_3813_10028:()=>klp,content_3813_10030:()=>Mlp,content_3813_10032:()=>wlp,content_3813_10034:()=>glp,content_3813_10036:()=>Llp,content_3813_10038:()=>Nlp,content_3813_1004:()=>Pft,content_3813_10040:()=>Plp,content_3813_10042:()=>Rlp,content_3813_10044:()=>Glp,content_3813_10046:()=>Ulp,content_3813_10048:()=>qlp,content_3813_10050:()=>Ylp,content_3813_10052:()=>Klp,content_3813_10054:()=>eup,content_3813_10056:()=>pup,content_3813_10058:()=>cup,content_3813_1006:()=>Rft,content_3813_10060:()=>lup,content_3813_10062:()=>dup,content_3813_10064:()=>kup,content_3813_10066:()=>Mup,content_3813_10068:()=>wup,content_3813_10070:()=>gup,content_3813_10072:()=>Lup,content_3813_10074:()=>Nup,content_3813_10076:()=>Pup,content_3813_10078:()=>Rup,content_3813_1008:()=>Gft,content_3813_10080:()=>Gup,content_3813_10082:()=>Uup,content_3813_10084:()=>qup,content_3813_10086:()=>Yup,content_3813_10088:()=>Kup,content_3813_10090:()=>emp,content_3813_10092:()=>pmp,content_3813_10094:()=>cmp,content_3813_10096:()=>lmp,content_3813_10098:()=>dmp,content_3813_1010:()=>Uft,content_3813_10100:()=>kmp,content_3813_10102:()=>Mmp,content_3813_10104:()=>wmp,content_3813_10106:()=>gmp,content_3813_10108:()=>Lmp,content_3813_10110:()=>Nmp,content_3813_10112:()=>Pmp,content_3813_10114:()=>Rmp,content_3813_10116:()=>Gmp,content_3813_10118:()=>Ump,content_3813_1012:()=>qft,content_3813_10120:()=>qmp,content_3813_10122:()=>Ymp,content_3813_10124:()=>Kmp,content_3813_10126:()=>edp,content_3813_10128:()=>pdp,content_3813_10130:()=>cdp,content_3813_10132:()=>ldp,content_3813_10134:()=>ddp,content_3813_10136:()=>kdp,content_3813_10138:()=>Mdp,content_3813_1014:()=>Yft,content_3813_10140:()=>wdp,content_3813_10142:()=>gdp,content_3813_10144:()=>Ldp,content_3813_10146:()=>Ndp,content_3813_10148:()=>Pdp,content_3813_10150:()=>Rdp,content_3813_10152:()=>Gdp,content_3813_10154:()=>Udp,content_3813_10156:()=>qdp,content_3813_10158:()=>Ydp,content_3813_1016:()=>Kft,content_3813_10160:()=>Kdp,content_3813_10162:()=>ehp,content_3813_10164:()=>php,content_3813_10166:()=>chp,content_3813_10168:()=>lhp,content_3813_10170:()=>dhp,content_3813_10172:()=>khp,content_3813_10174:()=>Mhp,content_3813_10176:()=>whp,content_3813_10178:()=>ghp,content_3813_1018:()=>ekt,content_3813_10180:()=>Lhp,content_3813_10182:()=>Nhp,content_3813_10184:()=>Php,content_3813_10186:()=>Rhp,content_3813_10188:()=>Ghp,content_3813_10190:()=>Uhp,content_3813_10192:()=>qhp,content_3813_10194:()=>Yhp,content_3813_10196:()=>Khp,content_3813_10198:()=>efp,content_3813_102:()=>b0,content_3813_1020:()=>pkt,content_3813_10200:()=>pfp,content_3813_10202:()=>cfp,content_3813_10204:()=>lfp,content_3813_10206:()=>dfp,content_3813_10208:()=>kfp,content_3813_10210:()=>Mfp,content_3813_10212:()=>wfp,content_3813_10214:()=>gfp,content_3813_10216:()=>Lfp,content_3813_10218:()=>Nfp,content_3813_1022:()=>ckt,content_3813_10220:()=>Pfp,content_3813_10222:()=>Rfp,content_3813_10224:()=>Gfp,content_3813_10226:()=>Ufp,content_3813_10228:()=>qfp,content_3813_10230:()=>Yfp,content_3813_10232:()=>Kfp,content_3813_10234:()=>ekp,content_3813_10236:()=>pkp,content_3813_10238:()=>ckp,content_3813_1024:()=>lkt,content_3813_10240:()=>lkp,content_3813_10242:()=>dkp,content_3813_10244:()=>kkp,content_3813_10246:()=>Mkp,content_3813_10248:()=>wkp,content_3813_10250:()=>gkp,content_3813_10252:()=>Lkp,content_3813_10254:()=>Nkp,content_3813_10256:()=>Pkp,content_3813_10258:()=>Rkp,content_3813_1026:()=>dkt,content_3813_10260:()=>Gkp,content_3813_10262:()=>Ukp,content_3813_10264:()=>qkp,content_3813_10266:()=>Ykp,content_3813_10268:()=>Kkp,content_3813_10270:()=>eyp,content_3813_10272:()=>pyp,content_3813_10274:()=>cyp,content_3813_10276:()=>lyp,content_3813_10278:()=>dyp,content_3813_1028:()=>kkt,content_3813_10280:()=>kyp,content_3813_10282:()=>Myp,content_3813_10284:()=>wyp,content_3813_10286:()=>gyp,content_3813_10288:()=>Lyp,content_3813_10290:()=>Nyp,content_3813_10292:()=>Pyp,content_3813_10294:()=>Ryp,content_3813_10296:()=>Gyp,content_3813_10298:()=>Uyp,content_3813_1030:()=>Mkt,content_3813_10300:()=>qyp,content_3813_10302:()=>Yyp,content_3813_10304:()=>Kyp,content_3813_10306:()=>eDp,content_3813_10308:()=>pDp,content_3813_10310:()=>cDp,content_3813_10312:()=>lDp,content_3813_10314:()=>dDp,content_3813_10316:()=>kDp,content_3813_10318:()=>MDp,content_3813_1032:()=>wkt,content_3813_10320:()=>wDp,content_3813_10322:()=>gDp,content_3813_10324:()=>LDp,content_3813_10326:()=>NDp,content_3813_10328:()=>PDp,content_3813_10330:()=>RDp,content_3813_10332:()=>GDp,content_3813_10334:()=>UDp,content_3813_10336:()=>qDp,content_3813_10338:()=>YDp,content_3813_1034:()=>gkt,content_3813_10340:()=>KDp,content_3813_10342:()=>eMp,content_3813_10344:()=>pMp,content_3813_10346:()=>cMp,content_3813_10348:()=>lMp,content_3813_10350:()=>dMp,content_3813_10352:()=>kMp,content_3813_10354:()=>MMp,content_3813_10356:()=>wMp,content_3813_10358:()=>gMp,content_3813_1036:()=>Lkt,content_3813_10360:()=>LMp,content_3813_10362:()=>NMp,content_3813_10364:()=>PMp,content_3813_10366:()=>RMp,content_3813_10368:()=>GMp,content_3813_10370:()=>UMp,content_3813_10372:()=>qMp,content_3813_10374:()=>YMp,content_3813_10376:()=>KMp,content_3813_10378:()=>eXp,content_3813_1038:()=>Nkt,content_3813_10380:()=>pXp,content_3813_10382:()=>cXp,content_3813_10384:()=>lXp,content_3813_10386:()=>dXp,content_3813_10388:()=>kXp,content_3813_10390:()=>MXp,content_3813_10392:()=>wXp,content_3813_10394:()=>gXp,content_3813_10396:()=>LXp,content_3813_10398:()=>NXp,content_3813_104:()=>A0,content_3813_1040:()=>Pkt,content_3813_10400:()=>PXp,content_3813_10402:()=>RXp,content_3813_10404:()=>GXp,content_3813_10406:()=>UXp,content_3813_10408:()=>qXp,content_3813_10410:()=>YXp,content_3813_10412:()=>KXp,content_3813_10414:()=>e_p,content_3813_10416:()=>p_p,content_3813_10418:()=>c_p,content_3813_1042:()=>Rkt,content_3813_10420:()=>l_p,content_3813_10422:()=>d_p,content_3813_10424:()=>k_p,content_3813_10426:()=>M_p,content_3813_10428:()=>w_p,content_3813_10430:()=>g_p,content_3813_10432:()=>L_p,content_3813_10434:()=>N_p,content_3813_10436:()=>P_p,content_3813_10438:()=>R_p,content_3813_1044:()=>Gkt,content_3813_10440:()=>G_p,content_3813_10442:()=>U_p,content_3813_10444:()=>q_p,content_3813_10446:()=>Y_p,content_3813_10448:()=>K_p,content_3813_10450:()=>ewp,content_3813_10452:()=>pwp,content_3813_10454:()=>cwp,content_3813_10456:()=>lwp,content_3813_10458:()=>dwp,content_3813_1046:()=>Ukt,content_3813_10460:()=>kwp,content_3813_10462:()=>Mwp,content_3813_10464:()=>wwp,content_3813_10466:()=>gwp,content_3813_10468:()=>Lwp,content_3813_10470:()=>Nwp,content_3813_10472:()=>Pwp,content_3813_10474:()=>Rwp,content_3813_10476:()=>Gwp,content_3813_10478:()=>Uwp,content_3813_1048:()=>qkt,content_3813_10480:()=>qwp,content_3813_10482:()=>Ywp,content_3813_10484:()=>Kwp,content_3813_10486:()=>eTp,content_3813_10488:()=>pTp,content_3813_10490:()=>cTp,content_3813_10492:()=>lTp,content_3813_10494:()=>dTp,content_3813_10496:()=>kTp,content_3813_10498:()=>MTp,content_3813_1050:()=>Ykt,content_3813_10500:()=>wTp,content_3813_10502:()=>gTp,content_3813_10504:()=>LTp,content_3813_10506:()=>NTp,content_3813_10508:()=>PTp,content_3813_10510:()=>RTp,content_3813_10512:()=>GTp,content_3813_10514:()=>UTp,content_3813_10516:()=>qTp,content_3813_10518:()=>YTp,content_3813_1052:()=>Kkt,content_3813_10520:()=>KTp,content_3813_10522:()=>eCp,content_3813_10524:()=>pCp,content_3813_10526:()=>cCp,content_3813_10528:()=>lCp,content_3813_10530:()=>dCp,content_3813_10532:()=>kCp,content_3813_10534:()=>MCp,content_3813_10536:()=>wCp,content_3813_10538:()=>gCp,content_3813_1054:()=>eyt,content_3813_10540:()=>LCp,content_3813_10542:()=>NCp,content_3813_10544:()=>PCp,content_3813_10546:()=>RCp,content_3813_10548:()=>GCp,content_3813_10550:()=>UCp,content_3813_10552:()=>qCp,content_3813_10554:()=>YCp,content_3813_10556:()=>KCp,content_3813_10558:()=>egp,content_3813_1056:()=>pyt,content_3813_10560:()=>pgp,content_3813_10562:()=>cgp,content_3813_10564:()=>lgp,content_3813_10566:()=>dgp,content_3813_10568:()=>kgp,content_3813_10570:()=>Mgp,content_3813_10572:()=>wgp,content_3813_10574:()=>ggp,content_3813_10576:()=>Lgp,content_3813_10578:()=>Ngp,content_3813_1058:()=>cyt,content_3813_10580:()=>Pgp,content_3813_10582:()=>Rgp,content_3813_10584:()=>Ggp,content_3813_10586:()=>Ugp,content_3813_10588:()=>qgp,content_3813_10590:()=>Ygp,content_3813_10592:()=>Kgp,content_3813_10594:()=>exp,content_3813_10596:()=>pxp,content_3813_10598:()=>cxp,content_3813_106:()=>W0,content_3813_1060:()=>lyt,content_3813_10600:()=>lxp,content_3813_10602:()=>dxp,content_3813_10604:()=>kxp,content_3813_10606:()=>Mxp,content_3813_10608:()=>wxp,content_3813_10610:()=>gxp,content_3813_10612:()=>Lxp,content_3813_10614:()=>Nxp,content_3813_10616:()=>Pxp,content_3813_10618:()=>Rxp,content_3813_1062:()=>dyt,content_3813_10620:()=>Gxp,content_3813_10622:()=>Uxp,content_3813_10624:()=>qxp,content_3813_10626:()=>Yxp,content_3813_10628:()=>Kxp,content_3813_10630:()=>evp,content_3813_10632:()=>pvp,content_3813_10634:()=>cvp,content_3813_10636:()=>lvp,content_3813_10638:()=>dvp,content_3813_1064:()=>kyt,content_3813_10640:()=>kvp,content_3813_10642:()=>Mvp,content_3813_10644:()=>wvp,content_3813_10646:()=>gvp,content_3813_10648:()=>Lvp,content_3813_10650:()=>Nvp,content_3813_10652:()=>Pvp,content_3813_10654:()=>Rvp,content_3813_10656:()=>Gvp,content_3813_10658:()=>Uvp,content_3813_1066:()=>Myt,content_3813_10660:()=>qvp,content_3813_10662:()=>Yvp,content_3813_10664:()=>Kvp,content_3813_10666:()=>eLp,content_3813_10668:()=>pLp,content_3813_10670:()=>cLp,content_3813_10672:()=>lLp,content_3813_10674:()=>dLp,content_3813_10676:()=>kLp,content_3813_10678:()=>MLp,content_3813_1068:()=>wyt,content_3813_10680:()=>wLp,content_3813_10682:()=>gLp,content_3813_10684:()=>LLp,content_3813_10686:()=>NLp,content_3813_10688:()=>PLp,content_3813_10690:()=>RLp,content_3813_10692:()=>GLp,content_3813_10694:()=>ULp,content_3813_10696:()=>qLp,content_3813_10698:()=>YLp,content_3813_1070:()=>gyt,content_3813_10700:()=>KLp,content_3813_10702:()=>eZp,content_3813_10704:()=>pZp,content_3813_10706:()=>cZp,content_3813_10708:()=>lZp,content_3813_10710:()=>dZp,content_3813_10712:()=>kZp,content_3813_10714:()=>MZp,content_3813_10716:()=>wZp,content_3813_10718:()=>gZp,content_3813_1072:()=>Lyt,content_3813_10720:()=>LZp,content_3813_10722:()=>NZp,content_3813_10724:()=>PZp,content_3813_10726:()=>RZp,content_3813_10728:()=>GZp,content_3813_10730:()=>UZp,content_3813_10732:()=>qZp,content_3813_10734:()=>YZp,content_3813_10736:()=>KZp,content_3813_10738:()=>ebp,content_3813_1074:()=>Nyt,content_3813_10740:()=>pbp,content_3813_10742:()=>cbp,content_3813_10744:()=>lbp,content_3813_10746:()=>dbp,content_3813_10748:()=>kbp,content_3813_10750:()=>Mbp,content_3813_10752:()=>wbp,content_3813_10754:()=>gbp,content_3813_10756:()=>Lbp,content_3813_10758:()=>Nbp,content_3813_1076:()=>Pyt,content_3813_10760:()=>Pbp,content_3813_10762:()=>Rbp,content_3813_10764:()=>Gbp,content_3813_10766:()=>Ubp,content_3813_10768:()=>qbp,content_3813_10770:()=>Ybp,content_3813_10772:()=>Kbp,content_3813_10774:()=>eNp,content_3813_10776:()=>pNp,content_3813_10778:()=>cNp,content_3813_1078:()=>Ryt,content_3813_10780:()=>lNp,content_3813_10782:()=>dNp,content_3813_10784:()=>kNp,content_3813_10786:()=>MNp,content_3813_10788:()=>wNp,content_3813_10790:()=>gNp,content_3813_10792:()=>LNp,content_3813_10794:()=>NNp,content_3813_10796:()=>PNp,content_3813_10798:()=>RNp,content_3813_108:()=>B0,content_3813_1080:()=>Gyt,content_3813_10800:()=>GNp,content_3813_10802:()=>UNp,content_3813_10804:()=>qNp,content_3813_10806:()=>YNp,content_3813_10808:()=>KNp,content_3813_10810:()=>ezp,content_3813_10812:()=>pzp,content_3813_10814:()=>czp,content_3813_10816:()=>lzp,content_3813_10818:()=>dzp,content_3813_1082:()=>Uyt,content_3813_10820:()=>kzp,content_3813_10822:()=>Mzp,content_3813_10824:()=>wzp,content_3813_10826:()=>gzp,content_3813_10828:()=>Lzp,content_3813_10830:()=>Nzp,content_3813_10832:()=>Pzp,content_3813_10834:()=>Rzp,content_3813_10836:()=>Gzp,content_3813_10838:()=>Uzp,content_3813_1084:()=>qyt,content_3813_10840:()=>qzp,content_3813_10842:()=>Yzp,content_3813_10844:()=>Kzp,content_3813_10846:()=>eAp,content_3813_10848:()=>pAp,content_3813_10850:()=>cAp,content_3813_10852:()=>lAp,content_3813_10854:()=>dAp,content_3813_10856:()=>kAp,content_3813_10858:()=>MAp,content_3813_1086:()=>Yyt,content_3813_10860:()=>wAp,content_3813_10862:()=>gAp,content_3813_10864:()=>LAp,content_3813_10866:()=>NAp,content_3813_10868:()=>PAp,content_3813_10870:()=>RAp,content_3813_10872:()=>GAp,content_3813_10874:()=>UAp,content_3813_10876:()=>qAp,content_3813_10878:()=>YAp,content_3813_1088:()=>Kyt,content_3813_10880:()=>KAp,content_3813_10882:()=>ePp,content_3813_10884:()=>pPp,content_3813_10886:()=>cPp,content_3813_10888:()=>lPp,content_3813_10890:()=>dPp,content_3813_10892:()=>kPp,content_3813_10894:()=>MPp,content_3813_10896:()=>wPp,content_3813_10898:()=>gPp,content_3813_1090:()=>eDt,content_3813_10900:()=>LPp,content_3813_10902:()=>NPp,content_3813_10904:()=>PPp,content_3813_10906:()=>RPp,content_3813_10908:()=>GPp,content_3813_10910:()=>UPp,content_3813_10912:()=>qPp,content_3813_10914:()=>YPp,content_3813_10916:()=>KPp,content_3813_10918:()=>eIp,content_3813_1092:()=>pDt,content_3813_10920:()=>pIp,content_3813_10922:()=>cIp,content_3813_10924:()=>lIp,content_3813_10926:()=>dIp,content_3813_10928:()=>kIp,content_3813_10930:()=>MIp,content_3813_10932:()=>wIp,content_3813_10934:()=>gIp,content_3813_10936:()=>LIp,content_3813_10938:()=>NIp,content_3813_1094:()=>cDt,content_3813_10940:()=>PIp,content_3813_10942:()=>RIp,content_3813_10944:()=>GIp,content_3813_10946:()=>UIp,content_3813_10948:()=>qIp,content_3813_10950:()=>YIp,content_3813_10952:()=>KIp,content_3813_10954:()=>eWp,content_3813_10956:()=>pWp,content_3813_10958:()=>cWp,content_3813_1096:()=>lDt,content_3813_10960:()=>lWp,content_3813_10962:()=>dWp,content_3813_10964:()=>kWp,content_3813_10966:()=>MWp,content_3813_10968:()=>wWp,content_3813_10970:()=>gWp,content_3813_10972:()=>LWp,content_3813_10974:()=>NWp,content_3813_10976:()=>PWp,content_3813_10978:()=>RWp,content_3813_1098:()=>dDt,content_3813_10980:()=>GWp,content_3813_10982:()=>UWp,content_3813_10984:()=>qWp,content_3813_10986:()=>YWp,content_3813_10988:()=>KWp,content_3813_10990:()=>eRp,content_3813_10992:()=>pRp,content_3813_10994:()=>cRp,content_3813_10996:()=>lRp,content_3813_10998:()=>dRp,content_3813_110:()=>O0,content_3813_1100:()=>kDt,content_3813_11000:()=>kRp,content_3813_11002:()=>MRp,content_3813_11004:()=>wRp,content_3813_11006:()=>gRp,content_3813_11008:()=>LRp,content_3813_11010:()=>NRp,content_3813_11012:()=>PRp,content_3813_11014:()=>RRp,content_3813_11016:()=>GRp,content_3813_11018:()=>URp,content_3813_1102:()=>MDt,content_3813_11020:()=>qRp,content_3813_11022:()=>YRp,content_3813_11024:()=>KRp,content_3813_11026:()=>eSp,content_3813_11028:()=>pSp,content_3813_11030:()=>cSp,content_3813_11032:()=>lSp,content_3813_11034:()=>dSp,content_3813_11036:()=>kSp,content_3813_11038:()=>MSp,content_3813_1104:()=>wDt,content_3813_11040:()=>wSp,content_3813_11042:()=>gSp,content_3813_11044:()=>LSp,content_3813_11046:()=>NSp,content_3813_11048:()=>PSp,content_3813_11050:()=>RSp,content_3813_11052:()=>GSp,content_3813_11054:()=>USp,content_3813_11056:()=>qSp,content_3813_11058:()=>YSp,content_3813_1106:()=>gDt,content_3813_11060:()=>KSp,content_3813_11062:()=>eBp,content_3813_11064:()=>pBp,content_3813_11066:()=>cBp,content_3813_11068:()=>lBp,content_3813_11070:()=>dBp,content_3813_11072:()=>kBp,content_3813_11074:()=>MBp,content_3813_11076:()=>wBp,content_3813_11078:()=>gBp,content_3813_1108:()=>LDt,content_3813_11080:()=>LBp,content_3813_11082:()=>NBp,content_3813_11084:()=>PBp,content_3813_11086:()=>RBp,content_3813_11088:()=>GBp,content_3813_11090:()=>UBp,content_3813_11092:()=>qBp,content_3813_11094:()=>YBp,content_3813_11096:()=>KBp,content_3813_11098:()=>eGp,content_3813_1110:()=>NDt,content_3813_11100:()=>pGp,content_3813_11102:()=>cGp,content_3813_11104:()=>lGp,content_3813_11106:()=>dGp,content_3813_11108:()=>kGp,content_3813_11110:()=>MGp,content_3813_11112:()=>wGp,content_3813_11114:()=>gGp,content_3813_11116:()=>LGp,content_3813_11118:()=>NGp,content_3813_1112:()=>PDt,content_3813_11120:()=>PGp,content_3813_11122:()=>RGp,content_3813_11124:()=>GGp,content_3813_11126:()=>UGp,content_3813_11128:()=>qGp,content_3813_11130:()=>YGp,content_3813_11132:()=>KGp,content_3813_11134:()=>eEp,content_3813_11136:()=>pEp,content_3813_11138:()=>cEp,content_3813_1114:()=>RDt,content_3813_11140:()=>lEp,content_3813_11142:()=>dEp,content_3813_11144:()=>kEp,content_3813_11146:()=>MEp,content_3813_11148:()=>wEp,content_3813_11150:()=>gEp,content_3813_11152:()=>LEp,content_3813_11154:()=>NEp,content_3813_11156:()=>PEp,content_3813_11158:()=>REp,content_3813_1116:()=>GDt,content_3813_11160:()=>GEp,content_3813_11162:()=>UEp,content_3813_11164:()=>qEp,content_3813_11166:()=>YEp,content_3813_11168:()=>KEp,content_3813_11170:()=>eOp,content_3813_11172:()=>pOp,content_3813_11174:()=>cOp,content_3813_11176:()=>lOp,content_3813_11178:()=>dOp,content_3813_1118:()=>UDt,content_3813_11180:()=>kOp,content_3813_11182:()=>MOp,content_3813_11184:()=>wOp,content_3813_11186:()=>gOp,content_3813_11188:()=>LOp,content_3813_11190:()=>NOp,content_3813_11192:()=>POp,content_3813_11194:()=>ROp,content_3813_11196:()=>GOp,content_3813_11198:()=>UOp,content_3813_112:()=>V0,content_3813_1120:()=>qDt,content_3813_11200:()=>qOp,content_3813_11202:()=>YOp,content_3813_11204:()=>KOp,content_3813_11206:()=>eUp,content_3813_11208:()=>pUp,content_3813_11210:()=>cUp,content_3813_11212:()=>lUp,content_3813_11214:()=>dUp,content_3813_11216:()=>kUp,content_3813_11218:()=>MUp,content_3813_1122:()=>YDt,content_3813_11220:()=>wUp,content_3813_11222:()=>gUp,content_3813_11224:()=>LUp,content_3813_11226:()=>NUp,content_3813_11228:()=>PUp,content_3813_11230:()=>RUp,content_3813_11232:()=>GUp,content_3813_11234:()=>UUp,content_3813_11236:()=>qUp,content_3813_11238:()=>YUp,content_3813_1124:()=>KDt,content_3813_11240:()=>KUp,content_3813_11242:()=>eFp,content_3813_11244:()=>pFp,content_3813_11246:()=>cFp,content_3813_11248:()=>lFp,content_3813_11250:()=>dFp,content_3813_11252:()=>kFp,content_3813_11254:()=>MFp,content_3813_11256:()=>wFp,content_3813_11258:()=>gFp,content_3813_1126:()=>eMt,content_3813_11260:()=>LFp,content_3813_11262:()=>NFp,content_3813_11264:()=>PFp,content_3813_11266:()=>RFp,content_3813_11268:()=>GFp,content_3813_11270:()=>UFp,content_3813_11272:()=>qFp,content_3813_11274:()=>YFp,content_3813_11276:()=>KFp,content_3813_11278:()=>eVp,content_3813_1128:()=>pMt,content_3813_11280:()=>pVp,content_3813_11282:()=>cVp,content_3813_11284:()=>lVp,content_3813_11286:()=>dVp,content_3813_11288:()=>kVp,content_3813_11290:()=>MVp,content_3813_11292:()=>wVp,content_3813_11294:()=>gVp,content_3813_11296:()=>LVp,content_3813_11298:()=>NVp,content_3813_1130:()=>cMt,content_3813_11300:()=>PVp,content_3813_11302:()=>RVp,content_3813_11304:()=>GVp,content_3813_11306:()=>UVp,content_3813_11308:()=>qVp,content_3813_11310:()=>YVp,content_3813_11312:()=>KVp,content_3813_11314:()=>eqp,content_3813_11316:()=>pqp,content_3813_11318:()=>cqp,content_3813_1132:()=>lMt,content_3813_11320:()=>lqp,content_3813_11322:()=>dqp,content_3813_11324:()=>kqp,content_3813_11326:()=>Mqp,content_3813_11328:()=>wqp,content_3813_11330:()=>gqp,content_3813_11332:()=>Lqp,content_3813_11334:()=>Nqp,content_3813_11336:()=>Pqp,content_3813_11338:()=>Rqp,content_3813_1134:()=>dMt,content_3813_11340:()=>Gqp,content_3813_11342:()=>Uqp,content_3813_11344:()=>qqp,content_3813_11346:()=>Yqp,content_3813_11348:()=>Kqp,content_3813_11350:()=>ejp,content_3813_11352:()=>pjp,content_3813_11354:()=>cjp,content_3813_11356:()=>ljp,content_3813_11358:()=>djp,content_3813_1136:()=>kMt,content_3813_11360:()=>kjp,content_3813_11362:()=>Mjp,content_3813_11364:()=>wjp,content_3813_11366:()=>gjp,content_3813_11368:()=>Ljp,content_3813_11370:()=>Njp,content_3813_11372:()=>Pjp,content_3813_11374:()=>Rjp,content_3813_11376:()=>Gjp,content_3813_11378:()=>Ujp,content_3813_1138:()=>MMt,content_3813_11380:()=>qjp,content_3813_11382:()=>Yjp,content_3813_11384:()=>Kjp,content_3813_11386:()=>eHp,content_3813_11388:()=>pHp,content_3813_11390:()=>cHp,content_3813_11392:()=>lHp,content_3813_11394:()=>dHp,content_3813_11396:()=>kHp,content_3813_11398:()=>MHp,content_3813_114:()=>H0,content_3813_1140:()=>wMt,content_3813_11400:()=>wHp,content_3813_11402:()=>gHp,content_3813_11404:()=>LHp,content_3813_11406:()=>NHp,content_3813_11408:()=>PHp,content_3813_11410:()=>RHp,content_3813_11412:()=>GHp,content_3813_11414:()=>UHp,content_3813_11416:()=>qHp,content_3813_11418:()=>YHp,content_3813_1142:()=>gMt,content_3813_11420:()=>KHp,content_3813_11422:()=>eYp,content_3813_11424:()=>pYp,content_3813_11426:()=>cYp,content_3813_11428:()=>lYp,content_3813_11430:()=>dYp,content_3813_11432:()=>kYp,content_3813_11434:()=>MYp,content_3813_11436:()=>wYp,content_3813_11438:()=>gYp,content_3813_1144:()=>LMt,content_3813_11440:()=>LYp,content_3813_11442:()=>NYp,content_3813_11444:()=>PYp,content_3813_11446:()=>RYp,content_3813_11448:()=>GYp,content_3813_11450:()=>UYp,content_3813_11452:()=>qYp,content_3813_11454:()=>YYp,content_3813_11456:()=>KYp,content_3813_11458:()=>eQp,content_3813_1146:()=>NMt,content_3813_11460:()=>pQp,content_3813_11462:()=>cQp,content_3813_11464:()=>lQp,content_3813_11466:()=>dQp,content_3813_11468:()=>kQp,content_3813_11470:()=>MQp,content_3813_11472:()=>wQp,content_3813_11474:()=>gQp,content_3813_11476:()=>LQp,content_3813_11478:()=>NQp,content_3813_1148:()=>PMt,content_3813_11480:()=>PQp,content_3813_11482:()=>RQp,content_3813_11484:()=>GQp,content_3813_11486:()=>UQp,content_3813_11488:()=>qQp,content_3813_11490:()=>YQp,content_3813_11492:()=>KQp,content_3813_11494:()=>e$p,content_3813_11496:()=>p$p,content_3813_11498:()=>c$p,content_3813_1150:()=>RMt,content_3813_11500:()=>l$p,content_3813_11502:()=>d$p,content_3813_11504:()=>k$p,content_3813_11506:()=>M$p,content_3813_11508:()=>w$p,content_3813_11510:()=>g$p,content_3813_11512:()=>L$p,content_3813_11514:()=>N$p,content_3813_11516:()=>P$p,content_3813_11518:()=>R$p,content_3813_1152:()=>GMt,content_3813_11520:()=>G$p,content_3813_11522:()=>U$p,content_3813_11524:()=>q$p,content_3813_11526:()=>Y$p,content_3813_11528:()=>K$p,content_3813_11530:()=>eKp,content_3813_11532:()=>pKp,content_3813_11534:()=>cKp,content_3813_11536:()=>lKp,content_3813_11538:()=>dKp,content_3813_1154:()=>UMt,content_3813_11540:()=>kKp,content_3813_11542:()=>MKp,content_3813_11544:()=>wKp,content_3813_11546:()=>gKp,content_3813_11548:()=>LKp,content_3813_11550:()=>NKp,content_3813_11552:()=>PKp,content_3813_11554:()=>RKp,content_3813_11556:()=>GKp,content_3813_11558:()=>UKp,content_3813_1156:()=>qMt,content_3813_11560:()=>qKp,content_3813_11562:()=>YKp,content_3813_11564:()=>KKp,content_3813_11566:()=>eJp,content_3813_11568:()=>pJp,content_3813_11570:()=>cJp,content_3813_11572:()=>lJp,content_3813_11574:()=>dJp,content_3813_11576:()=>kJp,content_3813_11578:()=>MJp,content_3813_1158:()=>YMt,content_3813_11580:()=>wJp,content_3813_11582:()=>gJp,content_3813_11584:()=>LJp,content_3813_11586:()=>NJp,content_3813_11588:()=>PJp,content_3813_11590:()=>RJp,content_3813_11592:()=>GJp,content_3813_11594:()=>UJp,content_3813_11596:()=>qJp,content_3813_11598:()=>YJp,content_3813_116:()=>$0,content_3813_1160:()=>KMt,content_3813_11600:()=>KJp,content_3813_11602:()=>e0p,content_3813_11604:()=>p0p,content_3813_11606:()=>c0p,content_3813_11608:()=>l0p,content_3813_11610:()=>d0p,content_3813_11612:()=>k0p,content_3813_11614:()=>M0p,content_3813_11616:()=>w0p,content_3813_11618:()=>g0p,content_3813_1162:()=>eXt,content_3813_11620:()=>L0p,content_3813_11622:()=>N0p,content_3813_11624:()=>P0p,content_3813_11626:()=>R0p,content_3813_11628:()=>G0p,content_3813_11630:()=>U0p,content_3813_11632:()=>q0p,content_3813_11634:()=>Y0p,content_3813_11636:()=>K0p,content_3813_11638:()=>e3p,content_3813_1164:()=>pXt,content_3813_11640:()=>p3p,content_3813_11642:()=>c3p,content_3813_11644:()=>l3p,content_3813_11646:()=>d3p,content_3813_11648:()=>k3p,content_3813_11650:()=>M3p,content_3813_11652:()=>w3p,content_3813_11654:()=>g3p,content_3813_11656:()=>L3p,content_3813_11658:()=>N3p,content_3813_1166:()=>cXt,content_3813_11660:()=>P3p,content_3813_11662:()=>R3p,content_3813_11664:()=>G3p,content_3813_11666:()=>U3p,content_3813_11668:()=>q3p,content_3813_11670:()=>Y3p,content_3813_11672:()=>K3p,content_3813_11674:()=>e1p,content_3813_11676:()=>p1p,content_3813_11678:()=>c1p,content_3813_1168:()=>lXt,content_3813_11680:()=>l1p,content_3813_11682:()=>d1p,content_3813_11684:()=>k1p,content_3813_11686:()=>M1p,content_3813_11688:()=>w1p,content_3813_11690:()=>g1p,content_3813_11692:()=>L1p,content_3813_11694:()=>N1p,content_3813_11696:()=>P1p,content_3813_11698:()=>R1p,content_3813_1170:()=>dXt,content_3813_11700:()=>G1p,content_3813_11702:()=>U1p,content_3813_11704:()=>q1p,content_3813_11706:()=>Y1p,content_3813_11708:()=>K1p,content_3813_11710:()=>e8p,content_3813_11712:()=>p8p,content_3813_11714:()=>c8p,content_3813_11716:()=>l8p,content_3813_11718:()=>d8p,content_3813_1172:()=>kXt,content_3813_11720:()=>k8p,content_3813_11722:()=>M8p,content_3813_11724:()=>w8p,content_3813_11726:()=>g8p,content_3813_11728:()=>L8p,content_3813_11730:()=>N8p,content_3813_11732:()=>P8p,content_3813_11734:()=>R8p,content_3813_11736:()=>G8p,content_3813_11738:()=>U8p,content_3813_1174:()=>MXt,content_3813_11740:()=>q8p,content_3813_11742:()=>Y8p,content_3813_11744:()=>K8p,content_3813_11746:()=>e2p,content_3813_11748:()=>p2p,content_3813_11750:()=>c2p,content_3813_11752:()=>l2p,content_3813_11754:()=>d2p,content_3813_11756:()=>k2p,content_3813_11758:()=>M2p,content_3813_1176:()=>wXt,content_3813_11760:()=>w2p,content_3813_11762:()=>g2p,content_3813_11764:()=>L2p,content_3813_11766:()=>N2p,content_3813_11768:()=>P2p,content_3813_11770:()=>R2p,content_3813_11772:()=>G2p,content_3813_11774:()=>U2p,content_3813_11776:()=>q2p,content_3813_11778:()=>Y2p,content_3813_1178:()=>gXt,content_3813_11780:()=>K2p,content_3813_11782:()=>e4p,content_3813_11784:()=>p4p,content_3813_11786:()=>c4p,content_3813_11788:()=>l4p,content_3813_11790:()=>d4p,content_3813_11792:()=>k4p,content_3813_11794:()=>M4p,content_3813_11796:()=>w4p,content_3813_11798:()=>g4p,content_3813_118:()=>t3,content_3813_1180:()=>LXt,content_3813_11800:()=>L4p,content_3813_11802:()=>N4p,content_3813_11804:()=>P4p,content_3813_11806:()=>R4p,content_3813_11808:()=>G4p,content_3813_11810:()=>U4p,content_3813_11812:()=>q4p,content_3813_11814:()=>Y4p,content_3813_11816:()=>K4p,content_3813_11818:()=>e6p,content_3813_1182:()=>NXt,content_3813_11820:()=>p6p,content_3813_11822:()=>c6p,content_3813_11824:()=>l6p,content_3813_11826:()=>d6p,content_3813_11828:()=>k6p,content_3813_11830:()=>M6p,content_3813_11832:()=>w6p,content_3813_11834:()=>g6p,content_3813_11836:()=>L6p,content_3813_11838:()=>N6p,content_3813_1184:()=>PXt,content_3813_11840:()=>P6p,content_3813_11842:()=>R6p,content_3813_11844:()=>G6p,content_3813_11846:()=>U6p,content_3813_11848:()=>q6p,content_3813_11850:()=>Y6p,content_3813_11852:()=>K6p,content_3813_11854:()=>e5p,content_3813_11856:()=>p5p,content_3813_11858:()=>c5p,content_3813_1186:()=>RXt,content_3813_11860:()=>l5p,content_3813_11862:()=>d5p,content_3813_11864:()=>k5p,content_3813_11866:()=>M5p,content_3813_11868:()=>w5p,content_3813_11870:()=>g5p,content_3813_11872:()=>L5p,content_3813_11874:()=>N5p,content_3813_11876:()=>P5p,content_3813_11878:()=>R5p,content_3813_1188:()=>GXt,content_3813_11880:()=>G5p,content_3813_11882:()=>U5p,content_3813_11884:()=>q5p,content_3813_11886:()=>Y5p,content_3813_11888:()=>K5p,content_3813_11890:()=>e7p,content_3813_11892:()=>p7p,content_3813_11894:()=>c7p,content_3813_11896:()=>l7p,content_3813_11898:()=>d7p,content_3813_1190:()=>UXt,content_3813_11900:()=>k7p,content_3813_11902:()=>M7p,content_3813_11904:()=>w7p,content_3813_11906:()=>g7p,content_3813_11908:()=>L7p,content_3813_11910:()=>N7p,content_3813_11912:()=>P7p,content_3813_11914:()=>R7p,content_3813_11916:()=>G7p,content_3813_11918:()=>U7p,content_3813_1192:()=>qXt,content_3813_11920:()=>q7p,content_3813_11922:()=>Y7p,content_3813_11924:()=>K7p,content_3813_11926:()=>e9p,content_3813_11928:()=>p9p,content_3813_11930:()=>c9p,content_3813_11932:()=>l9p,content_3813_11934:()=>d9p,content_3813_11936:()=>k9p,content_3813_11938:()=>M9p,content_3813_1194:()=>YXt,content_3813_11940:()=>w9p,content_3813_11942:()=>g9p,content_3813_11944:()=>L9p,content_3813_11946:()=>N9p,content_3813_11948:()=>P9p,content_3813_11950:()=>R9p,content_3813_11952:()=>G9p,content_3813_11954:()=>U9p,content_3813_11956:()=>q9p,content_3813_11958:()=>Y9p,content_3813_1196:()=>KXt,content_3813_11960:()=>K9p,content_3813_11962:()=>etr,content_3813_11964:()=>ptr,content_3813_11966:()=>ctr,content_3813_11968:()=>ltr,content_3813_11970:()=>dtr,content_3813_11972:()=>ktr,content_3813_11974:()=>Mtr,content_3813_11976:()=>wtr,content_3813_11978:()=>gtr,content_3813_1198:()=>e_t,content_3813_11980:()=>Ltr,content_3813_11982:()=>Ntr,content_3813_11984:()=>Ptr,content_3813_11986:()=>Rtr,content_3813_11988:()=>Gtr,content_3813_11990:()=>Utr,content_3813_11992:()=>qtr,content_3813_11994:()=>Ytr,content_3813_11996:()=>Ktr,content_3813_11998:()=>eer,content_3813_12:()=>oK,content_3813_120:()=>o3,content_3813_1200:()=>p_t,content_3813_12000:()=>per,content_3813_12002:()=>cer,content_3813_12004:()=>ler,content_3813_12006:()=>der,content_3813_12008:()=>ker,content_3813_12010:()=>Mer,content_3813_12012:()=>wer,content_3813_12014:()=>ger,content_3813_12016:()=>Ler,content_3813_12018:()=>Ner,content_3813_1202:()=>c_t,content_3813_12020:()=>Per,content_3813_12022:()=>Rer,content_3813_12024:()=>Ger,content_3813_12026:()=>Uer,content_3813_12028:()=>qer,content_3813_12030:()=>Yer,content_3813_12032:()=>Ker,content_3813_12034:()=>enr,content_3813_12036:()=>pnr,content_3813_12038:()=>cnr,content_3813_1204:()=>l_t,content_3813_12040:()=>lnr,content_3813_12042:()=>dnr,content_3813_12044:()=>knr,content_3813_12046:()=>Mnr,content_3813_12048:()=>wnr,content_3813_12050:()=>gnr,content_3813_12052:()=>Lnr,content_3813_12054:()=>Nnr,content_3813_12056:()=>Pnr,content_3813_12058:()=>Rnr,content_3813_1206:()=>d_t,content_3813_12060:()=>Gnr,content_3813_12062:()=>Unr,content_3813_12064:()=>qnr,content_3813_12066:()=>Ynr,content_3813_12068:()=>Knr,content_3813_12070:()=>eor,content_3813_12072:()=>por,content_3813_12074:()=>cor,content_3813_12076:()=>lor,content_3813_12078:()=>dor,content_3813_1208:()=>k_t,content_3813_12080:()=>yor,content_3813_12082:()=>Xor,content_3813_12084:()=>Tor,content_3813_12086:()=>xor,content_3813_12088:()=>Zor,content_3813_12090:()=>zor,content_3813_12092:()=>Ior,content_3813_12094:()=>Sor,content_3813_12096:()=>Eor,content_3813_12098:()=>For,content_3813_1210:()=>M_t,content_3813_12100:()=>jor,content_3813_12102:()=>Qor,content_3813_12104:()=>Jor,content_3813_12106:()=>npr,content_3813_12108:()=>rpr,content_3813_12110:()=>apr,content_3813_12112:()=>upr,content_3813_12114:()=>hpr,content_3813_12116:()=>ypr,content_3813_12118:()=>Xpr,content_3813_1212:()=>w_t,content_3813_12120:()=>Tpr,content_3813_12122:()=>xpr,content_3813_12124:()=>Zpr,content_3813_12126:()=>zpr,content_3813_12128:()=>Ipr,content_3813_12130:()=>Spr,content_3813_12132:()=>Epr,content_3813_12134:()=>Fpr,content_3813_12136:()=>jpr,content_3813_12138:()=>Qpr,content_3813_1214:()=>g_t,content_3813_12140:()=>Jpr,content_3813_12142:()=>nrr,content_3813_12144:()=>rrr,content_3813_12146:()=>arr,content_3813_12148:()=>urr,content_3813_12150:()=>hrr,content_3813_12152:()=>yrr,content_3813_12154:()=>Xrr,content_3813_12156:()=>Trr,content_3813_12158:()=>xrr,content_3813_1216:()=>L_t,content_3813_12160:()=>Zrr,content_3813_12162:()=>zrr,content_3813_12164:()=>Irr,content_3813_12166:()=>Srr,content_3813_12168:()=>Err,content_3813_12170:()=>Frr,content_3813_12172:()=>jrr,content_3813_12174:()=>Qrr,content_3813_12176:()=>Jrr,content_3813_12178:()=>nsr,content_3813_1218:()=>N_t,content_3813_12180:()=>rsr,content_3813_12182:()=>asr,content_3813_12184:()=>usr,content_3813_12186:()=>hsr,content_3813_12188:()=>ysr,content_3813_12190:()=>Xsr,content_3813_12192:()=>Tsr,content_3813_12194:()=>xsr,content_3813_12196:()=>Zsr,content_3813_12198:()=>zsr,content_3813_122:()=>s3,content_3813_1220:()=>P_t,content_3813_12200:()=>Isr,content_3813_12202:()=>Ssr,content_3813_12204:()=>Esr,content_3813_12206:()=>Fsr,content_3813_12208:()=>jsr,content_3813_12210:()=>Qsr,content_3813_12212:()=>Jsr,content_3813_12214:()=>ncr,content_3813_12216:()=>rcr,content_3813_12218:()=>acr,content_3813_1222:()=>R_t,content_3813_12220:()=>ucr,content_3813_12222:()=>hcr,content_3813_12224:()=>ycr,content_3813_12226:()=>Xcr,content_3813_12228:()=>Tcr,content_3813_12230:()=>xcr,content_3813_12232:()=>Zcr,content_3813_12234:()=>zcr,content_3813_12236:()=>Icr,content_3813_12238:()=>Scr,content_3813_1224:()=>G_t,content_3813_12240:()=>Ecr,content_3813_12242:()=>Fcr,content_3813_12244:()=>jcr,content_3813_12246:()=>Qcr,content_3813_12248:()=>Jcr,content_3813_12250:()=>nar,content_3813_12252:()=>rar,content_3813_12254:()=>aar,content_3813_12256:()=>uar,content_3813_12258:()=>har,content_3813_1226:()=>U_t,content_3813_12260:()=>yar,content_3813_12262:()=>Xar,content_3813_12264:()=>Tar,content_3813_12266:()=>xar,content_3813_12268:()=>bar,content_3813_12270:()=>Aar,content_3813_12272:()=>War,content_3813_12274:()=>Bar,content_3813_12276:()=>Oar,content_3813_12278:()=>Var,content_3813_1228:()=>q_t,content_3813_12280:()=>Har,content_3813_12282:()=>$ar,content_3813_12284:()=>tir,content_3813_12286:()=>oir,content_3813_12288:()=>sir,content_3813_12290:()=>iir,content_3813_12292:()=>mir,content_3813_12294:()=>fir,content_3813_12296:()=>Dir,content_3813_12298:()=>_ir,content_3813_1230:()=>Y_t,content_3813_12300:()=>Cir,content_3813_12302:()=>vir,content_3813_12304:()=>bir,content_3813_12306:()=>Air,content_3813_12308:()=>Wir,content_3813_12310:()=>Bir,content_3813_12312:()=>Oir,content_3813_12314:()=>Vir,content_3813_12316:()=>Hir,content_3813_12318:()=>$ir,content_3813_1232:()=>K_t,content_3813_12320:()=>tlr,content_3813_12322:()=>olr,content_3813_12324:()=>slr,content_3813_12326:()=>ilr,content_3813_12328:()=>mlr,content_3813_12330:()=>flr,content_3813_12332:()=>Dlr,content_3813_12334:()=>_lr,content_3813_12336:()=>Clr,content_3813_12338:()=>vlr,content_3813_1234:()=>ewt,content_3813_12340:()=>blr,content_3813_12342:()=>Alr,content_3813_12344:()=>Wlr,content_3813_12346:()=>Blr,content_3813_12348:()=>Olr,content_3813_12350:()=>Vlr,content_3813_12352:()=>Hlr,content_3813_12354:()=>$lr,content_3813_12356:()=>tur,content_3813_12358:()=>our,content_3813_1236:()=>pwt,content_3813_12360:()=>sur,content_3813_12362:()=>iur,content_3813_12364:()=>mur,content_3813_12366:()=>fur,content_3813_12368:()=>Dur,content_3813_12370:()=>_ur,content_3813_12372:()=>Cur,content_3813_12374:()=>vur,content_3813_12376:()=>bur,content_3813_12378:()=>Aur,content_3813_1238:()=>cwt,content_3813_12380:()=>Wur,content_3813_12382:()=>Bur,content_3813_12384:()=>Our,content_3813_12386:()=>Vur,content_3813_12388:()=>Hur,content_3813_12390:()=>$ur,content_3813_12392:()=>tmr,content_3813_12394:()=>omr,content_3813_12396:()=>smr,content_3813_12398:()=>imr,content_3813_124:()=>i3,content_3813_1240:()=>lwt,content_3813_12400:()=>mmr,content_3813_12402:()=>fmr,content_3813_12404:()=>Dmr,content_3813_12406:()=>_mr,content_3813_12408:()=>Cmr,content_3813_12410:()=>vmr,content_3813_12412:()=>bmr,content_3813_12414:()=>Amr,content_3813_12416:()=>Wmr,content_3813_12418:()=>Bmr,content_3813_1242:()=>dwt,content_3813_12420:()=>Omr,content_3813_12422:()=>Vmr,content_3813_12424:()=>Hmr,content_3813_12426:()=>$mr,content_3813_12428:()=>tdr,content_3813_12430:()=>odr,content_3813_12432:()=>sdr,content_3813_12434:()=>idr,content_3813_12436:()=>mdr,content_3813_12438:()=>fdr,content_3813_1244:()=>kwt,content_3813_12440:()=>Ddr,content_3813_12442:()=>_dr,content_3813_12444:()=>Cdr,content_3813_12446:()=>vdr,content_3813_12448:()=>bdr,content_3813_12450:()=>Adr,content_3813_12452:()=>Wdr,content_3813_12454:()=>Bdr,content_3813_12456:()=>Odr,content_3813_12458:()=>Vdr,content_3813_1246:()=>Mwt,content_3813_12460:()=>Hdr,content_3813_12462:()=>$dr,content_3813_12464:()=>thr,content_3813_12466:()=>ohr,content_3813_12468:()=>shr,content_3813_12470:()=>ihr,content_3813_12472:()=>mhr,content_3813_12474:()=>fhr,content_3813_12476:()=>Dhr,content_3813_12478:()=>_hr,content_3813_1248:()=>wwt,content_3813_12480:()=>Chr,content_3813_12482:()=>vhr,content_3813_12484:()=>bhr,content_3813_12486:()=>Ahr,content_3813_12488:()=>Whr,content_3813_12490:()=>Bhr,content_3813_12492:()=>Ohr,content_3813_12494:()=>Vhr,content_3813_12496:()=>Hhr,content_3813_12498:()=>$hr,content_3813_1250:()=>gwt,content_3813_12500:()=>tfr,content_3813_12502:()=>ofr,content_3813_12504:()=>sfr,content_3813_12506:()=>ifr,content_3813_12508:()=>mfr,content_3813_12510:()=>ffr,content_3813_12512:()=>Dfr,content_3813_12514:()=>_fr,content_3813_12516:()=>Cfr,content_3813_12518:()=>vfr,content_3813_1252:()=>Lwt,content_3813_12520:()=>bfr,content_3813_12522:()=>Afr,content_3813_12524:()=>Wfr,content_3813_12526:()=>Bfr,content_3813_12528:()=>Ofr,content_3813_12530:()=>Vfr,content_3813_12532:()=>Hfr,content_3813_12534:()=>$fr,content_3813_12536:()=>tkr,content_3813_12538:()=>okr,content_3813_1254:()=>Nwt,content_3813_12540:()=>skr,content_3813_12542:()=>ikr,content_3813_12544:()=>mkr,content_3813_12546:()=>fkr,content_3813_12548:()=>Dkr,content_3813_12550:()=>_kr,content_3813_12552:()=>Ckr,content_3813_12554:()=>vkr,content_3813_12556:()=>bkr,content_3813_12558:()=>Akr,content_3813_1256:()=>Pwt,content_3813_12560:()=>Wkr,content_3813_12562:()=>Bkr,content_3813_12564:()=>Okr,content_3813_12566:()=>Vkr,content_3813_12568:()=>Hkr,content_3813_12570:()=>$kr,content_3813_12572:()=>tyr,content_3813_12574:()=>oyr,content_3813_12576:()=>syr,content_3813_12578:()=>iyr,content_3813_1258:()=>Rwt,content_3813_12580:()=>myr,content_3813_12582:()=>fyr,content_3813_12584:()=>Dyr,content_3813_12586:()=>_yr,content_3813_12588:()=>Cyr,content_3813_12590:()=>vyr,content_3813_12592:()=>byr,content_3813_12594:()=>Ayr,content_3813_12596:()=>Wyr,content_3813_12598:()=>Byr,content_3813_126:()=>m3,content_3813_1260:()=>Gwt,content_3813_12600:()=>Oyr,content_3813_12602:()=>Vyr,content_3813_12604:()=>Hyr,content_3813_12606:()=>$yr,content_3813_12608:()=>tDr,content_3813_12610:()=>oDr,content_3813_12612:()=>sDr,content_3813_12614:()=>iDr,content_3813_12616:()=>mDr,content_3813_12618:()=>fDr,content_3813_1262:()=>Uwt,content_3813_12620:()=>DDr,content_3813_12622:()=>_Dr,content_3813_12624:()=>CDr,content_3813_12626:()=>vDr,content_3813_12628:()=>bDr,content_3813_12630:()=>ADr,content_3813_12632:()=>WDr,content_3813_12634:()=>BDr,content_3813_12636:()=>ODr,content_3813_12638:()=>VDr,content_3813_1264:()=>qwt,content_3813_12640:()=>HDr,content_3813_12642:()=>$Dr,content_3813_12644:()=>tMr,content_3813_12646:()=>oMr,content_3813_12648:()=>sMr,content_3813_12650:()=>iMr,content_3813_12652:()=>mMr,content_3813_12654:()=>fMr,content_3813_12656:()=>DMr,content_3813_12658:()=>_Mr,content_3813_1266:()=>Ywt,content_3813_12660:()=>CMr,content_3813_12662:()=>vMr,content_3813_12664:()=>bMr,content_3813_12666:()=>AMr,content_3813_12668:()=>WMr,content_3813_12670:()=>BMr,content_3813_12672:()=>OMr,content_3813_12674:()=>VMr,content_3813_12676:()=>HMr,content_3813_12678:()=>$Mr,content_3813_1268:()=>Kwt,content_3813_12680:()=>tXr,content_3813_12682:()=>oXr,content_3813_12684:()=>sXr,content_3813_12686:()=>iXr,content_3813_12688:()=>mXr,content_3813_12690:()=>fXr,content_3813_12692:()=>DXr,content_3813_12694:()=>_Xr,content_3813_12696:()=>CXr,content_3813_12698:()=>vXr,content_3813_1270:()=>eTt,content_3813_12700:()=>bXr,content_3813_12702:()=>AXr,content_3813_12704:()=>WXr,content_3813_12706:()=>BXr,content_3813_12708:()=>OXr,content_3813_12710:()=>VXr,content_3813_12712:()=>HXr,content_3813_12714:()=>$Xr,content_3813_12716:()=>t_r,content_3813_12718:()=>o_r,content_3813_1272:()=>pTt,content_3813_12720:()=>s_r,content_3813_12722:()=>i_r,content_3813_12724:()=>m_r,content_3813_12726:()=>f_r,content_3813_12728:()=>D_r,content_3813_12730:()=>__r,content_3813_12732:()=>C_r,content_3813_12734:()=>v_r,content_3813_12736:()=>b_r,content_3813_12738:()=>A_r,content_3813_1274:()=>cTt,content_3813_12740:()=>W_r,content_3813_12742:()=>B_r,content_3813_12744:()=>O_r,content_3813_12746:()=>V_r,content_3813_12748:()=>H_r,content_3813_12750:()=>$_r,content_3813_12752:()=>twr,content_3813_12754:()=>owr,content_3813_12756:()=>swr,content_3813_12758:()=>iwr,content_3813_1276:()=>lTt,content_3813_12760:()=>mwr,content_3813_12762:()=>fwr,content_3813_12764:()=>Dwr,content_3813_12766:()=>_wr,content_3813_12768:()=>Cwr,content_3813_12770:()=>vwr,content_3813_12772:()=>bwr,content_3813_12774:()=>Awr,content_3813_12776:()=>Wwr,content_3813_12778:()=>Bwr,content_3813_1278:()=>dTt,content_3813_12780:()=>Owr,content_3813_12782:()=>Vwr,content_3813_12784:()=>Hwr,content_3813_12786:()=>$wr,content_3813_12788:()=>tTr,content_3813_12790:()=>oTr,content_3813_12792:()=>sTr,content_3813_12794:()=>iTr,content_3813_12796:()=>mTr,content_3813_12798:()=>fTr,content_3813_128:()=>f3,content_3813_1280:()=>kTt,content_3813_12800:()=>DTr,content_3813_12802:()=>_Tr,content_3813_12804:()=>CTr,content_3813_12806:()=>vTr,content_3813_12808:()=>bTr,content_3813_12810:()=>ATr,content_3813_12812:()=>WTr,content_3813_12814:()=>BTr,content_3813_12816:()=>OTr,content_3813_12818:()=>VTr,content_3813_1282:()=>MTt,content_3813_12820:()=>HTr,content_3813_12822:()=>$Tr,content_3813_12824:()=>tCr,content_3813_12826:()=>oCr,content_3813_12828:()=>sCr,content_3813_12830:()=>iCr,content_3813_12832:()=>mCr,content_3813_12834:()=>fCr,content_3813_12836:()=>DCr,content_3813_12838:()=>_Cr,content_3813_1284:()=>wTt,content_3813_1286:()=>gTt,content_3813_1288:()=>LTt,content_3813_1290:()=>NTt,content_3813_1292:()=>PTt,content_3813_1294:()=>RTt,content_3813_1296:()=>GTt,content_3813_1298:()=>UTt,content_3813_130:()=>D3,content_3813_1300:()=>qTt,content_3813_1302:()=>YTt,content_3813_1304:()=>KTt,content_3813_1306:()=>eCt,content_3813_1308:()=>pCt,content_3813_1310:()=>cCt,content_3813_1312:()=>lCt,content_3813_1314:()=>dCt,content_3813_1316:()=>kCt,content_3813_1318:()=>MCt,content_3813_132:()=>_3,content_3813_1320:()=>wCt,content_3813_1322:()=>gCt,content_3813_1324:()=>LCt,content_3813_1326:()=>NCt,content_3813_1328:()=>PCt,content_3813_1330:()=>RCt,content_3813_1332:()=>GCt,content_3813_1334:()=>UCt,content_3813_1336:()=>qCt,content_3813_1338:()=>YCt,content_3813_134:()=>C3,content_3813_1340:()=>KCt,content_3813_1342:()=>egt,content_3813_1344:()=>pgt,content_3813_1346:()=>cgt,content_3813_1348:()=>lgt,content_3813_1350:()=>dgt,content_3813_1352:()=>kgt,content_3813_1354:()=>Mgt,content_3813_1356:()=>wgt,content_3813_1358:()=>ggt,content_3813_136:()=>v3,content_3813_1360:()=>Lgt,content_3813_1362:()=>Ngt,content_3813_1364:()=>Pgt,content_3813_1366:()=>Rgt,content_3813_1368:()=>Ggt,content_3813_1370:()=>Ugt,content_3813_1372:()=>qgt,content_3813_1374:()=>Ygt,content_3813_1376:()=>Kgt,content_3813_1378:()=>ext,content_3813_138:()=>b3,content_3813_1380:()=>pxt,content_3813_1382:()=>cxt,content_3813_1384:()=>lxt,content_3813_1386:()=>dxt,content_3813_1388:()=>kxt,content_3813_1390:()=>Mxt,content_3813_1392:()=>wxt,content_3813_1394:()=>gxt,content_3813_1396:()=>Lxt,content_3813_1398:()=>Nxt,content_3813_14:()=>sK,content_3813_140:()=>A3,content_3813_1400:()=>Pxt,content_3813_1402:()=>Rxt,content_3813_1404:()=>Gxt,content_3813_1406:()=>Uxt,content_3813_1408:()=>qxt,content_3813_1410:()=>Yxt,content_3813_1412:()=>Kxt,content_3813_1414:()=>evt,content_3813_1416:()=>pvt,content_3813_1418:()=>cvt,content_3813_142:()=>W3,content_3813_1420:()=>lvt,content_3813_1422:()=>dvt,content_3813_1424:()=>kvt,content_3813_1426:()=>Mvt,content_3813_1428:()=>wvt,content_3813_1430:()=>gvt,content_3813_1432:()=>Lvt,content_3813_1434:()=>Nvt,content_3813_1436:()=>Pvt,content_3813_1438:()=>Rvt,content_3813_144:()=>B3,content_3813_1440:()=>Gvt,content_3813_1442:()=>Uvt,content_3813_1444:()=>qvt,content_3813_1446:()=>Yvt,content_3813_1448:()=>Kvt,content_3813_1450:()=>eLt,content_3813_1452:()=>pLt,content_3813_1454:()=>cLt,content_3813_1456:()=>lLt,content_3813_1458:()=>dLt,content_3813_146:()=>O3,content_3813_1460:()=>kLt,content_3813_1462:()=>MLt,content_3813_1464:()=>wLt,content_3813_1466:()=>gLt,content_3813_1468:()=>LLt,content_3813_1470:()=>NLt,content_3813_1472:()=>PLt,content_3813_1474:()=>RLt,content_3813_1476:()=>GLt,content_3813_1478:()=>ULt,content_3813_148:()=>V3,content_3813_1480:()=>qLt,content_3813_1482:()=>YLt,content_3813_1484:()=>KLt,content_3813_1486:()=>eZt,content_3813_1488:()=>pZt,content_3813_1490:()=>cZt,content_3813_1492:()=>lZt,content_3813_1494:()=>dZt,content_3813_1496:()=>kZt,content_3813_1498:()=>MZt,content_3813_150:()=>H3,content_3813_1500:()=>wZt,content_3813_1502:()=>gZt,content_3813_1504:()=>LZt,content_3813_1506:()=>NZt,content_3813_1508:()=>PZt,content_3813_1510:()=>RZt,content_3813_1512:()=>GZt,content_3813_1514:()=>UZt,content_3813_1516:()=>qZt,content_3813_1518:()=>YZt,content_3813_152:()=>$3,content_3813_1520:()=>KZt,content_3813_1522:()=>ebt,content_3813_1524:()=>pbt,content_3813_1526:()=>cbt,content_3813_1528:()=>lbt,content_3813_1530:()=>dbt,content_3813_1532:()=>kbt,content_3813_1534:()=>Mbt,content_3813_1536:()=>wbt,content_3813_1538:()=>gbt,content_3813_154:()=>t1,content_3813_1540:()=>Lbt,content_3813_1542:()=>Nbt,content_3813_1544:()=>Pbt,content_3813_1546:()=>Rbt,content_3813_1548:()=>Gbt,content_3813_1550:()=>Ubt,content_3813_1552:()=>qbt,content_3813_1554:()=>Ybt,content_3813_1556:()=>Kbt,content_3813_1558:()=>eNt,content_3813_156:()=>o1,content_3813_1560:()=>pNt,content_3813_1562:()=>cNt,content_3813_1564:()=>lNt,content_3813_1566:()=>dNt,content_3813_1568:()=>kNt,content_3813_1570:()=>MNt,content_3813_1572:()=>wNt,content_3813_1574:()=>gNt,content_3813_1576:()=>LNt,content_3813_1578:()=>NNt,content_3813_158:()=>s1,content_3813_1580:()=>PNt,content_3813_1582:()=>RNt,content_3813_1584:()=>GNt,content_3813_1586:()=>UNt,content_3813_1588:()=>qNt,content_3813_1590:()=>YNt,content_3813_1592:()=>KNt,content_3813_1594:()=>ezt,content_3813_1596:()=>pzt,content_3813_1598:()=>czt,content_3813_16:()=>iK,content_3813_160:()=>i1,content_3813_1600:()=>lzt,content_3813_1602:()=>dzt,content_3813_1604:()=>kzt,content_3813_1606:()=>Mzt,content_3813_1608:()=>wzt,content_3813_1610:()=>gzt,content_3813_1612:()=>Lzt,content_3813_1614:()=>Nzt,content_3813_1616:()=>Pzt,content_3813_1618:()=>Rzt,content_3813_162:()=>m1,content_3813_1620:()=>Gzt,content_3813_1622:()=>Uzt,content_3813_1624:()=>qzt,content_3813_1626:()=>Yzt,content_3813_1628:()=>Kzt,content_3813_1630:()=>eAt,content_3813_1632:()=>pAt,content_3813_1634:()=>cAt,content_3813_1636:()=>lAt,content_3813_1638:()=>dAt,content_3813_164:()=>f1,content_3813_1640:()=>kAt,content_3813_1642:()=>MAt,content_3813_1644:()=>wAt,content_3813_1646:()=>gAt,content_3813_1648:()=>LAt,content_3813_1650:()=>NAt,content_3813_1652:()=>PAt,content_3813_1654:()=>RAt,content_3813_1656:()=>GAt,content_3813_1658:()=>UAt,content_3813_166:()=>D1,content_3813_1660:()=>qAt,content_3813_1662:()=>YAt,content_3813_1664:()=>KAt,content_3813_1666:()=>ePt,content_3813_1668:()=>pPt,content_3813_1670:()=>cPt,content_3813_1672:()=>lPt,content_3813_1674:()=>dPt,content_3813_1676:()=>kPt,content_3813_1678:()=>MPt,content_3813_168:()=>_1,content_3813_1680:()=>wPt,content_3813_1682:()=>gPt,content_3813_1684:()=>LPt,content_3813_1686:()=>NPt,content_3813_1688:()=>PPt,content_3813_1690:()=>RPt,content_3813_1692:()=>GPt,content_3813_1694:()=>UPt,content_3813_1696:()=>qPt,content_3813_1698:()=>YPt,content_3813_170:()=>C1,content_3813_1700:()=>KPt,content_3813_1702:()=>eIt,content_3813_1704:()=>pIt,content_3813_1706:()=>cIt,content_3813_1708:()=>lIt,content_3813_1710:()=>dIt,content_3813_1712:()=>kIt,content_3813_1714:()=>MIt,content_3813_1716:()=>wIt,content_3813_1718:()=>gIt,content_3813_172:()=>v1,content_3813_1720:()=>LIt,content_3813_1722:()=>NIt,content_3813_1724:()=>PIt,content_3813_1726:()=>RIt,content_3813_1728:()=>GIt,content_3813_1730:()=>UIt,content_3813_1732:()=>qIt,content_3813_1734:()=>YIt,content_3813_1736:()=>KIt,content_3813_1738:()=>eWt,content_3813_174:()=>b1,content_3813_1740:()=>pWt,content_3813_1742:()=>cWt,content_3813_1744:()=>lWt,content_3813_1746:()=>dWt,content_3813_1748:()=>kWt,content_3813_1750:()=>MWt,content_3813_1752:()=>wWt,content_3813_1754:()=>gWt,content_3813_1756:()=>LWt,content_3813_1758:()=>NWt,content_3813_176:()=>A1,content_3813_1760:()=>PWt,content_3813_1762:()=>RWt,content_3813_1764:()=>GWt,content_3813_1766:()=>UWt,content_3813_1768:()=>qWt,content_3813_1770:()=>YWt,content_3813_1772:()=>KWt,content_3813_1774:()=>eRt,content_3813_1776:()=>pRt,content_3813_1778:()=>cRt,content_3813_178:()=>W1,content_3813_1780:()=>lRt,content_3813_1782:()=>dRt,content_3813_1784:()=>kRt,content_3813_1786:()=>MRt,content_3813_1788:()=>wRt,content_3813_1790:()=>gRt,content_3813_1792:()=>LRt,content_3813_1794:()=>NRt,content_3813_1796:()=>PRt,content_3813_1798:()=>RRt,content_3813_18:()=>mK,content_3813_180:()=>B1,content_3813_1800:()=>GRt,content_3813_1802:()=>URt,content_3813_1804:()=>qRt,content_3813_1806:()=>YRt,content_3813_1808:()=>KRt,content_3813_1810:()=>eSt,content_3813_1812:()=>pSt,content_3813_1814:()=>cSt,content_3813_1816:()=>lSt,content_3813_1818:()=>dSt,content_3813_182:()=>O1,content_3813_1820:()=>kSt,content_3813_1822:()=>MSt,content_3813_1824:()=>wSt,content_3813_1826:()=>gSt,content_3813_1828:()=>LSt,content_3813_1830:()=>NSt,content_3813_1832:()=>PSt,content_3813_1834:()=>RSt,content_3813_1836:()=>GSt,content_3813_1838:()=>USt,content_3813_184:()=>V1,content_3813_1840:()=>qSt,content_3813_1842:()=>YSt,content_3813_1844:()=>KSt,content_3813_1846:()=>eBt,content_3813_1848:()=>pBt,content_3813_1850:()=>cBt,content_3813_1852:()=>lBt,content_3813_1854:()=>dBt,content_3813_1856:()=>kBt,content_3813_1858:()=>MBt,content_3813_186:()=>H1,content_3813_1860:()=>wBt,content_3813_1862:()=>gBt,content_3813_1864:()=>LBt,content_3813_1866:()=>NBt,content_3813_1868:()=>PBt,content_3813_1870:()=>RBt,content_3813_1872:()=>GBt,content_3813_1874:()=>UBt,content_3813_1876:()=>qBt,content_3813_1878:()=>YBt,content_3813_188:()=>$1,content_3813_1880:()=>KBt,content_3813_1882:()=>eGt,content_3813_1884:()=>pGt,content_3813_1886:()=>cGt,content_3813_1888:()=>lGt,content_3813_1890:()=>dGt,content_3813_1892:()=>kGt,content_3813_1894:()=>MGt,content_3813_1896:()=>wGt,content_3813_1898:()=>gGt,content_3813_190:()=>t8,content_3813_1900:()=>LGt,content_3813_1902:()=>NGt,content_3813_1904:()=>PGt,content_3813_1906:()=>RGt,content_3813_1908:()=>GGt,content_3813_1910:()=>UGt,content_3813_1912:()=>qGt,content_3813_1914:()=>YGt,content_3813_1916:()=>KGt,content_3813_1918:()=>eEt,content_3813_192:()=>o8,content_3813_1920:()=>pEt,content_3813_1922:()=>cEt,content_3813_1924:()=>lEt,content_3813_1926:()=>dEt,content_3813_1928:()=>kEt,content_3813_1930:()=>MEt,content_3813_1932:()=>wEt,content_3813_1934:()=>gEt,content_3813_1936:()=>LEt,content_3813_1938:()=>NEt,content_3813_194:()=>s8,content_3813_1940:()=>PEt,content_3813_1942:()=>REt,content_3813_1944:()=>GEt,content_3813_1946:()=>UEt,content_3813_1948:()=>qEt,content_3813_1950:()=>YEt,content_3813_1952:()=>KEt,content_3813_1954:()=>eOt,content_3813_1956:()=>pOt,content_3813_1958:()=>cOt,content_3813_196:()=>i8,content_3813_1960:()=>lOt,content_3813_1962:()=>dOt,content_3813_1964:()=>kOt,content_3813_1966:()=>MOt,content_3813_1968:()=>wOt,content_3813_1970:()=>gOt,content_3813_1972:()=>LOt,content_3813_1974:()=>NOt,content_3813_1976:()=>POt,content_3813_1978:()=>ROt,content_3813_198:()=>m8,content_3813_1980:()=>GOt,content_3813_1982:()=>UOt,content_3813_1984:()=>qOt,content_3813_1986:()=>YOt,content_3813_1988:()=>KOt,content_3813_1990:()=>eUt,content_3813_1992:()=>pUt,content_3813_1994:()=>cUt,content_3813_1996:()=>lUt,content_3813_1998:()=>dUt,content_3813_2:()=>O$,content_3813_20:()=>fK,content_3813_200:()=>f8,content_3813_2000:()=>kUt,content_3813_2002:()=>MUt,content_3813_2004:()=>wUt,content_3813_2006:()=>gUt,content_3813_2008:()=>LUt,content_3813_2010:()=>NUt,content_3813_2012:()=>PUt,content_3813_2014:()=>RUt,content_3813_2016:()=>GUt,content_3813_2018:()=>UUt,content_3813_202:()=>D8,content_3813_2020:()=>qUt,content_3813_2022:()=>YUt,content_3813_2024:()=>KUt,content_3813_2026:()=>eFt,content_3813_2028:()=>pFt,content_3813_2030:()=>cFt,content_3813_2032:()=>lFt,content_3813_2034:()=>dFt,content_3813_2036:()=>kFt,content_3813_2038:()=>MFt,content_3813_204:()=>_8,content_3813_2040:()=>wFt,content_3813_2042:()=>gFt,content_3813_2044:()=>LFt,content_3813_2046:()=>NFt,content_3813_2048:()=>PFt,content_3813_2050:()=>RFt,content_3813_2052:()=>GFt,content_3813_2054:()=>UFt,content_3813_2056:()=>qFt,content_3813_2058:()=>YFt,content_3813_206:()=>C8,content_3813_2060:()=>KFt,content_3813_2062:()=>eVt,content_3813_2064:()=>pVt,content_3813_2066:()=>cVt,content_3813_2068:()=>lVt,content_3813_2070:()=>dVt,content_3813_2072:()=>kVt,content_3813_2074:()=>MVt,content_3813_2076:()=>wVt,content_3813_2078:()=>gVt,content_3813_208:()=>v8,content_3813_2080:()=>LVt,content_3813_2082:()=>NVt,content_3813_2084:()=>PVt,content_3813_2086:()=>RVt,content_3813_2088:()=>GVt,content_3813_2090:()=>UVt,content_3813_2092:()=>qVt,content_3813_2094:()=>YVt,content_3813_2096:()=>KVt,content_3813_2098:()=>eqt,content_3813_210:()=>b8,content_3813_2100:()=>pqt,content_3813_2102:()=>cqt,content_3813_2104:()=>lqt,content_3813_2106:()=>dqt,content_3813_2108:()=>kqt,content_3813_2110:()=>Mqt,content_3813_2112:()=>wqt,content_3813_2114:()=>gqt,content_3813_2116:()=>Lqt,content_3813_2118:()=>Nqt,content_3813_212:()=>A8,content_3813_2120:()=>Pqt,content_3813_2122:()=>Rqt,content_3813_2124:()=>Gqt,content_3813_2126:()=>Uqt,content_3813_2128:()=>qqt,content_3813_2130:()=>Yqt,content_3813_2132:()=>Kqt,content_3813_2134:()=>ejt,content_3813_2136:()=>pjt,content_3813_2138:()=>cjt,content_3813_214:()=>W8,content_3813_2140:()=>ljt,content_3813_2142:()=>djt,content_3813_2144:()=>kjt,content_3813_2146:()=>Mjt,content_3813_2148:()=>wjt,content_3813_2150:()=>gjt,content_3813_2152:()=>Ljt,content_3813_2154:()=>Njt,content_3813_2156:()=>Pjt,content_3813_2158:()=>Rjt,content_3813_216:()=>B8,content_3813_2160:()=>Gjt,content_3813_2162:()=>Ujt,content_3813_2164:()=>qjt,content_3813_2166:()=>Yjt,content_3813_2168:()=>Kjt,content_3813_2170:()=>eHt,content_3813_2172:()=>pHt,content_3813_2174:()=>cHt,content_3813_2176:()=>lHt,content_3813_2178:()=>dHt,content_3813_218:()=>O8,content_3813_2180:()=>kHt,content_3813_2182:()=>MHt,content_3813_2184:()=>wHt,content_3813_2186:()=>gHt,content_3813_2188:()=>LHt,content_3813_2190:()=>NHt,content_3813_2192:()=>PHt,content_3813_2194:()=>RHt,content_3813_2196:()=>GHt,content_3813_2198:()=>UHt,content_3813_22:()=>DK,content_3813_220:()=>V8,content_3813_2200:()=>qHt,content_3813_2202:()=>YHt,content_3813_2204:()=>KHt,content_3813_2206:()=>eYt,content_3813_2208:()=>pYt,content_3813_2210:()=>cYt,content_3813_2212:()=>lYt,content_3813_2214:()=>dYt,content_3813_2216:()=>kYt,content_3813_2218:()=>MYt,content_3813_222:()=>H8,content_3813_2220:()=>wYt,content_3813_2222:()=>gYt,content_3813_2224:()=>LYt,content_3813_2226:()=>NYt,content_3813_2228:()=>PYt,content_3813_2230:()=>RYt,content_3813_2232:()=>GYt,content_3813_2234:()=>UYt,content_3813_2236:()=>qYt,content_3813_2238:()=>YYt,content_3813_224:()=>$8,content_3813_2240:()=>KYt,content_3813_2242:()=>eQt,content_3813_2244:()=>pQt,content_3813_2246:()=>cQt,content_3813_2248:()=>lQt,content_3813_2250:()=>dQt,content_3813_2252:()=>kQt,content_3813_2254:()=>MQt,content_3813_2256:()=>wQt,content_3813_2258:()=>gQt,content_3813_226:()=>t2,content_3813_2260:()=>LQt,content_3813_2262:()=>NQt,content_3813_2264:()=>PQt,content_3813_2266:()=>RQt,content_3813_2268:()=>GQt,content_3813_2270:()=>UQt,content_3813_2272:()=>qQt,content_3813_2274:()=>YQt,content_3813_2276:()=>KQt,content_3813_2278:()=>e$t,content_3813_228:()=>o2,content_3813_2280:()=>p$t,content_3813_2282:()=>c$t,content_3813_2284:()=>l$t,content_3813_2286:()=>d$t,content_3813_2288:()=>k$t,content_3813_2290:()=>M$t,content_3813_2292:()=>w$t,content_3813_2294:()=>g$t,content_3813_2296:()=>L$t,content_3813_2298:()=>N$t,content_3813_230:()=>s2,content_3813_2300:()=>P$t,content_3813_2302:()=>R$t,content_3813_2304:()=>G$t,content_3813_2306:()=>U$t,content_3813_2308:()=>q$t,content_3813_2310:()=>Y$t,content_3813_2312:()=>K$t,content_3813_2314:()=>eKt,content_3813_2316:()=>pKt,content_3813_2318:()=>cKt,content_3813_232:()=>i2,content_3813_2320:()=>lKt,content_3813_2322:()=>dKt,content_3813_2324:()=>kKt,content_3813_2326:()=>MKt,content_3813_2328:()=>wKt,content_3813_2330:()=>gKt,content_3813_2332:()=>LKt,content_3813_2334:()=>NKt,content_3813_2336:()=>PKt,content_3813_2338:()=>RKt,content_3813_234:()=>m2,content_3813_2340:()=>GKt,content_3813_2342:()=>UKt,content_3813_2344:()=>qKt,content_3813_2346:()=>YKt,content_3813_2348:()=>KKt,content_3813_2350:()=>eJt,content_3813_2352:()=>pJt,content_3813_2354:()=>cJt,content_3813_2356:()=>lJt,content_3813_2358:()=>dJt,content_3813_236:()=>f2,content_3813_2360:()=>kJt,content_3813_2362:()=>MJt,content_3813_2364:()=>wJt,content_3813_2366:()=>gJt,content_3813_2368:()=>LJt,content_3813_2370:()=>NJt,content_3813_2372:()=>PJt,content_3813_2374:()=>RJt,content_3813_2376:()=>GJt,content_3813_2378:()=>UJt,content_3813_238:()=>D2,content_3813_2380:()=>qJt,content_3813_2382:()=>YJt,content_3813_2384:()=>KJt,content_3813_2386:()=>e0t,content_3813_2388:()=>p0t,content_3813_2390:()=>c0t,content_3813_2392:()=>l0t,content_3813_2394:()=>d0t,content_3813_2396:()=>k0t,content_3813_2398:()=>M0t,content_3813_24:()=>_K,content_3813_240:()=>_2,content_3813_2400:()=>w0t,content_3813_2402:()=>g0t,content_3813_2404:()=>L0t,content_3813_2406:()=>N0t,content_3813_2408:()=>P0t,content_3813_2410:()=>R0t,content_3813_2412:()=>G0t,content_3813_2414:()=>U0t,content_3813_2416:()=>q0t,content_3813_2418:()=>Y0t,content_3813_242:()=>C2,content_3813_2420:()=>K0t,content_3813_2422:()=>e3t,content_3813_2424:()=>p3t,content_3813_2426:()=>c3t,content_3813_2428:()=>l3t,content_3813_2430:()=>d3t,content_3813_2432:()=>k3t,content_3813_2434:()=>M3t,content_3813_2436:()=>w3t,content_3813_2438:()=>g3t,content_3813_244:()=>v2,content_3813_2440:()=>L3t,content_3813_2442:()=>N3t,content_3813_2444:()=>P3t,content_3813_2446:()=>R3t,content_3813_2448:()=>G3t,content_3813_2450:()=>U3t,content_3813_2452:()=>q3t,content_3813_2454:()=>Y3t,content_3813_2456:()=>K3t,content_3813_2458:()=>e1t,content_3813_246:()=>b2,content_3813_2460:()=>p1t,content_3813_2462:()=>c1t,content_3813_2464:()=>l1t,content_3813_2466:()=>d1t,content_3813_2468:()=>k1t,content_3813_2470:()=>M1t,content_3813_2472:()=>w1t,content_3813_2474:()=>g1t,content_3813_2476:()=>L1t,content_3813_2478:()=>N1t,content_3813_248:()=>A2,content_3813_2480:()=>P1t,content_3813_2482:()=>R1t,content_3813_2484:()=>G1t,content_3813_2486:()=>U1t,content_3813_2488:()=>q1t,content_3813_2490:()=>Y1t,content_3813_2492:()=>K1t,content_3813_2494:()=>e8t,content_3813_2496:()=>p8t,content_3813_2498:()=>c8t,content_3813_250:()=>W2,content_3813_2500:()=>l8t,content_3813_2502:()=>d8t,content_3813_2504:()=>k8t,content_3813_2506:()=>M8t,content_3813_2508:()=>w8t,content_3813_2510:()=>g8t,content_3813_2512:()=>L8t,content_3813_2514:()=>N8t,content_3813_2516:()=>P8t,content_3813_2518:()=>R8t,content_3813_252:()=>B2,content_3813_2520:()=>G8t,content_3813_2522:()=>U8t,content_3813_2524:()=>q8t,content_3813_2526:()=>Y8t,content_3813_2528:()=>K8t,content_3813_2530:()=>e2t,content_3813_2532:()=>p2t,content_3813_2534:()=>c2t,content_3813_2536:()=>l2t,content_3813_2538:()=>d2t,content_3813_254:()=>O2,content_3813_2540:()=>k2t,content_3813_2542:()=>M2t,content_3813_2544:()=>w2t,content_3813_2546:()=>g2t,content_3813_2548:()=>L2t,content_3813_2550:()=>N2t,content_3813_2552:()=>P2t,content_3813_2554:()=>R2t,content_3813_2556:()=>G2t,content_3813_2558:()=>U2t,content_3813_256:()=>V2,content_3813_2560:()=>q2t,content_3813_2562:()=>Y2t,content_3813_2564:()=>K2t,content_3813_2566:()=>e4t,content_3813_2568:()=>p4t,content_3813_2570:()=>c4t,content_3813_2572:()=>l4t,content_3813_2574:()=>d4t,content_3813_2576:()=>k4t,content_3813_2578:()=>M4t,content_3813_258:()=>H2,content_3813_2580:()=>w4t,content_3813_2582:()=>g4t,content_3813_2584:()=>L4t,content_3813_2586:()=>N4t,content_3813_2588:()=>P4t,content_3813_2590:()=>R4t,content_3813_2592:()=>G4t,content_3813_2594:()=>U4t,content_3813_2596:()=>q4t,content_3813_2598:()=>Y4t,content_3813_26:()=>CK,content_3813_260:()=>$2,content_3813_2600:()=>K4t,content_3813_2602:()=>e6t,content_3813_2604:()=>p6t,content_3813_2606:()=>c6t,content_3813_2608:()=>l6t,content_3813_2610:()=>d6t,content_3813_2612:()=>k6t,content_3813_2614:()=>M6t,content_3813_2616:()=>w6t,content_3813_2618:()=>g6t,content_3813_262:()=>t4,content_3813_2620:()=>L6t,content_3813_2622:()=>N6t,content_3813_2624:()=>P6t,content_3813_2626:()=>R6t,content_3813_2628:()=>G6t,content_3813_2630:()=>U6t,content_3813_2632:()=>q6t,content_3813_2634:()=>Y6t,content_3813_2636:()=>K6t,content_3813_2638:()=>e5t,content_3813_264:()=>o4,content_3813_2640:()=>p5t,content_3813_2642:()=>c5t,content_3813_2644:()=>l5t,content_3813_2646:()=>d5t,content_3813_2648:()=>k5t,content_3813_2650:()=>M5t,content_3813_2652:()=>w5t,content_3813_2654:()=>g5t,content_3813_2656:()=>L5t,content_3813_2658:()=>N5t,content_3813_266:()=>s4,content_3813_2660:()=>P5t,content_3813_2662:()=>R5t,content_3813_2664:()=>G5t,content_3813_2666:()=>U5t,content_3813_2668:()=>q5t,content_3813_2670:()=>Y5t,content_3813_2672:()=>K5t,content_3813_2674:()=>e7t,content_3813_2676:()=>p7t,content_3813_2678:()=>c7t,content_3813_268:()=>i4,content_3813_2680:()=>l7t,content_3813_2682:()=>d7t,content_3813_2684:()=>k7t,content_3813_2686:()=>M7t,content_3813_2688:()=>w7t,content_3813_2690:()=>g7t,content_3813_2692:()=>L7t,content_3813_2694:()=>N7t,content_3813_2696:()=>P7t,content_3813_2698:()=>R7t,content_3813_270:()=>m4,content_3813_2700:()=>G7t,content_3813_2702:()=>U7t,content_3813_2704:()=>q7t,content_3813_2706:()=>Y7t,content_3813_2708:()=>K7t,content_3813_2710:()=>e9t,content_3813_2712:()=>p9t,content_3813_2714:()=>c9t,content_3813_2716:()=>l9t,content_3813_2718:()=>d9t,content_3813_272:()=>f4,content_3813_2720:()=>k9t,content_3813_2722:()=>M9t,content_3813_2724:()=>w9t,content_3813_2726:()=>g9t,content_3813_2728:()=>L9t,content_3813_2730:()=>N9t,content_3813_2732:()=>P9t,content_3813_2734:()=>R9t,content_3813_2736:()=>G9t,content_3813_2738:()=>U9t,content_3813_274:()=>D4,content_3813_2740:()=>q9t,content_3813_2742:()=>Y9t,content_3813_2744:()=>K9t,content_3813_2746:()=>ete,content_3813_2748:()=>pte,content_3813_2750:()=>cte,content_3813_2752:()=>lte,content_3813_2754:()=>dte,content_3813_2756:()=>kte,content_3813_2758:()=>Mte,content_3813_276:()=>_4,content_3813_2760:()=>wte,content_3813_2762:()=>gte,content_3813_2764:()=>Lte,content_3813_2766:()=>Nte,content_3813_2768:()=>Pte,content_3813_2770:()=>Rte,content_3813_2772:()=>Gte,content_3813_2774:()=>Ute,content_3813_2776:()=>qte,content_3813_2778:()=>Yte,content_3813_278:()=>C4,content_3813_2780:()=>Kte,content_3813_2782:()=>eee,content_3813_2784:()=>pee,content_3813_2786:()=>cee,content_3813_2788:()=>lee,content_3813_2790:()=>dee,content_3813_2792:()=>kee,content_3813_2794:()=>Mee,content_3813_2796:()=>wee,content_3813_2798:()=>gee,content_3813_28:()=>vK,content_3813_280:()=>v4,content_3813_2800:()=>Lee,content_3813_2802:()=>Nee,content_3813_2804:()=>Pee,content_3813_2806:()=>Ree,content_3813_2808:()=>Gee,content_3813_2810:()=>Uee,content_3813_2812:()=>qee,content_3813_2814:()=>Yee,content_3813_2816:()=>Kee,content_3813_2818:()=>ene,content_3813_282:()=>b4,content_3813_2820:()=>pne,content_3813_2822:()=>cne,content_3813_2824:()=>lne,content_3813_2826:()=>dne,content_3813_2828:()=>kne,content_3813_2830:()=>Mne,content_3813_2832:()=>wne,content_3813_2834:()=>gne,content_3813_2836:()=>Lne,content_3813_2838:()=>Nne,content_3813_284:()=>A4,content_3813_2840:()=>Pne,content_3813_2842:()=>Rne,content_3813_2844:()=>Gne,content_3813_2846:()=>Une,content_3813_2848:()=>qne,content_3813_2850:()=>Yne,content_3813_2852:()=>Kne,content_3813_2854:()=>eoe,content_3813_2856:()=>poe,content_3813_2858:()=>coe,content_3813_286:()=>W4,content_3813_2860:()=>loe,content_3813_2862:()=>doe,content_3813_2864:()=>koe,content_3813_2866:()=>Moe,content_3813_2868:()=>woe,content_3813_2870:()=>goe,content_3813_2872:()=>Loe,content_3813_2874:()=>Noe,content_3813_2876:()=>Poe,content_3813_2878:()=>Roe,content_3813_288:()=>B4,content_3813_2880:()=>Goe,content_3813_2882:()=>Uoe,content_3813_2884:()=>qoe,content_3813_2886:()=>Yoe,content_3813_2888:()=>Koe,content_3813_2890:()=>epe,content_3813_2892:()=>ppe,content_3813_2894:()=>cpe,content_3813_2896:()=>lpe,content_3813_2898:()=>dpe,content_3813_290:()=>O4,content_3813_2900:()=>kpe,content_3813_2902:()=>Mpe,content_3813_2904:()=>wpe,content_3813_2906:()=>gpe,content_3813_2908:()=>Lpe,content_3813_2910:()=>Npe,content_3813_2912:()=>Ppe,content_3813_2914:()=>Rpe,content_3813_2916:()=>Gpe,content_3813_2918:()=>Upe,content_3813_292:()=>V4,content_3813_2920:()=>qpe,content_3813_2922:()=>Ype,content_3813_2924:()=>Kpe,content_3813_2926:()=>ere,content_3813_2928:()=>pre,content_3813_2930:()=>cre,content_3813_2932:()=>lre,content_3813_2934:()=>dre,content_3813_2936:()=>kre,content_3813_2938:()=>Mre,content_3813_294:()=>H4,content_3813_2940:()=>wre,content_3813_2942:()=>gre,content_3813_2944:()=>Lre,content_3813_2946:()=>Nre,content_3813_2948:()=>Pre,content_3813_2950:()=>Rre,content_3813_2952:()=>Gre,content_3813_2954:()=>Ure,content_3813_2956:()=>qre,content_3813_2958:()=>Yre,content_3813_296:()=>$4,content_3813_2960:()=>Kre,content_3813_2962:()=>ese,content_3813_2964:()=>pse,content_3813_2966:()=>cse,content_3813_2968:()=>lse,content_3813_2970:()=>dse,content_3813_2972:()=>kse,content_3813_2974:()=>Mse,content_3813_2976:()=>wse,content_3813_2978:()=>gse,content_3813_298:()=>t6,content_3813_2980:()=>Lse,content_3813_2982:()=>Nse,content_3813_2984:()=>Pse,content_3813_2986:()=>Rse,content_3813_2988:()=>Gse,content_3813_2990:()=>Use,content_3813_2992:()=>qse,content_3813_2994:()=>Yse,content_3813_2996:()=>Kse,content_3813_2998:()=>ece,content_3813_30:()=>bK,content_3813_300:()=>o6,content_3813_3000:()=>pce,content_3813_3002:()=>cce,content_3813_3004:()=>lce,content_3813_3006:()=>dce,content_3813_3008:()=>kce,content_3813_3010:()=>Mce,content_3813_3012:()=>wce,content_3813_3014:()=>gce,content_3813_3016:()=>Lce,content_3813_3018:()=>Nce,content_3813_302:()=>s6,content_3813_3020:()=>Pce,content_3813_3022:()=>Rce,content_3813_3024:()=>Gce,content_3813_3026:()=>Uce,content_3813_3028:()=>qce,content_3813_3030:()=>Yce,content_3813_3032:()=>Kce,content_3813_3034:()=>eae,content_3813_3036:()=>pae,content_3813_3038:()=>cae,content_3813_304:()=>i6,content_3813_3040:()=>lae,content_3813_3042:()=>dae,content_3813_3044:()=>kae,content_3813_3046:()=>Mae,content_3813_3048:()=>wae,content_3813_3050:()=>gae,content_3813_3052:()=>Lae,content_3813_3054:()=>Nae,content_3813_3056:()=>Pae,content_3813_3058:()=>Rae,content_3813_306:()=>m6,content_3813_3060:()=>Gae,content_3813_3062:()=>Uae,content_3813_3064:()=>qae,content_3813_3066:()=>Yae,content_3813_3068:()=>Kae,content_3813_3070:()=>eie,content_3813_3072:()=>pie,content_3813_3074:()=>cie,content_3813_3076:()=>lie,content_3813_3078:()=>die,content_3813_308:()=>f6,content_3813_3080:()=>kie,content_3813_3082:()=>Mie,content_3813_3084:()=>wie,content_3813_3086:()=>gie,content_3813_3088:()=>Lie,content_3813_3090:()=>Nie,content_3813_3092:()=>Pie,content_3813_3094:()=>Rie,content_3813_3096:()=>Gie,content_3813_3098:()=>Uie,content_3813_310:()=>D6,content_3813_3100:()=>qie,content_3813_3102:()=>Yie,content_3813_3104:()=>Kie,content_3813_3106:()=>ele,content_3813_3108:()=>ple,content_3813_3110:()=>cle,content_3813_3112:()=>lle,content_3813_3114:()=>dle,content_3813_3116:()=>kle,content_3813_3118:()=>Mle,content_3813_312:()=>_6,content_3813_3120:()=>wle,content_3813_3122:()=>gle,content_3813_3124:()=>Lle,content_3813_3126:()=>Nle,content_3813_3128:()=>Ple,content_3813_3130:()=>Rle,content_3813_3132:()=>Gle,content_3813_3134:()=>Ule,content_3813_3136:()=>qle,content_3813_3138:()=>Yle,content_3813_314:()=>C6,content_3813_3140:()=>Kle,content_3813_3142:()=>eue,content_3813_3144:()=>pue,content_3813_3146:()=>cue,content_3813_3148:()=>lue,content_3813_3150:()=>due,content_3813_3152:()=>kue,content_3813_3154:()=>Mue,content_3813_3156:()=>wue,content_3813_3158:()=>gue,content_3813_316:()=>v6,content_3813_3160:()=>Lue,content_3813_3162:()=>Nue,content_3813_3164:()=>Pue,content_3813_3166:()=>Rue,content_3813_3168:()=>Gue,content_3813_3170:()=>Uue,content_3813_3172:()=>que,content_3813_3174:()=>Yue,content_3813_3176:()=>Kue,content_3813_3178:()=>eme,content_3813_318:()=>b6,content_3813_3180:()=>pme,content_3813_3182:()=>cme,content_3813_3184:()=>lme,content_3813_3186:()=>dme,content_3813_3188:()=>kme,content_3813_3190:()=>Mme,content_3813_3192:()=>wme,content_3813_3194:()=>gme,content_3813_3196:()=>Lme,content_3813_3198:()=>Nme,content_3813_32:()=>AK,content_3813_320:()=>A6,content_3813_3200:()=>Pme,content_3813_3202:()=>Rme,content_3813_3204:()=>Gme,content_3813_3206:()=>Ume,content_3813_3208:()=>qme,content_3813_3210:()=>Yme,content_3813_3212:()=>Kme,content_3813_3214:()=>ede,content_3813_3216:()=>pde,content_3813_3218:()=>cde,content_3813_322:()=>W6,content_3813_3220:()=>lde,content_3813_3222:()=>dde,content_3813_3224:()=>kde,content_3813_3226:()=>Mde,content_3813_3228:()=>wde,content_3813_3230:()=>gde,content_3813_3232:()=>Lde,content_3813_3234:()=>Nde,content_3813_3236:()=>Pde,content_3813_3238:()=>Rde,content_3813_324:()=>B6,content_3813_3240:()=>Gde,content_3813_3242:()=>Ude,content_3813_3244:()=>qde,content_3813_3246:()=>Yde,content_3813_3248:()=>Kde,content_3813_3250:()=>ehe,content_3813_3252:()=>phe,content_3813_3254:()=>che,content_3813_3256:()=>lhe,content_3813_3258:()=>dhe,content_3813_326:()=>O6,content_3813_3260:()=>khe,content_3813_3262:()=>Mhe,content_3813_3264:()=>whe,content_3813_3266:()=>ghe,content_3813_3268:()=>Lhe,content_3813_3270:()=>Nhe,content_3813_3272:()=>Phe,content_3813_3274:()=>Rhe,content_3813_3276:()=>Ghe,content_3813_3278:()=>Uhe,content_3813_328:()=>V6,content_3813_3280:()=>qhe,content_3813_3282:()=>Yhe,content_3813_3284:()=>Khe,content_3813_3286:()=>efe,content_3813_3288:()=>pfe,content_3813_3290:()=>cfe,content_3813_3292:()=>lfe,content_3813_3294:()=>dfe,content_3813_3296:()=>kfe,content_3813_3298:()=>Mfe,content_3813_330:()=>H6,content_3813_3300:()=>wfe,content_3813_3302:()=>gfe,content_3813_3304:()=>Lfe,content_3813_3306:()=>Nfe,content_3813_3308:()=>Pfe,content_3813_3310:()=>Rfe,content_3813_3312:()=>Gfe,content_3813_3314:()=>Ufe,content_3813_3316:()=>qfe,content_3813_3318:()=>Yfe,content_3813_332:()=>$6,content_3813_3320:()=>Kfe,content_3813_3322:()=>eke,content_3813_3324:()=>pke,content_3813_3326:()=>cke,content_3813_3328:()=>lke,content_3813_3330:()=>dke,content_3813_3332:()=>kke,content_3813_3334:()=>Mke,content_3813_3336:()=>wke,content_3813_3338:()=>gke,content_3813_334:()=>t5,content_3813_3340:()=>Lke,content_3813_3342:()=>Nke,content_3813_3344:()=>Pke,content_3813_3346:()=>Rke,content_3813_3348:()=>Gke,content_3813_3350:()=>Uke,content_3813_3352:()=>qke,content_3813_3354:()=>Yke,content_3813_3356:()=>Kke,content_3813_3358:()=>eye,content_3813_336:()=>o5,content_3813_3360:()=>pye,content_3813_3362:()=>cye,content_3813_3364:()=>lye,content_3813_3366:()=>dye,content_3813_3368:()=>kye,content_3813_3370:()=>Mye,content_3813_3372:()=>wye,content_3813_3374:()=>gye,content_3813_3376:()=>Lye,content_3813_3378:()=>Nye,content_3813_338:()=>s5,content_3813_3380:()=>Pye,content_3813_3382:()=>Rye,content_3813_3384:()=>Gye,content_3813_3386:()=>Uye,content_3813_3388:()=>qye,content_3813_3390:()=>Yye,content_3813_3392:()=>Kye,content_3813_3394:()=>eDe,content_3813_3396:()=>pDe,content_3813_3398:()=>cDe,content_3813_34:()=>WK,content_3813_340:()=>i5,content_3813_3400:()=>lDe,content_3813_3402:()=>dDe,content_3813_3404:()=>kDe,content_3813_3406:()=>MDe,content_3813_3408:()=>wDe,content_3813_3410:()=>gDe,content_3813_3412:()=>LDe,content_3813_3414:()=>NDe,content_3813_3416:()=>PDe,content_3813_3418:()=>RDe,content_3813_342:()=>m5,content_3813_3420:()=>GDe,content_3813_3422:()=>UDe,content_3813_3424:()=>qDe,content_3813_3426:()=>YDe,content_3813_3428:()=>KDe,content_3813_3430:()=>eMe,content_3813_3432:()=>pMe,content_3813_3434:()=>cMe,content_3813_3436:()=>lMe,content_3813_3438:()=>dMe,content_3813_344:()=>f5,content_3813_3440:()=>kMe,content_3813_3442:()=>MMe,content_3813_3444:()=>wMe,content_3813_3446:()=>gMe,content_3813_3448:()=>LMe,content_3813_3450:()=>NMe,content_3813_3452:()=>PMe,content_3813_3454:()=>RMe,content_3813_3456:()=>GMe,content_3813_3458:()=>UMe,content_3813_346:()=>D5,content_3813_3460:()=>qMe,content_3813_3462:()=>YMe,content_3813_3464:()=>KMe,content_3813_3466:()=>eXe,content_3813_3468:()=>pXe,content_3813_3470:()=>cXe,content_3813_3472:()=>lXe,content_3813_3474:()=>dXe,content_3813_3476:()=>kXe,content_3813_3478:()=>MXe,content_3813_348:()=>_5,content_3813_3480:()=>wXe,content_3813_3482:()=>gXe,content_3813_3484:()=>LXe,content_3813_3486:()=>NXe,content_3813_3488:()=>PXe,content_3813_3490:()=>RXe,content_3813_3492:()=>GXe,content_3813_3494:()=>UXe,content_3813_3496:()=>qXe,content_3813_3498:()=>YXe,content_3813_350:()=>C5,content_3813_3500:()=>KXe,content_3813_3502:()=>e_e,content_3813_3504:()=>p_e,content_3813_3506:()=>c_e,content_3813_3508:()=>l_e,content_3813_3510:()=>d_e,content_3813_3512:()=>k_e,content_3813_3514:()=>M_e,content_3813_3516:()=>w_e,content_3813_3518:()=>g_e,content_3813_352:()=>v5,content_3813_3520:()=>L_e,content_3813_3522:()=>N_e,content_3813_3524:()=>P_e,content_3813_3526:()=>R_e,content_3813_3528:()=>G_e,content_3813_3530:()=>U_e,content_3813_3532:()=>q_e,content_3813_3534:()=>Y_e,content_3813_3536:()=>K_e,content_3813_3538:()=>ewe,content_3813_354:()=>b5,content_3813_3540:()=>pwe,content_3813_3542:()=>cwe,content_3813_3544:()=>lwe,content_3813_3546:()=>dwe,content_3813_3548:()=>kwe,content_3813_3550:()=>Mwe,content_3813_3552:()=>wwe,content_3813_3554:()=>gwe,content_3813_3556:()=>Lwe,content_3813_3558:()=>Nwe,content_3813_356:()=>A5,content_3813_3560:()=>Pwe,content_3813_3562:()=>Rwe,content_3813_3564:()=>Gwe,content_3813_3566:()=>Uwe,content_3813_3568:()=>qwe,content_3813_3570:()=>Ywe,content_3813_3572:()=>Kwe,content_3813_3574:()=>eTe,content_3813_3576:()=>pTe,content_3813_3578:()=>cTe,content_3813_358:()=>W5,content_3813_3580:()=>lTe,content_3813_3582:()=>dTe,content_3813_3584:()=>kTe,content_3813_3586:()=>MTe,content_3813_3588:()=>wTe,content_3813_3590:()=>gTe,content_3813_3592:()=>LTe,content_3813_3594:()=>NTe,content_3813_3596:()=>PTe,content_3813_3598:()=>RTe,content_3813_36:()=>BK,content_3813_360:()=>B5,content_3813_3600:()=>GTe,content_3813_3602:()=>UTe,content_3813_3604:()=>qTe,content_3813_3606:()=>YTe,content_3813_3608:()=>KTe,content_3813_3610:()=>eCe,content_3813_3612:()=>pCe,content_3813_3614:()=>cCe,content_3813_3616:()=>lCe,content_3813_3618:()=>dCe,content_3813_362:()=>O5,content_3813_3620:()=>kCe,content_3813_3622:()=>MCe,content_3813_3624:()=>wCe,content_3813_3626:()=>gCe,content_3813_3628:()=>LCe,content_3813_3630:()=>NCe,content_3813_3632:()=>PCe,content_3813_3634:()=>RCe,content_3813_3636:()=>GCe,content_3813_3638:()=>UCe,content_3813_364:()=>V5,content_3813_3640:()=>qCe,content_3813_3642:()=>YCe,content_3813_3644:()=>KCe,content_3813_3646:()=>ege,content_3813_3648:()=>pge,content_3813_3650:()=>cge,content_3813_3652:()=>lge,content_3813_3654:()=>dge,content_3813_3656:()=>kge,content_3813_3658:()=>Mge,content_3813_366:()=>H5,content_3813_3660:()=>wge,content_3813_3662:()=>gge,content_3813_3664:()=>Lge,content_3813_3666:()=>Nge,content_3813_3668:()=>Pge,content_3813_3670:()=>Rge,content_3813_3672:()=>Gge,content_3813_3674:()=>Uge,content_3813_3676:()=>qge,content_3813_3678:()=>Yge,content_3813_368:()=>$5,content_3813_3680:()=>Kge,content_3813_3682:()=>exe,content_3813_3684:()=>pxe,content_3813_3686:()=>cxe,content_3813_3688:()=>lxe,content_3813_3690:()=>dxe,content_3813_3692:()=>kxe,content_3813_3694:()=>Mxe,content_3813_3696:()=>wxe,content_3813_3698:()=>gxe,content_3813_370:()=>t7,content_3813_3700:()=>Lxe,content_3813_3702:()=>Nxe,content_3813_3704:()=>Pxe,content_3813_3706:()=>Rxe,content_3813_3708:()=>Gxe,content_3813_3710:()=>Uxe,content_3813_3712:()=>qxe,content_3813_3714:()=>Yxe,content_3813_3716:()=>Kxe,content_3813_3718:()=>eve,content_3813_372:()=>o7,content_3813_3720:()=>pve,content_3813_3722:()=>cve,content_3813_3724:()=>lve,content_3813_3726:()=>dve,content_3813_3728:()=>kve,content_3813_3730:()=>Mve,content_3813_3732:()=>wve,content_3813_3734:()=>gve,content_3813_3736:()=>Lve,content_3813_3738:()=>Nve,content_3813_374:()=>s7,content_3813_3740:()=>Pve,content_3813_3742:()=>Rve,content_3813_3744:()=>Gve,content_3813_3746:()=>Uve,content_3813_3748:()=>qve,content_3813_3750:()=>Yve,content_3813_3752:()=>Kve,content_3813_3754:()=>eLe,content_3813_3756:()=>pLe,content_3813_3758:()=>cLe,content_3813_376:()=>i7,content_3813_3760:()=>lLe,content_3813_3762:()=>dLe,content_3813_3764:()=>kLe,content_3813_3766:()=>MLe,content_3813_3768:()=>wLe,content_3813_3770:()=>gLe,content_3813_3772:()=>LLe,content_3813_3774:()=>NLe,content_3813_3776:()=>PLe,content_3813_3778:()=>RLe,content_3813_378:()=>m7,content_3813_3780:()=>GLe,content_3813_3782:()=>ULe,content_3813_3784:()=>qLe,content_3813_3786:()=>YLe,content_3813_3788:()=>KLe,content_3813_3790:()=>eZe,content_3813_3792:()=>pZe,content_3813_3794:()=>cZe,content_3813_3796:()=>lZe,content_3813_3798:()=>dZe,content_3813_38:()=>OK,content_3813_380:()=>f7,content_3813_3800:()=>kZe,content_3813_3802:()=>MZe,content_3813_3804:()=>wZe,content_3813_3806:()=>gZe,content_3813_3808:()=>LZe,content_3813_3810:()=>NZe,content_3813_3812:()=>PZe,content_3813_3814:()=>RZe,content_3813_3816:()=>GZe,content_3813_3818:()=>UZe,content_3813_382:()=>D7,content_3813_3820:()=>qZe,content_3813_3822:()=>YZe,content_3813_3824:()=>KZe,content_3813_3826:()=>ebe,content_3813_3828:()=>pbe,content_3813_3830:()=>cbe,content_3813_3832:()=>lbe,content_3813_3834:()=>dbe,content_3813_3836:()=>kbe,content_3813_3838:()=>Mbe,content_3813_384:()=>_7,content_3813_3840:()=>wbe,content_3813_3842:()=>gbe,content_3813_3844:()=>Lbe,content_3813_3846:()=>Nbe,content_3813_3848:()=>Pbe,content_3813_3850:()=>Rbe,content_3813_3852:()=>Gbe,content_3813_3854:()=>Ube,content_3813_3856:()=>qbe,content_3813_3858:()=>Ybe,content_3813_386:()=>C7,content_3813_3860:()=>Kbe,content_3813_3862:()=>eNe,content_3813_3864:()=>pNe,content_3813_3866:()=>cNe,content_3813_3868:()=>lNe,content_3813_3870:()=>dNe,content_3813_3872:()=>kNe,content_3813_3874:()=>MNe,content_3813_3876:()=>wNe,content_3813_3878:()=>gNe,content_3813_388:()=>v7,content_3813_3880:()=>LNe,content_3813_3882:()=>NNe,content_3813_3884:()=>PNe,content_3813_3886:()=>RNe,content_3813_3888:()=>GNe,content_3813_3890:()=>UNe,content_3813_3892:()=>qNe,content_3813_3894:()=>YNe,content_3813_3896:()=>KNe,content_3813_3898:()=>eze,content_3813_390:()=>b7,content_3813_3900:()=>pze,content_3813_3902:()=>cze,content_3813_3904:()=>lze,content_3813_3906:()=>dze,content_3813_3908:()=>kze,content_3813_3910:()=>Mze,content_3813_3912:()=>wze,content_3813_3914:()=>gze,content_3813_3916:()=>Lze,content_3813_3918:()=>Nze,content_3813_392:()=>A7,content_3813_3920:()=>Pze,content_3813_3922:()=>Rze,content_3813_3924:()=>Gze,content_3813_3926:()=>Uze,content_3813_3928:()=>qze,content_3813_3930:()=>Yze,content_3813_3932:()=>Kze,content_3813_3934:()=>eAe,content_3813_3936:()=>pAe,content_3813_3938:()=>cAe,content_3813_394:()=>W7,content_3813_3940:()=>lAe,content_3813_3942:()=>dAe,content_3813_3944:()=>kAe,content_3813_3946:()=>MAe,content_3813_3948:()=>wAe,content_3813_3950:()=>gAe,content_3813_3952:()=>LAe,content_3813_3954:()=>NAe,content_3813_3956:()=>PAe,content_3813_3958:()=>RAe,content_3813_396:()=>B7,content_3813_3960:()=>GAe,content_3813_3962:()=>UAe,content_3813_3964:()=>qAe,content_3813_3966:()=>YAe,content_3813_3968:()=>KAe,content_3813_3970:()=>ePe,content_3813_3972:()=>pPe,content_3813_3974:()=>cPe,content_3813_3976:()=>lPe,content_3813_3978:()=>dPe,content_3813_398:()=>O7,content_3813_3980:()=>kPe,content_3813_3982:()=>MPe,content_3813_3984:()=>wPe,content_3813_3986:()=>gPe,content_3813_3988:()=>LPe,content_3813_3990:()=>NPe,content_3813_3992:()=>PPe,content_3813_3994:()=>RPe,content_3813_3996:()=>GPe,content_3813_3998:()=>UPe,content_3813_4:()=>V$,content_3813_40:()=>VK,content_3813_400:()=>V7,content_3813_4000:()=>qPe,content_3813_4002:()=>YPe,content_3813_4004:()=>KPe,content_3813_4006:()=>eIe,content_3813_4008:()=>pIe,content_3813_4010:()=>cIe,content_3813_4012:()=>lIe,content_3813_4014:()=>dIe,content_3813_4016:()=>kIe,content_3813_4018:()=>MIe,content_3813_402:()=>H7,content_3813_4020:()=>wIe,content_3813_4022:()=>gIe,content_3813_4024:()=>LIe,content_3813_4026:()=>NIe,content_3813_4028:()=>PIe,content_3813_4030:()=>RIe,content_3813_4032:()=>GIe,content_3813_4034:()=>UIe,content_3813_4036:()=>qIe,content_3813_4038:()=>YIe,content_3813_404:()=>$7,content_3813_4040:()=>KIe,content_3813_4042:()=>eWe,content_3813_4044:()=>pWe,content_3813_4046:()=>cWe,content_3813_4048:()=>lWe,content_3813_4050:()=>dWe,content_3813_4052:()=>kWe,content_3813_4054:()=>MWe,content_3813_4056:()=>wWe,content_3813_4058:()=>gWe,content_3813_406:()=>t9,content_3813_4060:()=>LWe,content_3813_4062:()=>NWe,content_3813_4064:()=>PWe,content_3813_4066:()=>RWe,content_3813_4068:()=>GWe,content_3813_4070:()=>UWe,content_3813_4072:()=>qWe,content_3813_4074:()=>YWe,content_3813_4076:()=>KWe,content_3813_4078:()=>eRe,content_3813_408:()=>o9,content_3813_4080:()=>pRe,content_3813_4082:()=>cRe,content_3813_4084:()=>lRe,content_3813_4086:()=>dRe,content_3813_4088:()=>kRe,content_3813_4090:()=>MRe,content_3813_4092:()=>wRe,content_3813_4094:()=>gRe,content_3813_4096:()=>LRe,content_3813_4098:()=>NRe,content_3813_410:()=>s9,content_3813_4100:()=>PRe,content_3813_4102:()=>RRe,content_3813_4104:()=>GRe,content_3813_4106:()=>URe,content_3813_4108:()=>qRe,content_3813_4110:()=>YRe,content_3813_4112:()=>KRe,content_3813_4114:()=>eSe,content_3813_4116:()=>pSe,content_3813_4118:()=>cSe,content_3813_412:()=>i9,content_3813_4120:()=>lSe,content_3813_4122:()=>dSe,content_3813_4124:()=>kSe,content_3813_4126:()=>MSe,content_3813_4128:()=>wSe,content_3813_4130:()=>gSe,content_3813_4132:()=>LSe,content_3813_4134:()=>NSe,content_3813_4136:()=>PSe,content_3813_4138:()=>RSe,content_3813_414:()=>m9,content_3813_4140:()=>GSe,content_3813_4142:()=>USe,content_3813_4144:()=>qSe,content_3813_4146:()=>YSe,content_3813_4148:()=>KSe,content_3813_4150:()=>eBe,content_3813_4152:()=>pBe,content_3813_4154:()=>cBe,content_3813_4156:()=>lBe,content_3813_4158:()=>dBe,content_3813_416:()=>f9,content_3813_4160:()=>kBe,content_3813_4162:()=>MBe,content_3813_4164:()=>wBe,content_3813_4166:()=>gBe,content_3813_4168:()=>LBe,content_3813_4170:()=>NBe,content_3813_4172:()=>PBe,content_3813_4174:()=>RBe,content_3813_4176:()=>GBe,content_3813_4178:()=>UBe,content_3813_418:()=>D9,content_3813_4180:()=>qBe,content_3813_4182:()=>YBe,content_3813_4184:()=>KBe,content_3813_4186:()=>eGe,content_3813_4188:()=>pGe,content_3813_4190:()=>cGe,content_3813_4192:()=>lGe,content_3813_4194:()=>dGe,content_3813_4196:()=>kGe,content_3813_4198:()=>MGe,content_3813_42:()=>HK,content_3813_420:()=>_9,content_3813_4200:()=>wGe,content_3813_4202:()=>gGe,content_3813_4204:()=>LGe,content_3813_4206:()=>NGe,content_3813_4208:()=>PGe,content_3813_4210:()=>RGe,content_3813_4212:()=>GGe,content_3813_4214:()=>UGe,content_3813_4216:()=>qGe,content_3813_4218:()=>YGe,content_3813_422:()=>C9,content_3813_4220:()=>KGe,content_3813_4222:()=>eEe,content_3813_4224:()=>pEe,content_3813_4226:()=>cEe,content_3813_4228:()=>lEe,content_3813_4230:()=>dEe,content_3813_4232:()=>kEe,content_3813_4234:()=>MEe,content_3813_4236:()=>wEe,content_3813_4238:()=>gEe,content_3813_424:()=>v9,content_3813_4240:()=>LEe,content_3813_4242:()=>NEe,content_3813_4244:()=>PEe,content_3813_4246:()=>REe,content_3813_4248:()=>GEe,content_3813_4250:()=>UEe,content_3813_4252:()=>qEe,content_3813_4254:()=>YEe,content_3813_4256:()=>KEe,content_3813_4258:()=>eOe,content_3813_426:()=>b9,content_3813_4260:()=>pOe,content_3813_4262:()=>cOe,content_3813_4264:()=>lOe,content_3813_4266:()=>dOe,content_3813_4268:()=>kOe,content_3813_4270:()=>MOe,content_3813_4272:()=>wOe,content_3813_4274:()=>gOe,content_3813_4276:()=>LOe,content_3813_4278:()=>NOe,content_3813_428:()=>A9,content_3813_4280:()=>POe,content_3813_4282:()=>ROe,content_3813_4284:()=>GOe,content_3813_4286:()=>UOe,content_3813_4288:()=>qOe,content_3813_4290:()=>YOe,content_3813_4292:()=>KOe,content_3813_4294:()=>eUe,content_3813_4296:()=>pUe,content_3813_4298:()=>cUe,content_3813_430:()=>W9,content_3813_4300:()=>lUe,content_3813_4302:()=>dUe,content_3813_4304:()=>kUe,content_3813_4306:()=>MUe,content_3813_4308:()=>wUe,content_3813_4310:()=>gUe,content_3813_4312:()=>LUe,content_3813_4314:()=>NUe,content_3813_4316:()=>PUe,content_3813_4318:()=>RUe,content_3813_432:()=>B9,content_3813_4320:()=>GUe,content_3813_4322:()=>UUe,content_3813_4324:()=>qUe,content_3813_4326:()=>YUe,content_3813_4328:()=>KUe,content_3813_4330:()=>eFe,content_3813_4332:()=>pFe,content_3813_4334:()=>cFe,content_3813_4336:()=>lFe,content_3813_4338:()=>dFe,content_3813_434:()=>O9,content_3813_4340:()=>kFe,content_3813_4342:()=>MFe,content_3813_4344:()=>wFe,content_3813_4346:()=>gFe,content_3813_4348:()=>LFe,content_3813_4350:()=>NFe,content_3813_4352:()=>PFe,content_3813_4354:()=>RFe,content_3813_4356:()=>GFe,content_3813_4358:()=>UFe,content_3813_436:()=>V9,content_3813_4360:()=>qFe,content_3813_4362:()=>YFe,content_3813_4364:()=>KFe,content_3813_4366:()=>eVe,content_3813_4368:()=>pVe,content_3813_4370:()=>cVe,content_3813_4372:()=>lVe,content_3813_4374:()=>dVe,content_3813_4376:()=>kVe,content_3813_4378:()=>MVe,content_3813_438:()=>H9,content_3813_4380:()=>wVe,content_3813_4382:()=>gVe,content_3813_4384:()=>LVe,content_3813_4386:()=>NVe,content_3813_4388:()=>PVe,content_3813_4390:()=>RVe,content_3813_4392:()=>GVe,content_3813_4394:()=>UVe,content_3813_4396:()=>qVe,content_3813_4398:()=>YVe,content_3813_44:()=>$K,content_3813_440:()=>$9,content_3813_4400:()=>KVe,content_3813_4402:()=>eqe,content_3813_4404:()=>pqe,content_3813_4406:()=>cqe,content_3813_4408:()=>lqe,content_3813_4410:()=>dqe,content_3813_4412:()=>kqe,content_3813_4414:()=>Mqe,content_3813_4416:()=>wqe,content_3813_4418:()=>gqe,content_3813_442:()=>ttt,content_3813_4420:()=>Lqe,content_3813_4422:()=>Nqe,content_3813_4424:()=>Pqe,content_3813_4426:()=>Rqe,content_3813_4428:()=>Gqe,content_3813_4430:()=>Uqe,content_3813_4432:()=>qqe,content_3813_4434:()=>Yqe,content_3813_4436:()=>Kqe,content_3813_4438:()=>eje,content_3813_444:()=>ott,content_3813_4440:()=>pje,content_3813_4442:()=>cje,content_3813_4444:()=>lje,content_3813_4446:()=>dje,content_3813_4448:()=>kje,content_3813_4450:()=>Mje,content_3813_4452:()=>wje,content_3813_4454:()=>gje,content_3813_4456:()=>Lje,content_3813_4458:()=>Nje,content_3813_446:()=>stt,content_3813_4460:()=>Pje,content_3813_4462:()=>Rje,content_3813_4464:()=>Gje,content_3813_4466:()=>Uje,content_3813_4468:()=>qje,content_3813_4470:()=>Yje,content_3813_4472:()=>Kje,content_3813_4474:()=>eHe,content_3813_4476:()=>pHe,content_3813_4478:()=>cHe,content_3813_448:()=>itt,content_3813_4480:()=>lHe,content_3813_4482:()=>dHe,content_3813_4484:()=>kHe,content_3813_4486:()=>MHe,content_3813_4488:()=>wHe,content_3813_4490:()=>gHe,content_3813_4492:()=>LHe,content_3813_4494:()=>NHe,content_3813_4496:()=>PHe,content_3813_4498:()=>RHe,content_3813_450:()=>mtt,content_3813_4500:()=>GHe,content_3813_4502:()=>UHe,content_3813_4504:()=>qHe,content_3813_4506:()=>YHe,content_3813_4508:()=>KHe,content_3813_4510:()=>eYe,content_3813_4512:()=>pYe,content_3813_4514:()=>cYe,content_3813_4516:()=>lYe,content_3813_4518:()=>dYe,content_3813_452:()=>ftt,content_3813_4520:()=>kYe,content_3813_4522:()=>MYe,content_3813_4524:()=>wYe,content_3813_4526:()=>gYe,content_3813_4528:()=>LYe,content_3813_4530:()=>NYe,content_3813_4532:()=>PYe,content_3813_4534:()=>RYe,content_3813_4536:()=>GYe,content_3813_4538:()=>UYe,content_3813_454:()=>Dtt,content_3813_4540:()=>qYe,content_3813_4542:()=>YYe,content_3813_4544:()=>KYe,content_3813_4546:()=>eQe,content_3813_4548:()=>pQe,content_3813_4550:()=>cQe,content_3813_4552:()=>lQe,content_3813_4554:()=>dQe,content_3813_4556:()=>kQe,content_3813_4558:()=>MQe,content_3813_456:()=>_tt,content_3813_4560:()=>wQe,content_3813_4562:()=>gQe,content_3813_4564:()=>LQe,content_3813_4566:()=>NQe,content_3813_4568:()=>PQe,content_3813_4570:()=>RQe,content_3813_4572:()=>GQe,content_3813_4574:()=>UQe,content_3813_4576:()=>qQe,content_3813_4578:()=>YQe,content_3813_458:()=>Ctt,content_3813_4580:()=>KQe,content_3813_4582:()=>e$e,content_3813_4584:()=>p$e,content_3813_4586:()=>c$e,content_3813_4588:()=>l$e,content_3813_4590:()=>d$e,content_3813_4592:()=>k$e,content_3813_4594:()=>M$e,content_3813_4596:()=>w$e,content_3813_4598:()=>g$e,content_3813_46:()=>tJ,content_3813_460:()=>vtt,content_3813_4600:()=>L$e,content_3813_4602:()=>N$e,content_3813_4604:()=>P$e,content_3813_4606:()=>R$e,content_3813_4608:()=>G$e,content_3813_4610:()=>U$e,content_3813_4612:()=>q$e,content_3813_4614:()=>Y$e,content_3813_4616:()=>K$e,content_3813_4618:()=>eKe,content_3813_462:()=>btt,content_3813_4620:()=>pKe,content_3813_4622:()=>cKe,content_3813_4624:()=>lKe,content_3813_4626:()=>dKe,content_3813_4628:()=>kKe,content_3813_4630:()=>MKe,content_3813_4632:()=>wKe,content_3813_4634:()=>gKe,content_3813_4636:()=>LKe,content_3813_4638:()=>NKe,content_3813_464:()=>Att,content_3813_4640:()=>PKe,content_3813_4642:()=>RKe,content_3813_4644:()=>GKe,content_3813_4646:()=>UKe,content_3813_4648:()=>qKe,content_3813_4650:()=>YKe,content_3813_4652:()=>KKe,content_3813_4654:()=>eJe,content_3813_4656:()=>pJe,content_3813_4658:()=>cJe,content_3813_466:()=>Wtt,content_3813_4660:()=>lJe,content_3813_4662:()=>dJe,content_3813_4664:()=>kJe,content_3813_4666:()=>MJe,content_3813_4668:()=>wJe,content_3813_4670:()=>gJe,content_3813_4672:()=>LJe,content_3813_4674:()=>NJe,content_3813_4676:()=>PJe,content_3813_4678:()=>RJe,content_3813_468:()=>Btt,content_3813_4680:()=>GJe,content_3813_4682:()=>UJe,content_3813_4684:()=>qJe,content_3813_4686:()=>YJe,content_3813_4688:()=>KJe,content_3813_4690:()=>e0e,content_3813_4692:()=>p0e,content_3813_4694:()=>c0e,content_3813_4696:()=>l0e,content_3813_4698:()=>d0e,content_3813_470:()=>Ott,content_3813_4700:()=>k0e,content_3813_4702:()=>M0e,content_3813_4704:()=>w0e,content_3813_4706:()=>g0e,content_3813_4708:()=>L0e,content_3813_4710:()=>N0e,content_3813_4712:()=>P0e,content_3813_4714:()=>R0e,content_3813_4716:()=>G0e,content_3813_4718:()=>U0e,content_3813_472:()=>Vtt,content_3813_4720:()=>q0e,content_3813_4722:()=>Y0e,content_3813_4724:()=>K0e,content_3813_4726:()=>e3e,content_3813_4728:()=>p3e,content_3813_4730:()=>c3e,content_3813_4732:()=>l3e,content_3813_4734:()=>d3e,content_3813_4736:()=>k3e,content_3813_4738:()=>M3e,content_3813_474:()=>Htt,content_3813_4740:()=>w3e,content_3813_4742:()=>g3e,content_3813_4744:()=>L3e,content_3813_4746:()=>N3e,content_3813_4748:()=>P3e,content_3813_4750:()=>R3e,content_3813_4752:()=>G3e,content_3813_4754:()=>U3e,content_3813_4756:()=>q3e,content_3813_4758:()=>Y3e,content_3813_476:()=>$tt,content_3813_4760:()=>K3e,content_3813_4762:()=>e1e,content_3813_4764:()=>p1e,content_3813_4766:()=>c1e,content_3813_4768:()=>l1e,content_3813_4770:()=>d1e,content_3813_4772:()=>k1e,content_3813_4774:()=>M1e,content_3813_4776:()=>w1e,content_3813_4778:()=>g1e,content_3813_478:()=>tet,content_3813_4780:()=>L1e,content_3813_4782:()=>N1e,content_3813_4784:()=>P1e,content_3813_4786:()=>R1e,content_3813_4788:()=>G1e,content_3813_4790:()=>U1e,content_3813_4792:()=>q1e,content_3813_4794:()=>Y1e,content_3813_4796:()=>K1e,content_3813_4798:()=>e8e,content_3813_48:()=>oJ,content_3813_480:()=>oet,content_3813_4800:()=>p8e,content_3813_4802:()=>c8e,content_3813_4804:()=>l8e,content_3813_4806:()=>d8e,content_3813_4808:()=>k8e,content_3813_4810:()=>M8e,content_3813_4812:()=>w8e,content_3813_4814:()=>g8e,content_3813_4816:()=>L8e,content_3813_4818:()=>N8e,content_3813_482:()=>set,content_3813_4820:()=>P8e,content_3813_4822:()=>R8e,content_3813_4824:()=>G8e,content_3813_4826:()=>U8e,content_3813_4828:()=>q8e,content_3813_4830:()=>Y8e,content_3813_4832:()=>K8e,content_3813_4834:()=>e2e,content_3813_4836:()=>p2e,content_3813_4838:()=>c2e,content_3813_484:()=>iet,content_3813_4840:()=>l2e,content_3813_4842:()=>d2e,content_3813_4844:()=>k2e,content_3813_4846:()=>M2e,content_3813_4848:()=>w2e,content_3813_4850:()=>g2e,content_3813_4852:()=>L2e,content_3813_4854:()=>N2e,content_3813_4856:()=>P2e,content_3813_4858:()=>R2e,content_3813_486:()=>det,content_3813_4860:()=>G2e,content_3813_4862:()=>U2e,content_3813_4864:()=>q2e,content_3813_4866:()=>Y2e,content_3813_4868:()=>K2e,content_3813_4870:()=>e4e,content_3813_4872:()=>p4e,content_3813_4874:()=>c4e,content_3813_4876:()=>l4e,content_3813_4878:()=>d4e,content_3813_488:()=>ket,content_3813_4880:()=>k4e,content_3813_4882:()=>M4e,content_3813_4884:()=>w4e,content_3813_4886:()=>g4e,content_3813_4888:()=>L4e,content_3813_4890:()=>N4e,content_3813_4892:()=>P4e,content_3813_4894:()=>R4e,content_3813_4896:()=>G4e,content_3813_4898:()=>U4e,content_3813_490:()=>Met,content_3813_4900:()=>q4e,content_3813_4902:()=>Y4e,content_3813_4904:()=>K4e,content_3813_4906:()=>e6e,content_3813_4908:()=>p6e,content_3813_4910:()=>c6e,content_3813_4912:()=>l6e,content_3813_4914:()=>d6e,content_3813_4916:()=>k6e,content_3813_4918:()=>M6e,content_3813_492:()=>wet,content_3813_4920:()=>w6e,content_3813_4922:()=>g6e,content_3813_4924:()=>L6e,content_3813_4926:()=>N6e,content_3813_4928:()=>P6e,content_3813_4930:()=>R6e,content_3813_4932:()=>G6e,content_3813_4934:()=>U6e,content_3813_4936:()=>q6e,content_3813_4938:()=>Y6e,content_3813_494:()=>get,content_3813_4940:()=>K6e,content_3813_4942:()=>e5e,content_3813_4944:()=>p5e,content_3813_4946:()=>c5e,content_3813_4948:()=>l5e,content_3813_4950:()=>d5e,content_3813_4952:()=>k5e,content_3813_4954:()=>M5e,content_3813_4956:()=>w5e,content_3813_4958:()=>g5e,content_3813_496:()=>Let,content_3813_4960:()=>L5e,content_3813_4962:()=>N5e,content_3813_4964:()=>P5e,content_3813_4966:()=>R5e,content_3813_4968:()=>G5e,content_3813_4970:()=>U5e,content_3813_4972:()=>q5e,content_3813_4974:()=>Y5e,content_3813_4976:()=>K5e,content_3813_4978:()=>e7e,content_3813_498:()=>Net,content_3813_4980:()=>p7e,content_3813_4982:()=>c7e,content_3813_4984:()=>l7e,content_3813_4986:()=>d7e,content_3813_4988:()=>k7e,content_3813_4990:()=>M7e,content_3813_4992:()=>w7e,content_3813_4994:()=>g7e,content_3813_4996:()=>L7e,content_3813_4998:()=>N7e,content_3813_50:()=>sJ,content_3813_500:()=>Pet,content_3813_5000:()=>P7e,content_3813_5002:()=>R7e,content_3813_5004:()=>G7e,content_3813_5006:()=>U7e,content_3813_5008:()=>q7e,content_3813_5010:()=>Y7e,content_3813_5012:()=>K7e,content_3813_5014:()=>e9e,content_3813_5016:()=>p9e,content_3813_5018:()=>c9e,content_3813_502:()=>Ret,content_3813_5020:()=>l9e,content_3813_5022:()=>d9e,content_3813_5024:()=>k9e,content_3813_5026:()=>M9e,content_3813_5028:()=>w9e,content_3813_5030:()=>g9e,content_3813_5032:()=>L9e,content_3813_5034:()=>N9e,content_3813_5036:()=>P9e,content_3813_5038:()=>R9e,content_3813_504:()=>Get,content_3813_5040:()=>G9e,content_3813_5042:()=>U9e,content_3813_5044:()=>q9e,content_3813_5046:()=>Y9e,content_3813_5048:()=>K9e,content_3813_5050:()=>etn,content_3813_5052:()=>ptn,content_3813_5054:()=>ctn,content_3813_5056:()=>ltn,content_3813_5058:()=>dtn,content_3813_506:()=>Uet,content_3813_5060:()=>ktn,content_3813_5062:()=>Mtn,content_3813_5064:()=>wtn,content_3813_5066:()=>gtn,content_3813_5068:()=>Ltn,content_3813_5070:()=>Ntn,content_3813_5072:()=>Ptn,content_3813_5074:()=>Rtn,content_3813_5076:()=>Gtn,content_3813_5078:()=>Utn,content_3813_508:()=>qet,content_3813_5080:()=>qtn,content_3813_5082:()=>Ytn,content_3813_5084:()=>Ktn,content_3813_5086:()=>een,content_3813_5088:()=>pen,content_3813_5090:()=>cen,content_3813_5092:()=>len,content_3813_5094:()=>den,content_3813_5096:()=>ken,content_3813_5098:()=>Men,content_3813_510:()=>Yet,content_3813_5100:()=>wen,content_3813_5102:()=>gen,content_3813_5104:()=>Len,content_3813_5106:()=>Nen,content_3813_5108:()=>Pen,content_3813_5110:()=>Ren,content_3813_5112:()=>Gen,content_3813_5114:()=>Uen,content_3813_5116:()=>qen,content_3813_5118:()=>Yen,content_3813_512:()=>Ket,content_3813_5120:()=>Ken,content_3813_5122:()=>enn,content_3813_5124:()=>pnn,content_3813_5126:()=>cnn,content_3813_5128:()=>lnn,content_3813_5130:()=>dnn,content_3813_5132:()=>knn,content_3813_5134:()=>Mnn,content_3813_5136:()=>wnn,content_3813_5138:()=>gnn,content_3813_514:()=>ent,content_3813_5140:()=>Lnn,content_3813_5142:()=>Nnn,content_3813_5144:()=>Pnn,content_3813_5146:()=>Rnn,content_3813_5148:()=>Gnn,content_3813_5150:()=>Unn,content_3813_5152:()=>qnn,content_3813_5154:()=>Ynn,content_3813_5156:()=>Knn,content_3813_5158:()=>eon,content_3813_516:()=>pnt,content_3813_5160:()=>pon,content_3813_5162:()=>con,content_3813_5164:()=>lon,content_3813_5166:()=>don,content_3813_5168:()=>kon,content_3813_5170:()=>Mon,content_3813_5172:()=>won,content_3813_5174:()=>gon,content_3813_5176:()=>Lon,content_3813_5178:()=>Non,content_3813_518:()=>cnt,content_3813_5180:()=>Pon,content_3813_5182:()=>Ron,content_3813_5184:()=>Gon,content_3813_5186:()=>Uon,content_3813_5188:()=>qon,content_3813_5190:()=>Yon,content_3813_5192:()=>Kon,content_3813_5194:()=>epn,content_3813_5196:()=>ppn,content_3813_5198:()=>cpn,content_3813_52:()=>iJ,content_3813_520:()=>lnt,content_3813_5200:()=>lpn,content_3813_5202:()=>dpn,content_3813_5204:()=>kpn,content_3813_5206:()=>Mpn,content_3813_5208:()=>wpn,content_3813_5210:()=>gpn,content_3813_5212:()=>Lpn,content_3813_5214:()=>Npn,content_3813_5216:()=>Ppn,content_3813_5218:()=>Rpn,content_3813_522:()=>dnt,content_3813_5220:()=>Gpn,content_3813_5222:()=>Upn,content_3813_5224:()=>qpn,content_3813_5226:()=>Ypn,content_3813_5228:()=>Kpn,content_3813_5230:()=>ern,content_3813_5232:()=>prn,content_3813_5234:()=>crn,content_3813_5236:()=>lrn,content_3813_5238:()=>drn,content_3813_524:()=>knt,content_3813_5240:()=>krn,content_3813_5242:()=>Mrn,content_3813_5244:()=>wrn,content_3813_5246:()=>grn,content_3813_5248:()=>Lrn,content_3813_5250:()=>Nrn,content_3813_5252:()=>Prn,content_3813_5254:()=>Rrn,content_3813_5256:()=>Grn,content_3813_5258:()=>Urn,content_3813_526:()=>Mnt,content_3813_5260:()=>qrn,content_3813_5262:()=>Yrn,content_3813_5264:()=>Krn,content_3813_5266:()=>esn,content_3813_5268:()=>psn,content_3813_5270:()=>csn,content_3813_5272:()=>lsn,content_3813_5274:()=>dsn,content_3813_5276:()=>ksn,content_3813_5278:()=>Msn,content_3813_528:()=>wnt,content_3813_5280:()=>wsn,content_3813_5282:()=>gsn,content_3813_5284:()=>Lsn,content_3813_5286:()=>Nsn,content_3813_5288:()=>Psn,content_3813_5290:()=>Rsn,content_3813_5292:()=>Gsn,content_3813_5294:()=>Usn,content_3813_5296:()=>qsn,content_3813_5298:()=>Ysn,content_3813_530:()=>gnt,content_3813_5300:()=>Ksn,content_3813_5302:()=>ecn,content_3813_5304:()=>pcn,content_3813_5306:()=>ccn,content_3813_5308:()=>lcn,content_3813_5310:()=>dcn,content_3813_5312:()=>kcn,content_3813_5314:()=>Mcn,content_3813_5316:()=>wcn,content_3813_5318:()=>gcn,content_3813_532:()=>Lnt,content_3813_5320:()=>Lcn,content_3813_5322:()=>Ncn,content_3813_5324:()=>Pcn,content_3813_5326:()=>Rcn,content_3813_5328:()=>Gcn,content_3813_5330:()=>Ucn,content_3813_5332:()=>qcn,content_3813_5334:()=>Ycn,content_3813_5336:()=>Kcn,content_3813_5338:()=>ean,content_3813_534:()=>Nnt,content_3813_5340:()=>pan,content_3813_5342:()=>can,content_3813_5344:()=>lan,content_3813_5346:()=>dan,content_3813_5348:()=>kan,content_3813_5350:()=>Man,content_3813_5352:()=>wan,content_3813_5354:()=>gan,content_3813_5356:()=>Lan,content_3813_5358:()=>Nan,content_3813_536:()=>Pnt,content_3813_5360:()=>Pan,content_3813_5362:()=>Ran,content_3813_5364:()=>Gan,content_3813_5366:()=>Uan,content_3813_5368:()=>qan,content_3813_5370:()=>Yan,content_3813_5372:()=>Kan,content_3813_5374:()=>ein,content_3813_5376:()=>pin,content_3813_5378:()=>cin,content_3813_538:()=>Rnt,content_3813_5380:()=>lin,content_3813_5382:()=>din,content_3813_5384:()=>kin,content_3813_5386:()=>Min,content_3813_5388:()=>win,content_3813_5390:()=>gin,content_3813_5392:()=>Lin,content_3813_5394:()=>Nin,content_3813_5396:()=>Pin,content_3813_5398:()=>Rin,content_3813_54:()=>mJ,content_3813_540:()=>Gnt,content_3813_5400:()=>Gin,content_3813_5402:()=>Uin,content_3813_5404:()=>qin,content_3813_5406:()=>Yin,content_3813_5408:()=>Kin,content_3813_5410:()=>eln,content_3813_5412:()=>pln,content_3813_5414:()=>cln,content_3813_5416:()=>lln,content_3813_5418:()=>dln,content_3813_542:()=>Unt,content_3813_5420:()=>kln,content_3813_5422:()=>Mln,content_3813_5424:()=>wln,content_3813_5426:()=>gln,content_3813_5428:()=>Lln,content_3813_5430:()=>Nln,content_3813_5432:()=>Pln,content_3813_5434:()=>Rln,content_3813_5436:()=>Gln,content_3813_5438:()=>Uln,content_3813_544:()=>qnt,content_3813_5440:()=>qln,content_3813_5442:()=>Yln,content_3813_5444:()=>Kln,content_3813_5446:()=>eun,content_3813_5448:()=>pun,content_3813_5450:()=>cun,content_3813_5452:()=>lun,content_3813_5454:()=>dun,content_3813_5456:()=>kun,content_3813_5458:()=>Mun,content_3813_546:()=>Ynt,content_3813_5460:()=>wun,content_3813_5462:()=>gun,content_3813_5464:()=>Lun,content_3813_5466:()=>Nun,content_3813_5468:()=>Pun,content_3813_5470:()=>Run,content_3813_5472:()=>Gun,content_3813_5474:()=>Uun,content_3813_5476:()=>qun,content_3813_5478:()=>Yun,content_3813_548:()=>Knt,content_3813_5480:()=>Kun,content_3813_5482:()=>emn,content_3813_5484:()=>pmn,content_3813_5486:()=>cmn,content_3813_5488:()=>lmn,content_3813_5490:()=>dmn,content_3813_5492:()=>kmn,content_3813_5494:()=>Mmn,content_3813_5496:()=>wmn,content_3813_5498:()=>gmn,content_3813_550:()=>eot,content_3813_5500:()=>Lmn,content_3813_5502:()=>Nmn,content_3813_5504:()=>Pmn,content_3813_5506:()=>Rmn,content_3813_5508:()=>Gmn,content_3813_5510:()=>Umn,content_3813_5512:()=>qmn,content_3813_5514:()=>Ymn,content_3813_5516:()=>Kmn,content_3813_5518:()=>edn,content_3813_552:()=>pot,content_3813_5520:()=>pdn,content_3813_5522:()=>cdn,content_3813_5524:()=>ldn,content_3813_5526:()=>ddn,content_3813_5528:()=>kdn,content_3813_5530:()=>Mdn,content_3813_5532:()=>wdn,content_3813_5534:()=>gdn,content_3813_5536:()=>Ldn,content_3813_5538:()=>Ndn,content_3813_554:()=>cot,content_3813_5540:()=>Pdn,content_3813_5542:()=>Rdn,content_3813_5544:()=>Gdn,content_3813_5546:()=>Udn,content_3813_5548:()=>qdn,content_3813_5550:()=>Ydn,content_3813_5552:()=>Kdn,content_3813_5554:()=>ehn,content_3813_5556:()=>phn,content_3813_5558:()=>chn,content_3813_556:()=>lot,content_3813_5560:()=>lhn,content_3813_5562:()=>dhn,content_3813_5564:()=>khn,content_3813_5566:()=>Mhn,content_3813_5568:()=>whn,content_3813_5570:()=>ghn,content_3813_5572:()=>Lhn,content_3813_5574:()=>Nhn,content_3813_5576:()=>Phn,content_3813_5578:()=>Rhn,content_3813_558:()=>dot,content_3813_5580:()=>Ghn,content_3813_5582:()=>Uhn,content_3813_5584:()=>qhn,content_3813_5586:()=>Yhn,content_3813_5588:()=>Khn,content_3813_5590:()=>efn,content_3813_5592:()=>pfn,content_3813_5594:()=>cfn,content_3813_5596:()=>lfn,content_3813_5598:()=>dfn,content_3813_56:()=>fJ,content_3813_560:()=>kot,content_3813_5600:()=>kfn,content_3813_5602:()=>Mfn,content_3813_5604:()=>wfn,content_3813_5606:()=>gfn,content_3813_5608:()=>Lfn,content_3813_5610:()=>Nfn,content_3813_5612:()=>Pfn,content_3813_5614:()=>Rfn,content_3813_5616:()=>Gfn,content_3813_5618:()=>Ufn,content_3813_562:()=>Mot,content_3813_5620:()=>qfn,content_3813_5622:()=>Yfn,content_3813_5624:()=>Kfn,content_3813_5626:()=>ekn,content_3813_5628:()=>pkn,content_3813_5630:()=>ckn,content_3813_5632:()=>lkn,content_3813_5634:()=>dkn,content_3813_5636:()=>kkn,content_3813_5638:()=>Mkn,content_3813_564:()=>wot,content_3813_5640:()=>wkn,content_3813_5642:()=>gkn,content_3813_5644:()=>Lkn,content_3813_5646:()=>Nkn,content_3813_5648:()=>Pkn,content_3813_5650:()=>Rkn,content_3813_5652:()=>Gkn,content_3813_5654:()=>Ukn,content_3813_5656:()=>qkn,content_3813_5658:()=>Ykn,content_3813_566:()=>got,content_3813_5660:()=>Kkn,content_3813_5662:()=>eyn,content_3813_5664:()=>pyn,content_3813_5666:()=>cyn,content_3813_5668:()=>lyn,content_3813_5670:()=>dyn,content_3813_5672:()=>kyn,content_3813_5674:()=>Myn,content_3813_5676:()=>wyn,content_3813_5678:()=>gyn,content_3813_568:()=>Lot,content_3813_5680:()=>Lyn,content_3813_5682:()=>Nyn,content_3813_5684:()=>Pyn,content_3813_5686:()=>Ryn,content_3813_5688:()=>Gyn,content_3813_5690:()=>Uyn,content_3813_5692:()=>qyn,content_3813_5694:()=>Yyn,content_3813_5696:()=>Kyn,content_3813_5698:()=>eDn,content_3813_570:()=>Not,content_3813_5700:()=>pDn,content_3813_5702:()=>cDn,content_3813_5704:()=>lDn,content_3813_5706:()=>dDn,content_3813_5708:()=>kDn,content_3813_5710:()=>MDn,content_3813_5712:()=>wDn,content_3813_5714:()=>gDn,content_3813_5716:()=>LDn,content_3813_5718:()=>NDn,content_3813_572:()=>Pot,content_3813_5720:()=>PDn,content_3813_5722:()=>RDn,content_3813_5724:()=>GDn,content_3813_5726:()=>UDn,content_3813_5728:()=>qDn,content_3813_5730:()=>YDn,content_3813_5732:()=>KDn,content_3813_5734:()=>eMn,content_3813_5736:()=>pMn,content_3813_5738:()=>cMn,content_3813_574:()=>Rot,content_3813_5740:()=>lMn,content_3813_5742:()=>dMn,content_3813_5744:()=>kMn,content_3813_5746:()=>MMn,content_3813_5748:()=>wMn,content_3813_5750:()=>gMn,content_3813_5752:()=>LMn,content_3813_5754:()=>NMn,content_3813_5756:()=>PMn,content_3813_5758:()=>RMn,content_3813_576:()=>Got,content_3813_5760:()=>GMn,content_3813_5762:()=>UMn,content_3813_5764:()=>qMn,content_3813_5766:()=>YMn,content_3813_5768:()=>KMn,content_3813_5770:()=>eXn,content_3813_5772:()=>pXn,content_3813_5774:()=>cXn,content_3813_5776:()=>lXn,content_3813_5778:()=>dXn,content_3813_578:()=>Uot,content_3813_5780:()=>kXn,content_3813_5782:()=>MXn,content_3813_5784:()=>wXn,content_3813_5786:()=>gXn,content_3813_5788:()=>LXn,content_3813_5790:()=>NXn,content_3813_5792:()=>PXn,content_3813_5794:()=>RXn,content_3813_5796:()=>GXn,content_3813_5798:()=>UXn,content_3813_58:()=>DJ,content_3813_580:()=>qot,content_3813_5800:()=>qXn,content_3813_5802:()=>YXn,content_3813_5804:()=>KXn,content_3813_5806:()=>e_n,content_3813_5808:()=>p_n,content_3813_5810:()=>c_n,content_3813_5812:()=>l_n,content_3813_5814:()=>d_n,content_3813_5816:()=>k_n,content_3813_5818:()=>M_n,content_3813_582:()=>Yot,content_3813_5820:()=>w_n,content_3813_5822:()=>g_n,content_3813_5824:()=>L_n,content_3813_5826:()=>N_n,content_3813_5828:()=>P_n,content_3813_5830:()=>R_n,content_3813_5832:()=>G_n,content_3813_5834:()=>U_n,content_3813_5836:()=>q_n,content_3813_5838:()=>Y_n,content_3813_584:()=>Kot,content_3813_5840:()=>K_n,content_3813_5842:()=>ewn,content_3813_5844:()=>pwn,content_3813_5846:()=>cwn,content_3813_5848:()=>lwn,content_3813_5850:()=>dwn,content_3813_5852:()=>kwn,content_3813_5854:()=>Mwn,content_3813_5856:()=>wwn,content_3813_5858:()=>gwn,content_3813_586:()=>ept,content_3813_5860:()=>Lwn,content_3813_5862:()=>Nwn,content_3813_5864:()=>Pwn,content_3813_5866:()=>Rwn,content_3813_5868:()=>Gwn,content_3813_5870:()=>Uwn,content_3813_5872:()=>qwn,content_3813_5874:()=>Ywn,content_3813_5876:()=>Kwn,content_3813_5878:()=>eTn,content_3813_588:()=>ppt,content_3813_5880:()=>pTn,content_3813_5882:()=>cTn,content_3813_5884:()=>lTn,content_3813_5886:()=>dTn,content_3813_5888:()=>kTn,content_3813_5890:()=>MTn,content_3813_5892:()=>wTn,content_3813_5894:()=>gTn,content_3813_5896:()=>LTn,content_3813_5898:()=>NTn,content_3813_590:()=>cpt,content_3813_5900:()=>PTn,content_3813_5902:()=>RTn,content_3813_5904:()=>GTn,content_3813_5906:()=>UTn,content_3813_5908:()=>qTn,content_3813_5910:()=>YTn,content_3813_5912:()=>KTn,content_3813_5914:()=>eCn,content_3813_5916:()=>pCn,content_3813_5918:()=>cCn,content_3813_592:()=>lpt,content_3813_5920:()=>lCn,content_3813_5922:()=>dCn,content_3813_5924:()=>kCn,content_3813_5926:()=>MCn,content_3813_5928:()=>wCn,content_3813_5930:()=>gCn,content_3813_5932:()=>LCn,content_3813_5934:()=>NCn,content_3813_5936:()=>PCn,content_3813_5938:()=>RCn,content_3813_594:()=>dpt,content_3813_5940:()=>GCn,content_3813_5942:()=>UCn,content_3813_5944:()=>qCn,content_3813_5946:()=>YCn,content_3813_5948:()=>KCn,content_3813_5950:()=>egn,content_3813_5952:()=>pgn,content_3813_5954:()=>cgn,content_3813_5956:()=>lgn,content_3813_5958:()=>dgn,content_3813_596:()=>kpt,content_3813_5960:()=>kgn,content_3813_5962:()=>Mgn,content_3813_5964:()=>wgn,content_3813_5966:()=>ggn,content_3813_5968:()=>Lgn,content_3813_5970:()=>Ngn,content_3813_5972:()=>Pgn,content_3813_5974:()=>Rgn,content_3813_5976:()=>Ggn,content_3813_5978:()=>Ugn,content_3813_598:()=>Mpt,content_3813_5980:()=>qgn,content_3813_5982:()=>Ygn,content_3813_5984:()=>Kgn,content_3813_5986:()=>exn,content_3813_5988:()=>pxn,content_3813_5990:()=>cxn,content_3813_5992:()=>lxn,content_3813_5994:()=>dxn,content_3813_5996:()=>kxn,content_3813_5998:()=>Mxn,content_3813_6:()=>H$,content_3813_60:()=>_J,content_3813_600:()=>wpt,content_3813_6000:()=>wxn,content_3813_6002:()=>gxn,content_3813_6004:()=>Lxn,content_3813_6006:()=>Nxn,content_3813_6008:()=>Pxn,content_3813_6010:()=>Rxn,content_3813_6012:()=>Gxn,content_3813_6014:()=>Uxn,content_3813_6016:()=>qxn,content_3813_6018:()=>Yxn,content_3813_602:()=>gpt,content_3813_6020:()=>Kxn,content_3813_6022:()=>evn,content_3813_6024:()=>pvn,content_3813_6026:()=>cvn,content_3813_6028:()=>lvn,content_3813_6030:()=>dvn,content_3813_6032:()=>kvn,content_3813_6034:()=>Mvn,content_3813_6036:()=>wvn,content_3813_6038:()=>gvn,content_3813_604:()=>Lpt,content_3813_6040:()=>Lvn,content_3813_6042:()=>Nvn,content_3813_6044:()=>Pvn,content_3813_6046:()=>Rvn,content_3813_6048:()=>Gvn,content_3813_6050:()=>Uvn,content_3813_6052:()=>qvn,content_3813_6054:()=>Yvn,content_3813_6056:()=>Kvn,content_3813_6058:()=>eLn,content_3813_606:()=>Npt,content_3813_6060:()=>pLn,content_3813_6062:()=>cLn,content_3813_6064:()=>lLn,content_3813_6066:()=>dLn,content_3813_6068:()=>kLn,content_3813_6070:()=>MLn,content_3813_6072:()=>wLn,content_3813_6074:()=>gLn,content_3813_6076:()=>LLn,content_3813_6078:()=>NLn,content_3813_608:()=>Ppt,content_3813_6080:()=>PLn,content_3813_6082:()=>RLn,content_3813_6084:()=>GLn,content_3813_6086:()=>ULn,content_3813_6088:()=>qLn,content_3813_6090:()=>YLn,content_3813_6092:()=>KLn,content_3813_6094:()=>eZn,content_3813_6096:()=>pZn,content_3813_6098:()=>cZn,content_3813_610:()=>Rpt,content_3813_6100:()=>lZn,content_3813_6102:()=>dZn,content_3813_6104:()=>kZn,content_3813_6106:()=>MZn,content_3813_6108:()=>wZn,content_3813_6110:()=>gZn,content_3813_6112:()=>LZn,content_3813_6114:()=>NZn,content_3813_6116:()=>PZn,content_3813_6118:()=>RZn,content_3813_612:()=>Gpt,content_3813_6120:()=>GZn,content_3813_6122:()=>UZn,content_3813_6124:()=>qZn,content_3813_6126:()=>YZn,content_3813_6128:()=>KZn,content_3813_6130:()=>ebn,content_3813_6132:()=>pbn,content_3813_6134:()=>cbn,content_3813_6136:()=>lbn,content_3813_6138:()=>dbn,content_3813_614:()=>Upt,content_3813_6140:()=>kbn,content_3813_6142:()=>Mbn,content_3813_6144:()=>wbn,content_3813_6146:()=>gbn,content_3813_6148:()=>Lbn,content_3813_6150:()=>Nbn,content_3813_6152:()=>Pbn,content_3813_6154:()=>Rbn,content_3813_6156:()=>Gbn,content_3813_6158:()=>Ubn,content_3813_616:()=>qpt,content_3813_6160:()=>qbn,content_3813_6162:()=>Ybn,content_3813_6164:()=>Kbn,content_3813_6166:()=>eNn,content_3813_6168:()=>pNn,content_3813_6170:()=>cNn,content_3813_6172:()=>lNn,content_3813_6174:()=>dNn,content_3813_6176:()=>kNn,content_3813_6178:()=>MNn,content_3813_618:()=>Ypt,content_3813_6180:()=>wNn,content_3813_6182:()=>gNn,content_3813_6184:()=>LNn,content_3813_6186:()=>NNn,content_3813_6188:()=>PNn,content_3813_6190:()=>RNn,content_3813_6192:()=>GNn,content_3813_6194:()=>UNn,content_3813_6196:()=>qNn,content_3813_6198:()=>YNn,content_3813_62:()=>CJ,content_3813_620:()=>Kpt,content_3813_6200:()=>KNn,content_3813_6202:()=>ezn,content_3813_6204:()=>pzn,content_3813_6206:()=>czn,content_3813_6208:()=>lzn,content_3813_6210:()=>dzn,content_3813_6212:()=>kzn,content_3813_6214:()=>Mzn,content_3813_6216:()=>wzn,content_3813_6218:()=>gzn,content_3813_622:()=>ert,content_3813_6220:()=>Lzn,content_3813_6222:()=>Nzn,content_3813_6224:()=>Pzn,content_3813_6226:()=>Rzn,content_3813_6228:()=>Gzn,content_3813_6230:()=>Uzn,content_3813_6232:()=>qzn,content_3813_6234:()=>Yzn,content_3813_6236:()=>Kzn,content_3813_6238:()=>eAn,content_3813_624:()=>prt,content_3813_6240:()=>pAn,content_3813_6242:()=>cAn,content_3813_6244:()=>lAn,content_3813_6246:()=>dAn,content_3813_6248:()=>kAn,content_3813_6250:()=>MAn,content_3813_6252:()=>wAn,content_3813_6254:()=>gAn,content_3813_6256:()=>LAn,content_3813_6258:()=>NAn,content_3813_626:()=>crt,content_3813_6260:()=>PAn,content_3813_6262:()=>RAn,content_3813_6264:()=>GAn,content_3813_6266:()=>UAn,content_3813_6268:()=>qAn,content_3813_6270:()=>YAn,content_3813_6272:()=>KAn,content_3813_6274:()=>ePn,content_3813_6276:()=>pPn,content_3813_6278:()=>cPn,content_3813_628:()=>lrt,content_3813_6280:()=>lPn,content_3813_6282:()=>dPn,content_3813_6284:()=>kPn,content_3813_6286:()=>MPn,content_3813_6288:()=>wPn,content_3813_6290:()=>gPn,content_3813_6292:()=>LPn,content_3813_6294:()=>NPn,content_3813_6296:()=>PPn,content_3813_6298:()=>RPn,content_3813_630:()=>drt,content_3813_6300:()=>GPn,content_3813_6302:()=>UPn,content_3813_6304:()=>qPn,content_3813_6306:()=>YPn,content_3813_6308:()=>KPn,content_3813_6310:()=>eIn,content_3813_6312:()=>pIn,content_3813_6314:()=>cIn,content_3813_6316:()=>lIn,content_3813_6318:()=>dIn,content_3813_632:()=>krt,content_3813_6320:()=>kIn,content_3813_6322:()=>MIn,content_3813_6324:()=>wIn,content_3813_6326:()=>gIn,content_3813_6328:()=>LIn,content_3813_6330:()=>NIn,content_3813_6332:()=>PIn,content_3813_6334:()=>RIn,content_3813_6336:()=>GIn,content_3813_6338:()=>UIn,content_3813_634:()=>Mrt,content_3813_6340:()=>qIn,content_3813_6342:()=>YIn,content_3813_6344:()=>KIn,content_3813_6346:()=>eWn,content_3813_6348:()=>pWn,content_3813_6350:()=>cWn,content_3813_6352:()=>lWn,content_3813_6354:()=>dWn,content_3813_6356:()=>kWn,content_3813_6358:()=>MWn,content_3813_636:()=>wrt,content_3813_6360:()=>wWn,content_3813_6362:()=>gWn,content_3813_6364:()=>LWn,content_3813_6366:()=>NWn,content_3813_6368:()=>PWn,content_3813_6370:()=>RWn,content_3813_6372:()=>GWn,content_3813_6374:()=>UWn,content_3813_6376:()=>qWn,content_3813_6378:()=>YWn,content_3813_638:()=>grt,content_3813_6380:()=>KWn,content_3813_6382:()=>eRn,content_3813_6384:()=>pRn,content_3813_6386:()=>cRn,content_3813_6388:()=>lRn,content_3813_6390:()=>dRn,content_3813_6392:()=>kRn,content_3813_6394:()=>MRn,content_3813_6396:()=>wRn,content_3813_6398:()=>gRn,content_3813_64:()=>vJ,content_3813_640:()=>Lrt,content_3813_6400:()=>LRn,content_3813_6402:()=>NRn,content_3813_6404:()=>PRn,content_3813_6406:()=>RRn,content_3813_6408:()=>GRn,content_3813_6410:()=>URn,content_3813_6412:()=>qRn,content_3813_6414:()=>YRn,content_3813_6416:()=>KRn,content_3813_6418:()=>eSn,content_3813_642:()=>Nrt,content_3813_6420:()=>pSn,content_3813_6422:()=>cSn,content_3813_6424:()=>lSn,content_3813_6426:()=>dSn,content_3813_6428:()=>kSn,content_3813_6430:()=>MSn,content_3813_6432:()=>wSn,content_3813_6434:()=>gSn,content_3813_6436:()=>LSn,content_3813_6438:()=>NSn,content_3813_644:()=>Prt,content_3813_6440:()=>PSn,content_3813_6442:()=>RSn,content_3813_6444:()=>GSn,content_3813_6446:()=>USn,content_3813_6448:()=>qSn,content_3813_6450:()=>YSn,content_3813_6452:()=>KSn,content_3813_6454:()=>eBn,content_3813_6456:()=>pBn,content_3813_6458:()=>cBn,content_3813_646:()=>Rrt,content_3813_6460:()=>lBn,content_3813_6462:()=>dBn,content_3813_6464:()=>kBn,content_3813_6466:()=>MBn,content_3813_6468:()=>wBn,content_3813_6470:()=>gBn,content_3813_6472:()=>LBn,content_3813_6474:()=>NBn,content_3813_6476:()=>PBn,content_3813_6478:()=>RBn,content_3813_648:()=>Grt,content_3813_6480:()=>GBn,content_3813_6482:()=>UBn,content_3813_6484:()=>qBn,content_3813_6486:()=>YBn,content_3813_6488:()=>KBn,content_3813_6490:()=>eGn,content_3813_6492:()=>pGn,content_3813_6494:()=>cGn,content_3813_6496:()=>lGn,content_3813_6498:()=>dGn,content_3813_650:()=>Urt,content_3813_6500:()=>kGn,content_3813_6502:()=>MGn,content_3813_6504:()=>wGn,content_3813_6506:()=>gGn,content_3813_6508:()=>LGn,content_3813_6510:()=>NGn,content_3813_6512:()=>PGn,content_3813_6514:()=>RGn,content_3813_6516:()=>GGn,content_3813_6518:()=>UGn,content_3813_652:()=>qrt,content_3813_6520:()=>qGn,content_3813_6522:()=>YGn,content_3813_6524:()=>KGn,content_3813_6526:()=>eEn,content_3813_6528:()=>pEn,content_3813_6530:()=>cEn,content_3813_6532:()=>lEn,content_3813_6534:()=>dEn,content_3813_6536:()=>kEn,content_3813_6538:()=>MEn,content_3813_654:()=>Yrt,content_3813_6540:()=>wEn,content_3813_6542:()=>gEn,content_3813_6544:()=>LEn,content_3813_6546:()=>NEn,content_3813_6548:()=>PEn,content_3813_6550:()=>REn,content_3813_6552:()=>GEn,content_3813_6554:()=>UEn,content_3813_6556:()=>qEn,content_3813_6558:()=>YEn,content_3813_656:()=>Krt,content_3813_6560:()=>KEn,content_3813_6562:()=>eOn,content_3813_6564:()=>pOn,content_3813_6566:()=>cOn,content_3813_6568:()=>lOn,content_3813_6570:()=>dOn,content_3813_6572:()=>kOn,content_3813_6574:()=>MOn,content_3813_6576:()=>wOn,content_3813_6578:()=>gOn,content_3813_658:()=>est,content_3813_6580:()=>LOn,content_3813_6582:()=>NOn,content_3813_6584:()=>POn,content_3813_6586:()=>ROn,content_3813_6588:()=>GOn,content_3813_6590:()=>UOn,content_3813_6592:()=>qOn,content_3813_6594:()=>YOn,content_3813_6596:()=>KOn,content_3813_6598:()=>eUn,content_3813_66:()=>bJ,content_3813_660:()=>pst,content_3813_6600:()=>pUn,content_3813_6602:()=>cUn,content_3813_6604:()=>lUn,content_3813_6606:()=>dUn,content_3813_6608:()=>kUn,content_3813_6610:()=>MUn,content_3813_6612:()=>wUn,content_3813_6614:()=>gUn,content_3813_6616:()=>LUn,content_3813_6618:()=>NUn,content_3813_662:()=>cst,content_3813_6620:()=>PUn,content_3813_6622:()=>RUn,content_3813_6624:()=>GUn,content_3813_6626:()=>UUn,content_3813_6628:()=>qUn,content_3813_6630:()=>YUn,content_3813_6632:()=>KUn,content_3813_6634:()=>eFn,content_3813_6636:()=>pFn,content_3813_6638:()=>cFn,content_3813_664:()=>lst,content_3813_6640:()=>lFn,content_3813_6642:()=>dFn,content_3813_6644:()=>kFn,content_3813_6646:()=>MFn,content_3813_6648:()=>wFn,content_3813_6650:()=>gFn,content_3813_6652:()=>LFn,content_3813_6654:()=>NFn,content_3813_6656:()=>PFn,content_3813_6658:()=>RFn,content_3813_666:()=>dst,content_3813_6660:()=>GFn,content_3813_6662:()=>UFn,content_3813_6664:()=>qFn,content_3813_6666:()=>YFn,content_3813_6668:()=>KFn,content_3813_6670:()=>eVn,content_3813_6672:()=>pVn,content_3813_6674:()=>cVn,content_3813_6676:()=>lVn,content_3813_6678:()=>dVn,content_3813_668:()=>kst,content_3813_6680:()=>kVn,content_3813_6682:()=>MVn,content_3813_6684:()=>wVn,content_3813_6686:()=>gVn,content_3813_6688:()=>LVn,content_3813_6690:()=>NVn,content_3813_6692:()=>PVn,content_3813_6694:()=>RVn,content_3813_6696:()=>GVn,content_3813_6698:()=>UVn,content_3813_670:()=>Mst,content_3813_6700:()=>qVn,content_3813_6702:()=>YVn,content_3813_6704:()=>KVn,content_3813_6706:()=>eqn,content_3813_6708:()=>pqn,content_3813_6710:()=>cqn,content_3813_6712:()=>lqn,content_3813_6714:()=>dqn,content_3813_6716:()=>kqn,content_3813_6718:()=>Mqn,content_3813_672:()=>wst,content_3813_6720:()=>wqn,content_3813_6722:()=>gqn,content_3813_6724:()=>Lqn,content_3813_6726:()=>Nqn,content_3813_6728:()=>Pqn,content_3813_6730:()=>Rqn,content_3813_6732:()=>Gqn,content_3813_6734:()=>Uqn,content_3813_6736:()=>qqn,content_3813_6738:()=>Yqn,content_3813_674:()=>gst,content_3813_6740:()=>Kqn,content_3813_6742:()=>ejn,content_3813_6744:()=>pjn,content_3813_6746:()=>cjn,content_3813_6748:()=>ljn,content_3813_6750:()=>djn,content_3813_6752:()=>kjn,content_3813_6754:()=>Mjn,content_3813_6756:()=>wjn,content_3813_6758:()=>gjn,content_3813_676:()=>Lst,content_3813_6760:()=>Ljn,content_3813_6762:()=>Njn,content_3813_6764:()=>Pjn,content_3813_6766:()=>Rjn,content_3813_6768:()=>Gjn,content_3813_6770:()=>Ujn,content_3813_6772:()=>qjn,content_3813_6774:()=>Yjn,content_3813_6776:()=>Kjn,content_3813_6778:()=>eHn,content_3813_678:()=>Nst,content_3813_6780:()=>pHn,content_3813_6782:()=>cHn,content_3813_6784:()=>lHn,content_3813_6786:()=>dHn,content_3813_6788:()=>kHn,content_3813_6790:()=>MHn,content_3813_6792:()=>wHn,content_3813_6794:()=>gHn,content_3813_6796:()=>LHn,content_3813_6798:()=>NHn,content_3813_68:()=>AJ,content_3813_680:()=>Pst,content_3813_6800:()=>PHn,content_3813_6802:()=>RHn,content_3813_6804:()=>GHn,content_3813_6806:()=>UHn,content_3813_6808:()=>qHn,content_3813_6810:()=>YHn,content_3813_6812:()=>KHn,content_3813_6814:()=>eYn,content_3813_6816:()=>pYn,content_3813_6818:()=>cYn,content_3813_682:()=>Rst,content_3813_6820:()=>lYn,content_3813_6822:()=>dYn,content_3813_6824:()=>kYn,content_3813_6826:()=>MYn,content_3813_6828:()=>wYn,content_3813_6830:()=>gYn,content_3813_6832:()=>LYn,content_3813_6834:()=>NYn,content_3813_6836:()=>PYn,content_3813_6838:()=>RYn,content_3813_684:()=>Gst,content_3813_6840:()=>GYn,content_3813_6842:()=>UYn,content_3813_6844:()=>qYn,content_3813_6846:()=>YYn,content_3813_6848:()=>KYn,content_3813_6850:()=>eQn,content_3813_6852:()=>pQn,content_3813_6854:()=>cQn,content_3813_6856:()=>lQn,content_3813_6858:()=>dQn,content_3813_686:()=>Ust,content_3813_6860:()=>kQn,content_3813_6862:()=>MQn,content_3813_6864:()=>wQn,content_3813_6866:()=>gQn,content_3813_6868:()=>LQn,content_3813_6870:()=>NQn,content_3813_6872:()=>PQn,content_3813_6874:()=>RQn,content_3813_6876:()=>GQn,content_3813_6878:()=>UQn,content_3813_688:()=>qst,content_3813_6880:()=>qQn,content_3813_6882:()=>YQn,content_3813_6884:()=>KQn,content_3813_6886:()=>e$n,content_3813_6888:()=>p$n,content_3813_6890:()=>c$n,content_3813_6892:()=>l$n,content_3813_6894:()=>d$n,content_3813_6896:()=>k$n,content_3813_6898:()=>M$n,content_3813_690:()=>Yst,content_3813_6900:()=>w$n,content_3813_6902:()=>g$n,content_3813_6904:()=>L$n,content_3813_6906:()=>N$n,content_3813_6908:()=>P$n,content_3813_6910:()=>R$n,content_3813_6912:()=>G$n,content_3813_6914:()=>U$n,content_3813_6916:()=>q$n,content_3813_6918:()=>Y$n,content_3813_692:()=>Kst,content_3813_6920:()=>K$n,content_3813_6922:()=>eKn,content_3813_6924:()=>pKn,content_3813_6926:()=>cKn,content_3813_6928:()=>lKn,content_3813_6930:()=>dKn,content_3813_6932:()=>kKn,content_3813_6934:()=>MKn,content_3813_6936:()=>wKn,content_3813_6938:()=>gKn,content_3813_694:()=>ect,content_3813_6940:()=>LKn,content_3813_6942:()=>NKn,content_3813_6944:()=>PKn,content_3813_6946:()=>RKn,content_3813_6948:()=>GKn,content_3813_6950:()=>UKn,content_3813_6952:()=>qKn,content_3813_6954:()=>YKn,content_3813_6956:()=>KKn,content_3813_6958:()=>eJn,content_3813_696:()=>pct,content_3813_6960:()=>pJn,content_3813_6962:()=>cJn,content_3813_6964:()=>lJn,content_3813_6966:()=>dJn,content_3813_6968:()=>kJn,content_3813_6970:()=>MJn,content_3813_6972:()=>wJn,content_3813_6974:()=>gJn,content_3813_6976:()=>LJn,content_3813_6978:()=>NJn,content_3813_698:()=>cct,content_3813_6980:()=>PJn,content_3813_6982:()=>RJn,content_3813_6984:()=>GJn,content_3813_6986:()=>UJn,content_3813_6988:()=>qJn,content_3813_6990:()=>YJn,content_3813_6992:()=>KJn,content_3813_6994:()=>e0n,content_3813_6996:()=>p0n,content_3813_6998:()=>c0n,content_3813_70:()=>WJ,content_3813_700:()=>lct,content_3813_7000:()=>l0n,content_3813_7002:()=>d0n,content_3813_7004:()=>k0n,content_3813_7006:()=>M0n,content_3813_7008:()=>w0n,content_3813_7010:()=>g0n,content_3813_7012:()=>L0n,content_3813_7014:()=>N0n,content_3813_7016:()=>P0n,content_3813_7018:()=>R0n,content_3813_702:()=>dct,content_3813_7020:()=>G0n,content_3813_7022:()=>U0n,content_3813_7024:()=>q0n,content_3813_7026:()=>Y0n,content_3813_7028:()=>K0n,content_3813_7030:()=>e3n,content_3813_7032:()=>p3n,content_3813_7034:()=>c3n,content_3813_7036:()=>l3n,content_3813_7038:()=>d3n,content_3813_704:()=>kct,content_3813_7040:()=>k3n,content_3813_7042:()=>M3n,content_3813_7044:()=>w3n,content_3813_7046:()=>g3n,content_3813_7048:()=>L3n,content_3813_7050:()=>N3n,content_3813_7052:()=>P3n,content_3813_7054:()=>R3n,content_3813_7056:()=>G3n,content_3813_7058:()=>U3n,content_3813_706:()=>Mct,content_3813_7060:()=>q3n,content_3813_7062:()=>Y3n,content_3813_7064:()=>K3n,content_3813_7066:()=>e1n,content_3813_7068:()=>p1n,content_3813_7070:()=>c1n,content_3813_7072:()=>l1n,content_3813_7074:()=>d1n,content_3813_7076:()=>k1n,content_3813_7078:()=>M1n,content_3813_708:()=>wct,content_3813_7080:()=>w1n,content_3813_7082:()=>g1n,content_3813_7084:()=>L1n,content_3813_7086:()=>N1n,content_3813_7088:()=>P1n,content_3813_7090:()=>R1n,content_3813_7092:()=>G1n,content_3813_7094:()=>U1n,content_3813_7096:()=>q1n,content_3813_7098:()=>Y1n,content_3813_710:()=>gct,content_3813_7100:()=>K1n,content_3813_7102:()=>e8n,content_3813_7104:()=>p8n,content_3813_7106:()=>c8n,content_3813_7108:()=>l8n,content_3813_7110:()=>d8n,content_3813_7112:()=>k8n,content_3813_7114:()=>M8n,content_3813_7116:()=>w8n,content_3813_7118:()=>g8n,content_3813_712:()=>Lct,content_3813_7120:()=>L8n,content_3813_7122:()=>N8n,content_3813_7124:()=>P8n,content_3813_7126:()=>R8n,content_3813_7128:()=>G8n,content_3813_7130:()=>U8n,content_3813_7132:()=>q8n,content_3813_7134:()=>Y8n,content_3813_7136:()=>K8n,content_3813_7138:()=>e2n,content_3813_714:()=>Nct,content_3813_7140:()=>p2n,content_3813_7142:()=>c2n,content_3813_7144:()=>l2n,content_3813_7146:()=>d2n,content_3813_7148:()=>k2n,content_3813_7150:()=>M2n,content_3813_7152:()=>w2n,content_3813_7154:()=>g2n,content_3813_7156:()=>L2n,content_3813_7158:()=>N2n,content_3813_716:()=>Pct,content_3813_7160:()=>P2n,content_3813_7162:()=>R2n,content_3813_7164:()=>G2n,content_3813_7166:()=>U2n,content_3813_7168:()=>q2n,content_3813_7170:()=>Y2n,content_3813_7172:()=>K2n,content_3813_7174:()=>e4n,content_3813_7176:()=>p4n,content_3813_7178:()=>c4n,content_3813_718:()=>Rct,content_3813_7180:()=>l4n,content_3813_7182:()=>d4n,content_3813_7184:()=>k4n,content_3813_7186:()=>M4n,content_3813_7188:()=>w4n,content_3813_7190:()=>g4n,content_3813_7192:()=>L4n,content_3813_7194:()=>N4n,content_3813_7196:()=>P4n,content_3813_7198:()=>R4n,content_3813_72:()=>BJ,content_3813_720:()=>Gct,content_3813_7200:()=>G4n,content_3813_7202:()=>U4n,content_3813_7204:()=>q4n,content_3813_7206:()=>Y4n,content_3813_7208:()=>K4n,content_3813_7210:()=>e6n,content_3813_7212:()=>p6n,content_3813_7214:()=>c6n,content_3813_7216:()=>l6n,content_3813_7218:()=>d6n,content_3813_722:()=>Uct,content_3813_7220:()=>k6n,content_3813_7222:()=>M6n,content_3813_7224:()=>w6n,content_3813_7226:()=>g6n,content_3813_7228:()=>L6n,content_3813_7230:()=>N6n,content_3813_7232:()=>P6n,content_3813_7234:()=>R6n,content_3813_7236:()=>G6n,content_3813_7238:()=>U6n,content_3813_724:()=>qct,content_3813_7240:()=>q6n,content_3813_7242:()=>Y6n,content_3813_7244:()=>K6n,content_3813_7246:()=>e5n,content_3813_7248:()=>p5n,content_3813_7250:()=>c5n,content_3813_7252:()=>l5n,content_3813_7254:()=>d5n,content_3813_7256:()=>k5n,content_3813_7258:()=>M5n,content_3813_726:()=>Yct,content_3813_7260:()=>w5n,content_3813_7262:()=>g5n,content_3813_7264:()=>L5n,content_3813_7266:()=>N5n,content_3813_7268:()=>P5n,content_3813_7270:()=>R5n,content_3813_7272:()=>G5n,content_3813_7274:()=>U5n,content_3813_7276:()=>q5n,content_3813_7278:()=>Y5n,content_3813_728:()=>Kct,content_3813_7280:()=>K5n,content_3813_7282:()=>e7n,content_3813_7284:()=>p7n,content_3813_7286:()=>c7n,content_3813_7288:()=>l7n,content_3813_7290:()=>d7n,content_3813_7292:()=>k7n,content_3813_7294:()=>M7n,content_3813_7296:()=>w7n,content_3813_7298:()=>g7n,content_3813_730:()=>eat,content_3813_7300:()=>L7n,content_3813_7302:()=>N7n,content_3813_7304:()=>P7n,content_3813_7306:()=>R7n,content_3813_7308:()=>G7n,content_3813_7310:()=>U7n,content_3813_7312:()=>q7n,content_3813_7314:()=>Y7n,content_3813_7316:()=>K7n,content_3813_7318:()=>e9n,content_3813_732:()=>pat,content_3813_7320:()=>p9n,content_3813_7322:()=>c9n,content_3813_7324:()=>l9n,content_3813_7326:()=>d9n,content_3813_7328:()=>k9n,content_3813_7330:()=>M9n,content_3813_7332:()=>w9n,content_3813_7334:()=>g9n,content_3813_7336:()=>L9n,content_3813_7338:()=>N9n,content_3813_734:()=>cat,content_3813_7340:()=>P9n,content_3813_7342:()=>R9n,content_3813_7344:()=>G9n,content_3813_7346:()=>U9n,content_3813_7348:()=>q9n,content_3813_7350:()=>Y9n,content_3813_7352:()=>K9n,content_3813_7354:()=>eto,content_3813_7356:()=>pto,content_3813_7358:()=>cto,content_3813_736:()=>lat,content_3813_7360:()=>lto,content_3813_7362:()=>dto,content_3813_7364:()=>kto,content_3813_7366:()=>Mto,content_3813_7368:()=>wto,content_3813_7370:()=>gto,content_3813_7372:()=>Lto,content_3813_7374:()=>Nto,content_3813_7376:()=>Pto,content_3813_7378:()=>Rto,content_3813_738:()=>dat,content_3813_7380:()=>Gto,content_3813_7382:()=>Uto,content_3813_7384:()=>qto,content_3813_7386:()=>Yto,content_3813_7388:()=>Kto,content_3813_7390:()=>eeo,content_3813_7392:()=>peo,content_3813_7394:()=>ceo,content_3813_7396:()=>leo,content_3813_7398:()=>deo,content_3813_74:()=>OJ,content_3813_740:()=>kat,content_3813_7400:()=>keo,content_3813_7402:()=>Meo,content_3813_7404:()=>weo,content_3813_7406:()=>geo,content_3813_7408:()=>Leo,content_3813_7410:()=>Neo,content_3813_7412:()=>Peo,content_3813_7414:()=>Reo,content_3813_7416:()=>Geo,content_3813_7418:()=>Ueo,content_3813_742:()=>Mat,content_3813_7420:()=>qeo,content_3813_7422:()=>Yeo,content_3813_7424:()=>Keo,content_3813_7426:()=>eno,content_3813_7428:()=>pno,content_3813_7430:()=>cno,content_3813_7432:()=>lno,content_3813_7434:()=>dno,content_3813_7436:()=>kno,content_3813_7438:()=>Mno,content_3813_744:()=>wat,content_3813_7440:()=>wno,content_3813_7442:()=>gno,content_3813_7444:()=>Lno,content_3813_7446:()=>Nno,content_3813_7448:()=>Pno,content_3813_7450:()=>Rno,content_3813_7452:()=>Gno,content_3813_7454:()=>Uno,content_3813_7456:()=>qno,content_3813_7458:()=>Yno,content_3813_746:()=>gat,content_3813_7460:()=>Kno,content_3813_7462:()=>eoo,content_3813_7464:()=>poo,content_3813_7466:()=>coo,content_3813_7468:()=>loo,content_3813_7470:()=>doo,content_3813_7472:()=>koo,content_3813_7474:()=>Moo,content_3813_7476:()=>woo,content_3813_7478:()=>goo,content_3813_748:()=>Lat,content_3813_7480:()=>Loo,content_3813_7482:()=>Noo,content_3813_7484:()=>Poo,content_3813_7486:()=>Roo,content_3813_7488:()=>Goo,content_3813_7490:()=>Uoo,content_3813_7492:()=>qoo,content_3813_7494:()=>Yoo,content_3813_7496:()=>Koo,content_3813_7498:()=>epo,content_3813_750:()=>Nat,content_3813_7500:()=>ppo,content_3813_7502:()=>cpo,content_3813_7504:()=>lpo,content_3813_7506:()=>dpo,content_3813_7508:()=>kpo,content_3813_7510:()=>Mpo,content_3813_7512:()=>wpo,content_3813_7514:()=>gpo,content_3813_7516:()=>Lpo,content_3813_7518:()=>Npo,content_3813_752:()=>Pat,content_3813_7520:()=>Ppo,content_3813_7522:()=>Rpo,content_3813_7524:()=>Gpo,content_3813_7526:()=>Upo,content_3813_7528:()=>qpo,content_3813_7530:()=>Ypo,content_3813_7532:()=>Kpo,content_3813_7534:()=>ero,content_3813_7536:()=>pro,content_3813_7538:()=>cro,content_3813_754:()=>Rat,content_3813_7540:()=>lro,content_3813_7542:()=>dro,content_3813_7544:()=>kro,content_3813_7546:()=>Mro,content_3813_7548:()=>wro,content_3813_7550:()=>gro,content_3813_7552:()=>Lro,content_3813_7554:()=>Nro,content_3813_7556:()=>Pro,content_3813_7558:()=>Rro,content_3813_756:()=>Gat,content_3813_7560:()=>Gro,content_3813_7562:()=>Uro,content_3813_7564:()=>qro,content_3813_7566:()=>Yro,content_3813_7568:()=>Kro,content_3813_7570:()=>eso,content_3813_7572:()=>pso,content_3813_7574:()=>cso,content_3813_7576:()=>lso,content_3813_7578:()=>dso,content_3813_758:()=>Uat,content_3813_7580:()=>kso,content_3813_7582:()=>Mso,content_3813_7584:()=>wso,content_3813_7586:()=>gso,content_3813_7588:()=>Lso,content_3813_7590:()=>Nso,content_3813_7592:()=>Pso,content_3813_7594:()=>Rso,content_3813_7596:()=>Gso,content_3813_7598:()=>Uso,content_3813_76:()=>VJ,content_3813_760:()=>qat,content_3813_7600:()=>qso,content_3813_7602:()=>Yso,content_3813_7604:()=>Kso,content_3813_7606:()=>eco,content_3813_7608:()=>pco,content_3813_7610:()=>cco,content_3813_7612:()=>lco,content_3813_7614:()=>dco,content_3813_7616:()=>kco,content_3813_7618:()=>Mco,content_3813_762:()=>Yat,content_3813_7620:()=>wco,content_3813_7622:()=>gco,content_3813_7624:()=>Lco,content_3813_7626:()=>Nco,content_3813_7628:()=>Pco,content_3813_7630:()=>Rco,content_3813_7632:()=>Gco,content_3813_7634:()=>Uco,content_3813_7636:()=>qco,content_3813_7638:()=>Yco,content_3813_764:()=>Kat,content_3813_7640:()=>Kco,content_3813_7642:()=>eao,content_3813_7644:()=>pao,content_3813_7646:()=>cao,content_3813_7648:()=>lao,content_3813_7650:()=>dao,content_3813_7652:()=>kao,content_3813_7654:()=>Mao,content_3813_7656:()=>wao,content_3813_7658:()=>gao,content_3813_766:()=>eit,content_3813_7660:()=>Lao,content_3813_7662:()=>Nao,content_3813_7664:()=>Pao,content_3813_7666:()=>Rao,content_3813_7668:()=>Gao,content_3813_7670:()=>Uao,content_3813_7672:()=>qao,content_3813_7674:()=>Yao,content_3813_7676:()=>Kao,content_3813_7678:()=>eio,content_3813_768:()=>pit,content_3813_7680:()=>pio,content_3813_7682:()=>cio,content_3813_7684:()=>lio,content_3813_7686:()=>dio,content_3813_7688:()=>kio,content_3813_7690:()=>Mio,content_3813_7692:()=>wio,content_3813_7694:()=>gio,content_3813_7696:()=>Lio,content_3813_7698:()=>Nio,content_3813_770:()=>cit,content_3813_7700:()=>Pio,content_3813_7702:()=>Rio,content_3813_7704:()=>Gio,content_3813_7706:()=>Uio,content_3813_7708:()=>qio,content_3813_7710:()=>Yio,content_3813_7712:()=>Kio,content_3813_7714:()=>elo,content_3813_7716:()=>plo,content_3813_7718:()=>clo,content_3813_772:()=>lit,content_3813_7720:()=>llo,content_3813_7722:()=>dlo,content_3813_7724:()=>klo,content_3813_7726:()=>Mlo,content_3813_7728:()=>wlo,content_3813_7730:()=>glo,content_3813_7732:()=>Llo,content_3813_7734:()=>Nlo,content_3813_7736:()=>Plo,content_3813_7738:()=>Rlo,content_3813_774:()=>dit,content_3813_7740:()=>Glo,content_3813_7742:()=>Ulo,content_3813_7744:()=>qlo,content_3813_7746:()=>Ylo,content_3813_7748:()=>Klo,content_3813_7750:()=>euo,content_3813_7752:()=>puo,content_3813_7754:()=>cuo,content_3813_7756:()=>luo,content_3813_7758:()=>duo,content_3813_776:()=>kit,content_3813_7760:()=>kuo,content_3813_7762:()=>Muo,content_3813_7764:()=>wuo,content_3813_7766:()=>guo,content_3813_7768:()=>Luo,content_3813_7770:()=>Nuo,content_3813_7772:()=>Puo,content_3813_7774:()=>Ruo,content_3813_7776:()=>Guo,content_3813_7778:()=>Uuo,content_3813_778:()=>Mit,content_3813_7780:()=>quo,content_3813_7782:()=>Yuo,content_3813_7784:()=>Kuo,content_3813_7786:()=>emo,content_3813_7788:()=>pmo,content_3813_7790:()=>cmo,content_3813_7792:()=>lmo,content_3813_7794:()=>dmo,content_3813_7796:()=>kmo,content_3813_7798:()=>Mmo,content_3813_78:()=>HJ,content_3813_780:()=>wit,content_3813_7800:()=>wmo,content_3813_7802:()=>gmo,content_3813_7804:()=>Lmo,content_3813_7806:()=>Nmo,content_3813_7808:()=>Pmo,content_3813_7810:()=>Rmo,content_3813_7812:()=>Gmo,content_3813_7814:()=>Umo,content_3813_7816:()=>qmo,content_3813_7818:()=>Ymo,content_3813_782:()=>git,content_3813_7820:()=>Kmo,content_3813_7822:()=>edo,content_3813_7824:()=>pdo,content_3813_7826:()=>cdo,content_3813_7828:()=>ldo,content_3813_7830:()=>ddo,content_3813_7832:()=>kdo,content_3813_7834:()=>Mdo,content_3813_7836:()=>wdo,content_3813_7838:()=>gdo,content_3813_784:()=>Lit,content_3813_7840:()=>Ldo,content_3813_7842:()=>Ndo,content_3813_7844:()=>Pdo,content_3813_7846:()=>Rdo,content_3813_7848:()=>Gdo,content_3813_7850:()=>Udo,content_3813_7852:()=>qdo,content_3813_7854:()=>Ydo,content_3813_7856:()=>Kdo,content_3813_7858:()=>eho,content_3813_786:()=>Nit,content_3813_7860:()=>pho,content_3813_7862:()=>cho,content_3813_7864:()=>lho,content_3813_7866:()=>dho,content_3813_7868:()=>kho,content_3813_7870:()=>Mho,content_3813_7872:()=>who,content_3813_7874:()=>gho,content_3813_7876:()=>Lho,content_3813_7878:()=>Nho,content_3813_788:()=>Pit,content_3813_7880:()=>Pho,content_3813_7882:()=>Rho,content_3813_7884:()=>Gho,content_3813_7886:()=>Uho,content_3813_7888:()=>qho,content_3813_7890:()=>Yho,content_3813_7892:()=>Kho,content_3813_7894:()=>efo,content_3813_7896:()=>pfo,content_3813_7898:()=>cfo,content_3813_790:()=>Rit,content_3813_7900:()=>lfo,content_3813_7902:()=>dfo,content_3813_7904:()=>kfo,content_3813_7906:()=>Mfo,content_3813_7908:()=>wfo,content_3813_7910:()=>gfo,content_3813_7912:()=>Lfo,content_3813_7914:()=>Nfo,content_3813_7916:()=>Pfo,content_3813_7918:()=>Rfo,content_3813_792:()=>Git,content_3813_7920:()=>Gfo,content_3813_7922:()=>Ufo,content_3813_7924:()=>qfo,content_3813_7926:()=>Yfo,content_3813_7928:()=>Kfo,content_3813_7930:()=>eko,content_3813_7932:()=>pko,content_3813_7934:()=>cko,content_3813_7936:()=>lko,content_3813_7938:()=>dko,content_3813_794:()=>Uit,content_3813_7940:()=>kko,content_3813_7942:()=>Mko,content_3813_7944:()=>wko,content_3813_7946:()=>gko,content_3813_7948:()=>Lko,content_3813_7950:()=>Nko,content_3813_7952:()=>Pko,content_3813_7954:()=>Rko,content_3813_7956:()=>Gko,content_3813_7958:()=>Uko,content_3813_796:()=>qit,content_3813_7960:()=>qko,content_3813_7962:()=>Yko,content_3813_7964:()=>Kko,content_3813_7966:()=>eyo,content_3813_7968:()=>pyo,content_3813_7970:()=>cyo,content_3813_7972:()=>lyo,content_3813_7974:()=>dyo,content_3813_7976:()=>kyo,content_3813_7978:()=>Myo,content_3813_798:()=>Yit,content_3813_7980:()=>wyo,content_3813_7982:()=>gyo,content_3813_7984:()=>Lyo,content_3813_7986:()=>Nyo,content_3813_7988:()=>Pyo,content_3813_7990:()=>Ryo,content_3813_7992:()=>Gyo,content_3813_7994:()=>Uyo,content_3813_7996:()=>qyo,content_3813_7998:()=>Yyo,content_3813_8:()=>$$,content_3813_80:()=>$J,content_3813_800:()=>Kit,content_3813_8000:()=>Kyo,content_3813_8002:()=>eDo,content_3813_8004:()=>pDo,content_3813_8006:()=>cDo,content_3813_8008:()=>lDo,content_3813_8010:()=>dDo,content_3813_8012:()=>kDo,content_3813_8014:()=>MDo,content_3813_8016:()=>wDo,content_3813_8018:()=>gDo,content_3813_802:()=>elt,content_3813_8020:()=>LDo,content_3813_8022:()=>NDo,content_3813_8024:()=>PDo,content_3813_8026:()=>RDo,content_3813_8028:()=>GDo,content_3813_8030:()=>UDo,content_3813_8032:()=>qDo,content_3813_8034:()=>YDo,content_3813_8036:()=>KDo,content_3813_8038:()=>eMo,content_3813_804:()=>plt,content_3813_8040:()=>pMo,content_3813_8042:()=>cMo,content_3813_8044:()=>lMo,content_3813_8046:()=>dMo,content_3813_8048:()=>kMo,content_3813_8050:()=>MMo,content_3813_8052:()=>wMo,content_3813_8054:()=>gMo,content_3813_8056:()=>LMo,content_3813_8058:()=>NMo,content_3813_806:()=>clt,content_3813_8060:()=>PMo,content_3813_8062:()=>RMo,content_3813_8064:()=>GMo,content_3813_8066:()=>UMo,content_3813_8068:()=>qMo,content_3813_8070:()=>YMo,content_3813_8072:()=>KMo,content_3813_8074:()=>eXo,content_3813_8076:()=>pXo,content_3813_8078:()=>cXo,content_3813_808:()=>llt,content_3813_8080:()=>lXo,content_3813_8082:()=>dXo,content_3813_8084:()=>kXo,content_3813_8086:()=>MXo,content_3813_8088:()=>wXo,content_3813_8090:()=>gXo,content_3813_8092:()=>LXo,content_3813_8094:()=>NXo,content_3813_8096:()=>PXo,content_3813_8098:()=>RXo,content_3813_810:()=>dlt,content_3813_8100:()=>GXo,content_3813_8102:()=>UXo,content_3813_8104:()=>qXo,content_3813_8106:()=>YXo,content_3813_8108:()=>KXo,content_3813_8110:()=>e_o,content_3813_8112:()=>p_o,content_3813_8114:()=>c_o,content_3813_8116:()=>l_o,content_3813_8118:()=>d_o,content_3813_812:()=>klt,content_3813_8120:()=>k_o,content_3813_8122:()=>M_o,content_3813_8124:()=>w_o,content_3813_8126:()=>g_o,content_3813_8128:()=>L_o,content_3813_8130:()=>N_o,content_3813_8132:()=>P_o,content_3813_8134:()=>R_o,content_3813_8136:()=>G_o,content_3813_8138:()=>U_o,content_3813_814:()=>Mlt,content_3813_8140:()=>q_o,content_3813_8142:()=>Y_o,content_3813_8144:()=>K_o,content_3813_8146:()=>ewo,content_3813_8148:()=>pwo,content_3813_8150:()=>cwo,content_3813_8152:()=>lwo,content_3813_8154:()=>dwo,content_3813_8156:()=>kwo,content_3813_8158:()=>Mwo,content_3813_816:()=>wlt,content_3813_8160:()=>wwo,content_3813_8162:()=>gwo,content_3813_8164:()=>Lwo,content_3813_8166:()=>Nwo,content_3813_8168:()=>Pwo,content_3813_8170:()=>Rwo,content_3813_8172:()=>Gwo,content_3813_8174:()=>Uwo,content_3813_8176:()=>qwo,content_3813_8178:()=>Ywo,content_3813_818:()=>glt,content_3813_8180:()=>Kwo,content_3813_8182:()=>eTo,content_3813_8184:()=>pTo,content_3813_8186:()=>cTo,content_3813_8188:()=>lTo,content_3813_8190:()=>dTo,content_3813_8192:()=>kTo,content_3813_8194:()=>MTo,content_3813_8196:()=>wTo,content_3813_8198:()=>gTo,content_3813_82:()=>t0,content_3813_820:()=>Llt,content_3813_8200:()=>LTo,content_3813_8202:()=>NTo,content_3813_8204:()=>PTo,content_3813_8206:()=>RTo,content_3813_8208:()=>GTo,content_3813_8210:()=>UTo,content_3813_8212:()=>qTo,content_3813_8214:()=>YTo,content_3813_8216:()=>KTo,content_3813_8218:()=>eCo,content_3813_822:()=>Nlt,content_3813_8220:()=>pCo,content_3813_8222:()=>cCo,content_3813_8224:()=>lCo,content_3813_8226:()=>dCo,content_3813_8228:()=>kCo,content_3813_8230:()=>MCo,content_3813_8232:()=>wCo,content_3813_8234:()=>gCo,content_3813_8236:()=>LCo,content_3813_8238:()=>NCo,content_3813_824:()=>Plt,content_3813_8240:()=>PCo,content_3813_8242:()=>RCo,content_3813_8244:()=>GCo,content_3813_8246:()=>UCo,content_3813_8248:()=>qCo,content_3813_8250:()=>YCo,content_3813_8252:()=>KCo,content_3813_8254:()=>ego,content_3813_8256:()=>pgo,content_3813_8258:()=>cgo,content_3813_826:()=>Rlt,content_3813_8260:()=>lgo,content_3813_8262:()=>dgo,content_3813_8264:()=>kgo,content_3813_8266:()=>Mgo,content_3813_8268:()=>wgo,content_3813_8270:()=>ggo,content_3813_8272:()=>Lgo,content_3813_8274:()=>Ngo,content_3813_8276:()=>Pgo,content_3813_8278:()=>Rgo,content_3813_828:()=>Glt,content_3813_8280:()=>Ggo,content_3813_8282:()=>Ugo,content_3813_8284:()=>qgo,content_3813_8286:()=>Ygo,content_3813_8288:()=>Kgo,content_3813_8290:()=>exo,content_3813_8292:()=>pxo,content_3813_8294:()=>cxo,content_3813_8296:()=>lxo,content_3813_8298:()=>dxo,content_3813_830:()=>Ult,content_3813_8300:()=>kxo,content_3813_8302:()=>Mxo,content_3813_8304:()=>wxo,content_3813_8306:()=>gxo,content_3813_8308:()=>Lxo,content_3813_8310:()=>Nxo,content_3813_8312:()=>Pxo,content_3813_8314:()=>Rxo,content_3813_8316:()=>Gxo,content_3813_8318:()=>Uxo,content_3813_832:()=>qlt,content_3813_8320:()=>qxo,content_3813_8322:()=>Yxo,content_3813_8324:()=>Kxo,content_3813_8326:()=>evo,content_3813_8328:()=>pvo,content_3813_8330:()=>cvo,content_3813_8332:()=>lvo,content_3813_8334:()=>dvo,content_3813_8336:()=>kvo,content_3813_8338:()=>Mvo,content_3813_834:()=>Ylt,content_3813_8340:()=>wvo,content_3813_8342:()=>gvo,content_3813_8344:()=>Lvo,content_3813_8346:()=>Nvo,content_3813_8348:()=>Pvo,content_3813_8350:()=>Rvo,content_3813_8352:()=>Gvo,content_3813_8354:()=>Uvo,content_3813_8356:()=>qvo,content_3813_8358:()=>Yvo,content_3813_836:()=>Klt,content_3813_8360:()=>Kvo,content_3813_8362:()=>eLo,content_3813_8364:()=>pLo,content_3813_8366:()=>cLo,content_3813_8368:()=>lLo,content_3813_8370:()=>dLo,content_3813_8372:()=>kLo,content_3813_8374:()=>MLo,content_3813_8376:()=>wLo,content_3813_8378:()=>gLo,content_3813_838:()=>eut,content_3813_8380:()=>LLo,content_3813_8382:()=>NLo,content_3813_8384:()=>PLo,content_3813_8386:()=>RLo,content_3813_8388:()=>GLo,content_3813_8390:()=>ULo,content_3813_8392:()=>qLo,content_3813_8394:()=>YLo,content_3813_8396:()=>KLo,content_3813_8398:()=>eZo,content_3813_84:()=>o0,content_3813_840:()=>put,content_3813_8400:()=>pZo,content_3813_8402:()=>cZo,content_3813_8404:()=>lZo,content_3813_8406:()=>dZo,content_3813_8408:()=>kZo,content_3813_8410:()=>MZo,content_3813_8412:()=>wZo,content_3813_8414:()=>gZo,content_3813_8416:()=>LZo,content_3813_8418:()=>NZo,content_3813_842:()=>cut,content_3813_8420:()=>PZo,content_3813_8422:()=>RZo,content_3813_8424:()=>GZo,content_3813_8426:()=>UZo,content_3813_8428:()=>qZo,content_3813_8430:()=>YZo,content_3813_8432:()=>KZo,content_3813_8434:()=>ebo,content_3813_8436:()=>pbo,content_3813_8438:()=>cbo,content_3813_844:()=>lut,content_3813_8440:()=>lbo,content_3813_8442:()=>dbo,content_3813_8444:()=>kbo,content_3813_8446:()=>Mbo,content_3813_8448:()=>wbo,content_3813_8450:()=>gbo,content_3813_8452:()=>Lbo,content_3813_8454:()=>Nbo,content_3813_8456:()=>Pbo,content_3813_8458:()=>Rbo,content_3813_846:()=>dut,content_3813_8460:()=>Gbo,content_3813_8462:()=>Ubo,content_3813_8464:()=>qbo,content_3813_8466:()=>Ybo,content_3813_8468:()=>Kbo,content_3813_8470:()=>eNo,content_3813_8472:()=>pNo,content_3813_8474:()=>cNo,content_3813_8476:()=>lNo,content_3813_8478:()=>dNo,content_3813_848:()=>kut,content_3813_8480:()=>kNo,content_3813_8482:()=>MNo,content_3813_8484:()=>wNo,content_3813_8486:()=>gNo,content_3813_8488:()=>LNo,content_3813_8490:()=>NNo,content_3813_8492:()=>PNo,content_3813_8494:()=>RNo,content_3813_8496:()=>GNo,content_3813_8498:()=>UNo,content_3813_850:()=>Mut,content_3813_8500:()=>qNo,content_3813_8502:()=>YNo,content_3813_8504:()=>KNo,content_3813_8506:()=>ezo,content_3813_8508:()=>pzo,content_3813_8510:()=>czo,content_3813_8512:()=>lzo,content_3813_8514:()=>dzo,content_3813_8516:()=>kzo,content_3813_8518:()=>Mzo,content_3813_852:()=>wut,content_3813_8520:()=>wzo,content_3813_8522:()=>gzo,content_3813_8524:()=>Lzo,content_3813_8526:()=>Nzo,content_3813_8528:()=>Pzo,content_3813_8530:()=>Rzo,content_3813_8532:()=>Gzo,content_3813_8534:()=>Uzo,content_3813_8536:()=>qzo,content_3813_8538:()=>Yzo,content_3813_854:()=>gut,content_3813_8540:()=>Kzo,content_3813_8542:()=>eAo,content_3813_8544:()=>pAo,content_3813_8546:()=>cAo,content_3813_8548:()=>lAo,content_3813_8550:()=>dAo,content_3813_8552:()=>kAo,content_3813_8554:()=>MAo,content_3813_8556:()=>wAo,content_3813_8558:()=>gAo,content_3813_856:()=>Lut,content_3813_8560:()=>LAo,content_3813_8562:()=>NAo,content_3813_8564:()=>PAo,content_3813_8566:()=>RAo,content_3813_8568:()=>GAo,content_3813_8570:()=>UAo,content_3813_8572:()=>qAo,content_3813_8574:()=>YAo,content_3813_8576:()=>KAo,content_3813_8578:()=>ePo,content_3813_858:()=>Nut,content_3813_8580:()=>pPo,content_3813_8582:()=>cPo,content_3813_8584:()=>lPo,content_3813_8586:()=>dPo,content_3813_8588:()=>kPo,content_3813_8590:()=>MPo,content_3813_8592:()=>wPo,content_3813_8594:()=>gPo,content_3813_8596:()=>LPo,content_3813_8598:()=>NPo,content_3813_86:()=>s0,content_3813_860:()=>Put,content_3813_8600:()=>PPo,content_3813_8602:()=>RPo,content_3813_8604:()=>GPo,content_3813_8606:()=>UPo,content_3813_8608:()=>qPo,content_3813_8610:()=>YPo,content_3813_8612:()=>KPo,content_3813_8614:()=>eIo,content_3813_8616:()=>pIo,content_3813_8618:()=>cIo,content_3813_862:()=>Rut,content_3813_8620:()=>lIo,content_3813_8622:()=>dIo,content_3813_8624:()=>kIo,content_3813_8626:()=>MIo,content_3813_8628:()=>wIo,content_3813_8630:()=>gIo,content_3813_8632:()=>LIo,content_3813_8634:()=>NIo,content_3813_8636:()=>PIo,content_3813_8638:()=>RIo,content_3813_864:()=>Gut,content_3813_8640:()=>GIo,content_3813_8642:()=>UIo,content_3813_8644:()=>qIo,content_3813_8646:()=>YIo,content_3813_8648:()=>KIo,content_3813_8650:()=>eWo,content_3813_8652:()=>pWo,content_3813_8654:()=>cWo,content_3813_8656:()=>lWo,content_3813_8658:()=>dWo,content_3813_866:()=>Uut,content_3813_8660:()=>kWo,content_3813_8662:()=>MWo,content_3813_8664:()=>wWo,content_3813_8666:()=>gWo,content_3813_8668:()=>LWo,content_3813_8670:()=>NWo,content_3813_8672:()=>PWo,content_3813_8674:()=>RWo,content_3813_8676:()=>GWo,content_3813_8678:()=>UWo,content_3813_868:()=>qut,content_3813_8680:()=>qWo,content_3813_8682:()=>YWo,content_3813_8684:()=>KWo,content_3813_8686:()=>eRo,content_3813_8688:()=>pRo,content_3813_8690:()=>cRo,content_3813_8692:()=>lRo,content_3813_8694:()=>dRo,content_3813_8696:()=>kRo,content_3813_8698:()=>MRo,content_3813_870:()=>Yut,content_3813_8700:()=>wRo,content_3813_8702:()=>gRo,content_3813_8704:()=>LRo,content_3813_8706:()=>NRo,content_3813_8708:()=>PRo,content_3813_8710:()=>RRo,content_3813_8712:()=>GRo,content_3813_8714:()=>URo,content_3813_8716:()=>qRo,content_3813_8718:()=>YRo,content_3813_872:()=>Kut,content_3813_8720:()=>KRo,content_3813_8722:()=>eSo,content_3813_8724:()=>pSo,content_3813_8726:()=>cSo,content_3813_8728:()=>lSo,content_3813_8730:()=>dSo,content_3813_8732:()=>kSo,content_3813_8734:()=>MSo,content_3813_8736:()=>wSo,content_3813_8738:()=>gSo,content_3813_874:()=>emt,content_3813_8740:()=>LSo,content_3813_8742:()=>NSo,content_3813_8744:()=>PSo,content_3813_8746:()=>RSo,content_3813_8748:()=>GSo,content_3813_8750:()=>USo,content_3813_8752:()=>qSo,content_3813_8754:()=>YSo,content_3813_8756:()=>KSo,content_3813_8758:()=>eBo,content_3813_876:()=>pmt,content_3813_8760:()=>pBo,content_3813_8762:()=>cBo,content_3813_8764:()=>lBo,content_3813_8766:()=>dBo,content_3813_8768:()=>kBo,content_3813_8770:()=>MBo,content_3813_8772:()=>wBo,content_3813_8774:()=>gBo,content_3813_8776:()=>LBo,content_3813_8778:()=>NBo,content_3813_878:()=>cmt,content_3813_8780:()=>PBo,content_3813_8782:()=>RBo,content_3813_8784:()=>GBo,content_3813_8786:()=>UBo,content_3813_8788:()=>qBo,content_3813_8790:()=>YBo,content_3813_8792:()=>KBo,content_3813_8794:()=>eGo,content_3813_8796:()=>pGo,content_3813_8798:()=>cGo,content_3813_88:()=>i0,content_3813_880:()=>lmt,content_3813_8800:()=>lGo,content_3813_8802:()=>dGo,content_3813_8804:()=>kGo,content_3813_8806:()=>MGo,content_3813_8808:()=>wGo,content_3813_8810:()=>gGo,content_3813_8812:()=>LGo,content_3813_8814:()=>NGo,content_3813_8816:()=>PGo,content_3813_8818:()=>RGo,content_3813_882:()=>dmt,content_3813_8820:()=>GGo,content_3813_8822:()=>UGo,content_3813_8824:()=>qGo,content_3813_8826:()=>YGo,content_3813_8828:()=>KGo,content_3813_8830:()=>eEo,content_3813_8832:()=>pEo,content_3813_8834:()=>cEo,content_3813_8836:()=>lEo,content_3813_8838:()=>dEo,content_3813_884:()=>kmt,content_3813_8840:()=>kEo,content_3813_8842:()=>MEo,content_3813_8844:()=>wEo,content_3813_8846:()=>gEo,content_3813_8848:()=>LEo,content_3813_8850:()=>NEo,content_3813_8852:()=>PEo,content_3813_8854:()=>REo,content_3813_8856:()=>GEo,content_3813_8858:()=>UEo,content_3813_886:()=>Mmt,content_3813_8860:()=>qEo,content_3813_8862:()=>YEo,content_3813_8864:()=>KEo,content_3813_8866:()=>eOo,content_3813_8868:()=>pOo,content_3813_8870:()=>cOo,content_3813_8872:()=>lOo,content_3813_8874:()=>dOo,content_3813_8876:()=>kOo,content_3813_8878:()=>MOo,content_3813_888:()=>wmt,content_3813_8880:()=>wOo,content_3813_8882:()=>gOo,content_3813_8884:()=>LOo,content_3813_8886:()=>NOo,content_3813_8888:()=>POo,content_3813_8890:()=>ROo,content_3813_8892:()=>GOo,content_3813_8894:()=>UOo,content_3813_8896:()=>qOo,content_3813_8898:()=>YOo,content_3813_890:()=>gmt,content_3813_8900:()=>KOo,content_3813_8902:()=>eUo,content_3813_8904:()=>pUo,content_3813_8906:()=>cUo,content_3813_8908:()=>lUo,content_3813_8910:()=>dUo,content_3813_8912:()=>kUo,content_3813_8914:()=>MUo,content_3813_8916:()=>wUo,content_3813_8918:()=>gUo,content_3813_892:()=>Lmt,content_3813_8920:()=>LUo,content_3813_8922:()=>NUo,content_3813_8924:()=>PUo,content_3813_8926:()=>RUo,content_3813_8928:()=>GUo,content_3813_8930:()=>UUo,content_3813_8932:()=>qUo,content_3813_8934:()=>YUo,content_3813_8936:()=>KUo,content_3813_8938:()=>eFo,content_3813_894:()=>Nmt,content_3813_8940:()=>pFo,content_3813_8942:()=>cFo,content_3813_8944:()=>lFo,content_3813_8946:()=>dFo,content_3813_8948:()=>kFo,content_3813_8950:()=>MFo,content_3813_8952:()=>wFo,content_3813_8954:()=>gFo,content_3813_8956:()=>LFo,content_3813_8958:()=>NFo,content_3813_896:()=>Pmt,content_3813_8960:()=>PFo,content_3813_8962:()=>RFo,content_3813_8964:()=>GFo,content_3813_8966:()=>UFo,content_3813_8968:()=>qFo,content_3813_8970:()=>YFo,content_3813_8972:()=>KFo,content_3813_8974:()=>eVo,content_3813_8976:()=>pVo,content_3813_8978:()=>cVo,content_3813_898:()=>Rmt,content_3813_8980:()=>lVo,content_3813_8982:()=>dVo,content_3813_8984:()=>kVo,content_3813_8986:()=>MVo,content_3813_8988:()=>wVo,content_3813_8990:()=>gVo,content_3813_8992:()=>LVo,content_3813_8994:()=>NVo,content_3813_8996:()=>PVo,content_3813_8998:()=>RVo,content_3813_90:()=>m0,content_3813_900:()=>Gmt,content_3813_9000:()=>GVo,content_3813_9002:()=>UVo,content_3813_9004:()=>qVo,content_3813_9006:()=>YVo,content_3813_9008:()=>KVo,content_3813_9010:()=>eqo,content_3813_9012:()=>pqo,content_3813_9014:()=>cqo,content_3813_9016:()=>lqo,content_3813_9018:()=>dqo,content_3813_902:()=>Umt,content_3813_9020:()=>kqo,content_3813_9022:()=>Mqo,content_3813_9024:()=>wqo,content_3813_9026:()=>gqo,content_3813_9028:()=>Lqo,content_3813_9030:()=>Nqo,content_3813_9032:()=>Pqo,content_3813_9034:()=>Rqo,content_3813_9036:()=>Gqo,content_3813_9038:()=>Uqo,content_3813_904:()=>qmt,content_3813_9040:()=>qqo,content_3813_9042:()=>Yqo,content_3813_9044:()=>Kqo,content_3813_9046:()=>ejo,content_3813_9048:()=>pjo,content_3813_9050:()=>cjo,content_3813_9052:()=>ljo,content_3813_9054:()=>djo,content_3813_9056:()=>kjo,content_3813_9058:()=>Mjo,content_3813_906:()=>Ymt,content_3813_9060:()=>wjo,content_3813_9062:()=>gjo,content_3813_9064:()=>Ljo,content_3813_9066:()=>Njo,content_3813_9068:()=>Pjo,content_3813_9070:()=>Rjo,content_3813_9072:()=>Gjo,content_3813_9074:()=>Ujo,content_3813_9076:()=>qjo,content_3813_9078:()=>Yjo,content_3813_908:()=>Kmt,content_3813_9080:()=>Kjo,content_3813_9082:()=>eHo,content_3813_9084:()=>pHo,content_3813_9086:()=>cHo,content_3813_9088:()=>lHo,content_3813_9090:()=>dHo,content_3813_9092:()=>kHo,content_3813_9094:()=>MHo,content_3813_9096:()=>wHo,content_3813_9098:()=>gHo,content_3813_910:()=>edt,content_3813_9100:()=>LHo,content_3813_9102:()=>NHo,content_3813_9104:()=>PHo,content_3813_9106:()=>RHo,content_3813_9108:()=>GHo,content_3813_9110:()=>UHo,content_3813_9112:()=>qHo,content_3813_9114:()=>YHo,content_3813_9116:()=>KHo,content_3813_9118:()=>eYo,content_3813_912:()=>pdt,content_3813_9120:()=>pYo,content_3813_9122:()=>cYo,content_3813_9124:()=>lYo,content_3813_9126:()=>dYo,content_3813_9128:()=>kYo,content_3813_9130:()=>MYo,content_3813_9132:()=>wYo,content_3813_9134:()=>gYo,content_3813_9136:()=>LYo,content_3813_9138:()=>NYo,content_3813_914:()=>cdt,content_3813_9140:()=>PYo,content_3813_9142:()=>RYo,content_3813_9144:()=>GYo,content_3813_9146:()=>UYo,content_3813_9148:()=>qYo,content_3813_9150:()=>YYo,content_3813_9152:()=>KYo,content_3813_9154:()=>eQo,content_3813_9156:()=>pQo,content_3813_9158:()=>cQo,content_3813_916:()=>ldt,content_3813_9160:()=>lQo,content_3813_9162:()=>dQo,content_3813_9164:()=>kQo,content_3813_9166:()=>MQo,content_3813_9168:()=>wQo,content_3813_9170:()=>gQo,content_3813_9172:()=>LQo,content_3813_9174:()=>NQo,content_3813_9176:()=>PQo,content_3813_9178:()=>RQo,content_3813_918:()=>ddt,content_3813_9180:()=>GQo,content_3813_9182:()=>UQo,content_3813_9184:()=>qQo,content_3813_9186:()=>YQo,content_3813_9188:()=>KQo,content_3813_9190:()=>e$o,content_3813_9192:()=>p$o,content_3813_9194:()=>c$o,content_3813_9196:()=>l$o,content_3813_9198:()=>d$o,content_3813_92:()=>f0,content_3813_920:()=>kdt,content_3813_9200:()=>k$o,content_3813_9202:()=>M$o,content_3813_9204:()=>w$o,content_3813_9206:()=>g$o,content_3813_9208:()=>L$o,content_3813_9210:()=>N$o,content_3813_9212:()=>P$o,content_3813_9214:()=>R$o,content_3813_9216:()=>G$o,content_3813_9218:()=>U$o,content_3813_922:()=>Mdt,content_3813_9220:()=>q$o,content_3813_9222:()=>Y$o,content_3813_9224:()=>K$o,content_3813_9226:()=>eKo,content_3813_9228:()=>pKo,content_3813_9230:()=>cKo,content_3813_9232:()=>lKo,content_3813_9234:()=>dKo,content_3813_9236:()=>kKo,content_3813_9238:()=>MKo,content_3813_924:()=>wdt,content_3813_9240:()=>wKo,content_3813_9242:()=>gKo,content_3813_9244:()=>LKo,content_3813_9246:()=>NKo,content_3813_9248:()=>PKo,content_3813_9250:()=>RKo,content_3813_9252:()=>GKo,content_3813_9254:()=>UKo,content_3813_9256:()=>qKo,content_3813_9258:()=>YKo,content_3813_926:()=>gdt,content_3813_9260:()=>KKo,content_3813_9262:()=>eJo,content_3813_9264:()=>pJo,content_3813_9266:()=>cJo,content_3813_9268:()=>lJo,content_3813_9270:()=>dJo,content_3813_9272:()=>kJo,content_3813_9274:()=>MJo,content_3813_9276:()=>wJo,content_3813_9278:()=>gJo,content_3813_928:()=>Ldt,content_3813_9280:()=>LJo,content_3813_9282:()=>NJo,content_3813_9284:()=>PJo,content_3813_9286:()=>RJo,content_3813_9288:()=>GJo,content_3813_9290:()=>UJo,content_3813_9292:()=>qJo,content_3813_9294:()=>YJo,content_3813_9296:()=>KJo,content_3813_9298:()=>e0o,content_3813_930:()=>Ndt,content_3813_9300:()=>p0o,content_3813_9302:()=>c0o,content_3813_9304:()=>l0o,content_3813_9306:()=>d0o,content_3813_9308:()=>k0o,content_3813_9310:()=>M0o,content_3813_9312:()=>w0o,content_3813_9314:()=>g0o,content_3813_9316:()=>L0o,content_3813_9318:()=>N0o,content_3813_932:()=>Pdt,content_3813_9320:()=>P0o,content_3813_9322:()=>R0o,content_3813_9324:()=>G0o,content_3813_9326:()=>U0o,content_3813_9328:()=>q0o,content_3813_9330:()=>Y0o,content_3813_9332:()=>K0o,content_3813_9334:()=>e3o,content_3813_9336:()=>p3o,content_3813_9338:()=>c3o,content_3813_934:()=>Rdt,content_3813_9340:()=>l3o,content_3813_9342:()=>d3o,content_3813_9344:()=>k3o,content_3813_9346:()=>M3o,content_3813_9348:()=>w3o,content_3813_9350:()=>g3o,content_3813_9352:()=>L3o,content_3813_9354:()=>N3o,content_3813_9356:()=>P3o,content_3813_9358:()=>R3o,content_3813_936:()=>Gdt,content_3813_9360:()=>G3o,content_3813_9362:()=>U3o,content_3813_9364:()=>q3o,content_3813_9366:()=>Y3o,content_3813_9368:()=>K3o,content_3813_9370:()=>e1o,content_3813_9372:()=>p1o,content_3813_9374:()=>c1o,content_3813_9376:()=>l1o,content_3813_9378:()=>d1o,content_3813_938:()=>Udt,content_3813_9380:()=>k1o,content_3813_9382:()=>M1o,content_3813_9384:()=>w1o,content_3813_9386:()=>g1o,content_3813_9388:()=>L1o,content_3813_9390:()=>N1o,content_3813_9392:()=>P1o,content_3813_9394:()=>R1o,content_3813_9396:()=>G1o,content_3813_9398:()=>U1o,content_3813_94:()=>D0,content_3813_940:()=>qdt,content_3813_9400:()=>q1o,content_3813_9402:()=>Y1o,content_3813_9404:()=>K1o,content_3813_9406:()=>e8o,content_3813_9408:()=>p8o,content_3813_9410:()=>c8o,content_3813_9412:()=>l8o,content_3813_9414:()=>d8o,content_3813_9416:()=>k8o,content_3813_9418:()=>M8o,content_3813_942:()=>Ydt,content_3813_9420:()=>w8o,content_3813_9422:()=>g8o,content_3813_9424:()=>L8o,content_3813_9426:()=>N8o,content_3813_9428:()=>P8o,content_3813_9430:()=>R8o,content_3813_9432:()=>G8o,content_3813_9434:()=>U8o,content_3813_9436:()=>q8o,content_3813_9438:()=>Y8o,content_3813_944:()=>Kdt,content_3813_9440:()=>K8o,content_3813_9442:()=>e2o,content_3813_9444:()=>p2o,content_3813_9446:()=>c2o,content_3813_9448:()=>l2o,content_3813_9450:()=>d2o,content_3813_9452:()=>k2o,content_3813_9454:()=>M2o,content_3813_9456:()=>w2o,content_3813_9458:()=>g2o,content_3813_946:()=>eht,content_3813_9460:()=>L2o,content_3813_9462:()=>N2o,content_3813_9464:()=>P2o,content_3813_9466:()=>R2o,content_3813_9468:()=>G2o,content_3813_9470:()=>U2o,content_3813_9472:()=>q2o,content_3813_9474:()=>Y2o,content_3813_9476:()=>K2o,content_3813_9478:()=>e4o,content_3813_948:()=>pht,content_3813_9480:()=>p4o,content_3813_9482:()=>c4o,content_3813_9484:()=>l4o,content_3813_9486:()=>d4o,content_3813_9488:()=>k4o,content_3813_9490:()=>M4o,content_3813_9492:()=>w4o,content_3813_9494:()=>g4o,content_3813_9496:()=>L4o,content_3813_9498:()=>N4o,content_3813_950:()=>cht,content_3813_9500:()=>P4o,content_3813_9502:()=>R4o,content_3813_9504:()=>G4o,content_3813_9506:()=>U4o,content_3813_9508:()=>q4o,content_3813_9510:()=>Y4o,content_3813_9512:()=>K4o,content_3813_9514:()=>e6o,content_3813_9516:()=>p6o,content_3813_9518:()=>c6o,content_3813_952:()=>lht,content_3813_9520:()=>l6o,content_3813_9522:()=>d6o,content_3813_9524:()=>k6o,content_3813_9526:()=>M6o,content_3813_9528:()=>w6o,content_3813_9530:()=>g6o,content_3813_9532:()=>L6o,content_3813_9534:()=>N6o,content_3813_9536:()=>P6o,content_3813_9538:()=>R6o,content_3813_954:()=>dht,content_3813_9540:()=>G6o,content_3813_9542:()=>U6o,content_3813_9544:()=>q6o,content_3813_9546:()=>Y6o,content_3813_9548:()=>K6o,content_3813_9550:()=>e5o,content_3813_9552:()=>p5o,content_3813_9554:()=>c5o,content_3813_9556:()=>l5o,content_3813_9558:()=>d5o,content_3813_956:()=>kht,content_3813_9560:()=>k5o,content_3813_9562:()=>M5o,content_3813_9564:()=>w5o,content_3813_9566:()=>g5o,content_3813_9568:()=>L5o,content_3813_9570:()=>N5o,content_3813_9572:()=>P5o,content_3813_9574:()=>R5o,content_3813_9576:()=>G5o,content_3813_9578:()=>U5o,content_3813_958:()=>Mht,content_3813_9580:()=>q5o,content_3813_9582:()=>Y5o,content_3813_9584:()=>K5o,content_3813_9586:()=>e7o,content_3813_9588:()=>p7o,content_3813_9590:()=>c7o,content_3813_9592:()=>l7o,content_3813_9594:()=>d7o,content_3813_9596:()=>k7o,content_3813_9598:()=>M7o,content_3813_96:()=>_0,content_3813_960:()=>wht,content_3813_9600:()=>w7o,content_3813_9602:()=>g7o,content_3813_9604:()=>L7o,content_3813_9606:()=>N7o,content_3813_9608:()=>P7o,content_3813_9610:()=>R7o,content_3813_9612:()=>G7o,content_3813_9614:()=>U7o,content_3813_9616:()=>q7o,content_3813_9618:()=>Y7o,content_3813_962:()=>ght,content_3813_9620:()=>K7o,content_3813_9622:()=>e9o,content_3813_9624:()=>p9o,content_3813_9626:()=>c9o,content_3813_9628:()=>l9o,content_3813_9630:()=>d9o,content_3813_9632:()=>k9o,content_3813_9634:()=>M9o,content_3813_9636:()=>w9o,content_3813_9638:()=>g9o,content_3813_964:()=>Lht,content_3813_9640:()=>L9o,content_3813_9642:()=>N9o,content_3813_9644:()=>P9o,content_3813_9646:()=>R9o,content_3813_9648:()=>G9o,content_3813_9650:()=>U9o,content_3813_9652:()=>q9o,content_3813_9654:()=>Y9o,content_3813_9656:()=>K9o,content_3813_9658:()=>etp,content_3813_966:()=>Nht,content_3813_9660:()=>ptp,content_3813_9662:()=>ctp,content_3813_9664:()=>ltp,content_3813_9666:()=>dtp,content_3813_9668:()=>ktp,content_3813_9670:()=>Mtp,content_3813_9672:()=>wtp,content_3813_9674:()=>gtp,content_3813_9676:()=>Ltp,content_3813_9678:()=>Ntp,content_3813_968:()=>Pht,content_3813_9680:()=>Ptp,content_3813_9682:()=>Rtp,content_3813_9684:()=>Gtp,content_3813_9686:()=>Utp,content_3813_9688:()=>qtp,content_3813_9690:()=>Ytp,content_3813_9692:()=>Ktp,content_3813_9694:()=>eep,content_3813_9696:()=>pep,content_3813_9698:()=>cep,content_3813_970:()=>Rht,content_3813_9700:()=>lep,content_3813_9702:()=>dep,content_3813_9704:()=>kep,content_3813_9706:()=>Mep,content_3813_9708:()=>wep,content_3813_9710:()=>gep,content_3813_9712:()=>Lep,content_3813_9714:()=>Nep,content_3813_9716:()=>Pep,content_3813_9718:()=>Rep,content_3813_972:()=>Ght,content_3813_9720:()=>Gep,content_3813_9722:()=>Uep,content_3813_9724:()=>qep,content_3813_9726:()=>Yep,content_3813_9728:()=>Kep,content_3813_9730:()=>enp,content_3813_9732:()=>pnp,content_3813_9734:()=>cnp,content_3813_9736:()=>lnp,content_3813_9738:()=>dnp,content_3813_974:()=>Uht,content_3813_9740:()=>knp,content_3813_9742:()=>Mnp,content_3813_9744:()=>wnp,content_3813_9746:()=>gnp,content_3813_9748:()=>Lnp,content_3813_9750:()=>Nnp,content_3813_9752:()=>Pnp,content_3813_9754:()=>Rnp,content_3813_9756:()=>Gnp,content_3813_9758:()=>Unp,content_3813_976:()=>qht,content_3813_9760:()=>qnp,content_3813_9762:()=>Ynp,content_3813_9764:()=>Knp,content_3813_9766:()=>eop,content_3813_9768:()=>pop,content_3813_9770:()=>cop,content_3813_9772:()=>lop,content_3813_9774:()=>dop,content_3813_9776:()=>kop,content_3813_9778:()=>Mop,content_3813_978:()=>Yht,content_3813_9780:()=>wop,content_3813_9782:()=>gop,content_3813_9784:()=>Lop,content_3813_9786:()=>Nop,content_3813_9788:()=>Pop,content_3813_9790:()=>Rop,content_3813_9792:()=>Gop,content_3813_9794:()=>Uop,content_3813_9796:()=>qop,content_3813_9798:()=>Yop,content_3813_98:()=>C0,content_3813_980:()=>Kht,content_3813_9800:()=>Kop,content_3813_9802:()=>epp,content_3813_9804:()=>ppp,content_3813_9806:()=>cpp,content_3813_9808:()=>lpp,content_3813_9810:()=>dpp,content_3813_9812:()=>kpp,content_3813_9814:()=>Mpp,content_3813_9816:()=>wpp,content_3813_9818:()=>gpp,content_3813_982:()=>eft,content_3813_9820:()=>Lpp,content_3813_9822:()=>Npp,content_3813_9824:()=>Ppp,content_3813_9826:()=>Rpp,content_3813_9828:()=>Gpp,content_3813_9830:()=>Upp,content_3813_9832:()=>qpp,content_3813_9834:()=>Ypp,content_3813_9836:()=>Kpp,content_3813_9838:()=>erp,content_3813_984:()=>pft,content_3813_9840:()=>prp,content_3813_9842:()=>crp,content_3813_9844:()=>lrp,content_3813_9846:()=>drp,content_3813_9848:()=>krp,content_3813_9850:()=>Mrp,content_3813_9852:()=>wrp,content_3813_9854:()=>grp,content_3813_9856:()=>Lrp,content_3813_9858:()=>Nrp,content_3813_986:()=>cft,content_3813_9860:()=>Prp,content_3813_9862:()=>Rrp,content_3813_9864:()=>Grp,content_3813_9866:()=>Urp,content_3813_9868:()=>qrp,content_3813_9870:()=>Yrp,content_3813_9872:()=>Krp,content_3813_9874:()=>esp,content_3813_9876:()=>psp,content_3813_9878:()=>csp,content_3813_988:()=>lft,content_3813_9880:()=>lsp,content_3813_9882:()=>dsp,content_3813_9884:()=>ksp,content_3813_9886:()=>Msp,content_3813_9888:()=>wsp,content_3813_9890:()=>gsp,content_3813_9892:()=>Lsp,content_3813_9894:()=>Nsp,content_3813_9896:()=>Psp,content_3813_9898:()=>Rsp,content_3813_990:()=>dft,content_3813_9900:()=>Gsp,content_3813_9902:()=>Usp,content_3813_9904:()=>qsp,content_3813_9906:()=>Ysp,content_3813_9908:()=>Ksp,content_3813_9910:()=>ecp,content_3813_9912:()=>pcp,content_3813_9914:()=>ccp,content_3813_9916:()=>lcp,content_3813_9918:()=>dcp,content_3813_992:()=>kft,content_3813_9920:()=>kcp,content_3813_9922:()=>Mcp,content_3813_9924:()=>wcp,content_3813_9926:()=>gcp,content_3813_9928:()=>Lcp,content_3813_9930:()=>Ncp,content_3813_9932:()=>Pcp,content_3813_9934:()=>Rcp,content_3813_9936:()=>Gcp,content_3813_9938:()=>Ucp,content_3813_994:()=>Mft,content_3813_9940:()=>qcp,content_3813_9942:()=>Ycp,content_3813_9944:()=>Kcp,content_3813_9946:()=>eap,content_3813_9948:()=>pap,content_3813_9950:()=>cap,content_3813_9952:()=>lap,content_3813_9954:()=>dap,content_3813_9956:()=>kap,content_3813_9958:()=>Map,content_3813_996:()=>wft,content_3813_9960:()=>wap,content_3813_9962:()=>gap,content_3813_9964:()=>Lap,content_3813_9966:()=>Nap,content_3813_9968:()=>Pap,content_3813_9970:()=>Rap,content_3813_9972:()=>Gap,content_3813_9974:()=>Uap,content_3813_9976:()=>qap,content_3813_9978:()=>Yap,content_3813_998:()=>gft,content_3813_9980:()=>Kap,content_3813_9982:()=>eip,content_3813_9984:()=>pip,content_3813_9986:()=>cip,content_3813_9988:()=>lip,content_3813_9990:()=>dip,content_3813_9992:()=>kip,content_3813_9994:()=>Mip,content_3813_9996:()=>wip,content_3813_9998:()=>gip});var p=n(7896),r=n(2784),s=n(876);const c={toc:[]},a="wrapper";function i(t){let{components:e,...n}=t;return(0,s.kt)(a,(0,p.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const l={toc:[]},u="wrapper";function m(t){let{components:e,...n}=t;return(0,s.kt)(u,(0,p.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}m.isMDXComponent=!0;const d={toc:[]},h="wrapper";function f(t){let{components:e,...n}=t;return(0,s.kt)(h,(0,p.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}f.isMDXComponent=!0;const k={toc:[]},y="wrapper";function D(t){let{components:e,...n}=t;return(0,s.kt)(y,(0,p.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The time passed since the last frame in seconds."))}D.isMDXComponent=!0;const M={toc:[]},X="wrapper";function _(t){let{components:e,...n}=t;return(0,s.kt)(X,(0,p.Z)({},M,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}_.isMDXComponent=!0;const w={toc:[]},T="wrapper";function C(t){let{components:e,...n}=t;return(0,s.kt)(T,(0,p.Z)({},w,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}C.isMDXComponent=!0;const g={toc:[]},x="wrapper";function v(t){let{components:e,...n}=t;return(0,s.kt)(x,(0,p.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}v.isMDXComponent=!0;const L={toc:[]},Z="wrapper";function b(t){let{components:e,...n}=t;return(0,s.kt)(Z,(0,p.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}b.isMDXComponent=!0;const N={toc:[]},z="wrapper";function A(t){let{components:e,...n}=t;return(0,s.kt)(z,(0,p.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}A.isMDXComponent=!0;const P={toc:[]},I="wrapper";function W(t){let{components:e,...n}=t;return(0,s.kt)(I,(0,p.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}W.isMDXComponent=!0;const R={toc:[]},S="wrapper";function B(t){let{components:e,...n}=t;return(0,s.kt)(S,(0,p.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}B.isMDXComponent=!0;const G={toc:[]},E="wrapper";function O(t){let{components:e,...n}=t;return(0,s.kt)(E,(0,p.Z)({},G,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}O.isMDXComponent=!0;const U={toc:[]},F="wrapper";function V(t){let{components:e,...n}=t;return(0,s.kt)(F,(0,p.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}V.isMDXComponent=!0;const q={toc:[]},j="wrapper";function H(t){let{components:e,...n}=t;return(0,s.kt)(j,(0,p.Z)({},q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}H.isMDXComponent=!0;const Y={toc:[]},Q="wrapper";function $(t){let{components:e,...n}=t;return(0,s.kt)(Q,(0,p.Z)({},Y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}$.isMDXComponent=!0;const K={toc:[]},J="wrapper";function tt(t){let{components:e,...n}=t;return(0,s.kt)(J,(0,p.Z)({},K,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}tt.isMDXComponent=!0;const et={toc:[]},nt="wrapper";function ot(t){let{components:e,...n}=t;return(0,s.kt)(nt,(0,p.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}ot.isMDXComponent=!0;const pt={toc:[]},rt="wrapper";function st(t){let{components:e,...n}=t;return(0,s.kt)(rt,(0,p.Z)({},pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}st.isMDXComponent=!0;const ct={toc:[]},at="wrapper";function it(t){let{components:e,...n}=t;return(0,s.kt)(at,(0,p.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the given frame is inside the animation range."))}it.isMDXComponent=!0;const lt={toc:[]},ut="wrapper";function mt(t){let{components:e,...n}=t;return(0,s.kt)(ut,(0,p.Z)({},lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame to check."))}mt.isMDXComponent=!0;const dt={toc:[]},ht="wrapper";function ft(t){let{components:e,...n}=t;return(0,s.kt)(ht,(0,p.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the given frame is inside the user-defined range."))}ft.isMDXComponent=!0;const kt={toc:[]},yt="wrapper";function Dt(t){let{components:e,...n}=t;return(0,s.kt)(yt,(0,p.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame to check."))}Dt.isMDXComponent=!0;const Mt={toc:[]},Xt="wrapper";function _t(t){let{components:e,...n}=t;return(0,s.kt)(Xt,(0,p.Z)({},Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}_t.isMDXComponent=!0;const wt={toc:[]},Tt="wrapper";function Ct(t){let{components:e,...n}=t;return(0,s.kt)(Tt,(0,p.Z)({},wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}Ct.isMDXComponent=!0;const gt={toc:[]},xt="wrapper";function vt(t){let{components:e,...n}=t;return(0,s.kt)(xt,(0,p.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}vt.isMDXComponent=!0;const Lt={toc:[]},Zt="wrapper";function bt(t){let{components:e,...n}=t;return(0,s.kt)(Zt,(0,p.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}bt.isMDXComponent=!0;const Nt={toc:[]},zt="wrapper";function At(t){let{components:e,...n}=t;return(0,s.kt)(zt,(0,p.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}At.isMDXComponent=!0;const Pt={toc:[]},It="wrapper";function Wt(t){let{components:e,...n}=t;return(0,s.kt)(It,(0,p.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Wt.isMDXComponent=!0;const Rt={toc:[]},St="wrapper";function Bt(t){let{components:e,...n}=t;return(0,s.kt)(St,(0,p.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Bt.isMDXComponent=!0;const Gt={toc:[]},Et="wrapper";function Ot(t){let{components:e,...n}=t;return(0,s.kt)(Et,(0,p.Z)({},Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ot.isMDXComponent=!0;const Ut={toc:[]},Ft="wrapper";function Vt(t){let{components:e,...n}=t;return(0,s.kt)(Ft,(0,p.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}Vt.isMDXComponent=!0;const qt={toc:[]},jt="wrapper";function Ht(t){let{components:e,...n}=t;return(0,s.kt)(jt,(0,p.Z)({},qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ht.isMDXComponent=!0;const Yt={toc:[]},Qt="wrapper";function $t(t){let{components:e,...n}=t;return(0,s.kt)(Qt,(0,p.Z)({},Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}$t.isMDXComponent=!0;const Kt={toc:[]},Jt="wrapper";function te(t){let{components:e,...n}=t;return(0,s.kt)(Jt,(0,p.Z)({},Kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}te.isMDXComponent=!0;const ee={toc:[]},ne="wrapper";function oe(t){let{components:e,...n}=t;return(0,s.kt)(ne,(0,p.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}oe.isMDXComponent=!0;const pe={toc:[]},re="wrapper";function se(t){let{components:e,...n}=t;return(0,s.kt)(re,(0,p.Z)({},pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}se.isMDXComponent=!0;const ce={toc:[]},ae="wrapper";function ie(t){let{components:e,...n}=t;return(0,s.kt)(ae,(0,p.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ie.isMDXComponent=!0;const le={toc:[]},ue="wrapper";function me(t){let{components:e,...n}=t;return(0,s.kt)(ue,(0,p.Z)({},le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}me.isMDXComponent=!0;const de={toc:[]},he="wrapper";function fe(t){let{components:e,...n}=t;return(0,s.kt)(he,(0,p.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}fe.isMDXComponent=!0;const ke={toc:[]},ye="wrapper";function De(t){let{components:e,...n}=t;return(0,s.kt)(ye,(0,p.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}De.isMDXComponent=!0;const Me={toc:[]},Xe="wrapper";function _e(t){let{components:e,...n}=t;return(0,s.kt)(Xe,(0,p.Z)({},Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}_e.isMDXComponent=!0;const we={toc:[]},Te="wrapper";function Ce(t){let{components:e,...n}=t;return(0,s.kt)(Te,(0,p.Z)({},we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}Ce.isMDXComponent=!0;const ge={toc:[]},xe="wrapper";function ve(t){let{components:e,...n}=t;return(0,s.kt)(xe,(0,p.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}ve.isMDXComponent=!0;const Le={toc:[]},Ze="wrapper";function be(t){let{components:e,...n}=t;return(0,s.kt)(Ze,(0,p.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}be.isMDXComponent=!0;const Ne={toc:[]},ze="wrapper";function Ae(t){let{components:e,...n}=t;return(0,s.kt)(ze,(0,p.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Ae.isMDXComponent=!0;const Pe={toc:[]},Ie="wrapper";function We(t){let{components:e,...n}=t;return(0,s.kt)(Ie,(0,p.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}We.isMDXComponent=!0;const Re={toc:[]},Se="wrapper";function Be(t){let{components:e,...n}=t;return(0,s.kt)(Se,(0,p.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}Be.isMDXComponent=!0;const Ge={toc:[]},Ee="wrapper";function Oe(t){let{components:e,...n}=t;return(0,s.kt)(Ee,(0,p.Z)({},Ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Oe.isMDXComponent=!0;const Ue={toc:[]},Fe="wrapper";function Ve(t){let{components:e,...n}=t;return(0,s.kt)(Fe,(0,p.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Ve.isMDXComponent=!0;const qe={toc:[]},je="wrapper";function He(t){let{components:e,...n}=t;return(0,s.kt)(je,(0,p.Z)({},qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispose the WebGL context to free up resources."))}He.isMDXComponent=!0;const Ye={toc:[]},Qe="wrapper";function $e(t){let{components:e,...n}=t;return(0,s.kt)(Qe,(0,p.Z)({},Ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}$e.isMDXComponent=!0;const Ke={toc:[]},Je="wrapper";function tn(t){let{components:e,...n}=t;return(0,s.kt)(Je,(0,p.Z)({},Ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}tn.isMDXComponent=!0;const en={toc:[]},nn="wrapper";function on(t){let{components:e,...n}=t;return(0,s.kt)(nn,(0,p.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}on.isMDXComponent=!0;const pn={toc:[]},rn="wrapper";function sn(t){let{components:e,...n}=t;return(0,s.kt)(rn,(0,p.Z)({},pn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}sn.isMDXComponent=!0;const cn={toc:[]},an="wrapper";function ln(t){let{components:e,...n}=t;return(0,s.kt)(an,(0,p.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}ln.isMDXComponent=!0;const un={toc:[]},mn="wrapper";function dn(t){let{components:e,...n}=t;return(0,s.kt)(mn,(0,p.Z)({},un,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}dn.isMDXComponent=!0;const hn={toc:[]},fn="wrapper";function kn(t){let{components:e,...n}=t;return(0,s.kt)(fn,(0,p.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}kn.isMDXComponent=!0;const yn={toc:[]},Dn="wrapper";function Mn(t){let{components:e,...n}=t;return(0,s.kt)(Dn,(0,p.Z)({},yn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}Mn.isMDXComponent=!0;const Xn={toc:[]},_n="wrapper";function wn(t){let{components:e,...n}=t;return(0,s.kt)(_n,(0,p.Z)({},Xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}wn.isMDXComponent=!0;const Tn={toc:[]},Cn="wrapper";function gn(t){let{components:e,...n}=t;return(0,s.kt)(Cn,(0,p.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}gn.isMDXComponent=!0;const xn={toc:[]},vn="wrapper";function Ln(t){let{components:e,...n}=t;return(0,s.kt)(vn,(0,p.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}Ln.isMDXComponent=!0;const Zn={toc:[]},bn="wrapper";function Nn(t){let{components:e,...n}=t;return(0,s.kt)(bn,(0,p.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}Nn.isMDXComponent=!0;const zn={toc:[]},An="wrapper";function Pn(t){let{components:e,...n}=t;return(0,s.kt)(An,(0,p.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}Pn.isMDXComponent=!0;const In={toc:[]},Wn="wrapper";function Rn(t){let{components:e,...n}=t;return(0,s.kt)(Wn,(0,p.Z)({},In,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}Rn.isMDXComponent=!0;const Sn={toc:[]},Bn="wrapper";function Gn(t){let{components:e,...n}=t;return(0,s.kt)(Bn,(0,p.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}Gn.isMDXComponent=!0;const En={toc:[]},On="wrapper";function Un(t){let{components:e,...n}=t;return(0,s.kt)(On,(0,p.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}Un.isMDXComponent=!0;const Fn={toc:[]},Vn="wrapper";function qn(t){let{components:e,...n}=t;return(0,s.kt)(Vn,(0,p.Z)({},Fn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}qn.isMDXComponent=!0;const jn={toc:[]},Hn="wrapper";function Yn(t){let{components:e,...n}=t;return(0,s.kt)(Hn,(0,p.Z)({},jn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}Yn.isMDXComponent=!0;const Qn={toc:[]},$n="wrapper";function Kn(t){let{components:e,...n}=t;return(0,s.kt)($n,(0,p.Z)({},Qn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}Kn.isMDXComponent=!0;const Jn={toc:[]},to="wrapper";function eo(t){let{components:e,...n}=t;return(0,s.kt)(to,(0,p.Z)({},Jn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}eo.isMDXComponent=!0;const no={toc:[]},oo="wrapper";function po(t){let{components:e,...n}=t;return(0,s.kt)(oo,(0,p.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}po.isMDXComponent=!0;const ro={toc:[]},so="wrapper";function co(t){let{components:e,...n}=t;return(0,s.kt)(so,(0,p.Z)({},ro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}co.isMDXComponent=!0;const ao={toc:[]},io="wrapper";function lo(t){let{components:e,...n}=t;return(0,s.kt)(io,(0,p.Z)({},ao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}lo.isMDXComponent=!0;const uo={toc:[]},mo="wrapper";function ho(t){let{components:e,...n}=t;return(0,s.kt)(mo,(0,p.Z)({},uo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}ho.isMDXComponent=!0;const fo={toc:[]},ko="wrapper";function yo(t){let{components:e,...n}=t;return(0,s.kt)(ko,(0,p.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}yo.isMDXComponent=!0;const Do={toc:[]},Mo="wrapper";function Xo(t){let{components:e,...n}=t;return(0,s.kt)(Mo,(0,p.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}Xo.isMDXComponent=!0;const _o={toc:[]},wo="wrapper";function To(t){let{components:e,...n}=t;return(0,s.kt)(wo,(0,p.Z)({},_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When displayed in the editor, the log entry will have the following format:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                             inspect node \u2510\n  \u250c expand more          duration \u2510       \u2502\n  \u25bc                               \u25bc       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u25b6 message                       300 ms (+) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 remarks                                    \u2502\n\u2502 object                                     \u2502\n\u2502 stacktrace                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))}To.isMDXComponent=!0;const Co={toc:[]},go="wrapper";function xo(t){let{components:e,...n}=t;return(0,s.kt)(go,(0,p.Z)({},Co,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an individual log entry."))}xo.isMDXComponent=!0;const vo={toc:[]},Lo="wrapper";function Zo(t){let{components:e,...n}=t;return(0,s.kt)(Lo,(0,p.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}Zo.isMDXComponent=!0;const bo={toc:[]},No="wrapper";function zo(t){let{components:e,...n}=t;return(0,s.kt)(No,(0,p.Z)({},bo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}zo.isMDXComponent=!0;const Ao={toc:[]},Po="wrapper";function Io(t){let{components:e,...n}=t;return(0,s.kt)(Po,(0,p.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}Io.isMDXComponent=!0;const Wo={toc:[]},Ro="wrapper";function So(t){let{components:e,...n}=t;return(0,s.kt)(Ro,(0,p.Z)({},Wo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}So.isMDXComponent=!0;const Bo={toc:[]},Go="wrapper";function Eo(t){let{components:e,...n}=t;return(0,s.kt)(Go,(0,p.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log level."))}Eo.isMDXComponent=!0;const Oo={toc:[]},Uo="wrapper";function Fo(t){let{components:e,...n}=t;return(0,s.kt)(Uo,(0,p.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}Fo.isMDXComponent=!0;const Vo={toc:[]},qo="wrapper";function jo(t){let{components:e,...n}=t;return(0,s.kt)(qo,(0,p.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}jo.isMDXComponent=!0;const Ho={toc:[]},Yo="wrapper";function Qo(t){let{components:e,...n}=t;return(0,s.kt)(Yo,(0,p.Z)({},Ho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}Qo.isMDXComponent=!0;const $o={toc:[]},Ko="wrapper";function Jo(t){let{components:e,...n}=t;return(0,s.kt)(Ko,(0,p.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}Jo.isMDXComponent=!0;const tp={toc:[]},ep="wrapper";function np(t){let{components:e,...n}=t;return(0,s.kt)(ep,(0,p.Z)({},tp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}np.isMDXComponent=!0;const op={toc:[]},pp="wrapper";function rp(t){let{components:e,...n}=t;return(0,s.kt)(pp,(0,p.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional information about the log."))}rp.isMDXComponent=!0;const sp={toc:[]},cp="wrapper";function ap(t){let{components:e,...n}=t;return(0,s.kt)(cp,(0,p.Z)({},sp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded.\nThe current stack trace can be obtained using ",(0,s.kt)("inlineCode",{parentName:"p"},"new Error().stack"),".\nBoth Chromium and Firefox stack traces are supported."))}ap.isMDXComponent=!0;const ip={toc:[]},lp="wrapper";function up(t){let{components:e,...n}=t;return(0,s.kt)(lp,(0,p.Z)({},ip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace of the log."))}up.isMDXComponent=!0;const mp={toc:[]},dp="wrapper";function hp(t){let{components:e,...n}=t;return(0,s.kt)(dp,(0,p.Z)({},mp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/media#audio"},"https://motioncanvas.io/docs/media#audio")))}hp.isMDXComponent=!0;const fp={toc:[]},kp="wrapper";function yp(t){let{components:e,...n}=t;return(0,s.kt)(kp,(0,p.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An url for the audio track to play alongside the animation."))}yp.isMDXComponent=!0;const Dp={toc:[]},Mp="wrapper";function Xp(t){let{components:e,...n}=t;return(0,s.kt)(Mp,(0,p.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Xp.isMDXComponent=!0;const _p={toc:[]},wp="wrapper";function Tp(t){let{components:e,...n}=t;return(0,s.kt)(wp,(0,p.Z)({},_p,n,{components:e,mdxType:"MDXLayout"}))}Tp.isMDXComponent=!0;const Cp={toc:[]},gp="wrapper";function xp(t){let{components:e,...n}=t;return(0,s.kt)(gp,(0,p.Z)({},Cp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/experimental"},"https://motioncanvas.io/docs/experimental")))}xp.isMDXComponent=!0;const vp={toc:[]},Lp="wrapper";function Zp(t){let{components:e,...n}=t;return(0,s.kt)(Lp,(0,p.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enable experimental features."))}Zp.isMDXComponent=!0;const bp={toc:[]},Np="wrapper";function zp(t){let{components:e,...n}=t;return(0,s.kt)(Np,(0,p.Z)({},bp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A custom logger instance to use."))}zp.isMDXComponent=!0;const Ap={toc:[]},Pp="wrapper";function Ip(t){let{components:e,...n}=t;return(0,s.kt)(Pp,(0,p.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the project."))}Ip.isMDXComponent=!0;const Wp={toc:[]},Rp="wrapper";function Sp(t){let{components:e,...n}=t;return(0,s.kt)(Rp,(0,p.Z)({},Wp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When a string is provided, the plugin will be imported dynamically using\nthe string as the module specifier. This is the preferred way to include\neditor plugins because it makes sure that the plugin's source code gets\nexcluded from the production build."))}Sp.isMDXComponent=!0;const Bp={toc:[]},Gp="wrapper";function Ep(t){let{components:e,...n}=t;return(0,s.kt)(Gp,(0,p.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}Ep.isMDXComponent=!0;const Op={toc:[]},Up="wrapper";function Fp(t){let{components:e,...n}=t;return(0,s.kt)(Up,(0,p.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A full scene description can be obtained by loading a scene module with a\n",(0,s.kt)("inlineCode",{parentName:"p"},"?scene")," query parameter."))}Fp.isMDXComponent=!0;const Vp={toc:[]},qp="wrapper";function jp(t){let{components:e,...n}=t;return(0,s.kt)(qp,(0,p.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import exampleScene from './example?scene';\n\nexport default makeProject({\n  scenes: [exampleScene],\n});\n")))}jp.isMDXComponent=!0;const Hp={toc:[]},Yp="wrapper";function Qp(t){let{components:e,...n}=t;return(0,s.kt)(Yp,(0,p.Z)({},Hp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of scene descriptions that make up the project."))}Qp.isMDXComponent=!0;const $p={toc:[]},Kp="wrapper";function Jp(t){let{components:e,...n}=t;return(0,s.kt)(Kp,(0,p.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/project-variables"},"https://motioncanvas.io/docs/project-variables")))}Jp.isMDXComponent=!0;const tr={toc:[]},er="wrapper";function nr(t){let{components:e,...n}=t;return(0,s.kt)(er,(0,p.Z)({},tr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Default values for project variables."))}nr.isMDXComponent=!0;const or={toc:[]},pr="wrapper";function rr(t){let{components:e,...n}=t;return(0,s.kt)(pr,(0,p.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}rr.isMDXComponent=!0;const sr={toc:[]},cr="wrapper";function ar(t){let{components:e,...n}=t;return(0,s.kt)(cr,(0,p.Z)({},sr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}ar.isMDXComponent=!0;const ir={toc:[]},lr="wrapper";function ur(t){let{components:e,...n}=t;return(0,s.kt)(lr,(0,p.Z)({},ir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}ur.isMDXComponent=!0;const mr={toc:[]},dr="wrapper";function hr(t){let{components:e,...n}=t;return(0,s.kt)(dr,(0,p.Z)({},mr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}hr.isMDXComponent=!0;const fr={toc:[]},kr="wrapper";function yr(t){let{components:e,...n}=t;return(0,s.kt)(kr,(0,p.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}yr.isMDXComponent=!0;const Dr={toc:[]},Mr="wrapper";function Xr(t){let{components:e,...n}=t;return(0,s.kt)(Mr,(0,p.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}Xr.isMDXComponent=!0;const _r={toc:[]},wr="wrapper";function Tr(t){let{components:e,...n}=t;return(0,s.kt)(wr,(0,p.Z)({},_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}Tr.isMDXComponent=!0;const Cr={toc:[]},gr="wrapper";function xr(t){let{components:e,...n}=t;return(0,s.kt)(gr,(0,p.Z)({},Cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}xr.isMDXComponent=!0;const vr={toc:[]},Lr="wrapper";function Zr(t){let{components:e,...n}=t;return(0,s.kt)(Lr,(0,p.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}Zr.isMDXComponent=!0;const br={toc:[]},Nr="wrapper";function zr(t){let{components:e,...n}=t;return(0,s.kt)(Nr,(0,p.Z)({},br,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}zr.isMDXComponent=!0;const Ar={toc:[]},Pr="wrapper";function Ir(t){let{components:e,...n}=t;return(0,s.kt)(Pr,(0,p.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ir.isMDXComponent=!0;const Wr={toc:[]},Rr="wrapper";function Sr(t){let{components:e,...n}=t;return(0,s.kt)(Rr,(0,p.Z)({},Wr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Sr.isMDXComponent=!0;const Br={toc:[]},Gr="wrapper";function Er(t){let{components:e,...n}=t;return(0,s.kt)(Gr,(0,p.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Er.isMDXComponent=!0;const Or={toc:[]},Ur="wrapper";function Fr(t){let{components:e,...n}=t;return(0,s.kt)(Ur,(0,p.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Fr.isMDXComponent=!0;const Vr={toc:[]},qr="wrapper";function jr(t){let{components:e,...n}=t;return(0,s.kt)(qr,(0,p.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}jr.isMDXComponent=!0;const Hr={toc:[]},Yr="wrapper";function Qr(t){let{components:e,...n}=t;return(0,s.kt)(Yr,(0,p.Z)({},Hr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Qr.isMDXComponent=!0;const $r={toc:[]},Kr="wrapper";function Jr(t){let{components:e,...n}=t;return(0,s.kt)(Kr,(0,p.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Jr.isMDXComponent=!0;const ts={toc:[]},es="wrapper";function ns(t){let{components:e,...n}=t;return(0,s.kt)(es,(0,p.Z)({},ts,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}ns.isMDXComponent=!0;const os={toc:[]},ps="wrapper";function rs(t){let{components:e,...n}=t;return(0,s.kt)(ps,(0,p.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}rs.isMDXComponent=!0;const ss={toc:[]},cs="wrapper";function as(t){let{components:e,...n}=t;return(0,s.kt)(cs,(0,p.Z)({},ss,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}as.isMDXComponent=!0;const is={toc:[]},ls="wrapper";function us(t){let{components:e,...n}=t;return(0,s.kt)(ls,(0,p.Z)({},is,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}us.isMDXComponent=!0;const ms={toc:[]},ds="wrapper";function hs(t){let{components:e,...n}=t;return(0,s.kt)(ds,(0,p.Z)({},ms,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}hs.isMDXComponent=!0;const fs={toc:[]},ks="wrapper";function ys(t){let{components:e,...n}=t;return(0,s.kt)(ks,(0,p.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}ys.isMDXComponent=!0;const Ds={toc:[]},Ms="wrapper";function Xs(t){let{components:e,...n}=t;return(0,s.kt)(Ms,(0,p.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Xs.isMDXComponent=!0;const _s={toc:[]},ws="wrapper";function Ts(t){let{components:e,...n}=t;return(0,s.kt)(ws,(0,p.Z)({},_s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ts.isMDXComponent=!0;const Cs={toc:[]},gs="wrapper";function xs(t){let{components:e,...n}=t;return(0,s.kt)(gs,(0,p.Z)({},Cs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}xs.isMDXComponent=!0;const vs={toc:[]},Ls="wrapper";function Zs(t){let{components:e,...n}=t;return(0,s.kt)(Ls,(0,p.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Zs.isMDXComponent=!0;const bs={toc:[]},Ns="wrapper";function zs(t){let{components:e,...n}=t;return(0,s.kt)(Ns,(0,p.Z)({},bs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}zs.isMDXComponent=!0;const As={toc:[]},Ps="wrapper";function Is(t){let{components:e,...n}=t;return(0,s.kt)(Ps,(0,p.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Is.isMDXComponent=!0;const Ws={toc:[]},Rs="wrapper";function Ss(t){let{components:e,...n}=t;return(0,s.kt)(Rs,(0,p.Z)({},Ws,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Ss.isMDXComponent=!0;const Bs={toc:[]},Gs="wrapper";function Es(t){let{components:e,...n}=t;return(0,s.kt)(Gs,(0,p.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Es.isMDXComponent=!0;const Os={toc:[]},Us="wrapper";function Fs(t){let{components:e,...n}=t;return(0,s.kt)(Us,(0,p.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Fs.isMDXComponent=!0;const Vs={toc:[]},qs="wrapper";function js(t){let{components:e,...n}=t;return(0,s.kt)(qs,(0,p.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}js.isMDXComponent=!0;const Hs={toc:[]},Ys="wrapper";function Qs(t){let{components:e,...n}=t;return(0,s.kt)(Ys,(0,p.Z)({},Hs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Qs.isMDXComponent=!0;const $s={toc:[]},Ks="wrapper";function Js(t){let{components:e,...n}=t;return(0,s.kt)(Ks,(0,p.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Js.isMDXComponent=!0;const tc={toc:[]},ec="wrapper";function nc(t){let{components:e,...n}=t;return(0,s.kt)(ec,(0,p.Z)({},tc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}nc.isMDXComponent=!0;const oc={toc:[]},pc="wrapper";function rc(t){let{components:e,...n}=t;return(0,s.kt)(pc,(0,p.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}rc.isMDXComponent=!0;const sc={toc:[]},cc="wrapper";function ac(t){let{components:e,...n}=t;return(0,s.kt)(cc,(0,p.Z)({},sc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}ac.isMDXComponent=!0;const ic={toc:[]},lc="wrapper";function uc(t){let{components:e,...n}=t;return(0,s.kt)(lc,(0,p.Z)({},ic,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}uc.isMDXComponent=!0;const mc={toc:[]},dc="wrapper";function hc(t){let{components:e,...n}=t;return(0,s.kt)(dc,(0,p.Z)({},mc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}hc.isMDXComponent=!0;const fc={toc:[]},kc="wrapper";function yc(t){let{components:e,...n}=t;return(0,s.kt)(kc,(0,p.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}yc.isMDXComponent=!0;const Dc={toc:[]},Mc="wrapper";function Xc(t){let{components:e,...n}=t;return(0,s.kt)(Mc,(0,p.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}Xc.isMDXComponent=!0;const _c={toc:[]},wc="wrapper";function Tc(t){let{components:e,...n}=t;return(0,s.kt)(wc,(0,p.Z)({},_c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Tc.isMDXComponent=!0;const Cc={toc:[]},gc="wrapper";function xc(t){let{components:e,...n}=t;return(0,s.kt)(gc,(0,p.Z)({},Cc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}xc.isMDXComponent=!0;const vc={toc:[]},Lc="wrapper";function Zc(t){let{components:e,...n}=t;return(0,s.kt)(Lc,(0,p.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Zc.isMDXComponent=!0;const bc={toc:[]},Nc="wrapper";function zc(t){let{components:e,...n}=t;return(0,s.kt)(Nc,(0,p.Z)({},bc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}zc.isMDXComponent=!0;const Ac={toc:[]},Pc="wrapper";function Ic(t){let{components:e,...n}=t;return(0,s.kt)(Pc,(0,p.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ic.isMDXComponent=!0;const Wc={toc:[]},Rc="wrapper";function Sc(t){let{components:e,...n}=t;return(0,s.kt)(Rc,(0,p.Z)({},Wc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Sc.isMDXComponent=!0;const Bc={toc:[]},Gc="wrapper";function Ec(t){let{components:e,...n}=t;return(0,s.kt)(Gc,(0,p.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Ec.isMDXComponent=!0;const Oc={toc:[]},Uc="wrapper";function Fc(t){let{components:e,...n}=t;return(0,s.kt)(Uc,(0,p.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Fc.isMDXComponent=!0;const Vc={toc:[]},qc="wrapper";function jc(t){let{components:e,...n}=t;return(0,s.kt)(qc,(0,p.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}jc.isMDXComponent=!0;const Hc={toc:[]},Yc="wrapper";function Qc(t){let{components:e,...n}=t;return(0,s.kt)(Yc,(0,p.Z)({},Hc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Qc.isMDXComponent=!0;const $c={toc:[]},Kc="wrapper";function Jc(t){let{components:e,...n}=t;return(0,s.kt)(Kc,(0,p.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Jc.isMDXComponent=!0;const ta={toc:[]},ea="wrapper";function na(t){let{components:e,...n}=t;return(0,s.kt)(ea,(0,p.Z)({},ta,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}na.isMDXComponent=!0;const oa={toc:[]},pa="wrapper";function ra(t){let{components:e,...n}=t;return(0,s.kt)(pa,(0,p.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ra.isMDXComponent=!0;const sa={toc:[]},ca="wrapper";function aa(t){let{components:e,...n}=t;return(0,s.kt)(ca,(0,p.Z)({},sa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}aa.isMDXComponent=!0;const ia={toc:[]},la="wrapper";function ua(t){let{components:e,...n}=t;return(0,s.kt)(la,(0,p.Z)({},ia,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ua.isMDXComponent=!0;const ma={toc:[]},da="wrapper";function ha(t){let{components:e,...n}=t;return(0,s.kt)(da,(0,p.Z)({},ma,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}ha.isMDXComponent=!0;const fa={toc:[]},ka="wrapper";function ya(t){let{components:e,...n}=t;return(0,s.kt)(ka,(0,p.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}ya.isMDXComponent=!0;const Da={toc:[]},Ma="wrapper";function Xa(t){let{components:e,...n}=t;return(0,s.kt)(Ma,(0,p.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Xa.isMDXComponent=!0;const _a={toc:[]},wa="wrapper";function Ta(t){let{components:e,...n}=t;return(0,s.kt)(wa,(0,p.Z)({},_a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ta.isMDXComponent=!0;const Ca={toc:[]},ga="wrapper";function xa(t){let{components:e,...n}=t;return(0,s.kt)(ga,(0,p.Z)({},Ca,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}xa.isMDXComponent=!0;const va={toc:[]},La="wrapper";function Za(t){let{components:e,...n}=t;return(0,s.kt)(La,(0,p.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Za.isMDXComponent=!0;const ba={toc:[]},Na="wrapper";function za(t){let{components:e,...n}=t;return(0,s.kt)(Na,(0,p.Z)({},ba,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}za.isMDXComponent=!0;const Aa={toc:[]},Pa="wrapper";function Ia(t){let{components:e,...n}=t;return(0,s.kt)(Pa,(0,p.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ia.isMDXComponent=!0;const Wa={toc:[]},Ra="wrapper";function Sa(t){let{components:e,...n}=t;return(0,s.kt)(Ra,(0,p.Z)({},Wa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Sa.isMDXComponent=!0;const Ba={toc:[]},Ga="wrapper";function Ea(t){let{components:e,...n}=t;return(0,s.kt)(Ga,(0,p.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ea.isMDXComponent=!0;const Oa={toc:[]},Ua="wrapper";function Fa(t){let{components:e,...n}=t;return(0,s.kt)(Ua,(0,p.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Fa.isMDXComponent=!0;const Va={toc:[]},qa="wrapper";function ja(t){let{components:e,...n}=t;return(0,s.kt)(qa,(0,p.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}ja.isMDXComponent=!0;const Ha={toc:[]},Ya="wrapper";function Qa(t){let{components:e,...n}=t;return(0,s.kt)(Ya,(0,p.Z)({},Ha,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Qa.isMDXComponent=!0;const $a={toc:[]},Ka="wrapper";function Ja(t){let{components:e,...n}=t;return(0,s.kt)(Ka,(0,p.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Ja.isMDXComponent=!0;const ti={toc:[]},ei="wrapper";function ni(t){let{components:e,...n}=t;return(0,s.kt)(ei,(0,p.Z)({},ti,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}ni.isMDXComponent=!0;const oi={toc:[]},pi="wrapper";function ri(t){let{components:e,...n}=t;return(0,s.kt)(pi,(0,p.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}ri.isMDXComponent=!0;const si={toc:[]},ci="wrapper";function ai(t){let{components:e,...n}=t;return(0,s.kt)(ci,(0,p.Z)({},si,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}ai.isMDXComponent=!0;const ii={toc:[]},li="wrapper";function ui(t){let{components:e,...n}=t;return(0,s.kt)(li,(0,p.Z)({},ii,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}ui.isMDXComponent=!0;const mi={toc:[]},di="wrapper";function hi(t){let{components:e,...n}=t;return(0,s.kt)(di,(0,p.Z)({},mi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}hi.isMDXComponent=!0;const fi={toc:[]},ki="wrapper";function yi(t){let{components:e,...n}=t;return(0,s.kt)(ki,(0,p.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}yi.isMDXComponent=!0;const Di={toc:[]},Mi="wrapper";function Xi(t){let{components:e,...n}=t;return(0,s.kt)(Mi,(0,p.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Xi.isMDXComponent=!0;const _i={toc:[]},wi="wrapper";function Ti(t){let{components:e,...n}=t;return(0,s.kt)(wi,(0,p.Z)({},_i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ti.isMDXComponent=!0;const Ci={toc:[]},gi="wrapper";function xi(t){let{components:e,...n}=t;return(0,s.kt)(gi,(0,p.Z)({},Ci,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}xi.isMDXComponent=!0;const vi={toc:[]},Li="wrapper";function Zi(t){let{components:e,...n}=t;return(0,s.kt)(Li,(0,p.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Zi.isMDXComponent=!0;const bi={toc:[]},Ni="wrapper";function zi(t){let{components:e,...n}=t;return(0,s.kt)(Ni,(0,p.Z)({},bi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}zi.isMDXComponent=!0;const Ai={toc:[]},Pi="wrapper";function Ii(t){let{components:e,...n}=t;return(0,s.kt)(Pi,(0,p.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ii.isMDXComponent=!0;const Wi={toc:[]},Ri="wrapper";function Si(t){let{components:e,...n}=t;return(0,s.kt)(Ri,(0,p.Z)({},Wi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Si.isMDXComponent=!0;const Bi={toc:[]},Gi="wrapper";function Ei(t){let{components:e,...n}=t;return(0,s.kt)(Gi,(0,p.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ei.isMDXComponent=!0;const Oi={toc:[]},Ui="wrapper";function Fi(t){let{components:e,...n}=t;return(0,s.kt)(Ui,(0,p.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}Fi.isMDXComponent=!0;const Vi={toc:[]},qi="wrapper";function ji(t){let{components:e,...n}=t;return(0,s.kt)(qi,(0,p.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ji.isMDXComponent=!0;const Hi={toc:[]},Yi="wrapper";function Qi(t){let{components:e,...n}=t;return(0,s.kt)(Yi,(0,p.Z)({},Hi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Qi.isMDXComponent=!0;const $i={toc:[]},Ki="wrapper";function Ji(t){let{components:e,...n}=t;return(0,s.kt)(Ki,(0,p.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}Ji.isMDXComponent=!0;const tl={toc:[]},el="wrapper";function nl(t){let{components:e,...n}=t;return(0,s.kt)(el,(0,p.Z)({},tl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}nl.isMDXComponent=!0;const ol={toc:[]},pl="wrapper";function rl(t){let{components:e,...n}=t;return(0,s.kt)(pl,(0,p.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}rl.isMDXComponent=!0;const sl={toc:[]},cl="wrapper";function al(t){let{components:e,...n}=t;return(0,s.kt)(cl,(0,p.Z)({},sl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}al.isMDXComponent=!0;const il={toc:[]},ll="wrapper";function ul(t){let{components:e,...n}=t;return(0,s.kt)(ll,(0,p.Z)({},il,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}ul.isMDXComponent=!0;const ml={toc:[]},dl="wrapper";function hl(t){let{components:e,...n}=t;return(0,s.kt)(dl,(0,p.Z)({},ml,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback called by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow/EveryTimer"},(0,s.kt)("inlineCode",{parentName:"a"},"EveryTimer"))," every N seconds."))}hl.isMDXComponent=!0;const fl={toc:[]},kl="wrapper";function yl(t){let{components:e,...n}=t;return(0,s.kt)(kl,(0,p.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}yl.isMDXComponent=!0;const Dl={toc:[]},Ml="wrapper";function Xl(t){let{components:e,...n}=t;return(0,s.kt)(Ml,(0,p.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}Xl.isMDXComponent=!0;const _l={toc:[]},wl="wrapper";function Tl(t){let{components:e,...n}=t;return(0,s.kt)(wl,(0,p.Z)({},_l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}Tl.isMDXComponent=!0;const Cl={toc:[]},gl="wrapper";function xl(t){let{components:e,...n}=t;return(0,s.kt)(gl,(0,p.Z)({},Cl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback called by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#loop"},(0,s.kt)("inlineCode",{parentName:"a"},"loop"))," during each iteration."))}xl.isMDXComponent=!0;const vl={toc:[]},Ll="wrapper";function Zl(t){let{components:e,...n}=t;return(0,s.kt)(Ll,(0,p.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}Zl.isMDXComponent=!0;const bl={toc:[]},Nl="wrapper";function zl(t){let{components:e,...n}=t;return(0,s.kt)(Nl,(0,p.Z)({},bl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}zl.isMDXComponent=!0;const Al={toc:[]},Pl="wrapper";function Il(t){let{components:e,...n}=t;return(0,s.kt)(Pl,(0,p.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Il.isMDXComponent=!0;const Wl={toc:[]},Rl="wrapper";function Sl(t){let{components:e,...n}=t;return(0,s.kt)(Rl,(0,p.Z)({},Wl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Sl.isMDXComponent=!0;const Bl={toc:[]},Gl="wrapper";function El(t){let{components:e,...n}=t;return(0,s.kt)(Gl,(0,p.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}El.isMDXComponent=!0;const Ol={toc:[]},Ul="wrapper";function Fl(t){let{components:e,...n}=t;return(0,s.kt)(Ul,(0,p.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Fl.isMDXComponent=!0;const Vl={toc:[]},ql="wrapper";function jl(t){let{components:e,...n}=t;return(0,s.kt)(ql,(0,p.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}jl.isMDXComponent=!0;const Hl={toc:[]},Yl="wrapper";function Ql(t){let{components:e,...n}=t;return(0,s.kt)(Yl,(0,p.Z)({},Hl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Ql.isMDXComponent=!0;const $l={toc:[]},Kl="wrapper";function Jl(t){let{components:e,...n}=t;return(0,s.kt)(Kl,(0,p.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Jl.isMDXComponent=!0;const tu={toc:[]},eu="wrapper";function nu(t){let{components:e,...n}=t;return(0,s.kt)(eu,(0,p.Z)({},tu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}nu.isMDXComponent=!0;const ou={toc:[]},pu="wrapper";function ru(t){let{components:e,...n}=t;return(0,s.kt)(pu,(0,p.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}ru.isMDXComponent=!0;const su={toc:[]},cu="wrapper";function au(t){let{components:e,...n}=t;return(0,s.kt)(cu,(0,p.Z)({},su,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}au.isMDXComponent=!0;const iu={toc:[]},lu="wrapper";function uu(t){let{components:e,...n}=t;return(0,s.kt)(lu,(0,p.Z)({},iu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}uu.isMDXComponent=!0;const mu={toc:[]},du="wrapper";function hu(t){let{components:e,...n}=t;return(0,s.kt)(du,(0,p.Z)({},mu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}hu.isMDXComponent=!0;const fu={toc:[]},ku="wrapper";function yu(t){let{components:e,...n}=t;return(0,s.kt)(ku,(0,p.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}yu.isMDXComponent=!0;const Du={toc:[]},Mu="wrapper";function Xu(t){let{components:e,...n}=t;return(0,s.kt)(Mu,(0,p.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}Xu.isMDXComponent=!0;const _u={toc:[]},wu="wrapper";function Tu(t){let{components:e,...n}=t;return(0,s.kt)(wu,(0,p.Z)({},_u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}Tu.isMDXComponent=!0;const Cu={toc:[]},gu="wrapper";function xu(t){let{components:e,...n}=t;return(0,s.kt)(gu,(0,p.Z)({},Cu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}xu.isMDXComponent=!0;const vu={toc:[]},Lu="wrapper";function Zu(t){let{components:e,...n}=t;return(0,s.kt)(Lu,(0,p.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed.\nBecause this loop never finishes it cannot be used in the main thread.\nInstead, use ",(0,s.kt)("inlineCode",{parentName:"p"},"yield")," or ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.kt)("inlineCode",{parentName:"a"},"spawn"))," to run the loop concurrently."))}Zu.isMDXComponent=!0;const bu={toc:[]},Nu="wrapper";function zu(t){let{components:e,...n}=t;return(0,s.kt)(Nu,(0,p.Z)({},bu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the ",(0,s.kt)("inlineCode",{parentName:"p"},"rect")," indefinitely:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield loop(\n  () => rect.rotation(0).rotation(360, 2, linear),\n);\n")))}zu.isMDXComponent=!0;const Au={toc:[]},Pu="wrapper";function Iu(t){let{components:e,...n}=t;return(0,s.kt)(Pu,(0,p.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator in a loop."))}Iu.isMDXComponent=!0;const Wu={toc:[]},Ru="wrapper";function Su(t){let{components:e,...n}=t;return(0,s.kt)(Ru,(0,p.Z)({},Wu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Su.isMDXComponent=!0;const Bu={toc:[]},Gu="wrapper";function Eu(t){let{components:e,...n}=t;return(0,s.kt)(Gu,(0,p.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}Eu.isMDXComponent=!0;const Ou={toc:[]},Uu="wrapper";function Fu(t){let{components:e,...n}=t;return(0,s.kt)(Uu,(0,p.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}Fu.isMDXComponent=!0;const Vu={toc:[]},qu="wrapper";function ju(t){let{components:e,...n}=t;return(0,s.kt)(qu,(0,p.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}ju.isMDXComponent=!0;const Hu={toc:[]},Yu="wrapper";function Qu(t){let{components:e,...n}=t;return(0,s.kt)(Yu,(0,p.Z)({},Hu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}Qu.isMDXComponent=!0;const $u={toc:[]},Ku="wrapper";function Ju(t){let{components:e,...n}=t;return(0,s.kt)(Ku,(0,p.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Ju.isMDXComponent=!0;const tm={toc:[]},em="wrapper";function nm(t){let{components:e,...n}=t;return(0,s.kt)(em,(0,p.Z)({},tm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}nm.isMDXComponent=!0;const om={toc:[]},pm="wrapper";function rm(t){let{components:e,...n}=t;return(0,s.kt)(pm,(0,p.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}rm.isMDXComponent=!0;const sm={toc:[]},cm="wrapper";function am(t){let{components:e,...n}=t;return(0,s.kt)(cm,(0,p.Z)({},sm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}am.isMDXComponent=!0;const im={toc:[]},lm="wrapper";function um(t){let{components:e,...n}=t;return(0,s.kt)(lm,(0,p.Z)({},im,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}um.isMDXComponent=!0;const mm={toc:[]},dm="wrapper";function hm(t){let{components:e,...n}=t;return(0,s.kt)(dm,(0,p.Z)({},mm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}hm.isMDXComponent=!0;const fm={toc:[]},km="wrapper";function ym(t){let{components:e,...n}=t;return(0,s.kt)(km,(0,p.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}ym.isMDXComponent=!0;const Dm={toc:[]},Mm="wrapper";function Xm(t){let{components:e,...n}=t;return(0,s.kt)(Mm,(0,p.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Xm.isMDXComponent=!0;const _m={toc:[]},wm="wrapper";function Tm(t){let{components:e,...n}=t;return(0,s.kt)(wm,(0,p.Z)({},_m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Tm.isMDXComponent=!0;const Cm={toc:[]},gm="wrapper";function xm(t){let{components:e,...n}=t;return(0,s.kt)(gm,(0,p.Z)({},Cm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}xm.isMDXComponent=!0;const vm={toc:[]},Lm="wrapper";function Zm(t){let{components:e,...n}=t;return(0,s.kt)(Lm,(0,p.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Zm.isMDXComponent=!0;const bm={toc:[]},Nm="wrapper";function zm(t){let{components:e,...n}=t;return(0,s.kt)(Nm,(0,p.Z)({},bm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}zm.isMDXComponent=!0;const Am={toc:[]},Pm="wrapper";function Im(t){let{components:e,...n}=t;return(0,s.kt)(Pm,(0,p.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.kt)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}Im.isMDXComponent=!0;const Wm={toc:[]},Rm="wrapper";function Sm(t){let{components:e,...n}=t;return(0,s.kt)(Rm,(0,p.Z)({},Wm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}Sm.isMDXComponent=!0;const Bm={toc:[]},Gm="wrapper";function Em(t){let{components:e,...n}=t;return(0,s.kt)(Gm,(0,p.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a task."))}Em.isMDXComponent=!0;const Om={toc:[]},Um="wrapper";function Fm(t){let{components:e,...n}=t;return(0,s.kt)(Um,(0,p.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Fm.isMDXComponent=!0;const Vm={toc:[]},qm="wrapper";function jm(t){let{components:e,...n}=t;return(0,s.kt)(qm,(0,p.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.kt)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}jm.isMDXComponent=!0;const Hm={toc:[]},Ym="wrapper";function Qm(t){let{components:e,...n}=t;return(0,s.kt)(Ym,(0,p.Z)({},Hm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}Qm.isMDXComponent=!0;const $m={toc:[]},Km="wrapper";function Jm(t){let{components:e,...n}=t;return(0,s.kt)(Km,(0,p.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a task."))}Jm.isMDXComponent=!0;const td={toc:[]},ed="wrapper";function nd(t){let{components:e,...n}=t;return(0,s.kt)(ed,(0,p.Z)({},td,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}nd.isMDXComponent=!0;const od={toc:[]},pd="wrapper";function rd(t){let{components:e,...n}=t;return(0,s.kt)(pd,(0,p.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}rd.isMDXComponent=!0;const sd={toc:[]},cd="wrapper";function ad(t){let{components:e,...n}=t;return(0,s.kt)(cd,(0,p.Z)({},sd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}ad.isMDXComponent=!0;const id={toc:[]},ld="wrapper";function ud(t){let{components:e,...n}=t;return(0,s.kt)(ld,(0,p.Z)({},id,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}ud.isMDXComponent=!0;const md={toc:[]},dd="wrapper";function hd(t){let{components:e,...n}=t;return(0,s.kt)(dd,(0,p.Z)({},md,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}hd.isMDXComponent=!0;const fd={toc:[]},kd="wrapper";function yd(t){let{components:e,...n}=t;return(0,s.kt)(kd,(0,p.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}yd.isMDXComponent=!0;const Dd={toc:[]},Md="wrapper";function Xd(t){let{components:e,...n}=t;return(0,s.kt)(Md,(0,p.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}Xd.isMDXComponent=!0;const _d={toc:[]},wd="wrapper";function Td(t){let{components:e,...n}=t;return(0,s.kt)(wd,(0,p.Z)({},_d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Td.isMDXComponent=!0;const Cd={toc:[]},gd="wrapper";function xd(t){let{components:e,...n}=t;return(0,s.kt)(gd,(0,p.Z)({},Cd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}xd.isMDXComponent=!0;const vd={toc:[]},Ld="wrapper";function Zd(t){let{components:e,...n}=t;return(0,s.kt)(Ld,(0,p.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}Zd.isMDXComponent=!0;const bd={toc:[]},Nd="wrapper";function zd(t){let{components:e,...n}=t;return(0,s.kt)(Nd,(0,p.Z)({},bd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}zd.isMDXComponent=!0;const Ad={toc:[]},Pd="wrapper";function Id(t){let{components:e,...n}=t;return(0,s.kt)(Pd,(0,p.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}Id.isMDXComponent=!0;const Wd={toc:[]},Rd="wrapper";function Sd(t){let{components:e,...n}=t;return(0,s.kt)(Rd,(0,p.Z)({},Wd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}Sd.isMDXComponent=!0;const Bd={toc:[]},Gd="wrapper";function Ed(t){let{components:e,...n}=t;return(0,s.kt)(Gd,(0,p.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}Ed.isMDXComponent=!0;const Od={toc:[]},Ud="wrapper";function Fd(t){let{components:e,...n}=t;return(0,s.kt)(Ud,(0,p.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}Fd.isMDXComponent=!0;const Vd={toc:[]},qd="wrapper";function jd(t){let{components:e,...n}=t;return(0,s.kt)(qd,(0,p.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}jd.isMDXComponent=!0;const Hd={toc:[]},Yd="wrapper";function Qd(t){let{components:e,...n}=t;return(0,s.kt)(Yd,(0,p.Z)({},Hd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Qd.isMDXComponent=!0;const $d={toc:[]},Kd="wrapper";function Jd(t){let{components:e,...n}=t;return(0,s.kt)(Kd,(0,p.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Jd.isMDXComponent=!0;const th={toc:[]},eh="wrapper";function nh(t){let{components:e,...n}=t;return(0,s.kt)(eh,(0,p.Z)({},th,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}nh.isMDXComponent=!0;const oh={toc:[]},ph="wrapper";function rh(t){let{components:e,...n}=t;return(0,s.kt)(ph,(0,p.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}rh.isMDXComponent=!0;const sh={toc:[]},ch="wrapper";function ah(t){let{components:e,...n}=t;return(0,s.kt)(ch,(0,p.Z)({},sh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}ah.isMDXComponent=!0;const ih={toc:[]},lh="wrapper";function uh(t){let{components:e,...n}=t;return(0,s.kt)(lh,(0,p.Z)({},ih,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}uh.isMDXComponent=!0;const mh={toc:[]},dh="wrapper";function hh(t){let{components:e,...n}=t;return(0,s.kt)(dh,(0,p.Z)({},mh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}hh.isMDXComponent=!0;const fh={toc:[]},kh="wrapper";function yh(t){let{components:e,...n}=t;return(0,s.kt)(kh,(0,p.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}yh.isMDXComponent=!0;const Dh={toc:[]},Mh="wrapper";function Xh(t){let{components:e,...n}=t;return(0,s.kt)(Mh,(0,p.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Xh.isMDXComponent=!0;const _h={toc:[]},wh="wrapper";function Th(t){let{components:e,...n}=t;return(0,s.kt)(wh,(0,p.Z)({},_h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}Th.isMDXComponent=!0;const Ch={toc:[]},gh="wrapper";function xh(t){let{components:e,...n}=t;return(0,s.kt)(gh,(0,p.Z)({},Ch,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}xh.isMDXComponent=!0;const vh={toc:[]},Lh="wrapper";function Zh(t){let{components:e,...n}=t;return(0,s.kt)(Lh,(0,p.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Zh.isMDXComponent=!0;const bh={toc:[]},Nh="wrapper";function zh(t){let{components:e,...n}=t;return(0,s.kt)(Nh,(0,p.Z)({},bh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}zh.isMDXComponent=!0;const Ah={toc:[]},Ph="wrapper";function Ih(t){let{components:e,...n}=t;return(0,s.kt)(Ph,(0,p.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ih.isMDXComponent=!0;const Wh={toc:[]},Rh="wrapper";function Sh(t){let{components:e,...n}=t;return(0,s.kt)(Rh,(0,p.Z)({},Wh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Sh.isMDXComponent=!0;const Bh={toc:[]},Gh="wrapper";function Eh(t){let{components:e,...n}=t;return(0,s.kt)(Gh,(0,p.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Eh.isMDXComponent=!0;const Oh={toc:[]},Uh="wrapper";function Fh(t){let{components:e,...n}=t;return(0,s.kt)(Uh,(0,p.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Fh.isMDXComponent=!0;const Vh={toc:[]},qh="wrapper";function jh(t){let{components:e,...n}=t;return(0,s.kt)(qh,(0,p.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}jh.isMDXComponent=!0;const Hh={toc:[]},Yh="wrapper";function Qh(t){let{components:e,...n}=t;return(0,s.kt)(Yh,(0,p.Z)({},Hh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Qh.isMDXComponent=!0;const $h={toc:[]},Kh="wrapper";function Jh(t){let{components:e,...n}=t;return(0,s.kt)(Kh,(0,p.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Jh.isMDXComponent=!0;const tf={toc:[]},ef="wrapper";function nf(t){let{components:e,...n}=t;return(0,s.kt)(ef,(0,p.Z)({},tf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}nf.isMDXComponent=!0;const of={toc:[]},pf="wrapper";function rf(t){let{components:e,...n}=t;return(0,s.kt)(pf,(0,p.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}rf.isMDXComponent=!0;const sf={toc:[]},cf="wrapper";function af(t){let{components:e,...n}=t;return(0,s.kt)(cf,(0,p.Z)({},sf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}af.isMDXComponent=!0;const lf={toc:[]},uf="wrapper";function mf(t){let{components:e,...n}=t;return(0,s.kt)(uf,(0,p.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}mf.isMDXComponent=!0;const df={toc:[]},hf="wrapper";function ff(t){let{components:e,...n}=t;return(0,s.kt)(hf,(0,p.Z)({},df,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}ff.isMDXComponent=!0;const kf={toc:[]},yf="wrapper";function Df(t){let{components:e,...n}=t;return(0,s.kt)(yf,(0,p.Z)({},kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Df.isMDXComponent=!0;const Mf={toc:[]},Xf="wrapper";function _f(t){let{components:e,...n}=t;return(0,s.kt)(Xf,(0,p.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}_f.isMDXComponent=!0;const wf={toc:[]},Tf="wrapper";function Cf(t){let{components:e,...n}=t;return(0,s.kt)(Tf,(0,p.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Cf.isMDXComponent=!0;const gf={toc:[]},xf="wrapper";function vf(t){let{components:e,...n}=t;return(0,s.kt)(xf,(0,p.Z)({},gf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}vf.isMDXComponent=!0;const Lf={toc:[]},Zf="wrapper";function bf(t){let{components:e,...n}=t;return(0,s.kt)(Zf,(0,p.Z)({},Lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}bf.isMDXComponent=!0;const Nf={toc:[]},zf="wrapper";function Af(t){let{components:e,...n}=t;return(0,s.kt)(zf,(0,p.Z)({},Nf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}Af.isMDXComponent=!0;const Pf={toc:[]},If="wrapper";function Wf(t){let{components:e,...n}=t;return(0,s.kt)(If,(0,p.Z)({},Pf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Wf.isMDXComponent=!0;const Rf={toc:[]},Sf="wrapper";function Bf(t){let{components:e,...n}=t;return(0,s.kt)(Sf,(0,p.Z)({},Rf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Bf.isMDXComponent=!0;const Gf={toc:[]},Ef="wrapper";function Of(t){let{components:e,...n}=t;return(0,s.kt)(Ef,(0,p.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Of.isMDXComponent=!0;const Uf={toc:[]},Ff="wrapper";function Vf(t){let{components:e,...n}=t;return(0,s.kt)(Ff,(0,p.Z)({},Uf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Vf.isMDXComponent=!0;const qf={toc:[]},jf="wrapper";function Hf(t){let{components:e,...n}=t;return(0,s.kt)(jf,(0,p.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Hf.isMDXComponent=!0;const Yf={toc:[]},Qf="wrapper";function $f(t){let{components:e,...n}=t;return(0,s.kt)(Qf,(0,p.Z)({},Yf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}$f.isMDXComponent=!0;const Kf={toc:[]},Jf="wrapper";function tk(t){let{components:e,...n}=t;return(0,s.kt)(Jf,(0,p.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}tk.isMDXComponent=!0;const ek={toc:[]},nk="wrapper";function ok(t){let{components:e,...n}=t;return(0,s.kt)(nk,(0,p.Z)({},ek,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}ok.isMDXComponent=!0;const pk={toc:[]},rk="wrapper";function sk(t){let{components:e,...n}=t;return(0,s.kt)(rk,(0,p.Z)({},pk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}sk.isMDXComponent=!0;const ck={toc:[]},ak="wrapper";function ik(t){let{components:e,...n}=t;return(0,s.kt)(ak,(0,p.Z)({},ck,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}ik.isMDXComponent=!0;const lk={toc:[]},uk="wrapper";function mk(t){let{components:e,...n}=t;return(0,s.kt)(uk,(0,p.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}mk.isMDXComponent=!0;const dk={toc:[]},hk="wrapper";function fk(t){let{components:e,...n}=t;return(0,s.kt)(hk,(0,p.Z)({},dk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}fk.isMDXComponent=!0;const kk={toc:[]},yk="wrapper";function Dk(t){let{components:e,...n}=t;return(0,s.kt)(yk,(0,p.Z)({},kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Dk.isMDXComponent=!0;const Mk={toc:[]},Xk="wrapper";function _k(t){let{components:e,...n}=t;return(0,s.kt)(Xk,(0,p.Z)({},Mk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}_k.isMDXComponent=!0;const wk={toc:[]},Tk="wrapper";function Ck(t){let{components:e,...n}=t;return(0,s.kt)(Tk,(0,p.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Ck.isMDXComponent=!0;const gk={toc:[]},xk="wrapper";function vk(t){let{components:e,...n}=t;return(0,s.kt)(xk,(0,p.Z)({},gk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}vk.isMDXComponent=!0;const Lk={toc:[]},Zk="wrapper";function bk(t){let{components:e,...n}=t;return(0,s.kt)(Zk,(0,p.Z)({},Lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}bk.isMDXComponent=!0;const Nk={toc:[]},zk="wrapper";function Ak(t){let{components:e,...n}=t;return(0,s.kt)(zk,(0,p.Z)({},Nk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ak.isMDXComponent=!0;const Pk={toc:[]},Ik="wrapper";function Wk(t){let{components:e,...n}=t;return(0,s.kt)(Ik,(0,p.Z)({},Pk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Wk.isMDXComponent=!0;const Rk={toc:[]},Sk="wrapper";function Bk(t){let{components:e,...n}=t;return(0,s.kt)(Sk,(0,p.Z)({},Rk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Bk.isMDXComponent=!0;const Gk={toc:[]},Ek="wrapper";function Ok(t){let{components:e,...n}=t;return(0,s.kt)(Ek,(0,p.Z)({},Gk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}Ok.isMDXComponent=!0;const Uk={toc:[]},Fk="wrapper";function Vk(t){let{components:e,...n}=t;return(0,s.kt)(Fk,(0,p.Z)({},Uk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vk.isMDXComponent=!0;const qk={toc:[]},jk="wrapper";function Hk(t){let{components:e,...n}=t;return(0,s.kt)(jk,(0,p.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Hk.isMDXComponent=!0;const Yk={toc:[]},Qk="wrapper";function $k(t){let{components:e,...n}=t;return(0,s.kt)(Qk,(0,p.Z)({},Yk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}$k.isMDXComponent=!0;const Kk={toc:[]},Jk="wrapper";function ty(t){let{components:e,...n}=t;return(0,s.kt)(Jk,(0,p.Z)({},Kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ty.isMDXComponent=!0;const ey={toc:[]},ny="wrapper";function oy(t){let{components:e,...n}=t;return(0,s.kt)(ny,(0,p.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}oy.isMDXComponent=!0;const py={toc:[]},ry="wrapper";function sy(t){let{components:e,...n}=t;return(0,s.kt)(ry,(0,p.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}sy.isMDXComponent=!0;const cy={toc:[]},ay="wrapper";function iy(t){let{components:e,...n}=t;return(0,s.kt)(ay,(0,p.Z)({},cy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}iy.isMDXComponent=!0;const ly={toc:[]},uy="wrapper";function my(t){let{components:e,...n}=t;return(0,s.kt)(uy,(0,p.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}my.isMDXComponent=!0;const dy={toc:[]},hy="wrapper";function fy(t){let{components:e,...n}=t;return(0,s.kt)(hy,(0,p.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}fy.isMDXComponent=!0;const ky={toc:[]},yy="wrapper";function Dy(t){let{components:e,...n}=t;return(0,s.kt)(yy,(0,p.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Dy.isMDXComponent=!0;const My={toc:[]},Xy="wrapper";function _y(t){let{components:e,...n}=t;return(0,s.kt)(Xy,(0,p.Z)({},My,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}_y.isMDXComponent=!0;const wy={toc:[]},Ty="wrapper";function Cy(t){let{components:e,...n}=t;return(0,s.kt)(Ty,(0,p.Z)({},wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Cy.isMDXComponent=!0;const gy={toc:[]},xy="wrapper";function vy(t){let{components:e,...n}=t;return(0,s.kt)(xy,(0,p.Z)({},gy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}vy.isMDXComponent=!0;const Ly={toc:[]},Zy="wrapper";function by(t){let{components:e,...n}=t;return(0,s.kt)(Zy,(0,p.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}by.isMDXComponent=!0;const Ny={toc:[]},zy="wrapper";function Ay(t){let{components:e,...n}=t;return(0,s.kt)(zy,(0,p.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Ay.isMDXComponent=!0;const Py={toc:[]},Iy="wrapper";function Wy(t){let{components:e,...n}=t;return(0,s.kt)(Iy,(0,p.Z)({},Py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Wy.isMDXComponent=!0;const Ry={toc:[]},Sy="wrapper";function By(t){let{components:e,...n}=t;return(0,s.kt)(Sy,(0,p.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}By.isMDXComponent=!0;const Gy={toc:[]},Ey="wrapper";function Oy(t){let{components:e,...n}=t;return(0,s.kt)(Ey,(0,p.Z)({},Gy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Oy.isMDXComponent=!0;const Uy={toc:[]},Fy="wrapper";function Vy(t){let{components:e,...n}=t;return(0,s.kt)(Fy,(0,p.Z)({},Uy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}Vy.isMDXComponent=!0;const qy={toc:[]},jy="wrapper";function Hy(t){let{components:e,...n}=t;return(0,s.kt)(jy,(0,p.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Hy.isMDXComponent=!0;const Yy={toc:[]},Qy="wrapper";function $y(t){let{components:e,...n}=t;return(0,s.kt)(Qy,(0,p.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}$y.isMDXComponent=!0;const Ky={toc:[]},Jy="wrapper";function tD(t){let{components:e,...n}=t;return(0,s.kt)(Jy,(0,p.Z)({},Ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}tD.isMDXComponent=!0;const eD={toc:[]},nD="wrapper";function oD(t){let{components:e,...n}=t;return(0,s.kt)(nD,(0,p.Z)({},eD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}oD.isMDXComponent=!0;const pD={toc:[]},rD="wrapper";function sD(t){let{components:e,...n}=t;return(0,s.kt)(rD,(0,p.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}sD.isMDXComponent=!0;const cD={toc:[]},aD="wrapper";function iD(t){let{components:e,...n}=t;return(0,s.kt)(aD,(0,p.Z)({},cD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}iD.isMDXComponent=!0;const lD={toc:[]},uD="wrapper";function mD(t){let{components:e,...n}=t;return(0,s.kt)(uD,(0,p.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}mD.isMDXComponent=!0;const dD={toc:[]},hD="wrapper";function fD(t){let{components:e,...n}=t;return(0,s.kt)(hD,(0,p.Z)({},dD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}fD.isMDXComponent=!0;const kD={toc:[]},yD="wrapper";function DD(t){let{components:e,...n}=t;return(0,s.kt)(yD,(0,p.Z)({},kD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}DD.isMDXComponent=!0;const MD={toc:[]},XD="wrapper";function _D(t){let{components:e,...n}=t;return(0,s.kt)(XD,(0,p.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}_D.isMDXComponent=!0;const wD={toc:[]},TD="wrapper";function CD(t){let{components:e,...n}=t;return(0,s.kt)(TD,(0,p.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}CD.isMDXComponent=!0;const gD={toc:[]},xD="wrapper";function vD(t){let{components:e,...n}=t;return(0,s.kt)(xD,(0,p.Z)({},gD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}vD.isMDXComponent=!0;const LD={toc:[]},ZD="wrapper";function bD(t){let{components:e,...n}=t;return(0,s.kt)(ZD,(0,p.Z)({},LD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}bD.isMDXComponent=!0;const ND={toc:[]},zD="wrapper";function AD(t){let{components:e,...n}=t;return(0,s.kt)(zD,(0,p.Z)({},ND,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}AD.isMDXComponent=!0;const PD={toc:[]},ID="wrapper";function WD(t){let{components:e,...n}=t;return(0,s.kt)(ID,(0,p.Z)({},PD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}WD.isMDXComponent=!0;const RD={toc:[]},SD="wrapper";function BD(t){let{components:e,...n}=t;return(0,s.kt)(SD,(0,p.Z)({},RD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}BD.isMDXComponent=!0;const GD={toc:[]},ED="wrapper";function OD(t){let{components:e,...n}=t;return(0,s.kt)(ED,(0,p.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}OD.isMDXComponent=!0;const UD={toc:[]},FD="wrapper";function VD(t){let{components:e,...n}=t;return(0,s.kt)(FD,(0,p.Z)({},UD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}VD.isMDXComponent=!0;const qD={toc:[]},jD="wrapper";function HD(t){let{components:e,...n}=t;return(0,s.kt)(jD,(0,p.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}HD.isMDXComponent=!0;const YD={toc:[]},QD="wrapper";function $D(t){let{components:e,...n}=t;return(0,s.kt)(QD,(0,p.Z)({},YD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}$D.isMDXComponent=!0;const KD={toc:[]},JD="wrapper";function tM(t){let{components:e,...n}=t;return(0,s.kt)(JD,(0,p.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}tM.isMDXComponent=!0;const eM={toc:[]},nM="wrapper";function oM(t){let{components:e,...n}=t;return(0,s.kt)(nM,(0,p.Z)({},eM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}oM.isMDXComponent=!0;const pM={toc:[]},rM="wrapper";function sM(t){let{components:e,...n}=t;return(0,s.kt)(rM,(0,p.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}sM.isMDXComponent=!0;const cM={toc:[]},aM="wrapper";function iM(t){let{components:e,...n}=t;return(0,s.kt)(aM,(0,p.Z)({},cM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}iM.isMDXComponent=!0;const lM={toc:[]},uM="wrapper";function mM(t){let{components:e,...n}=t;return(0,s.kt)(uM,(0,p.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}mM.isMDXComponent=!0;const dM={toc:[]},hM="wrapper";function fM(t){let{components:e,...n}=t;return(0,s.kt)(hM,(0,p.Z)({},dM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}fM.isMDXComponent=!0;const kM={toc:[]},yM="wrapper";function DM(t){let{components:e,...n}=t;return(0,s.kt)(yM,(0,p.Z)({},kM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}DM.isMDXComponent=!0;const MM={toc:[]},XM="wrapper";function _M(t){let{components:e,...n}=t;return(0,s.kt)(XM,(0,p.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}_M.isMDXComponent=!0;const wM={toc:[]},TM="wrapper";function CM(t){let{components:e,...n}=t;return(0,s.kt)(TM,(0,p.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}CM.isMDXComponent=!0;const gM={toc:[]},xM="wrapper";function vM(t){let{components:e,...n}=t;return(0,s.kt)(xM,(0,p.Z)({},gM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}vM.isMDXComponent=!0;const LM={toc:[]},ZM="wrapper";function bM(t){let{components:e,...n}=t;return(0,s.kt)(ZM,(0,p.Z)({},LM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}bM.isMDXComponent=!0;const NM={toc:[]},zM="wrapper";function AM(t){let{components:e,...n}=t;return(0,s.kt)(zM,(0,p.Z)({},NM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}AM.isMDXComponent=!0;const PM={toc:[]},IM="wrapper";function WM(t){let{components:e,...n}=t;return(0,s.kt)(IM,(0,p.Z)({},PM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}WM.isMDXComponent=!0;const RM={toc:[]},SM="wrapper";function BM(t){let{components:e,...n}=t;return(0,s.kt)(SM,(0,p.Z)({},RM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}BM.isMDXComponent=!0;const GM={toc:[]},EM="wrapper";function OM(t){let{components:e,...n}=t;return(0,s.kt)(EM,(0,p.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}OM.isMDXComponent=!0;const UM={toc:[]},FM="wrapper";function VM(t){let{components:e,...n}=t;return(0,s.kt)(FM,(0,p.Z)({},UM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}VM.isMDXComponent=!0;const qM={toc:[]},jM="wrapper";function HM(t){let{components:e,...n}=t;return(0,s.kt)(jM,(0,p.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}HM.isMDXComponent=!0;const YM={toc:[]},QM="wrapper";function $M(t){let{components:e,...n}=t;return(0,s.kt)(QM,(0,p.Z)({},YM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}$M.isMDXComponent=!0;const KM={toc:[]},JM="wrapper";function tX(t){let{components:e,...n}=t;return(0,s.kt)(JM,(0,p.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}tX.isMDXComponent=!0;const eX={toc:[]},nX="wrapper";function oX(t){let{components:e,...n}=t;return(0,s.kt)(nX,(0,p.Z)({},eX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}oX.isMDXComponent=!0;const pX={toc:[]},rX="wrapper";function sX(t){let{components:e,...n}=t;return(0,s.kt)(rX,(0,p.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}sX.isMDXComponent=!0;const cX={toc:[]},aX="wrapper";function iX(t){let{components:e,...n}=t;return(0,s.kt)(aX,(0,p.Z)({},cX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}iX.isMDXComponent=!0;const lX={toc:[]},uX="wrapper";function mX(t){let{components:e,...n}=t;return(0,s.kt)(uX,(0,p.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}mX.isMDXComponent=!0;const dX={toc:[]},hX="wrapper";function fX(t){let{components:e,...n}=t;return(0,s.kt)(hX,(0,p.Z)({},dX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}fX.isMDXComponent=!0;const kX={toc:[]},yX="wrapper";function DX(t){let{components:e,...n}=t;return(0,s.kt)(yX,(0,p.Z)({},kX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}DX.isMDXComponent=!0;const MX={toc:[]},XX="wrapper";function _X(t){let{components:e,...n}=t;return(0,s.kt)(XX,(0,p.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}_X.isMDXComponent=!0;const wX={toc:[]},TX="wrapper";function CX(t){let{components:e,...n}=t;return(0,s.kt)(TX,(0,p.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}CX.isMDXComponent=!0;const gX={toc:[]},xX="wrapper";function vX(t){let{components:e,...n}=t;return(0,s.kt)(xX,(0,p.Z)({},gX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}vX.isMDXComponent=!0;const LX={toc:[]},ZX="wrapper";function bX(t){let{components:e,...n}=t;return(0,s.kt)(ZX,(0,p.Z)({},LX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}bX.isMDXComponent=!0;const NX={toc:[]},zX="wrapper";function AX(t){let{components:e,...n}=t;return(0,s.kt)(zX,(0,p.Z)({},NX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}AX.isMDXComponent=!0;const PX={toc:[]},IX="wrapper";function WX(t){let{components:e,...n}=t;return(0,s.kt)(IX,(0,p.Z)({},PX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}WX.isMDXComponent=!0;const RX={toc:[]},SX="wrapper";function BX(t){let{components:e,...n}=t;return(0,s.kt)(SX,(0,p.Z)({},RX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}BX.isMDXComponent=!0;const GX={toc:[]},EX="wrapper";function OX(t){let{components:e,...n}=t;return(0,s.kt)(EX,(0,p.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}OX.isMDXComponent=!0;const UX={toc:[]},FX="wrapper";function VX(t){let{components:e,...n}=t;return(0,s.kt)(FX,(0,p.Z)({},UX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}VX.isMDXComponent=!0;const qX={toc:[]},jX="wrapper";function HX(t){let{components:e,...n}=t;return(0,s.kt)(jX,(0,p.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}HX.isMDXComponent=!0;const YX={toc:[]},QX="wrapper";function $X(t){let{components:e,...n}=t;return(0,s.kt)(QX,(0,p.Z)({},YX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}$X.isMDXComponent=!0;const KX={toc:[]},JX="wrapper";function t_(t){let{components:e,...n}=t;return(0,s.kt)(JX,(0,p.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}t_.isMDXComponent=!0;const e_={toc:[]},n_="wrapper";function o_(t){let{components:e,...n}=t;return(0,s.kt)(n_,(0,p.Z)({},e_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}o_.isMDXComponent=!0;const p_={toc:[]},r_="wrapper";function s_(t){let{components:e,...n}=t;return(0,s.kt)(r_,(0,p.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}s_.isMDXComponent=!0;const c_={toc:[]},a_="wrapper";function i_(t){let{components:e,...n}=t;return(0,s.kt)(a_,(0,p.Z)({},c_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}i_.isMDXComponent=!0;const l_={toc:[]},u_="wrapper";function m_(t){let{components:e,...n}=t;return(0,s.kt)(u_,(0,p.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}m_.isMDXComponent=!0;const d_={toc:[]},h_="wrapper";function f_(t){let{components:e,...n}=t;return(0,s.kt)(h_,(0,p.Z)({},d_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}f_.isMDXComponent=!0;const k_={toc:[]},y_="wrapper";function D_(t){let{components:e,...n}=t;return(0,s.kt)(y_,(0,p.Z)({},k_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}D_.isMDXComponent=!0;const M_={toc:[]},X_="wrapper";function __(t){let{components:e,...n}=t;return(0,s.kt)(X_,(0,p.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}__.isMDXComponent=!0;const w_={toc:[]},T_="wrapper";function C_(t){let{components:e,...n}=t;return(0,s.kt)(T_,(0,p.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}C_.isMDXComponent=!0;const g_={toc:[]},x_="wrapper";function v_(t){let{components:e,...n}=t;return(0,s.kt)(x_,(0,p.Z)({},g_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}v_.isMDXComponent=!0;const L_={toc:[]},Z_="wrapper";function b_(t){let{components:e,...n}=t;return(0,s.kt)(Z_,(0,p.Z)({},L_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}b_.isMDXComponent=!0;const N_={toc:[]},z_="wrapper";function A_(t){let{components:e,...n}=t;return(0,s.kt)(z_,(0,p.Z)({},N_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}A_.isMDXComponent=!0;const P_={toc:[]},I_="wrapper";function W_(t){let{components:e,...n}=t;return(0,s.kt)(I_,(0,p.Z)({},P_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}W_.isMDXComponent=!0;const R_={toc:[]},S_="wrapper";function B_(t){let{components:e,...n}=t;return(0,s.kt)(S_,(0,p.Z)({},R_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}B_.isMDXComponent=!0;const G_={toc:[]},E_="wrapper";function O_(t){let{components:e,...n}=t;return(0,s.kt)(E_,(0,p.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}O_.isMDXComponent=!0;const U_={toc:[]},F_="wrapper";function V_(t){let{components:e,...n}=t;return(0,s.kt)(F_,(0,p.Z)({},U_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}V_.isMDXComponent=!0;const q_={toc:[]},j_="wrapper";function H_(t){let{components:e,...n}=t;return(0,s.kt)(j_,(0,p.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}H_.isMDXComponent=!0;const Y_={toc:[]},Q_="wrapper";function $_(t){let{components:e,...n}=t;return(0,s.kt)(Q_,(0,p.Z)({},Y_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}$_.isMDXComponent=!0;const K_={toc:[]},J_="wrapper";function tw(t){let{components:e,...n}=t;return(0,s.kt)(J_,(0,p.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}tw.isMDXComponent=!0;const ew={toc:[]},nw="wrapper";function ow(t){let{components:e,...n}=t;return(0,s.kt)(nw,(0,p.Z)({},ew,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}ow.isMDXComponent=!0;const pw={toc:[]},rw="wrapper";function sw(t){let{components:e,...n}=t;return(0,s.kt)(rw,(0,p.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}sw.isMDXComponent=!0;const cw={toc:[]},aw="wrapper";function iw(t){let{components:e,...n}=t;return(0,s.kt)(aw,(0,p.Z)({},cw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}iw.isMDXComponent=!0;const lw={toc:[]},uw="wrapper";function mw(t){let{components:e,...n}=t;return(0,s.kt)(uw,(0,p.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}mw.isMDXComponent=!0;const dw={toc:[]},hw="wrapper";function fw(t){let{components:e,...n}=t;return(0,s.kt)(hw,(0,p.Z)({},dw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}fw.isMDXComponent=!0;const kw={toc:[]},yw="wrapper";function Dw(t){let{components:e,...n}=t;return(0,s.kt)(yw,(0,p.Z)({},kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Dw.isMDXComponent=!0;const Mw={toc:[]},Xw="wrapper";function _w(t){let{components:e,...n}=t;return(0,s.kt)(Xw,(0,p.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}_w.isMDXComponent=!0;const ww={toc:[]},Tw="wrapper";function Cw(t){let{components:e,...n}=t;return(0,s.kt)(Tw,(0,p.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Cw.isMDXComponent=!0;const gw={toc:[]},xw="wrapper";function vw(t){let{components:e,...n}=t;return(0,s.kt)(xw,(0,p.Z)({},gw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}vw.isMDXComponent=!0;const Lw={toc:[]},Zw="wrapper";function bw(t){let{components:e,...n}=t;return(0,s.kt)(Zw,(0,p.Z)({},Lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}bw.isMDXComponent=!0;const Nw={toc:[]},zw="wrapper";function Aw(t){let{components:e,...n}=t;return(0,s.kt)(zw,(0,p.Z)({},Nw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}Aw.isMDXComponent=!0;const Pw={toc:[]},Iw="wrapper";function Ww(t){let{components:e,...n}=t;return(0,s.kt)(Iw,(0,p.Z)({},Pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}Ww.isMDXComponent=!0;const Rw={toc:[]},Sw="wrapper";function Bw(t){let{components:e,...n}=t;return(0,s.kt)(Sw,(0,p.Z)({},Rw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}Bw.isMDXComponent=!0;const Gw={toc:[]},Ew="wrapper";function Ow(t){let{components:e,...n}=t;return(0,s.kt)(Ew,(0,p.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Ow.isMDXComponent=!0;const Uw={toc:[]},Fw="wrapper";function Vw(t){let{components:e,...n}=t;return(0,s.kt)(Fw,(0,p.Z)({},Uw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}Vw.isMDXComponent=!0;const qw={toc:[]},jw="wrapper";function Hw(t){let{components:e,...n}=t;return(0,s.kt)(jw,(0,p.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}Hw.isMDXComponent=!0;const Yw={toc:[]},Qw="wrapper";function $w(t){let{components:e,...n}=t;return(0,s.kt)(Qw,(0,p.Z)({},Yw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}$w.isMDXComponent=!0;const Kw={toc:[]},Jw="wrapper";function tT(t){let{components:e,...n}=t;return(0,s.kt)(Jw,(0,p.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}tT.isMDXComponent=!0;const eT={toc:[]},nT="wrapper";function oT(t){let{components:e,...n}=t;return(0,s.kt)(nT,(0,p.Z)({},eT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}oT.isMDXComponent=!0;const pT={toc:[]},rT="wrapper";function sT(t){let{components:e,...n}=t;return(0,s.kt)(rT,(0,p.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}sT.isMDXComponent=!0;const cT={toc:[]},aT="wrapper";function iT(t){let{components:e,...n}=t;return(0,s.kt)(aT,(0,p.Z)({},cT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}iT.isMDXComponent=!0;const lT={toc:[]},uT="wrapper";function mT(t){let{components:e,...n}=t;return(0,s.kt)(uT,(0,p.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}mT.isMDXComponent=!0;const dT={toc:[]},hT="wrapper";function fT(t){let{components:e,...n}=t;return(0,s.kt)(hT,(0,p.Z)({},dT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}fT.isMDXComponent=!0;const kT={toc:[]},yT="wrapper";function DT(t){let{components:e,...n}=t;return(0,s.kt)(yT,(0,p.Z)({},kT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}DT.isMDXComponent=!0;const MT={toc:[]},XT="wrapper";function _T(t){let{components:e,...n}=t;return(0,s.kt)(XT,(0,p.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}_T.isMDXComponent=!0;const wT={toc:[]},TT="wrapper";function CT(t){let{components:e,...n}=t;return(0,s.kt)(TT,(0,p.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}CT.isMDXComponent=!0;const gT={toc:[]},xT="wrapper";function vT(t){let{components:e,...n}=t;return(0,s.kt)(xT,(0,p.Z)({},gT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}vT.isMDXComponent=!0;const LT={toc:[]},ZT="wrapper";function bT(t){let{components:e,...n}=t;return(0,s.kt)(ZT,(0,p.Z)({},LT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}bT.isMDXComponent=!0;const NT={toc:[]},zT="wrapper";function AT(t){let{components:e,...n}=t;return(0,s.kt)(zT,(0,p.Z)({},NT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}AT.isMDXComponent=!0;const PT={toc:[]},IT="wrapper";function WT(t){let{components:e,...n}=t;return(0,s.kt)(IT,(0,p.Z)({},PT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}WT.isMDXComponent=!0;const RT={toc:[]},ST="wrapper";function BT(t){let{components:e,...n}=t;return(0,s.kt)(ST,(0,p.Z)({},RT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}BT.isMDXComponent=!0;const GT={toc:[]},ET="wrapper";function OT(t){let{components:e,...n}=t;return(0,s.kt)(ET,(0,p.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}OT.isMDXComponent=!0;const UT={toc:[]},FT="wrapper";function VT(t){let{components:e,...n}=t;return(0,s.kt)(FT,(0,p.Z)({},UT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}VT.isMDXComponent=!0;const qT={toc:[]},jT="wrapper";function HT(t){let{components:e,...n}=t;return(0,s.kt)(jT,(0,p.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}HT.isMDXComponent=!0;const YT={toc:[]},QT="wrapper";function $T(t){let{components:e,...n}=t;return(0,s.kt)(QT,(0,p.Z)({},YT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}$T.isMDXComponent=!0;const KT={toc:[]},JT="wrapper";function tC(t){let{components:e,...n}=t;return(0,s.kt)(JT,(0,p.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}tC.isMDXComponent=!0;const eC={toc:[]},nC="wrapper";function oC(t){let{components:e,...n}=t;return(0,s.kt)(nC,(0,p.Z)({},eC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}oC.isMDXComponent=!0;const pC={toc:[]},rC="wrapper";function sC(t){let{components:e,...n}=t;return(0,s.kt)(rC,(0,p.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}sC.isMDXComponent=!0;const cC={toc:[]},aC="wrapper";function iC(t){let{components:e,...n}=t;return(0,s.kt)(aC,(0,p.Z)({},cC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}iC.isMDXComponent=!0;const lC={toc:[]},uC="wrapper";function mC(t){let{components:e,...n}=t;return(0,s.kt)(uC,(0,p.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}mC.isMDXComponent=!0;const dC={toc:[]},hC="wrapper";function fC(t){let{components:e,...n}=t;return(0,s.kt)(hC,(0,p.Z)({},dC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}fC.isMDXComponent=!0;const kC={toc:[]},yC="wrapper";function DC(t){let{components:e,...n}=t;return(0,s.kt)(yC,(0,p.Z)({},kC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}DC.isMDXComponent=!0;const MC={toc:[]},XC="wrapper";function _C(t){let{components:e,...n}=t;return(0,s.kt)(XC,(0,p.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}_C.isMDXComponent=!0;const wC={toc:[]},TC="wrapper";function CC(t){let{components:e,...n}=t;return(0,s.kt)(TC,(0,p.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}CC.isMDXComponent=!0;const gC={toc:[]},xC="wrapper";function vC(t){let{components:e,...n}=t;return(0,s.kt)(xC,(0,p.Z)({},gC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}vC.isMDXComponent=!0;const LC={toc:[]},ZC="wrapper";function bC(t){let{components:e,...n}=t;return(0,s.kt)(ZC,(0,p.Z)({},LC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}bC.isMDXComponent=!0;const NC={toc:[]},zC="wrapper";function AC(t){let{components:e,...n}=t;return(0,s.kt)(zC,(0,p.Z)({},NC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}AC.isMDXComponent=!0;const PC={toc:[]},IC="wrapper";function WC(t){let{components:e,...n}=t;return(0,s.kt)(IC,(0,p.Z)({},PC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}WC.isMDXComponent=!0;const RC={toc:[]},SC="wrapper";function BC(t){let{components:e,...n}=t;return(0,s.kt)(SC,(0,p.Z)({},RC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}BC.isMDXComponent=!0;const GC={toc:[]},EC="wrapper";function OC(t){let{components:e,...n}=t;return(0,s.kt)(EC,(0,p.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}OC.isMDXComponent=!0;const UC={toc:[]},FC="wrapper";function VC(t){let{components:e,...n}=t;return(0,s.kt)(FC,(0,p.Z)({},UC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}VC.isMDXComponent=!0;const qC={toc:[]},jC="wrapper";function HC(t){let{components:e,...n}=t;return(0,s.kt)(jC,(0,p.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}HC.isMDXComponent=!0;const YC={toc:[]},QC="wrapper";function $C(t){let{components:e,...n}=t;return(0,s.kt)(QC,(0,p.Z)({},YC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}$C.isMDXComponent=!0;const KC={toc:[]},JC="wrapper";function tg(t){let{components:e,...n}=t;return(0,s.kt)(JC,(0,p.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}tg.isMDXComponent=!0;const eg={toc:[]},ng="wrapper";function og(t){let{components:e,...n}=t;return(0,s.kt)(ng,(0,p.Z)({},eg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}og.isMDXComponent=!0;const pg={toc:[]},rg="wrapper";function sg(t){let{components:e,...n}=t;return(0,s.kt)(rg,(0,p.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sg.isMDXComponent=!0;const cg={toc:[]},ag="wrapper";function ig(t){let{components:e,...n}=t;return(0,s.kt)(ag,(0,p.Z)({},cg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ig.isMDXComponent=!0;const lg={toc:[]},ug="wrapper";function mg(t){let{components:e,...n}=t;return(0,s.kt)(ug,(0,p.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}mg.isMDXComponent=!0;const dg={toc:[]},hg="wrapper";function fg(t){let{components:e,...n}=t;return(0,s.kt)(hg,(0,p.Z)({},dg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an object with nested meta-fields."))}fg.isMDXComponent=!0;const kg={toc:[]},yg="wrapper";function Dg(t){let{components:e,...n}=t;return(0,s.kt)(yg,(0,p.Z)({},kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an object with nested meta-fields."))}Dg.isMDXComponent=!0;const Mg={toc:[]},Xg="wrapper";function _g(t){let{components:e,...n}=t;return(0,s.kt)(Xg,(0,p.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}_g.isMDXComponent=!0;const wg={toc:[]},Tg="wrapper";function Cg(t){let{components:e,...n}=t;return(0,s.kt)(Tg,(0,p.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name should be unique across the entire ecosystem of Motion Canvas.\nIf a plugin with the same name has already been registered, this plugin\nwill be ignored."),(0,s.kt)("p",null,"If you intend to publish your plugin to npm, it is recommended to prefix\nthis name with the name of your npm package."),(0,s.kt)("p",null,"Other identifiers defined by the plugin, such as a tab id, will be\nautomatically prefixed with this name and as such don't have to be unique."))}Cg.isMDXComponent=!0;const gg={toc:[]},xg="wrapper";function vg(t){let{components:e,...n}=t;return(0,s.kt)(xg,(0,p.Z)({},gg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unique name of the plugin."))}vg.isMDXComponent=!0;const Lg={toc:[]},Zg="wrapper";function bg(t){let{components:e,...n}=t;return(0,s.kt)(Zg,(0,p.Z)({},Lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}bg.isMDXComponent=!0;const Ng={toc:[]},zg="wrapper";function Ag(t){let{components:e,...n}=t;return(0,s.kt)(zg,(0,p.Z)({},Ng,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}Ag.isMDXComponent=!0;const Pg={toc:[]},Ig="wrapper";function Wg(t){let{components:e,...n}=t;return(0,s.kt)(Ig,(0,p.Z)({},Pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}Wg.isMDXComponent=!0;const Rg={toc:[]},Sg="wrapper";function Bg(t){let{components:e,...n}=t;return(0,s.kt)(Sg,(0,p.Z)({},Rg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}Bg.isMDXComponent=!0;const Gg={toc:[]},Eg="wrapper";function Og(t){let{components:e,...n}=t;return(0,s.kt)(Eg,(0,p.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}Og.isMDXComponent=!0;const Ug={toc:[]},Fg="wrapper";function Vg(t){let{components:e,...n}=t;return(0,s.kt)(Fg,(0,p.Z)({},Ug,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}Vg.isMDXComponent=!0;const qg={toc:[]},jg="wrapper";function Hg(t){let{components:e,...n}=t;return(0,s.kt)(jg,(0,p.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Hg.isMDXComponent=!0;const Yg={toc:[]},Qg="wrapper";function $g(t){let{components:e,...n}=t;return(0,s.kt)(Qg,(0,p.Z)({},Yg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}$g.isMDXComponent=!0;const Kg={toc:[]},Jg="wrapper";function tx(t){let{components:e,...n}=t;return(0,s.kt)(Jg,(0,p.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}tx.isMDXComponent=!0;const ex={toc:[]},nx="wrapper";function ox(t){let{components:e,...n}=t;return(0,s.kt)(nx,(0,p.Z)({},ex,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}ox.isMDXComponent=!0;const px={toc:[]},rx="wrapper";function sx(t){let{components:e,...n}=t;return(0,s.kt)(rx,(0,p.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}sx.isMDXComponent=!0;const cx={toc:[]},ax="wrapper";function ix(t){let{components:e,...n}=t;return(0,s.kt)(ax,(0,p.Z)({},cx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}ix.isMDXComponent=!0;const lx={toc:[]},ux="wrapper";function mx(t){let{components:e,...n}=t;return(0,s.kt)(ux,(0,p.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}mx.isMDXComponent=!0;const dx={toc:[]},hx="wrapper";function fx(t){let{components:e,...n}=t;return(0,s.kt)(hx,(0,p.Z)({},dx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}fx.isMDXComponent=!0;const kx={toc:[]},yx="wrapper";function Dx(t){let{components:e,...n}=t;return(0,s.kt)(yx,(0,p.Z)({},kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}Dx.isMDXComponent=!0;const Mx={toc:[]},Xx="wrapper";function _x(t){let{components:e,...n}=t;return(0,s.kt)(Xx,(0,p.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}_x.isMDXComponent=!0;const wx={toc:[]},Tx="wrapper";function Cx(t){let{components:e,...n}=t;return(0,s.kt)(Tx,(0,p.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Cx.isMDXComponent=!0;const gx={toc:[]},xx="wrapper";function vx(t){let{components:e,...n}=t;return(0,s.kt)(xx,(0,p.Z)({},gx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}vx.isMDXComponent=!0;const Lx={toc:[]},Zx="wrapper";function bx(t){let{components:e,...n}=t;return(0,s.kt)(Zx,(0,p.Z)({},Lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}bx.isMDXComponent=!0;const Nx={toc:[]},zx="wrapper";function Ax(t){let{components:e,...n}=t;return(0,s.kt)(zx,(0,p.Z)({},Nx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Ax.isMDXComponent=!0;const Px={toc:[]},Ix="wrapper";function Wx(t){let{components:e,...n}=t;return(0,s.kt)(Ix,(0,p.Z)({},Px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}Wx.isMDXComponent=!0;const Rx={toc:[]},Sx="wrapper";function Bx(t){let{components:e,...n}=t;return(0,s.kt)(Sx,(0,p.Z)({},Rx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}Bx.isMDXComponent=!0;const Gx={toc:[]},Ex="wrapper";function Ox(t){let{components:e,...n}=t;return(0,s.kt)(Ex,(0,p.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Ox.isMDXComponent=!0;const Ux={toc:[]},Fx="wrapper";function Vx(t){let{components:e,...n}=t;return(0,s.kt)(Fx,(0,p.Z)({},Ux,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}Vx.isMDXComponent=!0;const qx={toc:[]},jx="wrapper";function Hx(t){let{components:e,...n}=t;return(0,s.kt)(jx,(0,p.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Hx.isMDXComponent=!0;const Yx={toc:[]},Qx="wrapper";function $x(t){let{components:e,...n}=t;return(0,s.kt)(Qx,(0,p.Z)({},Yx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}$x.isMDXComponent=!0;const Kx={toc:[]},Jx="wrapper";function tv(t){let{components:e,...n}=t;return(0,s.kt)(Jx,(0,p.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}tv.isMDXComponent=!0;const ev={toc:[]},nv="wrapper";function ov(t){let{components:e,...n}=t;return(0,s.kt)(nv,(0,p.Z)({},ev,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}ov.isMDXComponent=!0;const pv={toc:[]},rv="wrapper";function sv(t){let{components:e,...n}=t;return(0,s.kt)(rv,(0,p.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}sv.isMDXComponent=!0;const cv={toc:[]},av="wrapper";function iv(t){let{components:e,...n}=t;return(0,s.kt)(av,(0,p.Z)({},cv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}iv.isMDXComponent=!0;const lv={toc:[]},uv="wrapper";function mv(t){let{components:e,...n}=t;return(0,s.kt)(uv,(0,p.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}mv.isMDXComponent=!0;const dv={toc:[]},hv="wrapper";function fv(t){let{components:e,...n}=t;return(0,s.kt)(hv,(0,p.Z)({},dv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}fv.isMDXComponent=!0;const kv={toc:[]},yv="wrapper";function Dv(t){let{components:e,...n}=t;return(0,s.kt)(yv,(0,p.Z)({},kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}Dv.isMDXComponent=!0;const Mv={toc:[]},Xv="wrapper";function _v(t){let{components:e,...n}=t;return(0,s.kt)(Xv,(0,p.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}_v.isMDXComponent=!0;const wv={toc:[]},Tv="wrapper";function Cv(t){let{components:e,...n}=t;return(0,s.kt)(Tv,(0,p.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}))}Cv.isMDXComponent=!0;const gv={toc:[]},xv="wrapper";function vv(t){let{components:e,...n}=t;return(0,s.kt)(xv,(0,p.Z)({},gv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}vv.isMDXComponent=!0;const Lv={toc:[]},Zv="wrapper";function bv(t){let{components:e,...n}=t;return(0,s.kt)(Zv,(0,p.Z)({},Lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}bv.isMDXComponent=!0;const Nv={toc:[]},zv="wrapper";function Av(t){let{components:e,...n}=t;return(0,s.kt)(zv,(0,p.Z)({},Nv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}Av.isMDXComponent=!0;const Pv={toc:[]},Iv="wrapper";function Wv(t){let{components:e,...n}=t;return(0,s.kt)(Iv,(0,p.Z)({},Pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}Wv.isMDXComponent=!0;const Rv={toc:[]},Sv="wrapper";function Bv(t){let{components:e,...n}=t;return(0,s.kt)(Sv,(0,p.Z)({},Rv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}Bv.isMDXComponent=!0;const Gv={toc:[]},Ev="wrapper";function Ov(t){let{components:e,...n}=t;return(0,s.kt)(Ev,(0,p.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Ov.isMDXComponent=!0;const Uv={toc:[]},Fv="wrapper";function Vv(t){let{components:e,...n}=t;return(0,s.kt)(Fv,(0,p.Z)({},Uv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Vv.isMDXComponent=!0;const qv={toc:[]},jv="wrapper";function Hv(t){let{components:e,...n}=t;return(0,s.kt)(jv,(0,p.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Hv.isMDXComponent=!0;const Yv={toc:[]},Qv="wrapper";function $v(t){let{components:e,...n}=t;return(0,s.kt)(Qv,(0,p.Z)({},Yv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}$v.isMDXComponent=!0;const Kv={toc:[]},Jv="wrapper";function tL(t){let{components:e,...n}=t;return(0,s.kt)(Jv,(0,p.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}tL.isMDXComponent=!0;const eL={toc:[]},nL="wrapper";function oL(t){let{components:e,...n}=t;return(0,s.kt)(nL,(0,p.Z)({},eL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}oL.isMDXComponent=!0;const pL={toc:[]},rL="wrapper";function sL(t){let{components:e,...n}=t;return(0,s.kt)(rL,(0,p.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}sL.isMDXComponent=!0;const cL={toc:[]},aL="wrapper";function iL(t){let{components:e,...n}=t;return(0,s.kt)(aL,(0,p.Z)({},cL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}iL.isMDXComponent=!0;const lL={toc:[]},uL="wrapper";function mL(t){let{components:e,...n}=t;return(0,s.kt)(uL,(0,p.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}mL.isMDXComponent=!0;const dL={toc:[]},hL="wrapper";function fL(t){let{components:e,...n}=t;return(0,s.kt)(hL,(0,p.Z)({},dL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}fL.isMDXComponent=!0;const kL={toc:[]},yL="wrapper";function DL(t){let{components:e,...n}=t;return(0,s.kt)(yL,(0,p.Z)({},kL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}DL.isMDXComponent=!0;const ML={toc:[]},XL="wrapper";function _L(t){let{components:e,...n}=t;return(0,s.kt)(XL,(0,p.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}_L.isMDXComponent=!0;const wL={toc:[]},TL="wrapper";function CL(t){let{components:e,...n}=t;return(0,s.kt)(TL,(0,p.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}CL.isMDXComponent=!0;const gL={toc:[]},xL="wrapper";function vL(t){let{components:e,...n}=t;return(0,s.kt)(xL,(0,p.Z)({},gL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}vL.isMDXComponent=!0;const LL={toc:[]},ZL="wrapper";function bL(t){let{components:e,...n}=t;return(0,s.kt)(ZL,(0,p.Z)({},LL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real size of this scene."))}bL.isMDXComponent=!0;const NL={toc:[]},zL="wrapper";function AL(t){let{components:e,...n}=t;return(0,s.kt)(zL,(0,p.Z)({},NL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually returns ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}AL.isMDXComponent=!0;const PL={toc:[]},IL="wrapper";function WL(t){let{components:e,...n}=t;return(0,s.kt)(IL,(0,p.Z)({},PL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."))}WL.isMDXComponent=!0;const RL={toc:[]},SL="wrapper";function BL(t){let{components:e,...n}=t;return(0,s.kt)(SL,(0,p.Z)({},RL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}BL.isMDXComponent=!0;const GL={toc:[]},EL="wrapper";function OL(t){let{components:e,...n}=t;return(0,s.kt)(EL,(0,p.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}OL.isMDXComponent=!0;const UL={toc:[]},FL="wrapper";function VL(t){let{components:e,...n}=t;return(0,s.kt)(FL,(0,p.Z)({},UL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"))}VL.isMDXComponent=!0;const qL={toc:[]},jL="wrapper";function HL(t){let{components:e,...n}=t;return(0,s.kt)(jL,(0,p.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}HL.isMDXComponent=!0;const YL={toc:[]},QL="wrapper";function $L(t){let{components:e,...n}=t;return(0,s.kt)(QL,(0,p.Z)({},YL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}$L.isMDXComponent=!0;const KL={toc:[]},JL="wrapper";function tZ(t){let{components:e,...n}=t;return(0,s.kt)(JL,(0,p.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}tZ.isMDXComponent=!0;const eZ={toc:[]},nZ="wrapper";function oZ(t){let{components:e,...n}=t;return(0,s.kt)(nZ,(0,p.Z)({},eZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}oZ.isMDXComponent=!0;const pZ={toc:[]},rZ="wrapper";function sZ(t){let{components:e,...n}=t;return(0,s.kt)(rZ,(0,p.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}sZ.isMDXComponent=!0;const cZ={toc:[]},aZ="wrapper";function iZ(t){let{components:e,...n}=t;return(0,s.kt)(aZ,(0,p.Z)({},cZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}iZ.isMDXComponent=!0;const lZ={toc:[]},uZ="wrapper";function mZ(t){let{components:e,...n}=t;return(0,s.kt)(uZ,(0,p.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}mZ.isMDXComponent=!0;const dZ={toc:[]},hZ="wrapper";function fZ(t){let{components:e,...n}=t;return(0,s.kt)(hZ,(0,p.Z)({},dZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}fZ.isMDXComponent=!0;const kZ={toc:[]},yZ="wrapper";function DZ(t){let{components:e,...n}=t;return(0,s.kt)(yZ,(0,p.Z)({},kZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}DZ.isMDXComponent=!0;const MZ={toc:[]},XZ="wrapper";function _Z(t){let{components:e,...n}=t;return(0,s.kt)(XZ,(0,p.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}_Z.isMDXComponent=!0;const wZ={toc:[]},TZ="wrapper";function CZ(t){let{components:e,...n}=t;return(0,s.kt)(TZ,(0,p.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}CZ.isMDXComponent=!0;const gZ={toc:[]},xZ="wrapper";function vZ(t){let{components:e,...n}=t;return(0,s.kt)(xZ,(0,p.Z)({},gZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}vZ.isMDXComponent=!0;const LZ={toc:[]},ZZ="wrapper";function bZ(t){let{components:e,...n}=t;return(0,s.kt)(ZZ,(0,p.Z)({},LZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}bZ.isMDXComponent=!0;const NZ={toc:[]},zZ="wrapper";function AZ(t){let{components:e,...n}=t;return(0,s.kt)(zZ,(0,p.Z)({},NZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}AZ.isMDXComponent=!0;const PZ={toc:[]},IZ="wrapper";function WZ(t){let{components:e,...n}=t;return(0,s.kt)(IZ,(0,p.Z)({},PZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}WZ.isMDXComponent=!0;const RZ={toc:[]},SZ="wrapper";function BZ(t){let{components:e,...n}=t;return(0,s.kt)(SZ,(0,p.Z)({},RZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}BZ.isMDXComponent=!0;const GZ={toc:[]},EZ="wrapper";function OZ(t){let{components:e,...n}=t;return(0,s.kt)(EZ,(0,p.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}OZ.isMDXComponent=!0;const UZ={toc:[]},FZ="wrapper";function VZ(t){let{components:e,...n}=t;return(0,s.kt)(FZ,(0,p.Z)({},UZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}VZ.isMDXComponent=!0;const qZ={toc:[]},jZ="wrapper";function HZ(t){let{components:e,...n}=t;return(0,s.kt)(jZ,(0,p.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}HZ.isMDXComponent=!0;const YZ={toc:[]},QZ="wrapper";function $Z(t){let{components:e,...n}=t;return(0,s.kt)(QZ,(0,p.Z)({},YZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}$Z.isMDXComponent=!0;const KZ={toc:[]},JZ="wrapper";function tb(t){let{components:e,...n}=t;return(0,s.kt)(JZ,(0,p.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}tb.isMDXComponent=!0;const eb={toc:[]},nb="wrapper";function ob(t){let{components:e,...n}=t;return(0,s.kt)(nb,(0,p.Z)({},eb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}ob.isMDXComponent=!0;const pb={toc:[]},rb="wrapper";function sb(t){let{components:e,...n}=t;return(0,s.kt)(rb,(0,p.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}sb.isMDXComponent=!0;const cb={toc:[]},ab="wrapper";function ib(t){let{components:e,...n}=t;return(0,s.kt)(ab,(0,p.Z)({},cb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}ib.isMDXComponent=!0;const lb={toc:[]},ub="wrapper";function mb(t){let{components:e,...n}=t;return(0,s.kt)(ub,(0,p.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}mb.isMDXComponent=!0;const db={toc:[]},hb="wrapper";function fb(t){let{components:e,...n}=t;return(0,s.kt)(hb,(0,p.Z)({},db,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}fb.isMDXComponent=!0;const kb={toc:[]},yb="wrapper";function Db(t){let{components:e,...n}=t;return(0,s.kt)(yb,(0,p.Z)({},kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Db.isMDXComponent=!0;const Mb={toc:[]},Xb="wrapper";function _b(t){let{components:e,...n}=t;return(0,s.kt)(Xb,(0,p.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}_b.isMDXComponent=!0;const wb={toc:[]},Tb="wrapper";function Cb(t){let{components:e,...n}=t;return(0,s.kt)(Tb,(0,p.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}Cb.isMDXComponent=!0;const gb={toc:[]},xb="wrapper";function vb(t){let{components:e,...n}=t;return(0,s.kt)(xb,(0,p.Z)({},gb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}vb.isMDXComponent=!0;const Lb={toc:[]},Zb="wrapper";function bb(t){let{components:e,...n}=t;return(0,s.kt)(Zb,(0,p.Z)({},Lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}bb.isMDXComponent=!0;const Nb={toc:[]},zb="wrapper";function Ab(t){let{components:e,...n}=t;return(0,s.kt)(zb,(0,p.Z)({},Nb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}Ab.isMDXComponent=!0;const Pb={toc:[]},Ib="wrapper";function Wb(t){let{components:e,...n}=t;return(0,s.kt)(Ib,(0,p.Z)({},Pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}Wb.isMDXComponent=!0;const Rb={toc:[]},Sb="wrapper";function Bb(t){let{components:e,...n}=t;return(0,s.kt)(Sb,(0,p.Z)({},Rb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}Bb.isMDXComponent=!0;const Gb={toc:[]},Eb="wrapper";function Ob(t){let{components:e,...n}=t;return(0,s.kt)(Eb,(0,p.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}Ob.isMDXComponent=!0;const Ub={toc:[]},Fb="wrapper";function Vb(t){let{components:e,...n}=t;return(0,s.kt)(Fb,(0,p.Z)({},Ub,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}Vb.isMDXComponent=!0;const qb={toc:[]},jb="wrapper";function Hb(t){let{components:e,...n}=t;return(0,s.kt)(jb,(0,p.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}Hb.isMDXComponent=!0;const Yb={toc:[]},Qb="wrapper";function $b(t){let{components:e,...n}=t;return(0,s.kt)(Qb,(0,p.Z)({},Yb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}$b.isMDXComponent=!0;const Kb={toc:[]},Jb="wrapper";function tN(t){let{components:e,...n}=t;return(0,s.kt)(Jb,(0,p.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}tN.isMDXComponent=!0;const eN={toc:[]},nN="wrapper";function oN(t){let{components:e,...n}=t;return(0,s.kt)(nN,(0,p.Z)({},eN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}oN.isMDXComponent=!0;const pN={toc:[]},rN="wrapper";function sN(t){let{components:e,...n}=t;return(0,s.kt)(rN,(0,p.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}sN.isMDXComponent=!0;const cN={toc:[]},aN="wrapper";function iN(t){let{components:e,...n}=t;return(0,s.kt)(aN,(0,p.Z)({},cN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}iN.isMDXComponent=!0;const lN={toc:[]},uN="wrapper";function mN(t){let{components:e,...n}=t;return(0,s.kt)(uN,(0,p.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}mN.isMDXComponent=!0;const dN={toc:[]},hN="wrapper";function fN(t){let{components:e,...n}=t;return(0,s.kt)(hN,(0,p.Z)({},dN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}fN.isMDXComponent=!0;const kN={toc:[]},yN="wrapper";function DN(t){let{components:e,...n}=t;return(0,s.kt)(yN,(0,p.Z)({},kN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}DN.isMDXComponent=!0;const MN={toc:[]},XN="wrapper";function _N(t){let{components:e,...n}=t;return(0,s.kt)(XN,(0,p.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}_N.isMDXComponent=!0;const wN={toc:[]},TN="wrapper";function CN(t){let{components:e,...n}=t;return(0,s.kt)(TN,(0,p.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}CN.isMDXComponent=!0;const gN={toc:[]},xN="wrapper";function vN(t){let{components:e,...n}=t;return(0,s.kt)(xN,(0,p.Z)({},gN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}vN.isMDXComponent=!0;const LN={toc:[]},ZN="wrapper";function bN(t){let{components:e,...n}=t;return(0,s.kt)(ZN,(0,p.Z)({},LN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}bN.isMDXComponent=!0;const NN={toc:[]},zN="wrapper";function AN(t){let{components:e,...n}=t;return(0,s.kt)(zN,(0,p.Z)({},NN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}AN.isMDXComponent=!0;const PN={toc:[]},IN="wrapper";function WN(t){let{components:e,...n}=t;return(0,s.kt)(IN,(0,p.Z)({},PN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}WN.isMDXComponent=!0;const RN={toc:[]},SN="wrapper";function BN(t){let{components:e,...n}=t;return(0,s.kt)(SN,(0,p.Z)({},RN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}BN.isMDXComponent=!0;const GN={toc:[]},EN="wrapper";function ON(t){let{components:e,...n}=t;return(0,s.kt)(EN,(0,p.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}ON.isMDXComponent=!0;const UN={toc:[]},FN="wrapper";function VN(t){let{components:e,...n}=t;return(0,s.kt)(FN,(0,p.Z)({},UN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}VN.isMDXComponent=!0;const qN={toc:[]},jN="wrapper";function HN(t){let{components:e,...n}=t;return(0,s.kt)(jN,(0,p.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}HN.isMDXComponent=!0;const YN={toc:[]},QN="wrapper";function $N(t){let{components:e,...n}=t;return(0,s.kt)(QN,(0,p.Z)({},YN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}$N.isMDXComponent=!0;const KN={toc:[]},JN="wrapper";function tz(t){let{components:e,...n}=t;return(0,s.kt)(JN,(0,p.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}tz.isMDXComponent=!0;const ez={toc:[]},nz="wrapper";function oz(t){let{components:e,...n}=t;return(0,s.kt)(nz,(0,p.Z)({},ez,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}oz.isMDXComponent=!0;const pz={toc:[]},rz="wrapper";function sz(t){let{components:e,...n}=t;return(0,s.kt)(rz,(0,p.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}sz.isMDXComponent=!0;const cz={toc:[]},az="wrapper";function iz(t){let{components:e,...n}=t;return(0,s.kt)(az,(0,p.Z)({},cz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}iz.isMDXComponent=!0;const lz={toc:[]},uz="wrapper";function mz(t){let{components:e,...n}=t;return(0,s.kt)(uz,(0,p.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}mz.isMDXComponent=!0;const dz={toc:[]},hz="wrapper";function fz(t){let{components:e,...n}=t;return(0,s.kt)(hz,(0,p.Z)({},dz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}fz.isMDXComponent=!0;const kz={toc:[]},yz="wrapper";function Dz(t){let{components:e,...n}=t;return(0,s.kt)(yz,(0,p.Z)({},kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}Dz.isMDXComponent=!0;const Mz={toc:[]},Xz="wrapper";function _z(t){let{components:e,...n}=t;return(0,s.kt)(Xz,(0,p.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}_z.isMDXComponent=!0;const wz={toc:[]},Tz="wrapper";function Cz(t){let{components:e,...n}=t;return(0,s.kt)(Tz,(0,p.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}Cz.isMDXComponent=!0;const gz={toc:[]},xz="wrapper";function vz(t){let{components:e,...n}=t;return(0,s.kt)(xz,(0,p.Z)({},gz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}vz.isMDXComponent=!0;const Lz={toc:[]},Zz="wrapper";function bz(t){let{components:e,...n}=t;return(0,s.kt)(Zz,(0,p.Z)({},Lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}bz.isMDXComponent=!0;const Nz={toc:[]},zz="wrapper";function Az(t){let{components:e,...n}=t;return(0,s.kt)(zz,(0,p.Z)({},Nz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}Az.isMDXComponent=!0;const Pz={toc:[]},Iz="wrapper";function Wz(t){let{components:e,...n}=t;return(0,s.kt)(Iz,(0,p.Z)({},Pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}Wz.isMDXComponent=!0;const Rz={toc:[]},Sz="wrapper";function Bz(t){let{components:e,...n}=t;return(0,s.kt)(Sz,(0,p.Z)({},Rz,n,{components:e,mdxType:"MDXLayout"}))}Bz.isMDXComponent=!0;const Gz={toc:[]},Ez="wrapper";function Oz(t){let{components:e,...n}=t;return(0,s.kt)(Ez,(0,p.Z)({},Gz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Oz.isMDXComponent=!0;const Uz={toc:[]},Fz="wrapper";function Vz(t){let{components:e,...n}=t;return(0,s.kt)(Fz,(0,p.Z)({},Uz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Vz.isMDXComponent=!0;const qz={toc:[]},jz="wrapper";function Hz(t){let{components:e,...n}=t;return(0,s.kt)(jz,(0,p.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether experimental features are enabled."))}Hz.isMDXComponent=!0;const Yz={toc:[]},Qz="wrapper";function $z(t){let{components:e,...n}=t;return(0,s.kt)(Qz,(0,p.Z)({},Yz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}$z.isMDXComponent=!0;const Kz={toc:[]},Jz="wrapper";function tA(t){let{components:e,...n}=t;return(0,s.kt)(Jz,(0,p.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}tA.isMDXComponent=!0;const eA={toc:[]},nA="wrapper";function oA(t){let{components:e,...n}=t;return(0,s.kt)(nA,(0,p.Z)({},eA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}oA.isMDXComponent=!0;const pA={toc:[]},rA="wrapper";function sA(t){let{components:e,...n}=t;return(0,s.kt)(rA,(0,p.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}sA.isMDXComponent=!0;const cA={toc:[]},aA="wrapper";function iA(t){let{components:e,...n}=t;return(0,s.kt)(aA,(0,p.Z)({},cA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}iA.isMDXComponent=!0;const lA={toc:[]},uA="wrapper";function mA(t){let{components:e,...n}=t;return(0,s.kt)(uA,(0,p.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}mA.isMDXComponent=!0;const dA={toc:[]},hA="wrapper";function fA(t){let{components:e,...n}=t;return(0,s.kt)(hA,(0,p.Z)({},dA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}fA.isMDXComponent=!0;const kA={toc:[]},yA="wrapper";function DA(t){let{components:e,...n}=t;return(0,s.kt)(yA,(0,p.Z)({},kA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}DA.isMDXComponent=!0;const MA={toc:[]},XA="wrapper";function _A(t){let{components:e,...n}=t;return(0,s.kt)(XA,(0,p.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}_A.isMDXComponent=!0;const wA={toc:[]},TA="wrapper";function CA(t){let{components:e,...n}=t;return(0,s.kt)(TA,(0,p.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}CA.isMDXComponent=!0;const gA={toc:[]},xA="wrapper";function vA(t){let{components:e,...n}=t;return(0,s.kt)(xA,(0,p.Z)({},gA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}vA.isMDXComponent=!0;const LA={toc:[]},ZA="wrapper";function bA(t){let{components:e,...n}=t;return(0,s.kt)(ZA,(0,p.Z)({},LA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}bA.isMDXComponent=!0;const NA={toc:[]},zA="wrapper";function AA(t){let{components:e,...n}=t;return(0,s.kt)(zA,(0,p.Z)({},NA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}AA.isMDXComponent=!0;const PA={toc:[]},IA="wrapper";function WA(t){let{components:e,...n}=t;return(0,s.kt)(IA,(0,p.Z)({},PA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}WA.isMDXComponent=!0;const RA={toc:[]},SA="wrapper";function BA(t){let{components:e,...n}=t;return(0,s.kt)(SA,(0,p.Z)({},RA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real size of this scene."))}BA.isMDXComponent=!0;const GA={toc:[]},EA="wrapper";function OA(t){let{components:e,...n}=t;return(0,s.kt)(EA,(0,p.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually returns ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}OA.isMDXComponent=!0;const UA={toc:[]},FA="wrapper";function VA(t){let{components:e,...n}=t;return(0,s.kt)(FA,(0,p.Z)({},UA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."))}VA.isMDXComponent=!0;const qA={toc:[]},jA="wrapper";function HA(t){let{components:e,...n}=t;return(0,s.kt)(jA,(0,p.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}HA.isMDXComponent=!0;const YA={toc:[]},QA="wrapper";function $A(t){let{components:e,...n}=t;return(0,s.kt)(QA,(0,p.Z)({},YA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}$A.isMDXComponent=!0;const KA={toc:[]},JA="wrapper";function tP(t){let{components:e,...n}=t;return(0,s.kt)(JA,(0,p.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"))}tP.isMDXComponent=!0;const eP={toc:[]},nP="wrapper";function oP(t){let{components:e,...n}=t;return(0,s.kt)(nP,(0,p.Z)({},eP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}oP.isMDXComponent=!0;const pP={toc:[]},rP="wrapper";function sP(t){let{components:e,...n}=t;return(0,s.kt)(rP,(0,p.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}sP.isMDXComponent=!0;const cP={toc:[]},aP="wrapper";function iP(t){let{components:e,...n}=t;return(0,s.kt)(aP,(0,p.Z)({},cP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}iP.isMDXComponent=!0;const lP={toc:[]},uP="wrapper";function mP(t){let{components:e,...n}=t;return(0,s.kt)(uP,(0,p.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}mP.isMDXComponent=!0;const dP={toc:[]},hP="wrapper";function fP(t){let{components:e,...n}=t;return(0,s.kt)(hP,(0,p.Z)({},dP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}fP.isMDXComponent=!0;const kP={toc:[]},yP="wrapper";function DP(t){let{components:e,...n}=t;return(0,s.kt)(yP,(0,p.Z)({},kP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}DP.isMDXComponent=!0;const MP={toc:[]},XP="wrapper";function _P(t){let{components:e,...n}=t;return(0,s.kt)(XP,(0,p.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}_P.isMDXComponent=!0;const wP={toc:[]},TP="wrapper";function CP(t){let{components:e,...n}=t;return(0,s.kt)(TP,(0,p.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}CP.isMDXComponent=!0;const gP={toc:[]},xP="wrapper";function vP(t){let{components:e,...n}=t;return(0,s.kt)(xP,(0,p.Z)({},gP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}vP.isMDXComponent=!0;const LP={toc:[]},ZP="wrapper";function bP(t){let{components:e,...n}=t;return(0,s.kt)(ZP,(0,p.Z)({},LP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}bP.isMDXComponent=!0;const NP={toc:[]},zP="wrapper";function AP(t){let{components:e,...n}=t;return(0,s.kt)(zP,(0,p.Z)({},NP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}AP.isMDXComponent=!0;const PP={toc:[]},IP="wrapper";function WP(t){let{components:e,...n}=t;return(0,s.kt)(IP,(0,p.Z)({},PP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}WP.isMDXComponent=!0;const RP={toc:[]},SP="wrapper";function BP(t){let{components:e,...n}=t;return(0,s.kt)(SP,(0,p.Z)({},RP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}BP.isMDXComponent=!0;const GP={toc:[]},EP="wrapper";function OP(t){let{components:e,...n}=t;return(0,s.kt)(EP,(0,p.Z)({},GP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}OP.isMDXComponent=!0;const UP={toc:[]},FP="wrapper";function VP(t){let{components:e,...n}=t;return(0,s.kt)(FP,(0,p.Z)({},UP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}VP.isMDXComponent=!0;const qP={toc:[]},jP="wrapper";function HP(t){let{components:e,...n}=t;return(0,s.kt)(jP,(0,p.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}HP.isMDXComponent=!0;const YP={toc:[]},QP="wrapper";function $P(t){let{components:e,...n}=t;return(0,s.kt)(QP,(0,p.Z)({},YP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}$P.isMDXComponent=!0;const KP={toc:[]},JP="wrapper";function tI(t){let{components:e,...n}=t;return(0,s.kt)(JP,(0,p.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}tI.isMDXComponent=!0;const eI={toc:[]},nI="wrapper";function oI(t){let{components:e,...n}=t;return(0,s.kt)(nI,(0,p.Z)({},eI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}oI.isMDXComponent=!0;const pI={toc:[]},rI="wrapper";function sI(t){let{components:e,...n}=t;return(0,s.kt)(rI,(0,p.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}sI.isMDXComponent=!0;const cI={toc:[]},aI="wrapper";function iI(t){let{components:e,...n}=t;return(0,s.kt)(aI,(0,p.Z)({},cI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}iI.isMDXComponent=!0;const lI={toc:[]},uI="wrapper";function mI(t){let{components:e,...n}=t;return(0,s.kt)(uI,(0,p.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}mI.isMDXComponent=!0;const dI={toc:[]},hI="wrapper";function fI(t){let{components:e,...n}=t;return(0,s.kt)(hI,(0,p.Z)({},dI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}fI.isMDXComponent=!0;const kI={toc:[]},yI="wrapper";function DI(t){let{components:e,...n}=t;return(0,s.kt)(yI,(0,p.Z)({},kI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}DI.isMDXComponent=!0;const MI={toc:[]},XI="wrapper";function _I(t){let{components:e,...n}=t;return(0,s.kt)(XI,(0,p.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}_I.isMDXComponent=!0;const wI={toc:[]},TI="wrapper";function CI(t){let{components:e,...n}=t;return(0,s.kt)(TI,(0,p.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}CI.isMDXComponent=!0;const gI={toc:[]},xI="wrapper";function vI(t){let{components:e,...n}=t;return(0,s.kt)(xI,(0,p.Z)({},gI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}vI.isMDXComponent=!0;const LI={toc:[]},ZI="wrapper";function bI(t){let{components:e,...n}=t;return(0,s.kt)(ZI,(0,p.Z)({},LI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}bI.isMDXComponent=!0;const NI={toc:[]},zI="wrapper";function AI(t){let{components:e,...n}=t;return(0,s.kt)(zI,(0,p.Z)({},NI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}AI.isMDXComponent=!0;const PI={toc:[]},II="wrapper";function WI(t){let{components:e,...n}=t;return(0,s.kt)(II,(0,p.Z)({},PI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}WI.isMDXComponent=!0;const RI={toc:[]},SI="wrapper";function BI(t){let{components:e,...n}=t;return(0,s.kt)(SI,(0,p.Z)({},RI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}BI.isMDXComponent=!0;const GI={toc:[]},EI="wrapper";function OI(t){let{components:e,...n}=t;return(0,s.kt)(EI,(0,p.Z)({},GI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}OI.isMDXComponent=!0;const UI={toc:[]},FI="wrapper";function VI(t){let{components:e,...n}=t;return(0,s.kt)(FI,(0,p.Z)({},UI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}VI.isMDXComponent=!0;const qI={toc:[]},jI="wrapper";function HI(t){let{components:e,...n}=t;return(0,s.kt)(jI,(0,p.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}HI.isMDXComponent=!0;const YI={toc:[]},QI="wrapper";function $I(t){let{components:e,...n}=t;return(0,s.kt)(QI,(0,p.Z)({},YI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}$I.isMDXComponent=!0;const KI={toc:[]},JI="wrapper";function tW(t){let{components:e,...n}=t;return(0,s.kt)(JI,(0,p.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}tW.isMDXComponent=!0;const eW={toc:[]},nW="wrapper";function oW(t){let{components:e,...n}=t;return(0,s.kt)(nW,(0,p.Z)({},eW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}oW.isMDXComponent=!0;const pW={toc:[]},rW="wrapper";function sW(t){let{components:e,...n}=t;return(0,s.kt)(rW,(0,p.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}sW.isMDXComponent=!0;const cW={toc:[]},aW="wrapper";function iW(t){let{components:e,...n}=t;return(0,s.kt)(aW,(0,p.Z)({},cW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}iW.isMDXComponent=!0;const lW={toc:[]},uW="wrapper";function mW(t){let{components:e,...n}=t;return(0,s.kt)(uW,(0,p.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}mW.isMDXComponent=!0;const dW={toc:[]},hW="wrapper";function fW(t){let{components:e,...n}=t;return(0,s.kt)(hW,(0,p.Z)({},dW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}fW.isMDXComponent=!0;const kW={toc:[]},yW="wrapper";function DW(t){let{components:e,...n}=t;return(0,s.kt)(yW,(0,p.Z)({},kW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}DW.isMDXComponent=!0;const MW={toc:[]},XW="wrapper";function _W(t){let{components:e,...n}=t;return(0,s.kt)(XW,(0,p.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}_W.isMDXComponent=!0;const wW={toc:[]},TW="wrapper";function CW(t){let{components:e,...n}=t;return(0,s.kt)(TW,(0,p.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}CW.isMDXComponent=!0;const gW={toc:[]},xW="wrapper";function vW(t){let{components:e,...n}=t;return(0,s.kt)(xW,(0,p.Z)({},gW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}vW.isMDXComponent=!0;const LW={toc:[]},ZW="wrapper";function bW(t){let{components:e,...n}=t;return(0,s.kt)(ZW,(0,p.Z)({},LW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}bW.isMDXComponent=!0;const NW={toc:[]},zW="wrapper";function AW(t){let{components:e,...n}=t;return(0,s.kt)(zW,(0,p.Z)({},NW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}AW.isMDXComponent=!0;const PW={toc:[]},IW="wrapper";function WW(t){let{components:e,...n}=t;return(0,s.kt)(IW,(0,p.Z)({},PW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}WW.isMDXComponent=!0;const RW={toc:[]},SW="wrapper";function BW(t){let{components:e,...n}=t;return(0,s.kt)(SW,(0,p.Z)({},RW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}BW.isMDXComponent=!0;const GW={toc:[]},EW="wrapper";function OW(t){let{components:e,...n}=t;return(0,s.kt)(EW,(0,p.Z)({},GW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}OW.isMDXComponent=!0;const UW={toc:[]},FW="wrapper";function VW(t){let{components:e,...n}=t;return(0,s.kt)(FW,(0,p.Z)({},UW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}VW.isMDXComponent=!0;const qW={toc:[]},jW="wrapper";function HW(t){let{components:e,...n}=t;return(0,s.kt)(jW,(0,p.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}HW.isMDXComponent=!0;const YW={toc:[]},QW="wrapper";function $W(t){let{components:e,...n}=t;return(0,s.kt)(QW,(0,p.Z)({},YW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}$W.isMDXComponent=!0;const KW={toc:[]},JW="wrapper";function tR(t){let{components:e,...n}=t;return(0,s.kt)(JW,(0,p.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}tR.isMDXComponent=!0;const eR={toc:[]},nR="wrapper";function oR(t){let{components:e,...n}=t;return(0,s.kt)(nR,(0,p.Z)({},eR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}oR.isMDXComponent=!0;const pR={toc:[]},rR="wrapper";function sR(t){let{components:e,...n}=t;return(0,s.kt)(rR,(0,p.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}sR.isMDXComponent=!0;const cR={toc:[]},aR="wrapper";function iR(t){let{components:e,...n}=t;return(0,s.kt)(aR,(0,p.Z)({},cR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}iR.isMDXComponent=!0;const lR={toc:[]},uR="wrapper";function mR(t){let{components:e,...n}=t;return(0,s.kt)(uR,(0,p.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}mR.isMDXComponent=!0;const dR={toc:[]},hR="wrapper";function fR(t){let{components:e,...n}=t;return(0,s.kt)(hR,(0,p.Z)({},dR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}fR.isMDXComponent=!0;const kR={toc:[]},yR="wrapper";function DR(t){let{components:e,...n}=t;return(0,s.kt)(yR,(0,p.Z)({},kR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}DR.isMDXComponent=!0;const MR={toc:[]},XR="wrapper";function _R(t){let{components:e,...n}=t;return(0,s.kt)(XR,(0,p.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}_R.isMDXComponent=!0;const wR={toc:[]},TR="wrapper";function CR(t){let{components:e,...n}=t;return(0,s.kt)(TR,(0,p.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}CR.isMDXComponent=!0;const gR={toc:[]},xR="wrapper";function vR(t){let{components:e,...n}=t;return(0,s.kt)(xR,(0,p.Z)({},gR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}vR.isMDXComponent=!0;const LR={toc:[]},ZR="wrapper";function bR(t){let{components:e,...n}=t;return(0,s.kt)(ZR,(0,p.Z)({},LR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}bR.isMDXComponent=!0;const NR={toc:[]},zR="wrapper";function AR(t){let{components:e,...n}=t;return(0,s.kt)(zR,(0,p.Z)({},NR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}AR.isMDXComponent=!0;const PR={toc:[]},IR="wrapper";function WR(t){let{components:e,...n}=t;return(0,s.kt)(IR,(0,p.Z)({},PR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}WR.isMDXComponent=!0;const RR={toc:[]},SR="wrapper";function BR(t){let{components:e,...n}=t;return(0,s.kt)(SR,(0,p.Z)({},RR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}BR.isMDXComponent=!0;const GR={toc:[]},ER="wrapper";function OR(t){let{components:e,...n}=t;return(0,s.kt)(ER,(0,p.Z)({},GR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}OR.isMDXComponent=!0;const UR={toc:[]},FR="wrapper";function VR(t){let{components:e,...n}=t;return(0,s.kt)(FR,(0,p.Z)({},UR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}VR.isMDXComponent=!0;const qR={toc:[]},jR="wrapper";function HR(t){let{components:e,...n}=t;return(0,s.kt)(jR,(0,p.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}HR.isMDXComponent=!0;const YR={toc:[]},QR="wrapper";function $R(t){let{components:e,...n}=t;return(0,s.kt)(QR,(0,p.Z)({},YR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}$R.isMDXComponent=!0;const KR={toc:[]},JR="wrapper";function tS(t){let{components:e,...n}=t;return(0,s.kt)(JR,(0,p.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}tS.isMDXComponent=!0;const eS={toc:[]},nS="wrapper";function oS(t){let{components:e,...n}=t;return(0,s.kt)(nS,(0,p.Z)({},eS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}oS.isMDXComponent=!0;const pS={toc:[]},rS="wrapper";function sS(t){let{components:e,...n}=t;return(0,s.kt)(rS,(0,p.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}sS.isMDXComponent=!0;const cS={toc:[]},aS="wrapper";function iS(t){let{components:e,...n}=t;return(0,s.kt)(aS,(0,p.Z)({},cS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}iS.isMDXComponent=!0;const lS={toc:[]},uS="wrapper";function mS(t){let{components:e,...n}=t;return(0,s.kt)(uS,(0,p.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}mS.isMDXComponent=!0;const dS={toc:[]},hS="wrapper";function fS(t){let{components:e,...n}=t;return(0,s.kt)(hS,(0,p.Z)({},dS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}fS.isMDXComponent=!0;const kS={toc:[]},yS="wrapper";function DS(t){let{components:e,...n}=t;return(0,s.kt)(yS,(0,p.Z)({},kS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}DS.isMDXComponent=!0;const MS={toc:[]},XS="wrapper";function _S(t){let{components:e,...n}=t;return(0,s.kt)(XS,(0,p.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}_S.isMDXComponent=!0;const wS={toc:[]},TS="wrapper";function CS(t){let{components:e,...n}=t;return(0,s.kt)(TS,(0,p.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}CS.isMDXComponent=!0;const gS={toc:[]},xS="wrapper";function vS(t){let{components:e,...n}=t;return(0,s.kt)(xS,(0,p.Z)({},gS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}vS.isMDXComponent=!0;const LS={toc:[]},ZS="wrapper";function bS(t){let{components:e,...n}=t;return(0,s.kt)(ZS,(0,p.Z)({},LS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}bS.isMDXComponent=!0;const NS={toc:[]},zS="wrapper";function AS(t){let{components:e,...n}=t;return(0,s.kt)(zS,(0,p.Z)({},NS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}AS.isMDXComponent=!0;const PS={toc:[]},IS="wrapper";function WS(t){let{components:e,...n}=t;return(0,s.kt)(IS,(0,p.Z)({},PS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}WS.isMDXComponent=!0;const RS={toc:[]},SS="wrapper";function BS(t){let{components:e,...n}=t;return(0,s.kt)(SS,(0,p.Z)({},RS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}BS.isMDXComponent=!0;const GS={toc:[]},ES="wrapper";function OS(t){let{components:e,...n}=t;return(0,s.kt)(ES,(0,p.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}OS.isMDXComponent=!0;const US={toc:[]},FS="wrapper";function VS(t){let{components:e,...n}=t;return(0,s.kt)(FS,(0,p.Z)({},US,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}VS.isMDXComponent=!0;const qS={toc:[]},jS="wrapper";function HS(t){let{components:e,...n}=t;return(0,s.kt)(jS,(0,p.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}HS.isMDXComponent=!0;const YS={toc:[]},QS="wrapper";function $S(t){let{components:e,...n}=t;return(0,s.kt)(QS,(0,p.Z)({},YS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}$S.isMDXComponent=!0;const KS={toc:[]},JS="wrapper";function tB(t){let{components:e,...n}=t;return(0,s.kt)(JS,(0,p.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}tB.isMDXComponent=!0;const eB={toc:[]},nB="wrapper";function oB(t){let{components:e,...n}=t;return(0,s.kt)(nB,(0,p.Z)({},eB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}oB.isMDXComponent=!0;const pB={toc:[]},rB="wrapper";function sB(t){let{components:e,...n}=t;return(0,s.kt)(rB,(0,p.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}sB.isMDXComponent=!0;const cB={toc:[]},aB="wrapper";function iB(t){let{components:e,...n}=t;return(0,s.kt)(aB,(0,p.Z)({},cB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}iB.isMDXComponent=!0;const lB={toc:[]},uB="wrapper";function mB(t){let{components:e,...n}=t;return(0,s.kt)(uB,(0,p.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}mB.isMDXComponent=!0;const dB={toc:[]},hB="wrapper";function fB(t){let{components:e,...n}=t;return(0,s.kt)(hB,(0,p.Z)({},dB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}fB.isMDXComponent=!0;const kB={toc:[]},yB="wrapper";function DB(t){let{components:e,...n}=t;return(0,s.kt)(yB,(0,p.Z)({},kB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}DB.isMDXComponent=!0;const MB={toc:[]},XB="wrapper";function _B(t){let{components:e,...n}=t;return(0,s.kt)(XB,(0,p.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}_B.isMDXComponent=!0;const wB={toc:[]},TB="wrapper";function CB(t){let{components:e,...n}=t;return(0,s.kt)(TB,(0,p.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}CB.isMDXComponent=!0;const gB={toc:[]},xB="wrapper";function vB(t){let{components:e,...n}=t;return(0,s.kt)(xB,(0,p.Z)({},gB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}vB.isMDXComponent=!0;const LB={toc:[]},ZB="wrapper";function bB(t){let{components:e,...n}=t;return(0,s.kt)(ZB,(0,p.Z)({},LB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}bB.isMDXComponent=!0;const NB={toc:[]},zB="wrapper";function AB(t){let{components:e,...n}=t;return(0,s.kt)(zB,(0,p.Z)({},NB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}AB.isMDXComponent=!0;const PB={toc:[]},IB="wrapper";function WB(t){let{components:e,...n}=t;return(0,s.kt)(IB,(0,p.Z)({},PB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using an existing task:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"spawn(rect().opacity(1, 1));\n")),(0,s.kt)("p",null,"Using a generator function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"spawn(function* () {\n  yield* rect().opacity(1, 1);\n  yield* waitFor('click');\n  yield* rect().opacity(0, 1);\n});\n")),(0,s.kt)("p",null,"Await the spawned task:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = spawn(rect().opacity(1, 1));\n// do some other things\nyield* join(task); // await the task\n")))}WB.isMDXComponent=!0;const RB={toc:[]},SB="wrapper";function BB(t){let{components:e,...n}=t;return(0,s.kt)(SB,(0,p.Z)({},RB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task concurrently."))}BB.isMDXComponent=!0;const GB={toc:[]},EB="wrapper";function OB(t){let{components:e,...n}=t;return(0,s.kt)(EB,(0,p.Z)({},GB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Either a generator function or a task to run."))}OB.isMDXComponent=!0;const UB={toc:[]},FB="wrapper";function VB(t){let{components:e,...n}=t;return(0,s.kt)(FB,(0,p.Z)({},UB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}VB.isMDXComponent=!0;const qB={toc:[]},jB="wrapper";function HB(t){let{components:e,...n}=t;return(0,s.kt)(jB,(0,p.Z)({},qB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}HB.isMDXComponent=!0;const YB={toc:[]},QB="wrapper";function $B(t){let{components:e,...n}=t;return(0,s.kt)(QB,(0,p.Z)({},YB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}$B.isMDXComponent=!0;const KB={toc:[]},JB="wrapper";function tG(t){let{components:e,...n}=t;return(0,s.kt)(JB,(0,p.Z)({},KB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}tG.isMDXComponent=!0;const eG={toc:[]},nG="wrapper";function oG(t){let{components:e,...n}=t;return(0,s.kt)(nG,(0,p.Z)({},eG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}oG.isMDXComponent=!0;const pG={toc:[]},rG="wrapper";function sG(t){let{components:e,...n}=t;return(0,s.kt)(rG,(0,p.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}sG.isMDXComponent=!0;const cG={toc:[]},aG="wrapper";function iG(t){let{components:e,...n}=t;return(0,s.kt)(aG,(0,p.Z)({},cG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}iG.isMDXComponent=!0;const lG={toc:[]},uG="wrapper";function mG(t){let{components:e,...n}=t;return(0,s.kt)(uG,(0,p.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}mG.isMDXComponent=!0;const dG={toc:[]},hG="wrapper";function fG(t){let{components:e,...n}=t;return(0,s.kt)(hG,(0,p.Z)({},dG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in the given direction."))}fG.isMDXComponent=!0;const kG={toc:[]},yG="wrapper";function DG(t){let{components:e,...n}=t;return(0,s.kt)(yG,(0,p.Z)({},kG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}DG.isMDXComponent=!0;const MG={toc:[]},XG="wrapper";function _G(t){let{components:e,...n}=t;return(0,s.kt)(XG,(0,p.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}_G.isMDXComponent=!0;const wG={toc:[]},TG="wrapper";function CG(t){let{components:e,...n}=t;return(0,s.kt)(TG,(0,p.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene towards the given origin."))}CG.isMDXComponent=!0;const gG={toc:[]},xG="wrapper";function vG(t){let{components:e,...n}=t;return(0,s.kt)(xG,(0,p.Z)({},gG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin towards which to slide."))}vG.isMDXComponent=!0;const LG={toc:[]},ZG="wrapper";function bG(t){let{components:e,...n}=t;return(0,s.kt)(ZG,(0,p.Z)({},LG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}bG.isMDXComponent=!0;const NG={toc:[]},zG="wrapper";function AG(t){let{components:e,...n}=t;return(0,s.kt)(zG,(0,p.Z)({},NG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}AG.isMDXComponent=!0;const PG={toc:[]},IG="wrapper";function WG(t){let{components:e,...n}=t;return(0,s.kt)(IG,(0,p.Z)({},PG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}WG.isMDXComponent=!0;const RG={toc:[]},SG="wrapper";function BG(t){let{components:e,...n}=t;return(0,s.kt)(SG,(0,p.Z)({},RG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}BG.isMDXComponent=!0;const GG={toc:[]},EG="wrapper";function OG(t){let{components:e,...n}=t;return(0,s.kt)(EG,(0,p.Z)({},GG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the previous scene should be rendered on top."))}OG.isMDXComponent=!0;const UG={toc:[]},FG="wrapper";function VG(t){let{components:e,...n}=t;return(0,s.kt)(FG,(0,p.Z)({},UG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is useful when you want to achieve a transition effect by animating\nobjects in the scenes. It will overlay the scenes on top of each other for\nthe duration of the transition."))}VG.isMDXComponent=!0;const qG={toc:[]},jG="wrapper";function HG(t){let{components:e,...n}=t;return(0,s.kt)(jG,(0,p.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that doesn't do anything."))}HG.isMDXComponent=!0;const YG={toc:[]},QG="wrapper";function $G(t){let{components:e,...n}=t;return(0,s.kt)(QG,(0,p.Z)({},YG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}$G.isMDXComponent=!0;const KG={toc:[]},JG="wrapper";function tE(t){let{components:e,...n}=t;return(0,s.kt)(JG,(0,p.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the previous scene should be rendered on top."))}tE.isMDXComponent=!0;const eE={toc:[]},nE="wrapper";function oE(t){let{components:e,...n}=t;return(0,s.kt)(nE,(0,p.Z)({},eE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}oE.isMDXComponent=!0;const pE={toc:[]},rE="wrapper";function sE(t){let{components:e,...n}=t;return(0,s.kt)(rE,(0,p.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}sE.isMDXComponent=!0;const cE={toc:[]},aE="wrapper";function iE(t){let{components:e,...n}=t;return(0,s.kt)(aE,(0,p.Z)({},cE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}iE.isMDXComponent=!0;const lE={toc:[]},uE="wrapper";function mE(t){let{components:e,...n}=t;return(0,s.kt)(uE,(0,p.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}mE.isMDXComponent=!0;const dE={toc:[]},hE="wrapper";function fE(t){let{components:e,...n}=t;return(0,s.kt)(hE,(0,p.Z)({},dE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}fE.isMDXComponent=!0;const kE={toc:[]},yE="wrapper";function DE(t){let{components:e,...n}=t;return(0,s.kt)(yE,(0,p.Z)({},kE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}DE.isMDXComponent=!0;const ME={toc:[]},XE="wrapper";function _E(t){let{components:e,...n}=t;return(0,s.kt)(XE,(0,p.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}_E.isMDXComponent=!0;const wE={toc:[]},TE="wrapper";function CE(t){let{components:e,...n}=t;return(0,s.kt)(TE,(0,p.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}CE.isMDXComponent=!0;const gE={toc:[]},xE="wrapper";function vE(t){let{components:e,...n}=t;return(0,s.kt)(xE,(0,p.Z)({},gE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}vE.isMDXComponent=!0;const LE={toc:[]},ZE="wrapper";function bE(t){let{components:e,...n}=t;return(0,s.kt)(ZE,(0,p.Z)({},LE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}bE.isMDXComponent=!0;const NE={toc:[]},zE="wrapper";function AE(t){let{components:e,...n}=t;return(0,s.kt)(zE,(0,p.Z)({},NE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}AE.isMDXComponent=!0;const PE={toc:[]},IE="wrapper";function WE(t){let{components:e,...n}=t;return(0,s.kt)(IE,(0,p.Z)({},PE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}WE.isMDXComponent=!0;const RE={toc:[]},SE="wrapper";function BE(t){let{components:e,...n}=t;return(0,s.kt)(SE,(0,p.Z)({},RE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}BE.isMDXComponent=!0;const GE={toc:[]},EE="wrapper";function OE(t){let{components:e,...n}=t;return(0,s.kt)(EE,(0,p.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}OE.isMDXComponent=!0;const UE={toc:[]},FE="wrapper";function VE(t){let{components:e,...n}=t;return(0,s.kt)(FE,(0,p.Z)({},UE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}VE.isMDXComponent=!0;const qE={toc:[]},jE="wrapper";function HE(t){let{components:e,...n}=t;return(0,s.kt)(jE,(0,p.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}HE.isMDXComponent=!0;const YE={toc:[]},QE="wrapper";function $E(t){let{components:e,...n}=t;return(0,s.kt)(QE,(0,p.Z)({},YE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}$E.isMDXComponent=!0;const KE={toc:[]},JE="wrapper";function tO(t){let{components:e,...n}=t;return(0,s.kt)(JE,(0,p.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}tO.isMDXComponent=!0;const eO={toc:[]},nO="wrapper";function oO(t){let{components:e,...n}=t;return(0,s.kt)(nO,(0,p.Z)({},eO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}oO.isMDXComponent=!0;const pO={toc:[]},rO="wrapper";function sO(t){let{components:e,...n}=t;return(0,s.kt)(rO,(0,p.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/BBox#expand"},(0,s.kt)("inlineCode",{parentName:"a"},"expand"))," instead."))}sO.isMDXComponent=!0;const cO={toc:[]},aO="wrapper";function iO(t){let{components:e,...n}=t;return(0,s.kt)(aO,(0,p.Z)({},cO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Expand the bounding box to accommodate the given spacing."))}iO.isMDXComponent=!0;const lO={toc:[]},uO="wrapper";function mO(t){let{components:e,...n}=t;return(0,s.kt)(uO,(0,p.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to expand the bounding box by."))}mO.isMDXComponent=!0;const dO={toc:[]},hO="wrapper";function fO(t){let{components:e,...n}=t;return(0,s.kt)(hO,(0,p.Z)({},dO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Expand the bounding box to accommodate the given spacing."))}fO.isMDXComponent=!0;const kO={toc:[]},yO="wrapper";function DO(t){let{components:e,...n}=t;return(0,s.kt)(yO,(0,p.Z)({},kO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to expand the bounding box by."))}DO.isMDXComponent=!0;const MO={toc:[]},XO="wrapper";function _O(t){let{components:e,...n}=t;return(0,s.kt)(XO,(0,p.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}_O.isMDXComponent=!0;const wO={toc:[]},TO="wrapper";function CO(t){let{components:e,...n}=t;return(0,s.kt)(TO,(0,p.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}CO.isMDXComponent=!0;const gO={toc:[]},xO="wrapper";function vO(t){let{components:e,...n}=t;return(0,s.kt)(xO,(0,p.Z)({},gO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}vO.isMDXComponent=!0;const LO={toc:[]},ZO="wrapper";function bO(t){let{components:e,...n}=t;return(0,s.kt)(ZO,(0,p.Z)({},LO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}bO.isMDXComponent=!0;const NO={toc:[]},zO="wrapper";function AO(t){let{components:e,...n}=t;return(0,s.kt)(zO,(0,p.Z)({},NO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}AO.isMDXComponent=!0;const PO={toc:[]},IO="wrapper";function WO(t){let{components:e,...n}=t;return(0,s.kt)(IO,(0,p.Z)({},PO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}WO.isMDXComponent=!0;const RO={toc:[]},SO="wrapper";function BO(t){let{components:e,...n}=t;return(0,s.kt)(SO,(0,p.Z)({},RO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}BO.isMDXComponent=!0;const GO={toc:[]},EO="wrapper";function OO(t){let{components:e,...n}=t;return(0,s.kt)(EO,(0,p.Z)({},GO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}OO.isMDXComponent=!0;const UO={toc:[]},FO="wrapper";function VO(t){let{components:e,...n}=t;return(0,s.kt)(FO,(0,p.Z)({},UO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}VO.isMDXComponent=!0;const qO={toc:[]},jO="wrapper";function HO(t){let{components:e,...n}=t;return(0,s.kt)(jO,(0,p.Z)({},qO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}HO.isMDXComponent=!0;const YO={toc:[]},QO="wrapper";function $O(t){let{components:e,...n}=t;return(0,s.kt)(QO,(0,p.Z)({},YO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}$O.isMDXComponent=!0;const KO={toc:[]},JO="wrapper";function tU(t){let{components:e,...n}=t;return(0,s.kt)(JO,(0,p.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}tU.isMDXComponent=!0;const eU={toc:[]},nU="wrapper";function oU(t){let{components:e,...n}=t;return(0,s.kt)(nU,(0,p.Z)({},eU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}oU.isMDXComponent=!0;const pU={toc:[]},rU="wrapper";function sU(t){let{components:e,...n}=t;return(0,s.kt)(rU,(0,p.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}sU.isMDXComponent=!0;const cU={toc:[]},aU="wrapper";function iU(t){let{components:e,...n}=t;return(0,s.kt)(aU,(0,p.Z)({},cU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}iU.isMDXComponent=!0;const lU={toc:[]},uU="wrapper";function mU(t){let{components:e,...n}=t;return(0,s.kt)(uU,(0,p.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}mU.isMDXComponent=!0;const dU={toc:[]},hU="wrapper";function fU(t){let{components:e,...n}=t;return(0,s.kt)(hU,(0,p.Z)({},dU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}fU.isMDXComponent=!0;const kU={toc:[]},yU="wrapper";function DU(t){let{components:e,...n}=t;return(0,s.kt)(yU,(0,p.Z)({},kU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}DU.isMDXComponent=!0;const MU={toc:[]},XU="wrapper";function _U(t){let{components:e,...n}=t;return(0,s.kt)(XU,(0,p.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}_U.isMDXComponent=!0;const wU={toc:[]},TU="wrapper";function CU(t){let{components:e,...n}=t;return(0,s.kt)(TU,(0,p.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}CU.isMDXComponent=!0;const gU={toc:[]},xU="wrapper";function vU(t){let{components:e,...n}=t;return(0,s.kt)(xU,(0,p.Z)({},gU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}vU.isMDXComponent=!0;const LU={toc:[]},ZU="wrapper";function bU(t){let{components:e,...n}=t;return(0,s.kt)(ZU,(0,p.Z)({},LU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}bU.isMDXComponent=!0;const NU={toc:[]},zU="wrapper";function AU(t){let{components:e,...n}=t;return(0,s.kt)(zU,(0,p.Z)({},NU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}AU.isMDXComponent=!0;const PU={toc:[]},IU="wrapper";function WU(t){let{components:e,...n}=t;return(0,s.kt)(IU,(0,p.Z)({},PU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}WU.isMDXComponent=!0;const RU={toc:[]},SU="wrapper";function BU(t){let{components:e,...n}=t;return(0,s.kt)(SU,(0,p.Z)({},RU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}BU.isMDXComponent=!0;const GU={toc:[]},EU="wrapper";function OU(t){let{components:e,...n}=t;return(0,s.kt)(EU,(0,p.Z)({},GU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}OU.isMDXComponent=!0;const UU={toc:[]},FU="wrapper";function VU(t){let{components:e,...n}=t;return(0,s.kt)(FU,(0,p.Z)({},UU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}VU.isMDXComponent=!0;const qU={toc:[]},jU="wrapper";function HU(t){let{components:e,...n}=t;return(0,s.kt)(jU,(0,p.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}HU.isMDXComponent=!0;const YU={toc:[]},QU="wrapper";function $U(t){let{components:e,...n}=t;return(0,s.kt)(QU,(0,p.Z)({},YU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}$U.isMDXComponent=!0;const KU={toc:[]},JU="wrapper";function tF(t){let{components:e,...n}=t;return(0,s.kt)(JU,(0,p.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}tF.isMDXComponent=!0;const eF={toc:[]},nF="wrapper";function oF(t){let{components:e,...n}=t;return(0,s.kt)(nF,(0,p.Z)({},eF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}oF.isMDXComponent=!0;const pF={toc:[]},rF="wrapper";function sF(t){let{components:e,...n}=t;return(0,s.kt)(rF,(0,p.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}sF.isMDXComponent=!0;const cF={toc:[]},aF="wrapper";function iF(t){let{components:e,...n}=t;return(0,s.kt)(aF,(0,p.Z)({},cF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}iF.isMDXComponent=!0;const lF={toc:[]},uF="wrapper";function mF(t){let{components:e,...n}=t;return(0,s.kt)(uF,(0,p.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}mF.isMDXComponent=!0;const dF={toc:[]},hF="wrapper";function fF(t){let{components:e,...n}=t;return(0,s.kt)(hF,(0,p.Z)({},dF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}fF.isMDXComponent=!0;const kF={toc:[]},yF="wrapper";function DF(t){let{components:e,...n}=t;return(0,s.kt)(yF,(0,p.Z)({},kF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}DF.isMDXComponent=!0;const MF={toc:[]},XF="wrapper";function _F(t){let{components:e,...n}=t;return(0,s.kt)(XF,(0,p.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}_F.isMDXComponent=!0;const wF={toc:[]},TF="wrapper";function CF(t){let{components:e,...n}=t;return(0,s.kt)(TF,(0,p.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}CF.isMDXComponent=!0;const gF={toc:[]},xF="wrapper";function vF(t){let{components:e,...n}=t;return(0,s.kt)(xF,(0,p.Z)({},gF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}vF.isMDXComponent=!0;const LF={toc:[]},ZF="wrapper";function bF(t){let{components:e,...n}=t;return(0,s.kt)(ZF,(0,p.Z)({},LF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}bF.isMDXComponent=!0;const NF={toc:[]},zF="wrapper";function AF(t){let{components:e,...n}=t;return(0,s.kt)(zF,(0,p.Z)({},NF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(0, 1)")))}AF.isMDXComponent=!0;const PF={toc:[]},IF="wrapper";function WF(t){let{components:e,...n}=t;return(0,s.kt)(IF,(0,p.Z)({},PF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(-1, 1)")))}WF.isMDXComponent=!0;const RF={toc:[]},SF="wrapper";function BF(t){let{components:e,...n}=t;return(0,s.kt)(SF,(0,p.Z)({},RF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(1, 1)")))}BF.isMDXComponent=!0;const GF={toc:[]},EF="wrapper";function OF(t){let{components:e,...n}=t;return(0,s.kt)(EF,(0,p.Z)({},GF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(0, -1)")))}OF.isMDXComponent=!0;const UF={toc:[]},FF="wrapper";function VF(t){let{components:e,...n}=t;return(0,s.kt)(FF,(0,p.Z)({},UF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(-1, -1)")))}VF.isMDXComponent=!0;const qF={toc:[]},jF="wrapper";function HF(t){let{components:e,...n}=t;return(0,s.kt)(jF,(0,p.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(1, -1)")))}HF.isMDXComponent=!0;const YF={toc:[]},QF="wrapper";function $F(t){let{components:e,...n}=t;return(0,s.kt)(QF,(0,p.Z)({},YF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}$F.isMDXComponent=!0;const KF={toc:[]},JF="wrapper";function tV(t){let{components:e,...n}=t;return(0,s.kt)(JF,(0,p.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}tV.isMDXComponent=!0;const eV={toc:[]},nV="wrapper";function oV(t){let{components:e,...n}=t;return(0,s.kt)(nV,(0,p.Z)({},eV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}oV.isMDXComponent=!0;const pV={toc:[]},rV="wrapper";function sV(t){let{components:e,...n}=t;return(0,s.kt)(rV,(0,p.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}sV.isMDXComponent=!0;const cV={toc:[]},aV="wrapper";function iV(t){let{components:e,...n}=t;return(0,s.kt)(aV,(0,p.Z)({},cV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}iV.isMDXComponent=!0;const lV={toc:[]},uV="wrapper";function mV(t){let{components:e,...n}=t;return(0,s.kt)(uV,(0,p.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}mV.isMDXComponent=!0;const dV={toc:[]},hV="wrapper";function fV(t){let{components:e,...n}=t;return(0,s.kt)(hV,(0,p.Z)({},dV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}fV.isMDXComponent=!0;const kV={toc:[]},yV="wrapper";function DV(t){let{components:e,...n}=t;return(0,s.kt)(yV,(0,p.Z)({},kV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}DV.isMDXComponent=!0;const MV={toc:[]},XV="wrapper";function _V(t){let{components:e,...n}=t;return(0,s.kt)(XV,(0,p.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}_V.isMDXComponent=!0;const wV={toc:[]},TV="wrapper";function CV(t){let{components:e,...n}=t;return(0,s.kt)(TV,(0,p.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}CV.isMDXComponent=!0;const gV={toc:[]},xV="wrapper";function vV(t){let{components:e,...n}=t;return(0,s.kt)(xV,(0,p.Z)({},gV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Raise the components to the power of 2."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const vector = new Vector2(2, 3);\nconst result = vector.transform(value => value ** 2);\n")))}vV.isMDXComponent=!0;const LV={toc:[]},ZV="wrapper";function bV(t){let{components:e,...n}=t;return(0,s.kt)(ZV,(0,p.Z)({},LV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the components of the vector."))}bV.isMDXComponent=!0;const NV={toc:[]},zV="wrapper";function AV(t){let{components:e,...n}=t;return(0,s.kt)(zV,(0,p.Z)({},NV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback to apply to each component."))}AV.isMDXComponent=!0;const PV={toc:[]},IV="wrapper";function WV(t){let{components:e,...n}=t;return(0,s.kt)(IV,(0,p.Z)({},PV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the vector around a point by the provided angle."))}WV.isMDXComponent=!0;const RV={toc:[]},SV="wrapper";function BV(t){let{components:e,...n}=t;return(0,s.kt)(SV,(0,p.Z)({},RV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate in degrees."))}BV.isMDXComponent=!0;const GV={toc:[]},EV="wrapper";function OV(t){let{components:e,...n}=t;return(0,s.kt)(EV,(0,p.Z)({},GV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}OV.isMDXComponent=!0;const UV={toc:[]},FV="wrapper";function VV(t){let{components:e,...n}=t;return(0,s.kt)(FV,(0,p.Z)({},UV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Helper function to create a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.kt)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}VV.isMDXComponent=!0;const qV={toc:[]},jV="wrapper";function HV(t){let{components:e,...n}=t;return(0,s.kt)(jV,(0,p.Z)({},qV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the point should get rotated\ncounterclockwise."))}HV.isMDXComponent=!0;const YV={toc:[]},QV="wrapper";function $V(t){let{components:e,...n}=t;return(0,s.kt)(QV,(0,p.Z)({},YV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}$V.isMDXComponent=!0;const KV={toc:[]},JV="wrapper";function tq(t){let{components:e,...n}=t;return(0,s.kt)(JV,(0,p.Z)({},KV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}tq.isMDXComponent=!0;const eq={toc:[]},nq="wrapper";function oq(t){let{components:e,...n}=t;return(0,s.kt)(nq,(0,p.Z)({},eq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}oq.isMDXComponent=!0;const pq={toc:[]},rq="wrapper";function sq(t){let{components:e,...n}=t;return(0,s.kt)(rq,(0,p.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}sq.isMDXComponent=!0;const cq={toc:[]},aq="wrapper";function iq(t){let{components:e,...n}=t;return(0,s.kt)(aq,(0,p.Z)({},cq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}iq.isMDXComponent=!0;const lq={toc:[]},uq="wrapper";function mq(t){let{components:e,...n}=t;return(0,s.kt)(uq,(0,p.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This function is useful when used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}mq.isMDXComponent=!0;const dq={toc:[]},hq="wrapper";function fq(t){let{components:e,...n}=t;return(0,s.kt)(hq,(0,p.Z)({},dq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Animating an object in a circle around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}fq.isMDXComponent=!0;const kq={toc:[]},yq="wrapper";function Dq(t){let{components:e,...n}=t;return(0,s.kt)(yq,(0,p.Z)({},kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object around the point ",(0,s.kt)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}Dq.isMDXComponent=!0;const Mq={toc:[]},Xq="wrapper";function _q(t){let{components:e,...n}=t;return(0,s.kt)(Xq,(0,p.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}_q.isMDXComponent=!0;const wq={toc:[]},Tq="wrapper";function Cq(t){let{components:e,...n}=t;return(0,s.kt)(Tq,(0,p.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}Cq.isMDXComponent=!0;const gq={toc:[]},xq="wrapper";function vq(t){let{components:e,...n}=t;return(0,s.kt)(xq,(0,p.Z)({},gq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting vector."))}vq.isMDXComponent=!0;const Lq={toc:[]},Zq="wrapper";function bq(t){let{components:e,...n}=t;return(0,s.kt)(Zq,(0,p.Z)({},Lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The target vector."))}bq.isMDXComponent=!0;const Nq={toc:[]},zq="wrapper";function Aq(t){let{components:e,...n}=t;return(0,s.kt)(zq,(0,p.Z)({},Nq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t-value of the interpolation."))}Aq.isMDXComponent=!0;const Pq={toc:[]},Iq="wrapper";function Wq(t){let{components:e,...n}=t;return(0,s.kt)(Iq,(0,p.Z)({},Pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.kt)("inlineCode",{parentName:"p"},"false"),"."))}Wq.isMDXComponent=!0;const Rq={toc:[]},Sq="wrapper";function Bq(t){let{components:e,...n}=t;return(0,s.kt)(Sq,(0,p.Z)({},Rq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}Bq.isMDXComponent=!0;const Gq={toc:[]},Eq="wrapper";function Oq(t){let{components:e,...n}=t;return(0,s.kt)(Eq,(0,p.Z)({},Gq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}Oq.isMDXComponent=!0;const Uq={toc:[]},Fq="wrapper";function Vq(t){let{components:e,...n}=t;return(0,s.kt)(Fq,(0,p.Z)({},Uq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}Vq.isMDXComponent=!0;const qq={toc:[]},jq="wrapper";function Hq(t){let{components:e,...n}=t;return(0,s.kt)(jq,(0,p.Z)({},qq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}Hq.isMDXComponent=!0;const Yq={toc:[]},Qq="wrapper";function $q(t){let{components:e,...n}=t;return(0,s.kt)(Qq,(0,p.Z)({},Yq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same class as the one created by\n",(0,s.kt)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.kt)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}$q.isMDXComponent=!0;const Kq={toc:[]},Jq="wrapper";function tj(t){let{components:e,...n}=t;return(0,s.kt)(Jq,(0,p.Z)({},Kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color."))}tj.isMDXComponent=!0;const ej={toc:[]},nj="wrapper";function oj(t){let{components:e,...n}=t;return(0,s.kt)(nj,(0,p.Z)({},ej,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}oj.isMDXComponent=!0;const pj={toc:[]},rj="wrapper";function sj(t){let{components:e,...n}=t;return(0,s.kt)(rj,(0,p.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}sj.isMDXComponent=!0;const cj={toc:[]},aj="wrapper";function ij(t){let{components:e,...n}=t;return(0,s.kt)(aj,(0,p.Z)({},cj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}ij.isMDXComponent=!0;const lj={toc:[]},uj="wrapper";function mj(t){let{components:e,...n}=t;return(0,s.kt)(uj,(0,p.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}mj.isMDXComponent=!0;const dj={toc:[]},hj="wrapper";function fj(t){let{components:e,...n}=t;return(0,s.kt)(hj,(0,p.Z)({},dj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}fj.isMDXComponent=!0;const kj={toc:[]},yj="wrapper";function Dj(t){let{components:e,...n}=t;return(0,s.kt)(yj,(0,p.Z)({},kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}Dj.isMDXComponent=!0;const Mj={toc:[]},Xj="wrapper";function _j(t){let{components:e,...n}=t;return(0,s.kt)(Xj,(0,p.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}_j.isMDXComponent=!0;const wj={toc:[]},Tj="wrapper";function Cj(t){let{components:e,...n}=t;return(0,s.kt)(Tj,(0,p.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}Cj.isMDXComponent=!0;const gj={toc:[]},xj="wrapper";function vj(t){let{components:e,...n}=t;return(0,s.kt)(xj,(0,p.Z)({},gj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}vj.isMDXComponent=!0;const Lj={toc:[]},Zj="wrapper";function bj(t){let{components:e,...n}=t;return(0,s.kt)(Zj,(0,p.Z)({},Lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}bj.isMDXComponent=!0;const Nj={toc:[]},zj="wrapper";function Aj(t){let{components:e,...n}=t;return(0,s.kt)(zj,(0,p.Z)({},Nj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}Aj.isMDXComponent=!0;const Pj={toc:[]},Ij="wrapper";function Wj(t){let{components:e,...n}=t;return(0,s.kt)(Ij,(0,p.Z)({},Pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}Wj.isMDXComponent=!0;const Rj={toc:[]},Sj="wrapper";function Bj(t){let{components:e,...n}=t;return(0,s.kt)(Sj,(0,p.Z)({},Rj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Bj.isMDXComponent=!0;const Gj={toc:[]},Ej="wrapper";function Oj(t){let{components:e,...n}=t;return(0,s.kt)(Ej,(0,p.Z)({},Gj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}Oj.isMDXComponent=!0;const Uj={toc:[]},Fj="wrapper";function Vj(t){let{components:e,...n}=t;return(0,s.kt)(Fj,(0,p.Z)({},Uj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}Vj.isMDXComponent=!0;const qj={toc:[]},jj="wrapper";function Hj(t){let{components:e,...n}=t;return(0,s.kt)(jj,(0,p.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}Hj.isMDXComponent=!0;const Yj={toc:[]},Qj="wrapper";function $j(t){let{components:e,...n}=t;return(0,s.kt)(Qj,(0,p.Z)({},Yj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}$j.isMDXComponent=!0;const Kj={toc:[]},Jj="wrapper";function tH(t){let{components:e,...n}=t;return(0,s.kt)(Jj,(0,p.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}tH.isMDXComponent=!0;const eH={toc:[]},nH="wrapper";function oH(t){let{components:e,...n}=t;return(0,s.kt)(nH,(0,p.Z)({},eH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}oH.isMDXComponent=!0;const pH={toc:[]},rH="wrapper";function sH(t){let{components:e,...n}=t;return(0,s.kt)(rH,(0,p.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}sH.isMDXComponent=!0;const cH={toc:[]},aH="wrapper";function iH(t){let{components:e,...n}=t;return(0,s.kt)(aH,(0,p.Z)({},cH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}iH.isMDXComponent=!0;const lH={toc:[]},uH="wrapper";function mH(t){let{components:e,...n}=t;return(0,s.kt)(uH,(0,p.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}mH.isMDXComponent=!0;const dH={toc:[]},hH="wrapper";function fH(t){let{components:e,...n}=t;return(0,s.kt)(hH,(0,p.Z)({},dH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}fH.isMDXComponent=!0;const kH={toc:[]},yH="wrapper";function DH(t){let{components:e,...n}=t;return(0,s.kt)(yH,(0,p.Z)({},kH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}DH.isMDXComponent=!0;const MH={toc:[]},XH="wrapper";function _H(t){let{components:e,...n}=t;return(0,s.kt)(XH,(0,p.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}_H.isMDXComponent=!0;const wH={toc:[]},TH="wrapper";function CH(t){let{components:e,...n}=t;return(0,s.kt)(TH,(0,p.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}CH.isMDXComponent=!0;const gH={toc:[]},xH="wrapper";function vH(t){let{components:e,...n}=t;return(0,s.kt)(xH,(0,p.Z)({},gH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of the transformed references."))}vH.isMDXComponent=!0;const LH={toc:[]},ZH="wrapper";function bH(t){let{components:e,...n}=t;return(0,s.kt)(ZH,(0,p.Z)({},LH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Maps the references in this group to a new array."))}bH.isMDXComponent=!0;const NH={toc:[]},zH="wrapper";function AH(t){let{components:e,...n}=t;return(0,s.kt)(zH,(0,p.Z)({},NH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to transform each reference."))}AH.isMDXComponent=!0;const PH={toc:[]},IH="wrapper";function WH(t){let{components:e,...n}=t;return(0,s.kt)(IH,(0,p.Z)({},PH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}WH.isMDXComponent=!0;const RH={toc:[]},SH="wrapper";function BH(t){let{components:e,...n}=t;return(0,s.kt)(SH,(0,p.Z)({},RH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}BH.isMDXComponent=!0;const GH={toc:[]},EH="wrapper";function OH(t){let{components:e,...n}=t;return(0,s.kt)(EH,(0,p.Z)({},GH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}OH.isMDXComponent=!0;const UH={toc:[]},FH="wrapper";function VH(t){let{components:e,...n}=t;return(0,s.kt)(FH,(0,p.Z)({},UH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}VH.isMDXComponent=!0;const qH={toc:[]},jH="wrapper";function HH(t){let{components:e,...n}=t;return(0,s.kt)(jH,(0,p.Z)({},qH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.kt)("inlineCode",{parentName:"p"},"ref")," property of a node."))}HH.isMDXComponent=!0;const YH={toc:[]},QH="wrapper";function $H(t){let{components:e,...n}=t;return(0,s.kt)(QH,(0,p.Z)({},YH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}$H.isMDXComponent=!0;const KH={toc:[]},JH="wrapper";function tY(t){let{components:e,...n}=t;return(0,s.kt)(JH,(0,p.Z)({},KH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array of references."))}tY.isMDXComponent=!0;const eY={toc:[]},nY="wrapper";function oY(t){let{components:e,...n}=t;return(0,s.kt)(nY,(0,p.Z)({},eY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.kt)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}oY.isMDXComponent=!0;const pY={toc:[]},rY="wrapper";function sY(t){let{components:e,...n}=t;return(0,s.kt)(rY,(0,p.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}sY.isMDXComponent=!0;const cY={toc:[]},aY="wrapper";function iY(t){let{components:e,...n}=t;return(0,s.kt)(aY,(0,p.Z)({},cY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a group of references."))}iY.isMDXComponent=!0;const lY={toc:[]},uY="wrapper";function mY(t){let{components:e,...n}=t;return(0,s.kt)(uY,(0,p.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}mY.isMDXComponent=!0;const dY={toc:[]},hY="wrapper";function fY(t){let{components:e,...n}=t;return(0,s.kt)(hY,(0,p.Z)({},dY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}fY.isMDXComponent=!0;const kY={toc:[]},yY="wrapper";function DY(t){let{components:e,...n}=t;return(0,s.kt)(yY,(0,p.Z)({},kY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}DY.isMDXComponent=!0;const MY={toc:[]},XY="wrapper";function _Y(t){let{components:e,...n}=t;return(0,s.kt)(XY,(0,p.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}_Y.isMDXComponent=!0;const wY={toc:[]},TY="wrapper";function CY(t){let{components:e,...n}=t;return(0,s.kt)(TY,(0,p.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}CY.isMDXComponent=!0;const gY={toc:[]},xY="wrapper";function vY(t){let{components:e,...n}=t;return(0,s.kt)(xY,(0,p.Z)({},gY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}vY.isMDXComponent=!0;const LY={toc:[]},ZY="wrapper";function bY(t){let{components:e,...n}=t;return(0,s.kt)(ZY,(0,p.Z)({},LY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}bY.isMDXComponent=!0;const NY={toc:[]},zY="wrapper";function AY(t){let{components:e,...n}=t;return(0,s.kt)(zY,(0,p.Z)({},NY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}AY.isMDXComponent=!0;const PY={toc:[]},IY="wrapper";function WY(t){let{components:e,...n}=t;return(0,s.kt)(IY,(0,p.Z)({},PY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}WY.isMDXComponent=!0;const RY={toc:[]},SY="wrapper";function BY(t){let{components:e,...n}=t;return(0,s.kt)(SY,(0,p.Z)({},RY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}BY.isMDXComponent=!0;const GY={toc:[]},EY="wrapper";function OY(t){let{components:e,...n}=t;return(0,s.kt)(EY,(0,p.Z)({},GY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}OY.isMDXComponent=!0;const UY={toc:[]},FY="wrapper";function VY(t){let{components:e,...n}=t;return(0,s.kt)(FY,(0,p.Z)({},UY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}VY.isMDXComponent=!0;const qY={toc:[]},jY="wrapper";function HY(t){let{components:e,...n}=t;return(0,s.kt)(jY,(0,p.Z)({},qY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}HY.isMDXComponent=!0;const YY={toc:[]},QY="wrapper";function $Y(t){let{components:e,...n}=t;return(0,s.kt)(QY,(0,p.Z)({},YY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}$Y.isMDXComponent=!0;const KY={toc:[]},JY="wrapper";function tQ(t){let{components:e,...n}=t;return(0,s.kt)(JY,(0,p.Z)({},KY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}tQ.isMDXComponent=!0;const eQ={toc:[]},nQ="wrapper";function oQ(t){let{components:e,...n}=t;return(0,s.kt)(nQ,(0,p.Z)({},eQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}oQ.isMDXComponent=!0;const pQ={toc:[]},rQ="wrapper";function sQ(t){let{components:e,...n}=t;return(0,s.kt)(rQ,(0,p.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}sQ.isMDXComponent=!0;const cQ={toc:[]},aQ="wrapper";function iQ(t){let{components:e,...n}=t;return(0,s.kt)(aQ,(0,p.Z)({},cQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}iQ.isMDXComponent=!0;const lQ={toc:[]},uQ="wrapper";function mQ(t){let{components:e,...n}=t;return(0,s.kt)(uQ,(0,p.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}mQ.isMDXComponent=!0;const dQ={toc:[]},hQ="wrapper";function fQ(t){let{components:e,...n}=t;return(0,s.kt)(hQ,(0,p.Z)({},dQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}fQ.isMDXComponent=!0;const kQ={toc:[]},yQ="wrapper";function DQ(t){let{components:e,...n}=t;return(0,s.kt)(yQ,(0,p.Z)({},kQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}DQ.isMDXComponent=!0;const MQ={toc:[]},XQ="wrapper";function _Q(t){let{components:e,...n}=t;return(0,s.kt)(XQ,(0,p.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}_Q.isMDXComponent=!0;const wQ={toc:[]},TQ="wrapper";function CQ(t){let{components:e,...n}=t;return(0,s.kt)(TQ,(0,p.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}CQ.isMDXComponent=!0;const gQ={toc:[]},xQ="wrapper";function vQ(t){let{components:e,...n}=t;return(0,s.kt)(xQ,(0,p.Z)({},gQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}vQ.isMDXComponent=!0;const LQ={toc:[]},ZQ="wrapper";function bQ(t){let{components:e,...n}=t;return(0,s.kt)(ZQ,(0,p.Z)({},LQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}bQ.isMDXComponent=!0;const NQ={toc:[]},zQ="wrapper";function AQ(t){let{components:e,...n}=t;return(0,s.kt)(zQ,(0,p.Z)({},NQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}AQ.isMDXComponent=!0;const PQ={toc:[]},IQ="wrapper";function WQ(t){let{components:e,...n}=t;return(0,s.kt)(IQ,(0,p.Z)({},PQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}WQ.isMDXComponent=!0;const RQ={toc:[]},SQ="wrapper";function BQ(t){let{components:e,...n}=t;return(0,s.kt)(SQ,(0,p.Z)({},RQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}BQ.isMDXComponent=!0;const GQ={toc:[]},EQ="wrapper";function OQ(t){let{components:e,...n}=t;return(0,s.kt)(EQ,(0,p.Z)({},GQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}OQ.isMDXComponent=!0;const UQ={toc:[]},FQ="wrapper";function VQ(t){let{components:e,...n}=t;return(0,s.kt)(FQ,(0,p.Z)({},UQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}VQ.isMDXComponent=!0;const qQ={toc:[]},jQ="wrapper";function HQ(t){let{components:e,...n}=t;return(0,s.kt)(jQ,(0,p.Z)({},qQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}HQ.isMDXComponent=!0;const YQ={toc:[]},QQ="wrapper";function $Q(t){let{components:e,...n}=t;return(0,s.kt)(QQ,(0,p.Z)({},YQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}$Q.isMDXComponent=!0;const KQ={toc:[]},JQ="wrapper";function t$(t){let{components:e,...n}=t;return(0,s.kt)(JQ,(0,p.Z)({},KQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}t$.isMDXComponent=!0;const e$={toc:[]},n$="wrapper";function o$(t){let{components:e,...n}=t;return(0,s.kt)(n$,(0,p.Z)({},e$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}o$.isMDXComponent=!0;const p$={toc:[]},r$="wrapper";function s$(t){let{components:e,...n}=t;return(0,s.kt)(r$,(0,p.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}s$.isMDXComponent=!0;const c$={toc:[]},a$="wrapper";function i$(t){let{components:e,...n}=t;return(0,s.kt)(a$,(0,p.Z)({},c$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}i$.isMDXComponent=!0;const l$={toc:[]},u$="wrapper";function m$(t){let{components:e,...n}=t;return(0,s.kt)(u$,(0,p.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}m$.isMDXComponent=!0;const d$={toc:[]},h$="wrapper";function f$(t){let{components:e,...n}=t;return(0,s.kt)(h$,(0,p.Z)({},d$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}f$.isMDXComponent=!0;const k$={toc:[]},y$="wrapper";function D$(t){let{components:e,...n}=t;return(0,s.kt)(y$,(0,p.Z)({},k$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}D$.isMDXComponent=!0;const M$={toc:[]},X$="wrapper";function _$(t){let{components:e,...n}=t;return(0,s.kt)(X$,(0,p.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}_$.isMDXComponent=!0;const w$={toc:[]},T$="wrapper";function C$(t){let{components:e,...n}=t;return(0,s.kt)(T$,(0,p.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}C$.isMDXComponent=!0;const g$={toc:[]},x$="wrapper";function v$(t){let{components:e,...n}=t;return(0,s.kt)(x$,(0,p.Z)({},g$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}v$.isMDXComponent=!0;const L$={toc:[]},Z$="wrapper";function b$(t){let{components:e,...n}=t;return(0,s.kt)(Z$,(0,p.Z)({},L$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}b$.isMDXComponent=!0;const N$={toc:[]},z$="wrapper";function A$(t){let{components:e,...n}=t;return(0,s.kt)(z$,(0,p.Z)({},N$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}A$.isMDXComponent=!0;const P$={toc:[]},I$="wrapper";function W$(t){let{components:e,...n}=t;return(0,s.kt)(I$,(0,p.Z)({},P$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}W$.isMDXComponent=!0;const R$={toc:[]},S$="wrapper";function B$(t){let{components:e,...n}=t;return(0,s.kt)(S$,(0,p.Z)({},R$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}B$.isMDXComponent=!0;const G$={toc:[]},E$="wrapper";function O$(t){let{components:e,...n}=t;return(0,s.kt)(E$,(0,p.Z)({},G$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}O$.isMDXComponent=!0;const U$={toc:[]},F$="wrapper";function V$(t){let{components:e,...n}=t;return(0,s.kt)(F$,(0,p.Z)({},U$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}V$.isMDXComponent=!0;const q$={toc:[]},j$="wrapper";function H$(t){let{components:e,...n}=t;return(0,s.kt)(j$,(0,p.Z)({},q$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}H$.isMDXComponent=!0;const Y$={toc:[]},Q$="wrapper";function $$(t){let{components:e,...n}=t;return(0,s.kt)(Q$,(0,p.Z)({},Y$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}$$.isMDXComponent=!0;const K$={toc:[]},J$="wrapper";function tK(t){let{components:e,...n}=t;return(0,s.kt)(J$,(0,p.Z)({},K$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}tK.isMDXComponent=!0;const eK={toc:[]},nK="wrapper";function oK(t){let{components:e,...n}=t;return(0,s.kt)(nK,(0,p.Z)({},eK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}oK.isMDXComponent=!0;const pK={toc:[]},rK="wrapper";function sK(t){let{components:e,...n}=t;return(0,s.kt)(rK,(0,p.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}sK.isMDXComponent=!0;const cK={toc:[]},aK="wrapper";function iK(t){let{components:e,...n}=t;return(0,s.kt)(aK,(0,p.Z)({},cK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}iK.isMDXComponent=!0;const lK={toc:[]},uK="wrapper";function mK(t){let{components:e,...n}=t;return(0,s.kt)(uK,(0,p.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}mK.isMDXComponent=!0;const dK={toc:[]},hK="wrapper";function fK(t){let{components:e,...n}=t;return(0,s.kt)(hK,(0,p.Z)({},dK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}fK.isMDXComponent=!0;const kK={toc:[]},yK="wrapper";function DK(t){let{components:e,...n}=t;return(0,s.kt)(yK,(0,p.Z)({},kK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}DK.isMDXComponent=!0;const MK={toc:[]},XK="wrapper";function _K(t){let{components:e,...n}=t;return(0,s.kt)(XK,(0,p.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes custom highlighters used by the Code node."))}_K.isMDXComponent=!0;const wK={toc:[]},TK="wrapper";function CK(t){let{components:e,...n}=t;return(0,s.kt)(TK,(0,p.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Highlights the code at the given index."))}CK.isMDXComponent=!0;const gK={toc:[]},xK="wrapper";function vK(t){let{components:e,...n}=t;return(0,s.kt)(xK,(0,p.Z)({},gK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the code to highlight."))}vK.isMDXComponent=!0;const LK={toc:[]},ZK="wrapper";function bK(t){let{components:e,...n}=t;return(0,s.kt)(ZK,(0,p.Z)({},LK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#prepare"},(0,s.kt)("inlineCode",{parentName:"a"},"prepare")),"."))}bK.isMDXComponent=!0;const NK={toc:[]},zK="wrapper";function AK(t){let{components:e,...n}=t;return(0,s.kt)(zK,(0,p.Z)({},NK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.kt)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.kt)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.kt)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.kt)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}AK.isMDXComponent=!0;const PK={toc:[]},IK="wrapper";function WK(t){let{components:e,...n}=t;return(0,s.kt)(IK,(0,p.Z)({},PK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializes the highlighter."))}WK.isMDXComponent=!0;const RK={toc:[]},SK="wrapper";function BK(t){let{components:e,...n}=t;return(0,s.kt)(SK,(0,p.Z)({},RK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#highlight"},(0,s.kt)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}BK.isMDXComponent=!0;const GK={toc:[]},EK="wrapper";function OK(t){let{components:e,...n}=t;return(0,s.kt)(EK,(0,p.Z)({},GK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepares the code for highlighting."))}OK.isMDXComponent=!0;const UK={toc:[]},FK="wrapper";function VK(t){let{components:e,...n}=t;return(0,s.kt)(FK,(0,p.Z)({},UK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to prepare."))}VK.isMDXComponent=!0;const qK={toc:[]},jK="wrapper";function HK(t){let{components:e,...n}=t;return(0,s.kt)(jK,(0,p.Z)({},qK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tokenize the code."))}HK.isMDXComponent=!0;const YK={toc:[]},QK="wrapper";function $K(t){let{components:e,...n}=t;return(0,s.kt)(QK,(0,p.Z)({},YK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to tokenize."))}$K.isMDXComponent=!0;const KK={toc:[]},JK="wrapper";function tJ(t){let{components:e,...n}=t;return(0,s.kt)(JK,(0,p.Z)({},KK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes custom highlighters used by the Code node."))}tJ.isMDXComponent=!0;const eJ={toc:[]},nJ="wrapper";function oJ(t){let{components:e,...n}=t;return(0,s.kt)(nJ,(0,p.Z)({},eJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Highlights the code at the given index."))}oJ.isMDXComponent=!0;const pJ={toc:[]},rJ="wrapper";function sJ(t){let{components:e,...n}=t;return(0,s.kt)(rJ,(0,p.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the code to highlight."))}sJ.isMDXComponent=!0;const cJ={toc:[]},aJ="wrapper";function iJ(t){let{components:e,...n}=t;return(0,s.kt)(aJ,(0,p.Z)({},cJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#prepare"},(0,s.kt)("inlineCode",{parentName:"a"},"prepare")),"."))}iJ.isMDXComponent=!0;const lJ={toc:[]},uJ="wrapper";function mJ(t){let{components:e,...n}=t;return(0,s.kt)(uJ,(0,p.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.kt)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.kt)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.kt)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.kt)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}mJ.isMDXComponent=!0;const dJ={toc:[]},hJ="wrapper";function fJ(t){let{components:e,...n}=t;return(0,s.kt)(hJ,(0,p.Z)({},dJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializes the highlighter."))}fJ.isMDXComponent=!0;const kJ={toc:[]},yJ="wrapper";function DJ(t){let{components:e,...n}=t;return(0,s.kt)(yJ,(0,p.Z)({},kJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#highlight"},(0,s.kt)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}DJ.isMDXComponent=!0;const MJ={toc:[]},XJ="wrapper";function _J(t){let{components:e,...n}=t;return(0,s.kt)(XJ,(0,p.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepares the code for highlighting."))}_J.isMDXComponent=!0;const wJ={toc:[]},TJ="wrapper";function CJ(t){let{components:e,...n}=t;return(0,s.kt)(TJ,(0,p.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to prepare."))}CJ.isMDXComponent=!0;const gJ={toc:[]},xJ="wrapper";function vJ(t){let{components:e,...n}=t;return(0,s.kt)(xJ,(0,p.Z)({},gJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tokenize the code."))}vJ.isMDXComponent=!0;const LJ={toc:[]},ZJ="wrapper";function bJ(t){let{components:e,...n}=t;return(0,s.kt)(ZJ,(0,p.Z)({},LJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to tokenize."))}bJ.isMDXComponent=!0;const NJ={toc:[]},zJ="wrapper";function AJ(t){let{components:e,...n}=t;return(0,s.kt)(zJ,(0,p.Z)({},NJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the cache used by the highlighter."))}AJ.isMDXComponent=!0;const PJ={toc:[]},IJ="wrapper";function WJ(t){let{components:e,...n}=t;return(0,s.kt)(IJ,(0,p.Z)({},PJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the result of a highlight operation."))}WJ.isMDXComponent=!0;const RJ={toc:[]},SJ="wrapper";function BJ(t){let{components:e,...n}=t;return(0,s.kt)(SJ,(0,p.Z)({},RJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the code at the given index."))}BJ.isMDXComponent=!0;const GJ={toc:[]},EJ="wrapper";function OJ(t){let{components:e,...n}=t;return(0,s.kt)(EJ,(0,p.Z)({},GJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This should be used to skip to the end of the currently highlighted token.\nThe returned style will be used for the skipped characters, and they will\nbe drawn as one continuous string keeping emojis and ligatures intact."),(0,s.kt)("p",null,"The returned value is the number of characters to skip ahead, not the\nindex of the end of the token."))}OJ.isMDXComponent=!0;const UJ={toc:[]},FJ="wrapper";function VJ(t){let{components:e,...n}=t;return(0,s.kt)(FJ,(0,p.Z)({},UJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of characters to skip ahead."))}VJ.isMDXComponent=!0;const qJ={toc:[]},jJ="wrapper";function HJ(t){let{components:e,...n}=t;return(0,s.kt)(jJ,(0,p.Z)({},qJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that compares two code snippets and returns a list of\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code#CodeTag"},(0,s.kt)("inlineCode",{parentName:"a"},"CodeTag")),"s describing a transition between them."))}HJ.isMDXComponent=!0;const YJ={toc:[]},QJ="wrapper";function $J(t){let{components:e,...n}=t;return(0,s.kt)(QJ,(0,p.Z)({},YJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Default diffing function utilizing ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code#patienceDiff"},(0,s.kt)("inlineCode",{parentName:"a"},"patienceDiff")),"."))}$J.isMDXComponent=!0;const KJ={toc:[]},JJ="wrapper";function t0(t){let{components:e,...n}=t;return(0,s.kt)(JJ,(0,p.Z)({},KJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The original code scope."))}t0.isMDXComponent=!0;const e0={toc:[]},n0="wrapper";function o0(t){let{components:e,...n}=t;return(0,s.kt)(n0,(0,p.Z)({},e0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new code scope."))}o0.isMDXComponent=!0;const p0={toc:[]},r0="wrapper";function s0(t){let{components:e,...n}=t;return(0,s.kt)(r0,(0,p.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The inherited tokenizer to use."))}s0.isMDXComponent=!0;const c0={toc:[]},a0="wrapper";function i0(t){let{components:e,...n}=t;return(0,s.kt)(a0,(0,p.Z)({},c0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Default tokenizer function used by ownerless code signals."))}i0.isMDXComponent=!0;const l0={toc:[]},u0="wrapper";function m0(t){let{components:e,...n}=t;return(0,s.kt)(u0,(0,p.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to tokenize."))}m0.isMDXComponent=!0;const d0={toc:[]},h0="wrapper";function f0(t){let{components:e,...n}=t;return(0,s.kt)(h0,(0,p.Z)({},d0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This function will try to preserve the original fragments, resolving them\nonly if they overlap with the range."))}f0.isMDXComponent=!0;const k0={toc:[]},y0="wrapper";function D0(t){let{components:e,...n}=t;return(0,s.kt)(y0,(0,p.Z)({},k0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A tuple containing the transformed fragments and the index of the\nisolated fragment within."))}D0.isMDXComponent=!0;const M0={toc:[]},X0="wrapper";function _0(t){let{components:e,...n}=t;return(0,s.kt)(X0,(0,p.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the fragments to isolate the given range into its own fragment."))}_0.isMDXComponent=!0;const w0={toc:[]},T0="wrapper";function C0(t){let{components:e,...n}=t;return(0,s.kt)(T0,(0,p.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The range to extract."))}C0.isMDXComponent=!0;const g0={toc:[]},x0="wrapper";function v0(t){let{components:e,...n}=t;return(0,s.kt)(x0,(0,p.Z)({},g0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fragments to transform."))}v0.isMDXComponent=!0;const L0={toc:[]},Z0="wrapper";function b0(t){let{components:e,...n}=t;return(0,s.kt)(Z0,(0,p.Z)({},L0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all code ranges that match the given pattern."))}b0.isMDXComponent=!0;const N0={toc:[]},z0="wrapper";function A0(t){let{components:e,...n}=t;return(0,s.kt)(z0,(0,p.Z)({},N0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to search in."))}A0.isMDXComponent=!0;const P0={toc:[]},I0="wrapper";function W0(t){let{components:e,...n}=t;return(0,s.kt)(I0,(0,p.Z)({},P0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Either a string or a regular expression to search for."))}W0.isMDXComponent=!0;const R0={toc:[]},S0="wrapper";function B0(t){let{components:e,...n}=t;return(0,s.kt)(S0,(0,p.Z)({},R0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional limit on the number of ranges to find."))}B0.isMDXComponent=!0;const G0={toc:[]},E0="wrapper";function O0(t){let{components:e,...n}=t;return(0,s.kt)(E0,(0,p.Z)({},G0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.kt)("inlineCode",{parentName:"a"},"edit")),"."))}O0.isMDXComponent=!0;const U0={toc:[]},F0="wrapper";function V0(t){let{components:e,...n}=t;return(0,s.kt)(F0,(0,p.Z)({},U0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a code fragment that represents an insertion of code."))}V0.isMDXComponent=!0;const q0={toc:[]},j0="wrapper";function H0(t){let{components:e,...n}=t;return(0,s.kt)(j0,(0,p.Z)({},q0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to insert."))}H0.isMDXComponent=!0;const Y0={toc:[]},Q0="wrapper";function $0(t){let{components:e,...n}=t;return(0,s.kt)(Q0,(0,p.Z)({},Y0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a code range that spans the given lines."))}$0.isMDXComponent=!0;const K0={toc:[]},J0="wrapper";function t3(t){let{components:e,...n}=t;return(0,s.kt)(J0,(0,p.Z)({},K0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The line from which the range starts."))}t3.isMDXComponent=!0;const e3={toc:[]},n3="wrapper";function o3(t){let{components:e,...n}=t;return(0,s.kt)(n3,(0,p.Z)({},e3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The line at which the range ends. If omitted, the range will\ncover only one line."))}o3.isMDXComponent=!0;const p3={toc:[]},r3="wrapper";function s3(t){let{components:e,...n}=t;return(0,s.kt)(r3,(0,p.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Performs a patience diff on two arrays of strings, returning an object\ncontaining the lines that were deleted, inserted, and potentially moved\nlines. The plus parameter can result in a significant performance hit due\nto additional Longest Common Substring searches."))}s3.isMDXComponent=!0;const c3={toc:[]},a3="wrapper";function i3(t){let{components:e,...n}=t;return(0,s.kt)(a3,(0,p.Z)({},c3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The original array of strings"))}i3.isMDXComponent=!0;const l3={toc:[]},u3="wrapper";function m3(t){let{components:e,...n}=t;return(0,s.kt)(u3,(0,p.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new array of strings"))}m3.isMDXComponent=!0;const d3={toc:[]},h3="wrapper";function f3(t){let{components:e,...n}=t;return(0,s.kt)(h3,(0,p.Z)({},d3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a custom selection range."))}f3.isMDXComponent=!0;const k3={toc:[]},y3="wrapper";function D3(t){let{components:e,...n}=t;return(0,s.kt)(y3,(0,p.Z)({},k3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The line at which the selection starts."))}D3.isMDXComponent=!0;const M3={toc:[]},X3="wrapper";function _3(t){let{components:e,...n}=t;return(0,s.kt)(X3,(0,p.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The column at which the selection starts."))}_3.isMDXComponent=!0;const w3={toc:[]},T3="wrapper";function C3(t){let{components:e,...n}=t;return(0,s.kt)(T3,(0,p.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The line at which the selection ends."))}C3.isMDXComponent=!0;const g3={toc:[]},x3="wrapper";function v3(t){let{components:e,...n}=t;return(0,s.kt)(x3,(0,p.Z)({},g3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The column at which the selection ends."))}v3.isMDXComponent=!0;const L3={toc:[]},Z3="wrapper";function b3(t){let{components:e,...n}=t;return(0,s.kt)(Z3,(0,p.Z)({},L3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.kt)("inlineCode",{parentName:"a"},"edit")),"."))}b3.isMDXComponent=!0;const N3={toc:[]},z3="wrapper";function A3(t){let{components:e,...n}=t;return(0,s.kt)(z3,(0,p.Z)({},N3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a code fragment that represents a removal of code."))}A3.isMDXComponent=!0;const P3={toc:[]},I3="wrapper";function W3(t){let{components:e,...n}=t;return(0,s.kt)(I3,(0,p.Z)({},P3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to remove."))}W3.isMDXComponent=!0;const R3={toc:[]},S3="wrapper";function B3(t){let{components:e,...n}=t;return(0,s.kt)(S3,(0,p.Z)({},R3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.kt)("inlineCode",{parentName:"a"},"edit")),"."))}B3.isMDXComponent=!0;const G3={toc:[]},E3="wrapper";function O3(t){let{components:e,...n}=t;return(0,s.kt)(E3,(0,p.Z)({},G3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a code fragment that represents a change from one piece of code to\nanother."))}O3.isMDXComponent=!0;const U3={toc:[]},F3="wrapper";function V3(t){let{components:e,...n}=t;return(0,s.kt)(F3,(0,p.Z)({},U3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to change from."))}V3.isMDXComponent=!0;const q3={toc:[]},j3="wrapper";function H3(t){let{components:e,...n}=t;return(0,s.kt)(j3,(0,p.Z)({},q3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to change to."))}H3.isMDXComponent=!0;const Y3={toc:[]},Q3="wrapper";function $3(t){let{components:e,...n}=t;return(0,s.kt)(Q3,(0,p.Z)({},Y3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a code range that highlights the given word."))}$3.isMDXComponent=!0;const K3={toc:[]},J3="wrapper";function t1(t){let{components:e,...n}=t;return(0,s.kt)(J3,(0,p.Z)({},K3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The line at which the word appears."))}t1.isMDXComponent=!0;const e1={toc:[]},n1="wrapper";function o1(t){let{components:e,...n}=t;return(0,s.kt)(n1,(0,p.Z)({},e1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The column at which the word starts."))}o1.isMDXComponent=!0;const p1={toc:[]},r1="wrapper";function s1(t){let{components:e,...n}=t;return(0,s.kt)(r1,(0,p.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the word. If omitted, the range will cover the\nrest of the line."))}s1.isMDXComponent=!0;const c1={toc:[]},a1="wrapper";function i1(t){let{components:e,...n}=t;return(0,s.kt)(a1,(0,p.Z)({},c1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}i1.isMDXComponent=!0;const l1={toc:[]},u1="wrapper";function m1(t){let{components:e,...n}=t;return(0,s.kt)(u1,(0,p.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}m1.isMDXComponent=!0;const d1={toc:[]},h1="wrapper";function f1(t){let{components:e,...n}=t;return(0,s.kt)(h1,(0,p.Z)({},d1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}f1.isMDXComponent=!0;const k1={toc:[]},y1="wrapper";function D1(t){let{components:e,...n}=t;return(0,s.kt)(y1,(0,p.Z)({},k1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}D1.isMDXComponent=!0;const M1={toc:[]},X1="wrapper";function _1(t){let{components:e,...n}=t;return(0,s.kt)(X1,(0,p.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_1.isMDXComponent=!0;const w1={toc:[]},T1="wrapper";function C1(t){let{components:e,...n}=t;return(0,s.kt)(T1,(0,p.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}C1.isMDXComponent=!0;const g1={toc:[]},x1="wrapper";function v1(t){let{components:e,...n}=t;return(0,s.kt)(x1,(0,p.Z)({},g1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}v1.isMDXComponent=!0;const L1={toc:[]},Z1="wrapper";function b1(t){let{components:e,...n}=t;return(0,s.kt)(Z1,(0,p.Z)({},L1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}b1.isMDXComponent=!0;const N1={toc:[]},z1="wrapper";function A1(t){let{components:e,...n}=t;return(0,s.kt)(z1,(0,p.Z)({},N1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}A1.isMDXComponent=!0;const P1={toc:[]},I1="wrapper";function W1(t){let{components:e,...n}=t;return(0,s.kt)(I1,(0,p.Z)({},P1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}W1.isMDXComponent=!0;const R1={toc:[]},S1="wrapper";function B1(t){let{components:e,...n}=t;return(0,s.kt)(S1,(0,p.Z)({},R1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}B1.isMDXComponent=!0;const G1={toc:[]},E1="wrapper";function O1(t){let{components:e,...n}=t;return(0,s.kt)(E1,(0,p.Z)({},G1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}O1.isMDXComponent=!0;const U1={toc:[]},F1="wrapper";function V1(t){let{components:e,...n}=t;return(0,s.kt)(F1,(0,p.Z)({},U1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}V1.isMDXComponent=!0;const q1={toc:[]},j1="wrapper";function H1(t){let{components:e,...n}=t;return(0,s.kt)(j1,(0,p.Z)({},q1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}H1.isMDXComponent=!0;const Y1={toc:[]},Q1="wrapper";function $1(t){let{components:e,...n}=t;return(0,s.kt)(Q1,(0,p.Z)({},Y1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$1.isMDXComponent=!0;const K1={toc:[]},J1="wrapper";function t8(t){let{components:e,...n}=t;return(0,s.kt)(J1,(0,p.Z)({},K1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}t8.isMDXComponent=!0;const e8={toc:[]},n8="wrapper";function o8(t){let{components:e,...n}=t;return(0,s.kt)(n8,(0,p.Z)({},e8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}o8.isMDXComponent=!0;const p8={toc:[]},r8="wrapper";function s8(t){let{components:e,...n}=t;return(0,s.kt)(r8,(0,p.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}s8.isMDXComponent=!0;const c8={toc:[]},a8="wrapper";function i8(t){let{components:e,...n}=t;return(0,s.kt)(a8,(0,p.Z)({},c8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}i8.isMDXComponent=!0;const l8={toc:[]},u8="wrapper";function m8(t){let{components:e,...n}=t;return(0,s.kt)(u8,(0,p.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}m8.isMDXComponent=!0;const d8={toc:[]},h8="wrapper";function f8(t){let{components:e,...n}=t;return(0,s.kt)(h8,(0,p.Z)({},d8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}f8.isMDXComponent=!0;const k8={toc:[]},y8="wrapper";function D8(t){let{components:e,...n}=t;return(0,s.kt)(y8,(0,p.Z)({},k8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}D8.isMDXComponent=!0;const M8={toc:[]},X8="wrapper";function _8(t){let{components:e,...n}=t;return(0,s.kt)(X8,(0,p.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}_8.isMDXComponent=!0;const w8={toc:[]},T8="wrapper";function C8(t){let{components:e,...n}=t;return(0,s.kt)(T8,(0,p.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}C8.isMDXComponent=!0;const g8={toc:[]},x8="wrapper";function v8(t){let{components:e,...n}=t;return(0,s.kt)(x8,(0,p.Z)({},g8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}v8.isMDXComponent=!0;const L8={toc:[]},Z8="wrapper";function b8(t){let{components:e,...n}=t;return(0,s.kt)(Z8,(0,p.Z)({},L8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}b8.isMDXComponent=!0;const N8={toc:[]},z8="wrapper";function A8(t){let{components:e,...n}=t;return(0,s.kt)(z8,(0,p.Z)({},N8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}A8.isMDXComponent=!0;const P8={toc:[]},I8="wrapper";function W8(t){let{components:e,...n}=t;return(0,s.kt)(I8,(0,p.Z)({},P8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}W8.isMDXComponent=!0;const R8={toc:[]},S8="wrapper";function B8(t){let{components:e,...n}=t;return(0,s.kt)(S8,(0,p.Z)({},R8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}B8.isMDXComponent=!0;const G8={toc:[]},E8="wrapper";function O8(t){let{components:e,...n}=t;return(0,s.kt)(E8,(0,p.Z)({},G8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}O8.isMDXComponent=!0;const U8={toc:[]},F8="wrapper";function V8(t){let{components:e,...n}=t;return(0,s.kt)(F8,(0,p.Z)({},U8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}V8.isMDXComponent=!0;const q8={toc:[]},j8="wrapper";function H8(t){let{components:e,...n}=t;return(0,s.kt)(j8,(0,p.Z)({},q8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}H8.isMDXComponent=!0;const Y8={toc:[]},Q8="wrapper";function $8(t){let{components:e,...n}=t;return(0,s.kt)(Q8,(0,p.Z)({},Y8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}$8.isMDXComponent=!0;const K8={toc:[]},J8="wrapper";function t2(t){let{components:e,...n}=t;return(0,s.kt)(J8,(0,p.Z)({},K8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}t2.isMDXComponent=!0;const e2={toc:[]},n2="wrapper";function o2(t){let{components:e,...n}=t;return(0,s.kt)(n2,(0,p.Z)({},e2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}o2.isMDXComponent=!0;const p2={toc:[]},r2="wrapper";function s2(t){let{components:e,...n}=t;return(0,s.kt)(r2,(0,p.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}s2.isMDXComponent=!0;const c2={toc:[]},a2="wrapper";function i2(t){let{components:e,...n}=t;return(0,s.kt)(a2,(0,p.Z)({},c2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}i2.isMDXComponent=!0;const l2={toc:[]},u2="wrapper";function m2(t){let{components:e,...n}=t;return(0,s.kt)(u2,(0,p.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}m2.isMDXComponent=!0;const d2={toc:[]},h2="wrapper";function f2(t){let{components:e,...n}=t;return(0,s.kt)(h2,(0,p.Z)({},d2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}f2.isMDXComponent=!0;const k2={toc:[]},y2="wrapper";function D2(t){let{components:e,...n}=t;return(0,s.kt)(y2,(0,p.Z)({},k2,n,{components:e,mdxType:"MDXLayout"}))}D2.isMDXComponent=!0;const M2={toc:[]},X2="wrapper";function _2(t){let{components:e,...n}=t;return(0,s.kt)(X2,(0,p.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_2.isMDXComponent=!0;const w2={toc:[]},T2="wrapper";function C2(t){let{components:e,...n}=t;return(0,s.kt)(T2,(0,p.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}C2.isMDXComponent=!0;const g2={toc:[]},x2="wrapper";function v2(t){let{components:e,...n}=t;return(0,s.kt)(x2,(0,p.Z)({},g2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}v2.isMDXComponent=!0;const L2={toc:[]},Z2="wrapper";function b2(t){let{components:e,...n}=t;return(0,s.kt)(Z2,(0,p.Z)({},L2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}b2.isMDXComponent=!0;const N2={toc:[]},z2="wrapper";function A2(t){let{components:e,...n}=t;return(0,s.kt)(z2,(0,p.Z)({},N2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}A2.isMDXComponent=!0;const P2={toc:[]},I2="wrapper";function W2(t){let{components:e,...n}=t;return(0,s.kt)(I2,(0,p.Z)({},P2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}W2.isMDXComponent=!0;const R2={toc:[]},S2="wrapper";function B2(t){let{components:e,...n}=t;return(0,s.kt)(S2,(0,p.Z)({},R2,n,{components:e,mdxType:"MDXLayout"}))}B2.isMDXComponent=!0;const G2={toc:[]},E2="wrapper";function O2(t){let{components:e,...n}=t;return(0,s.kt)(E2,(0,p.Z)({},G2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}O2.isMDXComponent=!0;const U2={toc:[]},F2="wrapper";function V2(t){let{components:e,...n}=t;return(0,s.kt)(F2,(0,p.Z)({},U2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}V2.isMDXComponent=!0;const q2={toc:[]},j2="wrapper";function H2(t){let{components:e,...n}=t;return(0,s.kt)(j2,(0,p.Z)({},q2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}H2.isMDXComponent=!0;const Y2={toc:[]},Q2="wrapper";function $2(t){let{components:e,...n}=t;return(0,s.kt)(Q2,(0,p.Z)({},Y2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}$2.isMDXComponent=!0;const K2={toc:[]},J2="wrapper";function t4(t){let{components:e,...n}=t;return(0,s.kt)(J2,(0,p.Z)({},K2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}t4.isMDXComponent=!0;const e4={toc:[]},n4="wrapper";function o4(t){let{components:e,...n}=t;return(0,s.kt)(n4,(0,p.Z)({},e4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}o4.isMDXComponent=!0;const p4={toc:[]},r4="wrapper";function s4(t){let{components:e,...n}=t;return(0,s.kt)(r4,(0,p.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}s4.isMDXComponent=!0;const c4={toc:[]},a4="wrapper";function i4(t){let{components:e,...n}=t;return(0,s.kt)(a4,(0,p.Z)({},c4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}i4.isMDXComponent=!0;const l4={toc:[]},u4="wrapper";function m4(t){let{components:e,...n}=t;return(0,s.kt)(u4,(0,p.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}m4.isMDXComponent=!0;const d4={toc:[]},h4="wrapper";function f4(t){let{components:e,...n}=t;return(0,s.kt)(h4,(0,p.Z)({},d4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}f4.isMDXComponent=!0;const k4={toc:[]},y4="wrapper";function D4(t){let{components:e,...n}=t;return(0,s.kt)(y4,(0,p.Z)({},k4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}D4.isMDXComponent=!0;const M4={toc:[]},X4="wrapper";function _4(t){let{components:e,...n}=t;return(0,s.kt)(X4,(0,p.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}_4.isMDXComponent=!0;const w4={toc:[]},T4="wrapper";function C4(t){let{components:e,...n}=t;return(0,s.kt)(T4,(0,p.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}C4.isMDXComponent=!0;const g4={toc:[]},x4="wrapper";function v4(t){let{components:e,...n}=t;return(0,s.kt)(x4,(0,p.Z)({},g4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}v4.isMDXComponent=!0;const L4={toc:[]},Z4="wrapper";function b4(t){let{components:e,...n}=t;return(0,s.kt)(Z4,(0,p.Z)({},L4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}b4.isMDXComponent=!0;const N4={toc:[]},z4="wrapper";function A4(t){let{components:e,...n}=t;return(0,s.kt)(z4,(0,p.Z)({},N4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}A4.isMDXComponent=!0;const P4={toc:[]},I4="wrapper";function W4(t){let{components:e,...n}=t;return(0,s.kt)(I4,(0,p.Z)({},P4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}W4.isMDXComponent=!0;const R4={toc:[]},S4="wrapper";function B4(t){let{components:e,...n}=t;return(0,s.kt)(S4,(0,p.Z)({},R4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}B4.isMDXComponent=!0;const G4={toc:[]},E4="wrapper";function O4(t){let{components:e,...n}=t;return(0,s.kt)(E4,(0,p.Z)({},G4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}O4.isMDXComponent=!0;const U4={toc:[]},F4="wrapper";function V4(t){let{components:e,...n}=t;return(0,s.kt)(F4,(0,p.Z)({},U4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}V4.isMDXComponent=!0;const q4={toc:[]},j4="wrapper";function H4(t){let{components:e,...n}=t;return(0,s.kt)(j4,(0,p.Z)({},q4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}H4.isMDXComponent=!0;const Y4={toc:[]},Q4="wrapper";function $4(t){let{components:e,...n}=t;return(0,s.kt)(Q4,(0,p.Z)({},Y4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}$4.isMDXComponent=!0;const K4={toc:[]},J4="wrapper";function t6(t){let{components:e,...n}=t;return(0,s.kt)(J4,(0,p.Z)({},K4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}t6.isMDXComponent=!0;const e6={toc:[]},n6="wrapper";function o6(t){let{components:e,...n}=t;return(0,s.kt)(n6,(0,p.Z)({},e6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}o6.isMDXComponent=!0;const p6={toc:[]},r6="wrapper";function s6(t){let{components:e,...n}=t;return(0,s.kt)(r6,(0,p.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}s6.isMDXComponent=!0;const c6={toc:[]},a6="wrapper";function i6(t){let{components:e,...n}=t;return(0,s.kt)(a6,(0,p.Z)({},c6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}i6.isMDXComponent=!0;const l6={toc:[]},u6="wrapper";function m6(t){let{components:e,...n}=t;return(0,s.kt)(u6,(0,p.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}m6.isMDXComponent=!0;const d6={toc:[]},h6="wrapper";function f6(t){let{components:e,...n}=t;return(0,s.kt)(h6,(0,p.Z)({},d6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}f6.isMDXComponent=!0;const k6={toc:[]},y6="wrapper";function D6(t){let{components:e,...n}=t;return(0,s.kt)(y6,(0,p.Z)({},k6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}D6.isMDXComponent=!0;const M6={toc:[]},X6="wrapper";function _6(t){let{components:e,...n}=t;return(0,s.kt)(X6,(0,p.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}_6.isMDXComponent=!0;const w6={toc:[]},T6="wrapper";function C6(t){let{components:e,...n}=t;return(0,s.kt)(T6,(0,p.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}C6.isMDXComponent=!0;const g6={toc:[]},x6="wrapper";function v6(t){let{components:e,...n}=t;return(0,s.kt)(x6,(0,p.Z)({},g6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}v6.isMDXComponent=!0;const L6={toc:[]},Z6="wrapper";function b6(t){let{components:e,...n}=t;return(0,s.kt)(Z6,(0,p.Z)({},L6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}b6.isMDXComponent=!0;const N6={toc:[]},z6="wrapper";function A6(t){let{components:e,...n}=t;return(0,s.kt)(z6,(0,p.Z)({},N6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}A6.isMDXComponent=!0;const P6={toc:[]},I6="wrapper";function W6(t){let{components:e,...n}=t;return(0,s.kt)(I6,(0,p.Z)({},P6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}W6.isMDXComponent=!0;const R6={toc:[]},S6="wrapper";function B6(t){let{components:e,...n}=t;return(0,s.kt)(S6,(0,p.Z)({},R6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}B6.isMDXComponent=!0;const G6={toc:[]},E6="wrapper";function O6(t){let{components:e,...n}=t;return(0,s.kt)(E6,(0,p.Z)({},G6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}O6.isMDXComponent=!0;const U6={toc:[]},F6="wrapper";function V6(t){let{components:e,...n}=t;return(0,s.kt)(F6,(0,p.Z)({},U6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}V6.isMDXComponent=!0;const q6={toc:[]},j6="wrapper";function H6(t){let{components:e,...n}=t;return(0,s.kt)(j6,(0,p.Z)({},q6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}H6.isMDXComponent=!0;const Y6={toc:[]},Q6="wrapper";function $6(t){let{components:e,...n}=t;return(0,s.kt)(Q6,(0,p.Z)({},Y6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}$6.isMDXComponent=!0;const K6={toc:[]},J6="wrapper";function t5(t){let{components:e,...n}=t;return(0,s.kt)(J6,(0,p.Z)({},K6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}t5.isMDXComponent=!0;const e5={toc:[]},n5="wrapper";function o5(t){let{components:e,...n}=t;return(0,s.kt)(n5,(0,p.Z)({},e5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}o5.isMDXComponent=!0;const p5={toc:[]},r5="wrapper";function s5(t){let{components:e,...n}=t;return(0,s.kt)(r5,(0,p.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}s5.isMDXComponent=!0;const c5={toc:[]},a5="wrapper";function i5(t){let{components:e,...n}=t;return(0,s.kt)(a5,(0,p.Z)({},c5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}i5.isMDXComponent=!0;const l5={toc:[]},u5="wrapper";function m5(t){let{components:e,...n}=t;return(0,s.kt)(u5,(0,p.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}m5.isMDXComponent=!0;const d5={toc:[]},h5="wrapper";function f5(t){let{components:e,...n}=t;return(0,s.kt)(h5,(0,p.Z)({},d5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}f5.isMDXComponent=!0;const k5={toc:[]},y5="wrapper";function D5(t){let{components:e,...n}=t;return(0,s.kt)(y5,(0,p.Z)({},k5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}D5.isMDXComponent=!0;const M5={toc:[]},X5="wrapper";function _5(t){let{components:e,...n}=t;return(0,s.kt)(X5,(0,p.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}_5.isMDXComponent=!0;const w5={toc:[]},T5="wrapper";function C5(t){let{components:e,...n}=t;return(0,s.kt)(T5,(0,p.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}C5.isMDXComponent=!0;const g5={toc:[]},x5="wrapper";function v5(t){let{components:e,...n}=t;return(0,s.kt)(x5,(0,p.Z)({},g5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}v5.isMDXComponent=!0;const L5={toc:[]},Z5="wrapper";function b5(t){let{components:e,...n}=t;return(0,s.kt)(Z5,(0,p.Z)({},L5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}b5.isMDXComponent=!0;const N5={toc:[]},z5="wrapper";function A5(t){let{components:e,...n}=t;return(0,s.kt)(z5,(0,p.Z)({},N5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}A5.isMDXComponent=!0;const P5={toc:[]},I5="wrapper";function W5(t){let{components:e,...n}=t;return(0,s.kt)(I5,(0,p.Z)({},P5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}W5.isMDXComponent=!0;const R5={toc:[]},S5="wrapper";function B5(t){let{components:e,...n}=t;return(0,s.kt)(S5,(0,p.Z)({},R5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}B5.isMDXComponent=!0;const G5={toc:[]},E5="wrapper";function O5(t){let{components:e,...n}=t;return(0,s.kt)(E5,(0,p.Z)({},G5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}O5.isMDXComponent=!0;const U5={toc:[]},F5="wrapper";function V5(t){let{components:e,...n}=t;return(0,s.kt)(F5,(0,p.Z)({},U5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}V5.isMDXComponent=!0;const q5={toc:[]},j5="wrapper";function H5(t){let{components:e,...n}=t;return(0,s.kt)(j5,(0,p.Z)({},q5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}H5.isMDXComponent=!0;const Y5={toc:[]},Q5="wrapper";function $5(t){let{components:e,...n}=t;return(0,s.kt)(Q5,(0,p.Z)({},Y5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$5.isMDXComponent=!0;const K5={toc:[]},J5="wrapper";function t7(t){let{components:e,...n}=t;return(0,s.kt)(J5,(0,p.Z)({},K5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}t7.isMDXComponent=!0;const e7={toc:[]},n7="wrapper";function o7(t){let{components:e,...n}=t;return(0,s.kt)(n7,(0,p.Z)({},e7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}o7.isMDXComponent=!0;const p7={toc:[]},r7="wrapper";function s7(t){let{components:e,...n}=t;return(0,s.kt)(r7,(0,p.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}s7.isMDXComponent=!0;const c7={toc:[]},a7="wrapper";function i7(t){let{components:e,...n}=t;return(0,s.kt)(a7,(0,p.Z)({},c7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}i7.isMDXComponent=!0;const l7={toc:[]},u7="wrapper";function m7(t){let{components:e,...n}=t;return(0,s.kt)(u7,(0,p.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}m7.isMDXComponent=!0;const d7={toc:[]},h7="wrapper";function f7(t){let{components:e,...n}=t;return(0,s.kt)(h7,(0,p.Z)({},d7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}f7.isMDXComponent=!0;const k7={toc:[]},y7="wrapper";function D7(t){let{components:e,...n}=t;return(0,s.kt)(y7,(0,p.Z)({},k7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}D7.isMDXComponent=!0;const M7={toc:[]},X7="wrapper";function _7(t){let{components:e,...n}=t;return(0,s.kt)(X7,(0,p.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}_7.isMDXComponent=!0;const w7={toc:[]},T7="wrapper";function C7(t){let{components:e,...n}=t;return(0,s.kt)(T7,(0,p.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}C7.isMDXComponent=!0;const g7={toc:[]},x7="wrapper";function v7(t){let{components:e,...n}=t;return(0,s.kt)(x7,(0,p.Z)({},g7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}v7.isMDXComponent=!0;const L7={toc:[]},Z7="wrapper";function b7(t){let{components:e,...n}=t;return(0,s.kt)(Z7,(0,p.Z)({},L7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}b7.isMDXComponent=!0;const N7={toc:[]},z7="wrapper";function A7(t){let{components:e,...n}=t;return(0,s.kt)(z7,(0,p.Z)({},N7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}A7.isMDXComponent=!0;const P7={toc:[]},I7="wrapper";function W7(t){let{components:e,...n}=t;return(0,s.kt)(I7,(0,p.Z)({},P7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}W7.isMDXComponent=!0;const R7={toc:[]},S7="wrapper";function B7(t){let{components:e,...n}=t;return(0,s.kt)(S7,(0,p.Z)({},R7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}B7.isMDXComponent=!0;const G7={toc:[]},E7="wrapper";function O7(t){let{components:e,...n}=t;return(0,s.kt)(E7,(0,p.Z)({},G7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}O7.isMDXComponent=!0;const U7={toc:[]},F7="wrapper";function V7(t){let{components:e,...n}=t;return(0,s.kt)(F7,(0,p.Z)({},U7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}V7.isMDXComponent=!0;const q7={toc:[]},j7="wrapper";function H7(t){let{components:e,...n}=t;return(0,s.kt)(j7,(0,p.Z)({},q7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}H7.isMDXComponent=!0;const Y7={toc:[]},Q7="wrapper";function $7(t){let{components:e,...n}=t;return(0,s.kt)(Q7,(0,p.Z)({},Y7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}$7.isMDXComponent=!0;const K7={toc:[]},J7="wrapper";function t9(t){let{components:e,...n}=t;return(0,s.kt)(J7,(0,p.Z)({},K7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}t9.isMDXComponent=!0;const e9={toc:[]},n9="wrapper";function o9(t){let{components:e,...n}=t;return(0,s.kt)(n9,(0,p.Z)({},e9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}o9.isMDXComponent=!0;const p9={toc:[]},r9="wrapper";function s9(t){let{components:e,...n}=t;return(0,s.kt)(r9,(0,p.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}s9.isMDXComponent=!0;const c9={toc:[]},a9="wrapper";function i9(t){let{components:e,...n}=t;return(0,s.kt)(a9,(0,p.Z)({},c9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}i9.isMDXComponent=!0;const l9={toc:[]},u9="wrapper";function m9(t){let{components:e,...n}=t;return(0,s.kt)(u9,(0,p.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}m9.isMDXComponent=!0;const d9={toc:[]},h9="wrapper";function f9(t){let{components:e,...n}=t;return(0,s.kt)(h9,(0,p.Z)({},d9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}f9.isMDXComponent=!0;const k9={toc:[]},y9="wrapper";function D9(t){let{components:e,...n}=t;return(0,s.kt)(y9,(0,p.Z)({},k9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}D9.isMDXComponent=!0;const M9={toc:[]},X9="wrapper";function _9(t){let{components:e,...n}=t;return(0,s.kt)(X9,(0,p.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}_9.isMDXComponent=!0;const w9={toc:[]},T9="wrapper";function C9(t){let{components:e,...n}=t;return(0,s.kt)(T9,(0,p.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}C9.isMDXComponent=!0;const g9={toc:[]},x9="wrapper";function v9(t){let{components:e,...n}=t;return(0,s.kt)(x9,(0,p.Z)({},g9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}v9.isMDXComponent=!0;const L9={toc:[]},Z9="wrapper";function b9(t){let{components:e,...n}=t;return(0,s.kt)(Z9,(0,p.Z)({},L9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}b9.isMDXComponent=!0;const N9={toc:[]},z9="wrapper";function A9(t){let{components:e,...n}=t;return(0,s.kt)(z9,(0,p.Z)({},N9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}A9.isMDXComponent=!0;const P9={toc:[]},I9="wrapper";function W9(t){let{components:e,...n}=t;return(0,s.kt)(I9,(0,p.Z)({},P9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}W9.isMDXComponent=!0;const R9={toc:[]},S9="wrapper";function B9(t){let{components:e,...n}=t;return(0,s.kt)(S9,(0,p.Z)({},R9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}B9.isMDXComponent=!0;const G9={toc:[]},E9="wrapper";function O9(t){let{components:e,...n}=t;return(0,s.kt)(E9,(0,p.Z)({},G9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}O9.isMDXComponent=!0;const U9={toc:[]},F9="wrapper";function V9(t){let{components:e,...n}=t;return(0,s.kt)(F9,(0,p.Z)({},U9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}V9.isMDXComponent=!0;const q9={toc:[]},j9="wrapper";function H9(t){let{components:e,...n}=t;return(0,s.kt)(j9,(0,p.Z)({},q9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}H9.isMDXComponent=!0;const Y9={toc:[]},Q9="wrapper";function $9(t){let{components:e,...n}=t;return(0,s.kt)(Q9,(0,p.Z)({},Y9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}$9.isMDXComponent=!0;const K9={toc:[]},J9="wrapper";function ttt(t){let{components:e,...n}=t;return(0,s.kt)(J9,(0,p.Z)({},K9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ttt.isMDXComponent=!0;const ett={toc:[]},ntt="wrapper";function ott(t){let{components:e,...n}=t;return(0,s.kt)(ntt,(0,p.Z)({},ett,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}ott.isMDXComponent=!0;const ptt={toc:[]},rtt="wrapper";function stt(t){let{components:e,...n}=t;return(0,s.kt)(rtt,(0,p.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}stt.isMDXComponent=!0;const ctt={toc:[]},att="wrapper";function itt(t){let{components:e,...n}=t;return(0,s.kt)(att,(0,p.Z)({},ctt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}itt.isMDXComponent=!0;const ltt={toc:[]},utt="wrapper";function mtt(t){let{components:e,...n}=t;return(0,s.kt)(utt,(0,p.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}mtt.isMDXComponent=!0;const dtt={toc:[]},htt="wrapper";function ftt(t){let{components:e,...n}=t;return(0,s.kt)(htt,(0,p.Z)({},dtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ftt.isMDXComponent=!0;const ktt={toc:[]},ytt="wrapper";function Dtt(t){let{components:e,...n}=t;return(0,s.kt)(ytt,(0,p.Z)({},ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Dtt.isMDXComponent=!0;const Mtt={toc:[]},Xtt="wrapper";function _tt(t){let{components:e,...n}=t;return(0,s.kt)(Xtt,(0,p.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}_tt.isMDXComponent=!0;const wtt={toc:[]},Ttt="wrapper";function Ctt(t){let{components:e,...n}=t;return(0,s.kt)(Ttt,(0,p.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Ctt.isMDXComponent=!0;const gtt={toc:[]},xtt="wrapper";function vtt(t){let{components:e,...n}=t;return(0,s.kt)(xtt,(0,p.Z)({},gtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}vtt.isMDXComponent=!0;const Ltt={toc:[]},Ztt="wrapper";function btt(t){let{components:e,...n}=t;return(0,s.kt)(Ztt,(0,p.Z)({},Ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}btt.isMDXComponent=!0;const Ntt={toc:[]},ztt="wrapper";function Att(t){let{components:e,...n}=t;return(0,s.kt)(ztt,(0,p.Z)({},Ntt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Att.isMDXComponent=!0;const Ptt={toc:[]},Itt="wrapper";function Wtt(t){let{components:e,...n}=t;return(0,s.kt)(Itt,(0,p.Z)({},Ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Wtt.isMDXComponent=!0;const Rtt={toc:[]},Stt="wrapper";function Btt(t){let{components:e,...n}=t;return(0,s.kt)(Stt,(0,p.Z)({},Rtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Btt.isMDXComponent=!0;const Gtt={toc:[]},Ett="wrapper";function Ott(t){let{components:e,...n}=t;return(0,s.kt)(Ett,(0,p.Z)({},Gtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Ott.isMDXComponent=!0;const Utt={toc:[]},Ftt="wrapper";function Vtt(t){let{components:e,...n}=t;return(0,s.kt)(Ftt,(0,p.Z)({},Utt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Vtt.isMDXComponent=!0;const qtt={toc:[]},jtt="wrapper";function Htt(t){let{components:e,...n}=t;return(0,s.kt)(jtt,(0,p.Z)({},qtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Htt.isMDXComponent=!0;const Ytt={toc:[]},Qtt="wrapper";function $tt(t){let{components:e,...n}=t;return(0,s.kt)(Qtt,(0,p.Z)({},Ytt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}$tt.isMDXComponent=!0;const Ktt={toc:[]},Jtt="wrapper";function tet(t){let{components:e,...n}=t;return(0,s.kt)(Jtt,(0,p.Z)({},Ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}tet.isMDXComponent=!0;const eet={toc:[]},net="wrapper";function oet(t){let{components:e,...n}=t;return(0,s.kt)(net,(0,p.Z)({},eet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oet.isMDXComponent=!0;const pet={toc:[]},ret="wrapper";function set(t){let{components:e,...n}=t;return(0,s.kt)(ret,(0,p.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}set.isMDXComponent=!0;const cet={toc:[]},aet="wrapper";function iet(t){let{components:e,...n}=t;return(0,s.kt)(aet,(0,p.Z)({},cet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}iet.isMDXComponent=!0;const uet={toc:[]},met="wrapper";function det(t){let{components:e,...n}=t;return(0,s.kt)(met,(0,p.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}det.isMDXComponent=!0;const het={toc:[]},fet="wrapper";function ket(t){let{components:e,...n}=t;return(0,s.kt)(fet,(0,p.Z)({},het,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}ket.isMDXComponent=!0;const yet={toc:[]},Det="wrapper";function Met(t){let{components:e,...n}=t;return(0,s.kt)(Det,(0,p.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}Met.isMDXComponent=!0;const Xet={toc:[]},_et="wrapper";function wet(t){let{components:e,...n}=t;return(0,s.kt)(_et,(0,p.Z)({},Xet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}wet.isMDXComponent=!0;const Tet={toc:[]},Cet="wrapper";function get(t){let{components:e,...n}=t;return(0,s.kt)(Cet,(0,p.Z)({},Tet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}get.isMDXComponent=!0;const xet={toc:[]},vet="wrapper";function Let(t){let{components:e,...n}=t;return(0,s.kt)(vet,(0,p.Z)({},xet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Let.isMDXComponent=!0;const Zet={toc:[]},bet="wrapper";function Net(t){let{components:e,...n}=t;return(0,s.kt)(bet,(0,p.Z)({},Zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Net.isMDXComponent=!0;const zet={toc:[]},Aet="wrapper";function Pet(t){let{components:e,...n}=t;return(0,s.kt)(Aet,(0,p.Z)({},zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}Pet.isMDXComponent=!0;const Iet={toc:[]},Wet="wrapper";function Ret(t){let{components:e,...n}=t;return(0,s.kt)(Wet,(0,p.Z)({},Iet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Ret.isMDXComponent=!0;const Set={toc:[]},Bet="wrapper";function Get(t){let{components:e,...n}=t;return(0,s.kt)(Bet,(0,p.Z)({},Set,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Get.isMDXComponent=!0;const Eet={toc:[]},Oet="wrapper";function Uet(t){let{components:e,...n}=t;return(0,s.kt)(Oet,(0,p.Z)({},Eet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Uet.isMDXComponent=!0;const Fet={toc:[]},Vet="wrapper";function qet(t){let{components:e,...n}=t;return(0,s.kt)(Vet,(0,p.Z)({},Fet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qet.isMDXComponent=!0;const jet={toc:[]},Het="wrapper";function Yet(t){let{components:e,...n}=t;return(0,s.kt)(Het,(0,p.Z)({},jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Yet.isMDXComponent=!0;const Qet={toc:[]},$et="wrapper";function Ket(t){let{components:e,...n}=t;return(0,s.kt)($et,(0,p.Z)({},Qet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ket.isMDXComponent=!0;const Jet={toc:[]},tnt="wrapper";function ent(t){let{components:e,...n}=t;return(0,s.kt)(tnt,(0,p.Z)({},Jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}ent.isMDXComponent=!0;const nnt={toc:[]},ont="wrapper";function pnt(t){let{components:e,...n}=t;return(0,s.kt)(ont,(0,p.Z)({},nnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}pnt.isMDXComponent=!0;const rnt={toc:[]},snt="wrapper";function cnt(t){let{components:e,...n}=t;return(0,s.kt)(snt,(0,p.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}cnt.isMDXComponent=!0;const ant={toc:[]},int="wrapper";function lnt(t){let{components:e,...n}=t;return(0,s.kt)(int,(0,p.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}lnt.isMDXComponent=!0;const unt={toc:[]},mnt="wrapper";function dnt(t){let{components:e,...n}=t;return(0,s.kt)(mnt,(0,p.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dnt.isMDXComponent=!0;const hnt={toc:[]},fnt="wrapper";function knt(t){let{components:e,...n}=t;return(0,s.kt)(fnt,(0,p.Z)({},hnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}knt.isMDXComponent=!0;const ynt={toc:[]},Dnt="wrapper";function Mnt(t){let{components:e,...n}=t;return(0,s.kt)(Dnt,(0,p.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Mnt.isMDXComponent=!0;const Xnt={toc:[]},_nt="wrapper";function wnt(t){let{components:e,...n}=t;return(0,s.kt)(_nt,(0,p.Z)({},Xnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}wnt.isMDXComponent=!0;const Tnt={toc:[]},Cnt="wrapper";function gnt(t){let{components:e,...n}=t;return(0,s.kt)(Cnt,(0,p.Z)({},Tnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gnt.isMDXComponent=!0;const xnt={toc:[]},vnt="wrapper";function Lnt(t){let{components:e,...n}=t;return(0,s.kt)(vnt,(0,p.Z)({},xnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Lnt.isMDXComponent=!0;const Znt={toc:[]},bnt="wrapper";function Nnt(t){let{components:e,...n}=t;return(0,s.kt)(bnt,(0,p.Z)({},Znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Nnt.isMDXComponent=!0;const znt={toc:[]},Ant="wrapper";function Pnt(t){let{components:e,...n}=t;return(0,s.kt)(Ant,(0,p.Z)({},znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Pnt.isMDXComponent=!0;const Int={toc:[]},Wnt="wrapper";function Rnt(t){let{components:e,...n}=t;return(0,s.kt)(Wnt,(0,p.Z)({},Int,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Rnt.isMDXComponent=!0;const Snt={toc:[]},Bnt="wrapper";function Gnt(t){let{components:e,...n}=t;return(0,s.kt)(Bnt,(0,p.Z)({},Snt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Gnt.isMDXComponent=!0;const Ent={toc:[]},Ont="wrapper";function Unt(t){let{components:e,...n}=t;return(0,s.kt)(Ont,(0,p.Z)({},Ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Unt.isMDXComponent=!0;const Fnt={toc:[]},Vnt="wrapper";function qnt(t){let{components:e,...n}=t;return(0,s.kt)(Vnt,(0,p.Z)({},Fnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}qnt.isMDXComponent=!0;const jnt={toc:[]},Hnt="wrapper";function Ynt(t){let{components:e,...n}=t;return(0,s.kt)(Hnt,(0,p.Z)({},jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Ynt.isMDXComponent=!0;const Qnt={toc:[]},$nt="wrapper";function Knt(t){let{components:e,...n}=t;return(0,s.kt)($nt,(0,p.Z)({},Qnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Knt.isMDXComponent=!0;const Jnt={toc:[]},tot="wrapper";function eot(t){let{components:e,...n}=t;return(0,s.kt)(tot,(0,p.Z)({},Jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}eot.isMDXComponent=!0;const not={toc:[]},oot="wrapper";function pot(t){let{components:e,...n}=t;return(0,s.kt)(oot,(0,p.Z)({},not,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pot.isMDXComponent=!0;const rot={toc:[]},sot="wrapper";function cot(t){let{components:e,...n}=t;return(0,s.kt)(sot,(0,p.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cot.isMDXComponent=!0;const aot={toc:[]},iot="wrapper";function lot(t){let{components:e,...n}=t;return(0,s.kt)(iot,(0,p.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}lot.isMDXComponent=!0;const uot={toc:[]},mot="wrapper";function dot(t){let{components:e,...n}=t;return(0,s.kt)(mot,(0,p.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}dot.isMDXComponent=!0;const hot={toc:[]},fot="wrapper";function kot(t){let{components:e,...n}=t;return(0,s.kt)(fot,(0,p.Z)({},hot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}kot.isMDXComponent=!0;const yot={toc:[]},Dot="wrapper";function Mot(t){let{components:e,...n}=t;return(0,s.kt)(Dot,(0,p.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Mot.isMDXComponent=!0;const Xot={toc:[]},_ot="wrapper";function wot(t){let{components:e,...n}=t;return(0,s.kt)(_ot,(0,p.Z)({},Xot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}wot.isMDXComponent=!0;const Tot={toc:[]},Cot="wrapper";function got(t){let{components:e,...n}=t;return(0,s.kt)(Cot,(0,p.Z)({},Tot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}got.isMDXComponent=!0;const xot={toc:[]},vot="wrapper";function Lot(t){let{components:e,...n}=t;return(0,s.kt)(vot,(0,p.Z)({},xot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Lot.isMDXComponent=!0;const Zot={toc:[]},bot="wrapper";function Not(t){let{components:e,...n}=t;return(0,s.kt)(bot,(0,p.Z)({},Zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Not.isMDXComponent=!0;const zot={toc:[]},Aot="wrapper";function Pot(t){let{components:e,...n}=t;return(0,s.kt)(Aot,(0,p.Z)({},zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Pot.isMDXComponent=!0;const Iot={toc:[]},Wot="wrapper";function Rot(t){let{components:e,...n}=t;return(0,s.kt)(Wot,(0,p.Z)({},Iot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Rot.isMDXComponent=!0;const Sot={toc:[]},Bot="wrapper";function Got(t){let{components:e,...n}=t;return(0,s.kt)(Bot,(0,p.Z)({},Sot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Got.isMDXComponent=!0;const Eot={toc:[]},Oot="wrapper";function Uot(t){let{components:e,...n}=t;return(0,s.kt)(Oot,(0,p.Z)({},Eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Uot.isMDXComponent=!0;const Fot={toc:[]},Vot="wrapper";function qot(t){let{components:e,...n}=t;return(0,s.kt)(Vot,(0,p.Z)({},Fot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qot.isMDXComponent=!0;const jot={toc:[]},Hot="wrapper";function Yot(t){let{components:e,...n}=t;return(0,s.kt)(Hot,(0,p.Z)({},jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Yot.isMDXComponent=!0;const Qot={toc:[]},$ot="wrapper";function Kot(t){let{components:e,...n}=t;return(0,s.kt)($ot,(0,p.Z)({},Qot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Kot.isMDXComponent=!0;const Jot={toc:[]},tpt="wrapper";function ept(t){let{components:e,...n}=t;return(0,s.kt)(tpt,(0,p.Z)({},Jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ept.isMDXComponent=!0;const npt={toc:[]},opt="wrapper";function ppt(t){let{components:e,...n}=t;return(0,s.kt)(opt,(0,p.Z)({},npt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ppt.isMDXComponent=!0;const rpt={toc:[]},spt="wrapper";function cpt(t){let{components:e,...n}=t;return(0,s.kt)(spt,(0,p.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cpt.isMDXComponent=!0;const apt={toc:[]},ipt="wrapper";function lpt(t){let{components:e,...n}=t;return(0,s.kt)(ipt,(0,p.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lpt.isMDXComponent=!0;const upt={toc:[]},mpt="wrapper";function dpt(t){let{components:e,...n}=t;return(0,s.kt)(mpt,(0,p.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}dpt.isMDXComponent=!0;const hpt={toc:[]},fpt="wrapper";function kpt(t){let{components:e,...n}=t;return(0,s.kt)(fpt,(0,p.Z)({},hpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}kpt.isMDXComponent=!0;const ypt={toc:[]},Dpt="wrapper";function Mpt(t){let{components:e,...n}=t;return(0,s.kt)(Dpt,(0,p.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}Mpt.isMDXComponent=!0;const Xpt={toc:[]},_pt="wrapper";function wpt(t){let{components:e,...n}=t;return(0,s.kt)(_pt,(0,p.Z)({},Xpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}wpt.isMDXComponent=!0;const Tpt={toc:[]},Cpt="wrapper";function gpt(t){let{components:e,...n}=t;return(0,s.kt)(Cpt,(0,p.Z)({},Tpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}gpt.isMDXComponent=!0;const xpt={toc:[]},vpt="wrapper";function Lpt(t){let{components:e,...n}=t;return(0,s.kt)(vpt,(0,p.Z)({},xpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]},bpt="wrapper";function Npt(t){let{components:e,...n}=t;return(0,s.kt)(bpt,(0,p.Z)({},Zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Npt.isMDXComponent=!0;const zpt={toc:[]},Apt="wrapper";function Ppt(t){let{components:e,...n}=t;return(0,s.kt)(Apt,(0,p.Z)({},zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Ppt.isMDXComponent=!0;const Ipt={toc:[]},Wpt="wrapper";function Rpt(t){let{components:e,...n}=t;return(0,s.kt)(Wpt,(0,p.Z)({},Ipt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Rpt.isMDXComponent=!0;const Spt={toc:[]},Bpt="wrapper";function Gpt(t){let{components:e,...n}=t;return(0,s.kt)(Bpt,(0,p.Z)({},Spt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Gpt.isMDXComponent=!0;const Ept={toc:[]},Opt="wrapper";function Upt(t){let{components:e,...n}=t;return(0,s.kt)(Opt,(0,p.Z)({},Ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Upt.isMDXComponent=!0;const Fpt={toc:[]},Vpt="wrapper";function qpt(t){let{components:e,...n}=t;return(0,s.kt)(Vpt,(0,p.Z)({},Fpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}qpt.isMDXComponent=!0;const jpt={toc:[]},Hpt="wrapper";function Ypt(t){let{components:e,...n}=t;return(0,s.kt)(Hpt,(0,p.Z)({},jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Ypt.isMDXComponent=!0;const Qpt={toc:[]},$pt="wrapper";function Kpt(t){let{components:e,...n}=t;return(0,s.kt)($pt,(0,p.Z)({},Qpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]},trt="wrapper";function ert(t){let{components:e,...n}=t;return(0,s.kt)(trt,(0,p.Z)({},Jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ert.isMDXComponent=!0;const nrt={toc:[]},ort="wrapper";function prt(t){let{components:e,...n}=t;return(0,s.kt)(ort,(0,p.Z)({},nrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}prt.isMDXComponent=!0;const rrt={toc:[]},srt="wrapper";function crt(t){let{components:e,...n}=t;return(0,s.kt)(srt,(0,p.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}crt.isMDXComponent=!0;const art={toc:[]},irt="wrapper";function lrt(t){let{components:e,...n}=t;return(0,s.kt)(irt,(0,p.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lrt.isMDXComponent=!0;const urt={toc:[]},mrt="wrapper";function drt(t){let{components:e,...n}=t;return(0,s.kt)(mrt,(0,p.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}drt.isMDXComponent=!0;const hrt={toc:[]},frt="wrapper";function krt(t){let{components:e,...n}=t;return(0,s.kt)(frt,(0,p.Z)({},hrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}krt.isMDXComponent=!0;const yrt={toc:[]},Drt="wrapper";function Mrt(t){let{components:e,...n}=t;return(0,s.kt)(Drt,(0,p.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Mrt.isMDXComponent=!0;const Xrt={toc:[]},_rt="wrapper";function wrt(t){let{components:e,...n}=t;return(0,s.kt)(_rt,(0,p.Z)({},Xrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}wrt.isMDXComponent=!0;const Trt={toc:[]},Crt="wrapper";function grt(t){let{components:e,...n}=t;return(0,s.kt)(Crt,(0,p.Z)({},Trt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}grt.isMDXComponent=!0;const xrt={toc:[]},vrt="wrapper";function Lrt(t){let{components:e,...n}=t;return(0,s.kt)(vrt,(0,p.Z)({},xrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}Lrt.isMDXComponent=!0;const Zrt={toc:[]},brt="wrapper";function Nrt(t){let{components:e,...n}=t;return(0,s.kt)(brt,(0,p.Z)({},Zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}Nrt.isMDXComponent=!0;const zrt={toc:[]},Art="wrapper";function Prt(t){let{components:e,...n}=t;return(0,s.kt)(Art,(0,p.Z)({},zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}Prt.isMDXComponent=!0;const Irt={toc:[]},Wrt="wrapper";function Rrt(t){let{components:e,...n}=t;return(0,s.kt)(Wrt,(0,p.Z)({},Irt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}Rrt.isMDXComponent=!0;const Srt={toc:[]},Brt="wrapper";function Grt(t){let{components:e,...n}=t;return(0,s.kt)(Brt,(0,p.Z)({},Srt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Grt.isMDXComponent=!0;const Ert={toc:[]},Ort="wrapper";function Urt(t){let{components:e,...n}=t;return(0,s.kt)(Ort,(0,p.Z)({},Ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Urt.isMDXComponent=!0;const Frt={toc:[]},Vrt="wrapper";function qrt(t){let{components:e,...n}=t;return(0,s.kt)(Vrt,(0,p.Z)({},Frt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}qrt.isMDXComponent=!0;const jrt={toc:[]},Hrt="wrapper";function Yrt(t){let{components:e,...n}=t;return(0,s.kt)(Hrt,(0,p.Z)({},jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}Yrt.isMDXComponent=!0;const Qrt={toc:[]},$rt="wrapper";function Krt(t){let{components:e,...n}=t;return(0,s.kt)($rt,(0,p.Z)({},Qrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}Krt.isMDXComponent=!0;const Jrt={toc:[]},tst="wrapper";function est(t){let{components:e,...n}=t;return(0,s.kt)(tst,(0,p.Z)({},Jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}est.isMDXComponent=!0;const nst={toc:[]},ost="wrapper";function pst(t){let{components:e,...n}=t;return(0,s.kt)(ost,(0,p.Z)({},nst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}pst.isMDXComponent=!0;const rst={toc:[]},sst="wrapper";function cst(t){let{components:e,...n}=t;return(0,s.kt)(sst,(0,p.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}cst.isMDXComponent=!0;const ast={toc:[]},ist="wrapper";function lst(t){let{components:e,...n}=t;return(0,s.kt)(ist,(0,p.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}lst.isMDXComponent=!0;const ust={toc:[]},mst="wrapper";function dst(t){let{components:e,...n}=t;return(0,s.kt)(mst,(0,p.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}dst.isMDXComponent=!0;const hst={toc:[]},fst="wrapper";function kst(t){let{components:e,...n}=t;return(0,s.kt)(fst,(0,p.Z)({},hst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}kst.isMDXComponent=!0;const yst={toc:[]},Dst="wrapper";function Mst(t){let{components:e,...n}=t;return(0,s.kt)(Dst,(0,p.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Mst.isMDXComponent=!0;const Xst={toc:[]},_st="wrapper";function wst(t){let{components:e,...n}=t;return(0,s.kt)(_st,(0,p.Z)({},Xst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}wst.isMDXComponent=!0;const Tst={toc:[]},Cst="wrapper";function gst(t){let{components:e,...n}=t;return(0,s.kt)(Cst,(0,p.Z)({},Tst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gst.isMDXComponent=!0;const xst={toc:[]},vst="wrapper";function Lst(t){let{components:e,...n}=t;return(0,s.kt)(vst,(0,p.Z)({},xst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Lst.isMDXComponent=!0;const Zst={toc:[]},bst="wrapper";function Nst(t){let{components:e,...n}=t;return(0,s.kt)(bst,(0,p.Z)({},Zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Nst.isMDXComponent=!0;const zst={toc:[]},Ast="wrapper";function Pst(t){let{components:e,...n}=t;return(0,s.kt)(Ast,(0,p.Z)({},zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Pst.isMDXComponent=!0;const Ist={toc:[]},Wst="wrapper";function Rst(t){let{components:e,...n}=t;return(0,s.kt)(Wst,(0,p.Z)({},Ist,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Rst.isMDXComponent=!0;const Sst={toc:[]},Bst="wrapper";function Gst(t){let{components:e,...n}=t;return(0,s.kt)(Bst,(0,p.Z)({},Sst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Gst.isMDXComponent=!0;const Est={toc:[]},Ost="wrapper";function Ust(t){let{components:e,...n}=t;return(0,s.kt)(Ost,(0,p.Z)({},Est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Ust.isMDXComponent=!0;const Fst={toc:[]},Vst="wrapper";function qst(t){let{components:e,...n}=t;return(0,s.kt)(Vst,(0,p.Z)({},Fst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qst.isMDXComponent=!0;const jst={toc:[]},Hst="wrapper";function Yst(t){let{components:e,...n}=t;return(0,s.kt)(Hst,(0,p.Z)({},jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Yst.isMDXComponent=!0;const Qst={toc:[]},$st="wrapper";function Kst(t){let{components:e,...n}=t;return(0,s.kt)($st,(0,p.Z)({},Qst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Kst.isMDXComponent=!0;const Jst={toc:[]},tct="wrapper";function ect(t){let{components:e,...n}=t;return(0,s.kt)(tct,(0,p.Z)({},Jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}ect.isMDXComponent=!0;const nct={toc:[]},oct="wrapper";function pct(t){let{components:e,...n}=t;return(0,s.kt)(oct,(0,p.Z)({},nct,n,{components:e,mdxType:"MDXLayout"}))}pct.isMDXComponent=!0;const rct={toc:[]},sct="wrapper";function cct(t){let{components:e,...n}=t;return(0,s.kt)(sct,(0,p.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cct.isMDXComponent=!0;const act={toc:[]},ict="wrapper";function lct(t){let{components:e,...n}=t;return(0,s.kt)(ict,(0,p.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lct.isMDXComponent=!0;const uct={toc:[]},mct="wrapper";function dct(t){let{components:e,...n}=t;return(0,s.kt)(mct,(0,p.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}dct.isMDXComponent=!0;const hct={toc:[]},fct="wrapper";function kct(t){let{components:e,...n}=t;return(0,s.kt)(fct,(0,p.Z)({},hct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}kct.isMDXComponent=!0;const yct={toc:[]},Dct="wrapper";function Mct(t){let{components:e,...n}=t;return(0,s.kt)(Dct,(0,p.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Mct.isMDXComponent=!0;const Xct={toc:[]},_ct="wrapper";function wct(t){let{components:e,...n}=t;return(0,s.kt)(_ct,(0,p.Z)({},Xct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}wct.isMDXComponent=!0;const Tct={toc:[]},Cct="wrapper";function gct(t){let{components:e,...n}=t;return(0,s.kt)(Cct,(0,p.Z)({},Tct,n,{components:e,mdxType:"MDXLayout"}))}gct.isMDXComponent=!0;const xct={toc:[]},vct="wrapper";function Lct(t){let{components:e,...n}=t;return(0,s.kt)(vct,(0,p.Z)({},xct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Lct.isMDXComponent=!0;const Zct={toc:[]},bct="wrapper";function Nct(t){let{components:e,...n}=t;return(0,s.kt)(bct,(0,p.Z)({},Zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Nct.isMDXComponent=!0;const zct={toc:[]},Act="wrapper";function Pct(t){let{components:e,...n}=t;return(0,s.kt)(Act,(0,p.Z)({},zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Pct.isMDXComponent=!0;const Ict={toc:[]},Wct="wrapper";function Rct(t){let{components:e,...n}=t;return(0,s.kt)(Wct,(0,p.Z)({},Ict,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}Rct.isMDXComponent=!0;const Sct={toc:[]},Bct="wrapper";function Gct(t){let{components:e,...n}=t;return(0,s.kt)(Bct,(0,p.Z)({},Sct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}Gct.isMDXComponent=!0;const Ect={toc:[]},Oct="wrapper";function Uct(t){let{components:e,...n}=t;return(0,s.kt)(Oct,(0,p.Z)({},Ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Uct.isMDXComponent=!0;const Fct={toc:[]},Vct="wrapper";function qct(t){let{components:e,...n}=t;return(0,s.kt)(Vct,(0,p.Z)({},Fct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qct.isMDXComponent=!0;const jct={toc:[]},Hct="wrapper";function Yct(t){let{components:e,...n}=t;return(0,s.kt)(Hct,(0,p.Z)({},jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Yct.isMDXComponent=!0;const Qct={toc:[]},$ct="wrapper";function Kct(t){let{components:e,...n}=t;return(0,s.kt)($ct,(0,p.Z)({},Qct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Kct.isMDXComponent=!0;const Jct={toc:[]},tat="wrapper";function eat(t){let{components:e,...n}=t;return(0,s.kt)(tat,(0,p.Z)({},Jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}eat.isMDXComponent=!0;const nat={toc:[]},oat="wrapper";function pat(t){let{components:e,...n}=t;return(0,s.kt)(oat,(0,p.Z)({},nat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pat.isMDXComponent=!0;const rat={toc:[]},sat="wrapper";function cat(t){let{components:e,...n}=t;return(0,s.kt)(sat,(0,p.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}cat.isMDXComponent=!0;const aat={toc:[]},iat="wrapper";function lat(t){let{components:e,...n}=t;return(0,s.kt)(iat,(0,p.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lat.isMDXComponent=!0;const uat={toc:[]},mat="wrapper";function dat(t){let{components:e,...n}=t;return(0,s.kt)(mat,(0,p.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}dat.isMDXComponent=!0;const hat={toc:[]},fat="wrapper";function kat(t){let{components:e,...n}=t;return(0,s.kt)(fat,(0,p.Z)({},hat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}kat.isMDXComponent=!0;const yat={toc:[]},Dat="wrapper";function Mat(t){let{components:e,...n}=t;return(0,s.kt)(Dat,(0,p.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Mat.isMDXComponent=!0;const Xat={toc:[]},_at="wrapper";function wat(t){let{components:e,...n}=t;return(0,s.kt)(_at,(0,p.Z)({},Xat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wat.isMDXComponent=!0;const Tat={toc:[]},Cat="wrapper";function gat(t){let{components:e,...n}=t;return(0,s.kt)(Cat,(0,p.Z)({},Tat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}gat.isMDXComponent=!0;const xat={toc:[]},vat="wrapper";function Lat(t){let{components:e,...n}=t;return(0,s.kt)(vat,(0,p.Z)({},xat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Lat.isMDXComponent=!0;const Zat={toc:[]},bat="wrapper";function Nat(t){let{components:e,...n}=t;return(0,s.kt)(bat,(0,p.Z)({},Zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Nat.isMDXComponent=!0;const zat={toc:[]},Aat="wrapper";function Pat(t){let{components:e,...n}=t;return(0,s.kt)(Aat,(0,p.Z)({},zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Pat.isMDXComponent=!0;const Iat={toc:[]},Wat="wrapper";function Rat(t){let{components:e,...n}=t;return(0,s.kt)(Wat,(0,p.Z)({},Iat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Rat.isMDXComponent=!0;const Sat={toc:[]},Bat="wrapper";function Gat(t){let{components:e,...n}=t;return(0,s.kt)(Bat,(0,p.Z)({},Sat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Gat.isMDXComponent=!0;const Eat={toc:[]},Oat="wrapper";function Uat(t){let{components:e,...n}=t;return(0,s.kt)(Oat,(0,p.Z)({},Eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Uat.isMDXComponent=!0;const Fat={toc:[]},Vat="wrapper";function qat(t){let{components:e,...n}=t;return(0,s.kt)(Vat,(0,p.Z)({},Fat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qat.isMDXComponent=!0;const jat={toc:[]},Hat="wrapper";function Yat(t){let{components:e,...n}=t;return(0,s.kt)(Hat,(0,p.Z)({},jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Yat.isMDXComponent=!0;const Qat={toc:[]},$at="wrapper";function Kat(t){let{components:e,...n}=t;return(0,s.kt)($at,(0,p.Z)({},Qat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Kat.isMDXComponent=!0;const Jat={toc:[]},tit="wrapper";function eit(t){let{components:e,...n}=t;return(0,s.kt)(tit,(0,p.Z)({},Jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}eit.isMDXComponent=!0;const nit={toc:[]},oit="wrapper";function pit(t){let{components:e,...n}=t;return(0,s.kt)(oit,(0,p.Z)({},nit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}pit.isMDXComponent=!0;const rit={toc:[]},sit="wrapper";function cit(t){let{components:e,...n}=t;return(0,s.kt)(sit,(0,p.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}cit.isMDXComponent=!0;const ait={toc:[]},iit="wrapper";function lit(t){let{components:e,...n}=t;return(0,s.kt)(iit,(0,p.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lit.isMDXComponent=!0;const uit={toc:[]},mit="wrapper";function dit(t){let{components:e,...n}=t;return(0,s.kt)(mit,(0,p.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}dit.isMDXComponent=!0;const hit={toc:[]},fit="wrapper";function kit(t){let{components:e,...n}=t;return(0,s.kt)(fit,(0,p.Z)({},hit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}kit.isMDXComponent=!0;const yit={toc:[]},Dit="wrapper";function Mit(t){let{components:e,...n}=t;return(0,s.kt)(Dit,(0,p.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Mit.isMDXComponent=!0;const Xit={toc:[]},_it="wrapper";function wit(t){let{components:e,...n}=t;return(0,s.kt)(_it,(0,p.Z)({},Xit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}wit.isMDXComponent=!0;const Tit={toc:[]},Cit="wrapper";function git(t){let{components:e,...n}=t;return(0,s.kt)(Cit,(0,p.Z)({},Tit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}git.isMDXComponent=!0;const xit={toc:[]},vit="wrapper";function Lit(t){let{components:e,...n}=t;return(0,s.kt)(vit,(0,p.Z)({},xit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lit.isMDXComponent=!0;const Zit={toc:[]},bit="wrapper";function Nit(t){let{components:e,...n}=t;return(0,s.kt)(bit,(0,p.Z)({},Zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Nit.isMDXComponent=!0;const zit={toc:[]},Ait="wrapper";function Pit(t){let{components:e,...n}=t;return(0,s.kt)(Ait,(0,p.Z)({},zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Pit.isMDXComponent=!0;const Iit={toc:[]},Wit="wrapper";function Rit(t){let{components:e,...n}=t;return(0,s.kt)(Wit,(0,p.Z)({},Iit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Rit.isMDXComponent=!0;const Sit={toc:[]},Bit="wrapper";function Git(t){let{components:e,...n}=t;return(0,s.kt)(Bit,(0,p.Z)({},Sit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Git.isMDXComponent=!0;const Eit={toc:[]},Oit="wrapper";function Uit(t){let{components:e,...n}=t;return(0,s.kt)(Oit,(0,p.Z)({},Eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Uit.isMDXComponent=!0;const Fit={toc:[]},Vit="wrapper";function qit(t){let{components:e,...n}=t;return(0,s.kt)(Vit,(0,p.Z)({},Fit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}qit.isMDXComponent=!0;const jit={toc:[]},Hit="wrapper";function Yit(t){let{components:e,...n}=t;return(0,s.kt)(Hit,(0,p.Z)({},jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Yit.isMDXComponent=!0;const Qit={toc:[]},$it="wrapper";function Kit(t){let{components:e,...n}=t;return(0,s.kt)($it,(0,p.Z)({},Qit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Kit.isMDXComponent=!0;const Jit={toc:[]},tlt="wrapper";function elt(t){let{components:e,...n}=t;return(0,s.kt)(tlt,(0,p.Z)({},Jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}elt.isMDXComponent=!0;const nlt={toc:[]},olt="wrapper";function plt(t){let{components:e,...n}=t;return(0,s.kt)(olt,(0,p.Z)({},nlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}plt.isMDXComponent=!0;const rlt={toc:[]},slt="wrapper";function clt(t){let{components:e,...n}=t;return(0,s.kt)(slt,(0,p.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}clt.isMDXComponent=!0;const alt={toc:[]},ilt="wrapper";function llt(t){let{components:e,...n}=t;return(0,s.kt)(ilt,(0,p.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}llt.isMDXComponent=!0;const ult={toc:[]},mlt="wrapper";function dlt(t){let{components:e,...n}=t;return(0,s.kt)(mlt,(0,p.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}dlt.isMDXComponent=!0;const hlt={toc:[]},flt="wrapper";function klt(t){let{components:e,...n}=t;return(0,s.kt)(flt,(0,p.Z)({},hlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}klt.isMDXComponent=!0;const ylt={toc:[]},Dlt="wrapper";function Mlt(t){let{components:e,...n}=t;return(0,s.kt)(Dlt,(0,p.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Mlt.isMDXComponent=!0;const Xlt={toc:[]},_lt="wrapper";function wlt(t){let{components:e,...n}=t;return(0,s.kt)(_lt,(0,p.Z)({},Xlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wlt.isMDXComponent=!0;const Tlt={toc:[]},Clt="wrapper";function glt(t){let{components:e,...n}=t;return(0,s.kt)(Clt,(0,p.Z)({},Tlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}glt.isMDXComponent=!0;const xlt={toc:[]},vlt="wrapper";function Llt(t){let{components:e,...n}=t;return(0,s.kt)(vlt,(0,p.Z)({},xlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Llt.isMDXComponent=!0;const Zlt={toc:[]},blt="wrapper";function Nlt(t){let{components:e,...n}=t;return(0,s.kt)(blt,(0,p.Z)({},Zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Nlt.isMDXComponent=!0;const zlt={toc:[]},Alt="wrapper";function Plt(t){let{components:e,...n}=t;return(0,s.kt)(Alt,(0,p.Z)({},zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Plt.isMDXComponent=!0;const Ilt={toc:[]},Wlt="wrapper";function Rlt(t){let{components:e,...n}=t;return(0,s.kt)(Wlt,(0,p.Z)({},Ilt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Rlt.isMDXComponent=!0;const Slt={toc:[]},Blt="wrapper";function Glt(t){let{components:e,...n}=t;return(0,s.kt)(Blt,(0,p.Z)({},Slt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Glt.isMDXComponent=!0;const Elt={toc:[]},Olt="wrapper";function Ult(t){let{components:e,...n}=t;return(0,s.kt)(Olt,(0,p.Z)({},Elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Ult.isMDXComponent=!0;const Flt={toc:[]},Vlt="wrapper";function qlt(t){let{components:e,...n}=t;return(0,s.kt)(Vlt,(0,p.Z)({},Flt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qlt.isMDXComponent=!0;const jlt={toc:[]},Hlt="wrapper";function Ylt(t){let{components:e,...n}=t;return(0,s.kt)(Hlt,(0,p.Z)({},jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Ylt.isMDXComponent=!0;const Qlt={toc:[]},$lt="wrapper";function Klt(t){let{components:e,...n}=t;return(0,s.kt)($lt,(0,p.Z)({},Qlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Klt.isMDXComponent=!0;const Jlt={toc:[]},tut="wrapper";function eut(t){let{components:e,...n}=t;return(0,s.kt)(tut,(0,p.Z)({},Jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}eut.isMDXComponent=!0;const nut={toc:[]},out="wrapper";function put(t){let{components:e,...n}=t;return(0,s.kt)(out,(0,p.Z)({},nut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}put.isMDXComponent=!0;const rut={toc:[]},sut="wrapper";function cut(t){let{components:e,...n}=t;return(0,s.kt)(sut,(0,p.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}cut.isMDXComponent=!0;const aut={toc:[]},iut="wrapper";function lut(t){let{components:e,...n}=t;return(0,s.kt)(iut,(0,p.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lut.isMDXComponent=!0;const uut={toc:[]},mut="wrapper";function dut(t){let{components:e,...n}=t;return(0,s.kt)(mut,(0,p.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}dut.isMDXComponent=!0;const hut={toc:[]},fut="wrapper";function kut(t){let{components:e,...n}=t;return(0,s.kt)(fut,(0,p.Z)({},hut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kut.isMDXComponent=!0;const yut={toc:[]},Dut="wrapper";function Mut(t){let{components:e,...n}=t;return(0,s.kt)(Dut,(0,p.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mut.isMDXComponent=!0;const Xut={toc:[]},_ut="wrapper";function wut(t){let{components:e,...n}=t;return(0,s.kt)(_ut,(0,p.Z)({},Xut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wut.isMDXComponent=!0;const Tut={toc:[]},Cut="wrapper";function gut(t){let{components:e,...n}=t;return(0,s.kt)(Cut,(0,p.Z)({},Tut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}gut.isMDXComponent=!0;const xut={toc:[]},vut="wrapper";function Lut(t){let{components:e,...n}=t;return(0,s.kt)(vut,(0,p.Z)({},xut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lut.isMDXComponent=!0;const Zut={toc:[]},but="wrapper";function Nut(t){let{components:e,...n}=t;return(0,s.kt)(but,(0,p.Z)({},Zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Nut.isMDXComponent=!0;const zut={toc:[]},Aut="wrapper";function Put(t){let{components:e,...n}=t;return(0,s.kt)(Aut,(0,p.Z)({},zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Put.isMDXComponent=!0;const Iut={toc:[]},Wut="wrapper";function Rut(t){let{components:e,...n}=t;return(0,s.kt)(Wut,(0,p.Z)({},Iut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Rut.isMDXComponent=!0;const Sut={toc:[]},But="wrapper";function Gut(t){let{components:e,...n}=t;return(0,s.kt)(But,(0,p.Z)({},Sut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Gut.isMDXComponent=!0;const Eut={toc:[]},Out="wrapper";function Uut(t){let{components:e,...n}=t;return(0,s.kt)(Out,(0,p.Z)({},Eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Uut.isMDXComponent=!0;const Fut={toc:[]},Vut="wrapper";function qut(t){let{components:e,...n}=t;return(0,s.kt)(Vut,(0,p.Z)({},Fut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}qut.isMDXComponent=!0;const jut={toc:[]},Hut="wrapper";function Yut(t){let{components:e,...n}=t;return(0,s.kt)(Hut,(0,p.Z)({},jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Yut.isMDXComponent=!0;const Qut={toc:[]},$ut="wrapper";function Kut(t){let{components:e,...n}=t;return(0,s.kt)($ut,(0,p.Z)({},Qut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Kut.isMDXComponent=!0;const Jut={toc:[]},tmt="wrapper";function emt(t){let{components:e,...n}=t;return(0,s.kt)(tmt,(0,p.Z)({},Jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}emt.isMDXComponent=!0;const nmt={toc:[]},omt="wrapper";function pmt(t){let{components:e,...n}=t;return(0,s.kt)(omt,(0,p.Z)({},nmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}pmt.isMDXComponent=!0;const rmt={toc:[]},smt="wrapper";function cmt(t){let{components:e,...n}=t;return(0,s.kt)(smt,(0,p.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}cmt.isMDXComponent=!0;const amt={toc:[]},imt="wrapper";function lmt(t){let{components:e,...n}=t;return(0,s.kt)(imt,(0,p.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lmt.isMDXComponent=!0;const umt={toc:[]},mmt="wrapper";function dmt(t){let{components:e,...n}=t;return(0,s.kt)(mmt,(0,p.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}dmt.isMDXComponent=!0;const hmt={toc:[]},fmt="wrapper";function kmt(t){let{components:e,...n}=t;return(0,s.kt)(fmt,(0,p.Z)({},hmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}kmt.isMDXComponent=!0;const ymt={toc:[]},Dmt="wrapper";function Mmt(t){let{components:e,...n}=t;return(0,s.kt)(Dmt,(0,p.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Mmt.isMDXComponent=!0;const Xmt={toc:[]},_mt="wrapper";function wmt(t){let{components:e,...n}=t;return(0,s.kt)(_mt,(0,p.Z)({},Xmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wmt.isMDXComponent=!0;const Tmt={toc:[]},Cmt="wrapper";function gmt(t){let{components:e,...n}=t;return(0,s.kt)(Cmt,(0,p.Z)({},Tmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gmt.isMDXComponent=!0;const xmt={toc:[]},vmt="wrapper";function Lmt(t){let{components:e,...n}=t;return(0,s.kt)(vmt,(0,p.Z)({},xmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]},bmt="wrapper";function Nmt(t){let{components:e,...n}=t;return(0,s.kt)(bmt,(0,p.Z)({},Zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Nmt.isMDXComponent=!0;const zmt={toc:[]},Amt="wrapper";function Pmt(t){let{components:e,...n}=t;return(0,s.kt)(Amt,(0,p.Z)({},zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Pmt.isMDXComponent=!0;const Imt={toc:[]},Wmt="wrapper";function Rmt(t){let{components:e,...n}=t;return(0,s.kt)(Wmt,(0,p.Z)({},Imt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Rmt.isMDXComponent=!0;const Smt={toc:[]},Bmt="wrapper";function Gmt(t){let{components:e,...n}=t;return(0,s.kt)(Bmt,(0,p.Z)({},Smt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Gmt.isMDXComponent=!0;const Emt={toc:[]},Omt="wrapper";function Umt(t){let{components:e,...n}=t;return(0,s.kt)(Omt,(0,p.Z)({},Emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Umt.isMDXComponent=!0;const Fmt={toc:[]},Vmt="wrapper";function qmt(t){let{components:e,...n}=t;return(0,s.kt)(Vmt,(0,p.Z)({},Fmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}qmt.isMDXComponent=!0;const jmt={toc:[]},Hmt="wrapper";function Ymt(t){let{components:e,...n}=t;return(0,s.kt)(Hmt,(0,p.Z)({},jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Ymt.isMDXComponent=!0;const Qmt={toc:[]},$mt="wrapper";function Kmt(t){let{components:e,...n}=t;return(0,s.kt)($mt,(0,p.Z)({},Qmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]},tdt="wrapper";function edt(t){let{components:e,...n}=t;return(0,s.kt)(tdt,(0,p.Z)({},Jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}edt.isMDXComponent=!0;const ndt={toc:[]},odt="wrapper";function pdt(t){let{components:e,...n}=t;return(0,s.kt)(odt,(0,p.Z)({},ndt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pdt.isMDXComponent=!0;const rdt={toc:[]},sdt="wrapper";function cdt(t){let{components:e,...n}=t;return(0,s.kt)(sdt,(0,p.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cdt.isMDXComponent=!0;const adt={toc:[]},idt="wrapper";function ldt(t){let{components:e,...n}=t;return(0,s.kt)(idt,(0,p.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ldt.isMDXComponent=!0;const udt={toc:[]},mdt="wrapper";function ddt(t){let{components:e,...n}=t;return(0,s.kt)(mdt,(0,p.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ddt.isMDXComponent=!0;const hdt={toc:[]},fdt="wrapper";function kdt(t){let{components:e,...n}=t;return(0,s.kt)(fdt,(0,p.Z)({},hdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}kdt.isMDXComponent=!0;const ydt={toc:[]},Ddt="wrapper";function Mdt(t){let{components:e,...n}=t;return(0,s.kt)(Ddt,(0,p.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Mdt.isMDXComponent=!0;const Xdt={toc:[]},_dt="wrapper";function wdt(t){let{components:e,...n}=t;return(0,s.kt)(_dt,(0,p.Z)({},Xdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}wdt.isMDXComponent=!0;const Tdt={toc:[]},Cdt="wrapper";function gdt(t){let{components:e,...n}=t;return(0,s.kt)(Cdt,(0,p.Z)({},Tdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gdt.isMDXComponent=!0;const xdt={toc:[]},vdt="wrapper";function Ldt(t){let{components:e,...n}=t;return(0,s.kt)(vdt,(0,p.Z)({},xdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]},bdt="wrapper";function Ndt(t){let{components:e,...n}=t;return(0,s.kt)(bdt,(0,p.Z)({},Zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Ndt.isMDXComponent=!0;const zdt={toc:[]},Adt="wrapper";function Pdt(t){let{components:e,...n}=t;return(0,s.kt)(Adt,(0,p.Z)({},zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Pdt.isMDXComponent=!0;const Idt={toc:[]},Wdt="wrapper";function Rdt(t){let{components:e,...n}=t;return(0,s.kt)(Wdt,(0,p.Z)({},Idt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Rdt.isMDXComponent=!0;const Sdt={toc:[]},Bdt="wrapper";function Gdt(t){let{components:e,...n}=t;return(0,s.kt)(Bdt,(0,p.Z)({},Sdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Gdt.isMDXComponent=!0;const Edt={toc:[]},Odt="wrapper";function Udt(t){let{components:e,...n}=t;return(0,s.kt)(Odt,(0,p.Z)({},Edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Udt.isMDXComponent=!0;const Fdt={toc:[]},Vdt="wrapper";function qdt(t){let{components:e,...n}=t;return(0,s.kt)(Vdt,(0,p.Z)({},Fdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qdt.isMDXComponent=!0;const jdt={toc:[]},Hdt="wrapper";function Ydt(t){let{components:e,...n}=t;return(0,s.kt)(Hdt,(0,p.Z)({},jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ydt.isMDXComponent=!0;const Qdt={toc:[]},$dt="wrapper";function Kdt(t){let{components:e,...n}=t;return(0,s.kt)($dt,(0,p.Z)({},Qdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]},tht="wrapper";function eht(t){let{components:e,...n}=t;return(0,s.kt)(tht,(0,p.Z)({},Jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}eht.isMDXComponent=!0;const nht={toc:[]},oht="wrapper";function pht(t){let{components:e,...n}=t;return(0,s.kt)(oht,(0,p.Z)({},nht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pht.isMDXComponent=!0;const rht={toc:[]},sht="wrapper";function cht(t){let{components:e,...n}=t;return(0,s.kt)(sht,(0,p.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}cht.isMDXComponent=!0;const aht={toc:[]},iht="wrapper";function lht(t){let{components:e,...n}=t;return(0,s.kt)(iht,(0,p.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}lht.isMDXComponent=!0;const uht={toc:[]},mht="wrapper";function dht(t){let{components:e,...n}=t;return(0,s.kt)(mht,(0,p.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}dht.isMDXComponent=!0;const hht={toc:[]},fht="wrapper";function kht(t){let{components:e,...n}=t;return(0,s.kt)(fht,(0,p.Z)({},hht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}kht.isMDXComponent=!0;const yht={toc:[]},Dht="wrapper";function Mht(t){let{components:e,...n}=t;return(0,s.kt)(Dht,(0,p.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Mht.isMDXComponent=!0;const Xht={toc:[]},_ht="wrapper";function wht(t){let{components:e,...n}=t;return(0,s.kt)(_ht,(0,p.Z)({},Xht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}wht.isMDXComponent=!0;const Tht={toc:[]},Cht="wrapper";function ght(t){let{components:e,...n}=t;return(0,s.kt)(Cht,(0,p.Z)({},Tht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}ght.isMDXComponent=!0;const xht={toc:[]},vht="wrapper";function Lht(t){let{components:e,...n}=t;return(0,s.kt)(vht,(0,p.Z)({},xht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}Lht.isMDXComponent=!0;const Zht={toc:[]},bht="wrapper";function Nht(t){let{components:e,...n}=t;return(0,s.kt)(bht,(0,p.Z)({},Zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Nht.isMDXComponent=!0;const zht={toc:[]},Aht="wrapper";function Pht(t){let{components:e,...n}=t;return(0,s.kt)(Aht,(0,p.Z)({},zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Pht.isMDXComponent=!0;const Iht={toc:[]},Wht="wrapper";function Rht(t){let{components:e,...n}=t;return(0,s.kt)(Wht,(0,p.Z)({},Iht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Rht.isMDXComponent=!0;const Sht={toc:[]},Bht="wrapper";function Ght(t){let{components:e,...n}=t;return(0,s.kt)(Bht,(0,p.Z)({},Sht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Ght.isMDXComponent=!0;const Eht={toc:[]},Oht="wrapper";function Uht(t){let{components:e,...n}=t;return(0,s.kt)(Oht,(0,p.Z)({},Eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Uht.isMDXComponent=!0;const Fht={toc:[]},Vht="wrapper";function qht(t){let{components:e,...n}=t;return(0,s.kt)(Vht,(0,p.Z)({},Fht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qht.isMDXComponent=!0;const jht={toc:[]},Hht="wrapper";function Yht(t){let{components:e,...n}=t;return(0,s.kt)(Hht,(0,p.Z)({},jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Yht.isMDXComponent=!0;const Qht={toc:[]},$ht="wrapper";function Kht(t){let{components:e,...n}=t;return(0,s.kt)($ht,(0,p.Z)({},Qht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Kht.isMDXComponent=!0;const Jht={toc:[]},tft="wrapper";function eft(t){let{components:e,...n}=t;return(0,s.kt)(tft,(0,p.Z)({},Jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}eft.isMDXComponent=!0;const nft={toc:[]},oft="wrapper";function pft(t){let{components:e,...n}=t;return(0,s.kt)(oft,(0,p.Z)({},nft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pft.isMDXComponent=!0;const rft={toc:[]},sft="wrapper";function cft(t){let{components:e,...n}=t;return(0,s.kt)(sft,(0,p.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cft.isMDXComponent=!0;const aft={toc:[]},ift="wrapper";function lft(t){let{components:e,...n}=t;return(0,s.kt)(ift,(0,p.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lft.isMDXComponent=!0;const uft={toc:[]},mft="wrapper";function dft(t){let{components:e,...n}=t;return(0,s.kt)(mft,(0,p.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dft.isMDXComponent=!0;const hft={toc:[]},fft="wrapper";function kft(t){let{components:e,...n}=t;return(0,s.kt)(fft,(0,p.Z)({},hft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}kft.isMDXComponent=!0;const yft={toc:[]},Dft="wrapper";function Mft(t){let{components:e,...n}=t;return(0,s.kt)(Dft,(0,p.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Mft.isMDXComponent=!0;const Xft={toc:[]},_ft="wrapper";function wft(t){let{components:e,...n}=t;return(0,s.kt)(_ft,(0,p.Z)({},Xft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wft.isMDXComponent=!0;const Tft={toc:[]},Cft="wrapper";function gft(t){let{components:e,...n}=t;return(0,s.kt)(Cft,(0,p.Z)({},Tft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}gft.isMDXComponent=!0;const xft={toc:[]},vft="wrapper";function Lft(t){let{components:e,...n}=t;return(0,s.kt)(vft,(0,p.Z)({},xft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Lft.isMDXComponent=!0;const Zft={toc:[]},bft="wrapper";function Nft(t){let{components:e,...n}=t;return(0,s.kt)(bft,(0,p.Z)({},Zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Nft.isMDXComponent=!0;const zft={toc:[]},Aft="wrapper";function Pft(t){let{components:e,...n}=t;return(0,s.kt)(Aft,(0,p.Z)({},zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pft.isMDXComponent=!0;const Ift={toc:[]},Wft="wrapper";function Rft(t){let{components:e,...n}=t;return(0,s.kt)(Wft,(0,p.Z)({},Ift,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Rft.isMDXComponent=!0;const Sft={toc:[]},Bft="wrapper";function Gft(t){let{components:e,...n}=t;return(0,s.kt)(Bft,(0,p.Z)({},Sft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Gft.isMDXComponent=!0;const Eft={toc:[]},Oft="wrapper";function Uft(t){let{components:e,...n}=t;return(0,s.kt)(Oft,(0,p.Z)({},Eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Uft.isMDXComponent=!0;const Fft={toc:[]},Vft="wrapper";function qft(t){let{components:e,...n}=t;return(0,s.kt)(Vft,(0,p.Z)({},Fft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qft.isMDXComponent=!0;const jft={toc:[]},Hft="wrapper";function Yft(t){let{components:e,...n}=t;return(0,s.kt)(Hft,(0,p.Z)({},jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Yft.isMDXComponent=!0;const Qft={toc:[]},$ft="wrapper";function Kft(t){let{components:e,...n}=t;return(0,s.kt)($ft,(0,p.Z)({},Qft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Kft.isMDXComponent=!0;const Jft={toc:[]},tkt="wrapper";function ekt(t){let{components:e,...n}=t;return(0,s.kt)(tkt,(0,p.Z)({},Jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}ekt.isMDXComponent=!0;const nkt={toc:[]},okt="wrapper";function pkt(t){let{components:e,...n}=t;return(0,s.kt)(okt,(0,p.Z)({},nkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pkt.isMDXComponent=!0;const rkt={toc:[]},skt="wrapper";function ckt(t){let{components:e,...n}=t;return(0,s.kt)(skt,(0,p.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ckt.isMDXComponent=!0;const akt={toc:[]},ikt="wrapper";function lkt(t){let{components:e,...n}=t;return(0,s.kt)(ikt,(0,p.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lkt.isMDXComponent=!0;const ukt={toc:[]},mkt="wrapper";function dkt(t){let{components:e,...n}=t;return(0,s.kt)(mkt,(0,p.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}dkt.isMDXComponent=!0;const hkt={toc:[]},fkt="wrapper";function kkt(t){let{components:e,...n}=t;return(0,s.kt)(fkt,(0,p.Z)({},hkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}kkt.isMDXComponent=!0;const ykt={toc:[]},Dkt="wrapper";function Mkt(t){let{components:e,...n}=t;return(0,s.kt)(Dkt,(0,p.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Mkt.isMDXComponent=!0;const Xkt={toc:[]},_kt="wrapper";function wkt(t){let{components:e,...n}=t;return(0,s.kt)(_kt,(0,p.Z)({},Xkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wkt.isMDXComponent=!0;const Tkt={toc:[]},Ckt="wrapper";function gkt(t){let{components:e,...n}=t;return(0,s.kt)(Ckt,(0,p.Z)({},Tkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}gkt.isMDXComponent=!0;const xkt={toc:[]},vkt="wrapper";function Lkt(t){let{components:e,...n}=t;return(0,s.kt)(vkt,(0,p.Z)({},xkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]},bkt="wrapper";function Nkt(t){let{components:e,...n}=t;return(0,s.kt)(bkt,(0,p.Z)({},Zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Nkt.isMDXComponent=!0;const zkt={toc:[]},Akt="wrapper";function Pkt(t){let{components:e,...n}=t;return(0,s.kt)(Akt,(0,p.Z)({},zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pkt.isMDXComponent=!0;const Ikt={toc:[]},Wkt="wrapper";function Rkt(t){let{components:e,...n}=t;return(0,s.kt)(Wkt,(0,p.Z)({},Ikt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Rkt.isMDXComponent=!0;const Skt={toc:[]},Bkt="wrapper";function Gkt(t){let{components:e,...n}=t;return(0,s.kt)(Bkt,(0,p.Z)({},Skt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Gkt.isMDXComponent=!0;const Ekt={toc:[]},Okt="wrapper";function Ukt(t){let{components:e,...n}=t;return(0,s.kt)(Okt,(0,p.Z)({},Ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ukt.isMDXComponent=!0;const Fkt={toc:[]},Vkt="wrapper";function qkt(t){let{components:e,...n}=t;return(0,s.kt)(Vkt,(0,p.Z)({},Fkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qkt.isMDXComponent=!0;const jkt={toc:[]},Hkt="wrapper";function Ykt(t){let{components:e,...n}=t;return(0,s.kt)(Hkt,(0,p.Z)({},jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ykt.isMDXComponent=!0;const Qkt={toc:[]},$kt="wrapper";function Kkt(t){let{components:e,...n}=t;return(0,s.kt)($kt,(0,p.Z)({},Qkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Kkt.isMDXComponent=!0;const Jkt={toc:[]},tyt="wrapper";function eyt(t){let{components:e,...n}=t;return(0,s.kt)(tyt,(0,p.Z)({},Jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eyt.isMDXComponent=!0;const nyt={toc:[]},oyt="wrapper";function pyt(t){let{components:e,...n}=t;return(0,s.kt)(oyt,(0,p.Z)({},nyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pyt.isMDXComponent=!0;const ryt={toc:[]},syt="wrapper";function cyt(t){let{components:e,...n}=t;return(0,s.kt)(syt,(0,p.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cyt.isMDXComponent=!0;const ayt={toc:[]},iyt="wrapper";function lyt(t){let{components:e,...n}=t;return(0,s.kt)(iyt,(0,p.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lyt.isMDXComponent=!0;const uyt={toc:[]},myt="wrapper";function dyt(t){let{components:e,...n}=t;return(0,s.kt)(myt,(0,p.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Code, makeScene2D} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const code = createRef<Code>();\n\n  view.add(\n    <Code\n      ref={code}\n      offset={-1}\n      position={view.size().scale(-0.5).add(60)}\n      fontFamily={'JetBrains Mono, monospace'}\n      fontSize={36}\n      code={`\\\nfunction hello() {\n  console.log('Hello');\n}`}\n    />,\n  );\n\n  yield* code()\n    .code(\n      `\\\nfunction hello() {\n  console.warn('Hello World');\n}`,\n      1,\n    )\n    .wait(0.5)\n    .back(1)\n    .wait(0.5);\n});\n")))}dyt.isMDXComponent=!0;const hyt={toc:[]},fyt="wrapper";function kyt(t){let{components:e,...n}=t;return(0,s.kt)(fyt,(0,p.Z)({},hyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying and animating code."))}kyt.isMDXComponent=!0;const yyt={toc:[]},Dyt="wrapper";function Myt(t){let{components:e,...n}=t;return(0,s.kt)(Dyt,(0,p.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Myt.isMDXComponent=!0;const Xyt={toc:[]},_yt="wrapper";function wyt(t){let{components:e,...n}=t;return(0,s.kt)(_yt,(0,p.Z)({},Xyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}wyt.isMDXComponent=!0;const Tyt={toc:[]},Cyt="wrapper";function gyt(t){let{components:e,...n}=t;return(0,s.kt)(Cyt,(0,p.Z)({},Tyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}gyt.isMDXComponent=!0;const xyt={toc:[]},vyt="wrapper";function Lyt(t){let{components:e,...n}=t;return(0,s.kt)(vyt,(0,p.Z)({},xyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]},byt="wrapper";function Nyt(t){let{components:e,...n}=t;return(0,s.kt)(byt,(0,p.Z)({},Zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nyt.isMDXComponent=!0;const zyt={toc:[]},Ayt="wrapper";function Pyt(t){let{components:e,...n}=t;return(0,s.kt)(Ayt,(0,p.Z)({},zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Pyt.isMDXComponent=!0;const Iyt={toc:[]},Wyt="wrapper";function Ryt(t){let{components:e,...n}=t;return(0,s.kt)(Wyt,(0,p.Z)({},Iyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ryt.isMDXComponent=!0;const Syt={toc:[]},Byt="wrapper";function Gyt(t){let{components:e,...n}=t;return(0,s.kt)(Byt,(0,p.Z)({},Syt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Gyt.isMDXComponent=!0;const Eyt={toc:[]},Oyt="wrapper";function Uyt(t){let{components:e,...n}=t;return(0,s.kt)(Oyt,(0,p.Z)({},Eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Uyt.isMDXComponent=!0;const Fyt={toc:[]},Vyt="wrapper";function qyt(t){let{components:e,...n}=t;return(0,s.kt)(Vyt,(0,p.Z)({},Fyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qyt.isMDXComponent=!0;const jyt={toc:[]},Hyt="wrapper";function Yyt(t){let{components:e,...n}=t;return(0,s.kt)(Hyt,(0,p.Z)({},jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Yyt.isMDXComponent=!0;const Qyt={toc:[]},$yt="wrapper";function Kyt(t){let{components:e,...n}=t;return(0,s.kt)($yt,(0,p.Z)({},Qyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]},tDt="wrapper";function eDt(t){let{components:e,...n}=t;return(0,s.kt)(tDt,(0,p.Z)({},Jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eDt.isMDXComponent=!0;const nDt={toc:[]},oDt="wrapper";function pDt(t){let{components:e,...n}=t;return(0,s.kt)(oDt,(0,p.Z)({},nDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pDt.isMDXComponent=!0;const rDt={toc:[]},sDt="wrapper";function cDt(t){let{components:e,...n}=t;return(0,s.kt)(sDt,(0,p.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to display."))}cDt.isMDXComponent=!0;const aDt={toc:[]},iDt="wrapper";function lDt(t){let{components:e,...n}=t;return(0,s.kt)(iDt,(0,p.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check out ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.kt)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}lDt.isMDXComponent=!0;const uDt={toc:[]},mDt="wrapper";function dDt(t){let{components:e,...n}=t;return(0,s.kt)(mDt,(0,p.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Make the unselected code blurry and transparent:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  drawHooks={{\n    token(ctx, text, position, color, selection) {\n      const blur = map(3, 0, selection);\n      const alpha = map(0.5, 1, selection);\n      ctx.globalAlpha *= alpha;\n      ctx.filter = `blur(${blur}px)`;\n      ctx.fillStyle = color;\n      ctx.fillText(text, position.x, position.y);\n    },\n  }}\n  // ...\n/>\n")))}dDt.isMDXComponent=!0;const hDt={toc:[]},fDt="wrapper";function kDt(t){let{components:e,...n}=t;return(0,s.kt)(fDt,(0,p.Z)({},hDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Custom drawing logic for the code."))}kDt.isMDXComponent=!0;const yDt={toc:[]},DDt="wrapper";function MDt(t){let{components:e,...n}=t;return(0,s.kt)(DDt,(0,p.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defaults to a shared ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.kt)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}MDt.isMDXComponent=!0;const XDt={toc:[]},_Dt="wrapper";function wDt(t){let{components:e,...n}=t;return(0,s.kt)(_Dt,(0,p.Z)({},XDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code highlighter to use for this code node."))}wDt.isMDXComponent=!0;const TDt={toc:[]},CDt="wrapper";function gDt(t){let{components:e,...n}=t;return(0,s.kt)(CDt,(0,p.Z)({},TDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}gDt.isMDXComponent=!0;const xDt={toc:[]},vDt="wrapper";function LDt(t){let{components:e,...n}=t;return(0,s.kt)(vDt,(0,p.Z)({},xDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}LDt.isMDXComponent=!0;const ZDt={toc:[]},bDt="wrapper";function NDt(t){let{components:e,...n}=t;return(0,s.kt)(bDt,(0,p.Z)({},ZDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}NDt.isMDXComponent=!0;const zDt={toc:[]},ADt="wrapper";function PDt(t){let{components:e,...n}=t;return(0,s.kt)(ADt,(0,p.Z)({},zDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}PDt.isMDXComponent=!0;const IDt={toc:[]},WDt="wrapper";function RDt(t){let{components:e,...n}=t;return(0,s.kt)(WDt,(0,p.Z)({},IDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}RDt.isMDXComponent=!0;const SDt={toc:[]},BDt="wrapper";function GDt(t){let{components:e,...n}=t;return(0,s.kt)(BDt,(0,p.Z)({},SDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}GDt.isMDXComponent=!0;const EDt={toc:[]},ODt="wrapper";function UDt(t){let{components:e,...n}=t;return(0,s.kt)(ODt,(0,p.Z)({},EDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}UDt.isMDXComponent=!0;const FDt={toc:[]},VDt="wrapper";function qDt(t){let{components:e,...n}=t;return(0,s.kt)(VDt,(0,p.Z)({},FDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}qDt.isMDXComponent=!0;const jDt={toc:[]},HDt="wrapper";function YDt(t){let{components:e,...n}=t;return(0,s.kt)(HDt,(0,p.Z)({},jDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}YDt.isMDXComponent=!0;const QDt={toc:[]},$Dt="wrapper";function KDt(t){let{components:e,...n}=t;return(0,s.kt)($Dt,(0,p.Z)({},QDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}KDt.isMDXComponent=!0;const JDt={toc:[]},tMt="wrapper";function eMt(t){let{components:e,...n}=t;return(0,s.kt)(tMt,(0,p.Z)({},JDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eMt.isMDXComponent=!0;const nMt={toc:[]},oMt="wrapper";function pMt(t){let{components:e,...n}=t;return(0,s.kt)(oMt,(0,p.Z)({},nMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pMt.isMDXComponent=!0;const rMt={toc:[]},sMt="wrapper";function cMt(t){let{components:e,...n}=t;return(0,s.kt)(sMt,(0,p.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cMt.isMDXComponent=!0;const aMt={toc:[]},iMt="wrapper";function lMt(t){let{components:e,...n}=t;return(0,s.kt)(iMt,(0,p.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lMt.isMDXComponent=!0;const uMt={toc:[]},mMt="wrapper";function dMt(t){let{components:e,...n}=t;return(0,s.kt)(mMt,(0,p.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}dMt.isMDXComponent=!0;const hMt={toc:[]},fMt="wrapper";function kMt(t){let{components:e,...n}=t;return(0,s.kt)(fMt,(0,p.Z)({},hMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Either a single ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.kt)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.kt)("p",null,"You can use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.kt)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.kt)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}kMt.isMDXComponent=!0;const yMt={toc:[]},DMt="wrapper";function MMt(t){let{components:e,...n}=t;return(0,s.kt)(DMt,(0,p.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'The following will select the word "console" in the code.\nBoth lines and columns are 0-based. So it will select a 7-character-long\n(',(0,s.kt)("inlineCode",{parentName:"p"},"7"),") word in the second line (",(0,s.kt)("inlineCode",{parentName:"p"},"1"),") starting at the third character (",(0,s.kt)("inlineCode",{parentName:"p"},"2"),")."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  selection={word(1, 2, 7)}\n  code={`\\\nfunction hello() => {\n  console.log('Hello');\n}`}\n  // ...\n/>\n")))}MMt.isMDXComponent=!0;const XMt={toc:[]},_Mt="wrapper";function wMt(t){let{components:e,...n}=t;return(0,s.kt)(_Mt,(0,p.Z)({},XMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The currently selected code range."))}wMt.isMDXComponent=!0;const TMt={toc:[]},CMt="wrapper";function gMt(t){let{components:e,...n}=t;return(0,s.kt)(CMt,(0,p.Z)({},TMt,n,{components:e,mdxType:"MDXLayout"}))}gMt.isMDXComponent=!0;const xMt={toc:[]},vMt="wrapper";function LMt(t){let{components:e,...n}=t;return(0,s.kt)(vMt,(0,p.Z)({},xMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}LMt.isMDXComponent=!0;const ZMt={toc:[]},bMt="wrapper";function NMt(t){let{components:e,...n}=t;return(0,s.kt)(bMt,(0,p.Z)({},ZMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}NMt.isMDXComponent=!0;const zMt={toc:[]},AMt="wrapper";function PMt(t){let{components:e,...n}=t;return(0,s.kt)(AMt,(0,p.Z)({},zMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}PMt.isMDXComponent=!0;const IMt={toc:[]},WMt="wrapper";function RMt(t){let{components:e,...n}=t;return(0,s.kt)(WMt,(0,p.Z)({},IMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}RMt.isMDXComponent=!0;const SMt={toc:[]},BMt="wrapper";function GMt(t){let{components:e,...n}=t;return(0,s.kt)(BMt,(0,p.Z)({},SMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}GMt.isMDXComponent=!0;const EMt={toc:[]},OMt="wrapper";function UMt(t){let{components:e,...n}=t;return(0,s.kt)(OMt,(0,p.Z)({},EMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}UMt.isMDXComponent=!0;const FMt={toc:[]},VMt="wrapper";function qMt(t){let{components:e,...n}=t;return(0,s.kt)(VMt,(0,p.Z)({},FMt,n,{components:e,mdxType:"MDXLayout"}))}qMt.isMDXComponent=!0;const jMt={toc:[]},HMt="wrapper";function YMt(t){let{components:e,...n}=t;return(0,s.kt)(HMt,(0,p.Z)({},jMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}YMt.isMDXComponent=!0;const QMt={toc:[]},$Mt="wrapper";function KMt(t){let{components:e,...n}=t;return(0,s.kt)($Mt,(0,p.Z)({},QMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}KMt.isMDXComponent=!0;const JMt={toc:[]},tXt="wrapper";function eXt(t){let{components:e,...n}=t;return(0,s.kt)(tXt,(0,p.Z)({},JMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}eXt.isMDXComponent=!0;const nXt={toc:[]},oXt="wrapper";function pXt(t){let{components:e,...n}=t;return(0,s.kt)(oXt,(0,p.Z)({},nXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pXt.isMDXComponent=!0;const rXt={toc:[]},sXt="wrapper";function cXt(t){let{components:e,...n}=t;return(0,s.kt)(sXt,(0,p.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}cXt.isMDXComponent=!0;const aXt={toc:[]},iXt="wrapper";function lXt(t){let{components:e,...n}=t;return(0,s.kt)(iXt,(0,p.Z)({},aXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lXt.isMDXComponent=!0;const uXt={toc:[]},mXt="wrapper";function dXt(t){let{components:e,...n}=t;return(0,s.kt)(mXt,(0,p.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}dXt.isMDXComponent=!0;const hXt={toc:[]},fXt="wrapper";function kXt(t){let{components:e,...n}=t;return(0,s.kt)(fXt,(0,p.Z)({},hXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kXt.isMDXComponent=!0;const yXt={toc:[]},DXt="wrapper";function MXt(t){let{components:e,...n}=t;return(0,s.kt)(DXt,(0,p.Z)({},yXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}MXt.isMDXComponent=!0;const XXt={toc:[]},_Xt="wrapper";function wXt(t){let{components:e,...n}=t;return(0,s.kt)(_Xt,(0,p.Z)({},XXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}wXt.isMDXComponent=!0;const TXt={toc:[]},CXt="wrapper";function gXt(t){let{components:e,...n}=t;return(0,s.kt)(CXt,(0,p.Z)({},TXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}gXt.isMDXComponent=!0;const xXt={toc:[]},vXt="wrapper";function LXt(t){let{components:e,...n}=t;return(0,s.kt)(vXt,(0,p.Z)({},xXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}LXt.isMDXComponent=!0;const ZXt={toc:[]},bXt="wrapper";function NXt(t){let{components:e,...n}=t;return(0,s.kt)(bXt,(0,p.Z)({},ZXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}NXt.isMDXComponent=!0;const zXt={toc:[]},AXt="wrapper";function PXt(t){let{components:e,...n}=t;return(0,s.kt)(AXt,(0,p.Z)({},zXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}PXt.isMDXComponent=!0;const IXt={toc:[]},WXt="wrapper";function RXt(t){let{components:e,...n}=t;return(0,s.kt)(WXt,(0,p.Z)({},IXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}RXt.isMDXComponent=!0;const SXt={toc:[]},BXt="wrapper";function GXt(t){let{components:e,...n}=t;return(0,s.kt)(BXt,(0,p.Z)({},SXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}GXt.isMDXComponent=!0;const EXt={toc:[]},OXt="wrapper";function UXt(t){let{components:e,...n}=t;return(0,s.kt)(OXt,(0,p.Z)({},EXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}UXt.isMDXComponent=!0;const FXt={toc:[]},VXt="wrapper";function qXt(t){let{components:e,...n}=t;return(0,s.kt)(VXt,(0,p.Z)({},FXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qXt.isMDXComponent=!0;const jXt={toc:[]},HXt="wrapper";function YXt(t){let{components:e,...n}=t;return(0,s.kt)(HXt,(0,p.Z)({},jXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}YXt.isMDXComponent=!0;const QXt={toc:[]},$Xt="wrapper";function KXt(t){let{components:e,...n}=t;return(0,s.kt)($Xt,(0,p.Z)({},QXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}KXt.isMDXComponent=!0;const JXt={toc:[]},t_t="wrapper";function e_t(t){let{components:e,...n}=t;return(0,s.kt)(t_t,(0,p.Z)({},JXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}e_t.isMDXComponent=!0;const n_t={toc:[]},o_t="wrapper";function p_t(t){let{components:e,...n}=t;return(0,s.kt)(o_t,(0,p.Z)({},n_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}p_t.isMDXComponent=!0;const r_t={toc:[]},s_t="wrapper";function c_t(t){let{components:e,...n}=t;return(0,s.kt)(s_t,(0,p.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}c_t.isMDXComponent=!0;const a_t={toc:[]},i_t="wrapper";function l_t(t){let{components:e,...n}=t;return(0,s.kt)(i_t,(0,p.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}l_t.isMDXComponent=!0;const u_t={toc:[]},m_t="wrapper";function d_t(t){let{components:e,...n}=t;return(0,s.kt)(m_t,(0,p.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}d_t.isMDXComponent=!0;const h_t={toc:[]},f_t="wrapper";function k_t(t){let{components:e,...n}=t;return(0,s.kt)(f_t,(0,p.Z)({},h_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}k_t.isMDXComponent=!0;const y_t={toc:[]},D_t="wrapper";function M_t(t){let{components:e,...n}=t;return(0,s.kt)(D_t,(0,p.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}M_t.isMDXComponent=!0;const X_t={toc:[]},__t="wrapper";function w_t(t){let{components:e,...n}=t;return(0,s.kt)(__t,(0,p.Z)({},X_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}w_t.isMDXComponent=!0;const T_t={toc:[]},C_t="wrapper";function g_t(t){let{components:e,...n}=t;return(0,s.kt)(C_t,(0,p.Z)({},T_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a child code signal."))}g_t.isMDXComponent=!0;const x_t={toc:[]},v_t="wrapper";function L_t(t){let{components:e,...n}=t;return(0,s.kt)(v_t,(0,p.Z)({},x_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial code."))}L_t.isMDXComponent=!0;const Z_t={toc:[]},b_t="wrapper";function N_t(t){let{components:e,...n}=t;return(0,s.kt)(b_t,(0,p.Z)({},Z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}N_t.isMDXComponent=!0;const z_t={toc:[]},A_t="wrapper";function P_t(t){let{components:e,...n}=t;return(0,s.kt)(A_t,(0,p.Z)({},z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}P_t.isMDXComponent=!0;const I_t={toc:[]},W_t="wrapper";function R_t(t){let{components:e,...n}=t;return(0,s.kt)(W_t,(0,p.Z)({},I_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}R_t.isMDXComponent=!0;const S_t={toc:[]},B_t="wrapper";function G_t(t){let{components:e,...n}=t;return(0,s.kt)(B_t,(0,p.Z)({},S_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}G_t.isMDXComponent=!0;const E_t={toc:[]},O_t="wrapper";function U_t(t){let{components:e,...n}=t;return(0,s.kt)(O_t,(0,p.Z)({},E_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}U_t.isMDXComponent=!0;const F_t={toc:[]},V_t="wrapper";function q_t(t){let{components:e,...n}=t;return(0,s.kt)(V_t,(0,p.Z)({},F_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}q_t.isMDXComponent=!0;const j_t={toc:[]},H_t="wrapper";function Y_t(t){let{components:e,...n}=t;return(0,s.kt)(H_t,(0,p.Z)({},j_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Y_t.isMDXComponent=!0;const Q_t={toc:[]},$_t="wrapper";function K_t(t){let{components:e,...n}=t;return(0,s.kt)($_t,(0,p.Z)({},Q_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}K_t.isMDXComponent=!0;const J_t={toc:[]},twt="wrapper";function ewt(t){let{components:e,...n}=t;return(0,s.kt)(twt,(0,p.Z)({},J_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}ewt.isMDXComponent=!0;const nwt={toc:[]},owt="wrapper";function pwt(t){let{components:e,...n}=t;return(0,s.kt)(owt,(0,p.Z)({},nwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pwt.isMDXComponent=!0;const rwt={toc:[]},swt="wrapper";function cwt(t){let{components:e,...n}=t;return(0,s.kt)(swt,(0,p.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}cwt.isMDXComponent=!0;const awt={toc:[]},iwt="wrapper";function lwt(t){let{components:e,...n}=t;return(0,s.kt)(iwt,(0,p.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lwt.isMDXComponent=!0;const uwt={toc:[]},mwt="wrapper";function dwt(t){let{components:e,...n}=t;return(0,s.kt)(mwt,(0,p.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dwt.isMDXComponent=!0;const hwt={toc:[]},fwt="wrapper";function kwt(t){let{components:e,...n}=t;return(0,s.kt)(fwt,(0,p.Z)({},hwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}kwt.isMDXComponent=!0;const ywt={toc:[]},Dwt="wrapper";function Mwt(t){let{components:e,...n}=t;return(0,s.kt)(Dwt,(0,p.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mwt.isMDXComponent=!0;const Xwt={toc:[]},_wt="wrapper";function wwt(t){let{components:e,...n}=t;return(0,s.kt)(_wt,(0,p.Z)({},Xwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all code ranges that match the given pattern."))}wwt.isMDXComponent=!0;const Twt={toc:[]},Cwt="wrapper";function gwt(t){let{components:e,...n}=t;return(0,s.kt)(Cwt,(0,p.Z)({},Twt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Either a string or a regular expression to match."))}gwt.isMDXComponent=!0;const xwt={toc:[]},vwt="wrapper";function Lwt(t){let{components:e,...n}=t;return(0,s.kt)(vwt,(0,p.Z)({},xwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]},bwt="wrapper";function Nwt(t){let{components:e,...n}=t;return(0,s.kt)(bwt,(0,p.Z)({},Zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nwt.isMDXComponent=!0;const zwt={toc:[]},Awt="wrapper";function Pwt(t){let{components:e,...n}=t;return(0,s.kt)(Awt,(0,p.Z)({},zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Pwt.isMDXComponent=!0;const Iwt={toc:[]},Wwt="wrapper";function Rwt(t){let{components:e,...n}=t;return(0,s.kt)(Wwt,(0,p.Z)({},Iwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Rwt.isMDXComponent=!0;const Swt={toc:[]},Bwt="wrapper";function Gwt(t){let{components:e,...n}=t;return(0,s.kt)(Bwt,(0,p.Z)({},Swt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Gwt.isMDXComponent=!0;const Ewt={toc:[]},Owt="wrapper";function Uwt(t){let{components:e,...n}=t;return(0,s.kt)(Owt,(0,p.Z)({},Ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Uwt.isMDXComponent=!0;const Fwt={toc:[]},Vwt="wrapper";function qwt(t){let{components:e,...n}=t;return(0,s.kt)(Vwt,(0,p.Z)({},Fwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}qwt.isMDXComponent=!0;const jwt={toc:[]},Hwt="wrapper";function Ywt(t){let{components:e,...n}=t;return(0,s.kt)(Hwt,(0,p.Z)({},jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ywt.isMDXComponent=!0;const Qwt={toc:[]},$wt="wrapper";function Kwt(t){let{components:e,...n}=t;return(0,s.kt)($wt,(0,p.Z)({},Qwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first code range that matches the given pattern."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]},tTt="wrapper";function eTt(t){let{components:e,...n}=t;return(0,s.kt)(tTt,(0,p.Z)({},Jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Either a string or a regular expression to match."))}eTt.isMDXComponent=!0;const nTt={toc:[]},oTt="wrapper";function pTt(t){let{components:e,...n}=t;return(0,s.kt)(oTt,(0,p.Z)({},nTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}pTt.isMDXComponent=!0;const rTt={toc:[]},sTt="wrapper";function cTt(t){let{components:e,...n}=t;return(0,s.kt)(sTt,(0,p.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cTt.isMDXComponent=!0;const aTt={toc:[]},iTt="wrapper";function lTt(t){let{components:e,...n}=t;return(0,s.kt)(iTt,(0,p.Z)({},aTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}lTt.isMDXComponent=!0;const uTt={toc:[]},mTt="wrapper";function dTt(t){let{components:e,...n}=t;return(0,s.kt)(mTt,(0,p.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dTt.isMDXComponent=!0;const hTt={toc:[]},fTt="wrapper";function kTt(t){let{components:e,...n}=t;return(0,s.kt)(fTt,(0,p.Z)({},hTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last code range that matches the given pattern."))}kTt.isMDXComponent=!0;const yTt={toc:[]},DTt="wrapper";function MTt(t){let{components:e,...n}=t;return(0,s.kt)(DTt,(0,p.Z)({},yTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Either a string or a regular expression to match."))}MTt.isMDXComponent=!0;const XTt={toc:[]},_Tt="wrapper";function wTt(t){let{components:e,...n}=t;return(0,s.kt)(_Tt,(0,p.Z)({},XTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wTt.isMDXComponent=!0;const TTt={toc:[]},CTt="wrapper";function gTt(t){let{components:e,...n}=t;return(0,s.kt)(CTt,(0,p.Z)({},TTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}gTt.isMDXComponent=!0;const xTt={toc:[]},vTt="wrapper";function LTt(t){let{components:e,...n}=t;return(0,s.kt)(vTt,(0,p.Z)({},xTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}LTt.isMDXComponent=!0;const ZTt={toc:[]},bTt="wrapper";function NTt(t){let{components:e,...n}=t;return(0,s.kt)(bTt,(0,p.Z)({},ZTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}NTt.isMDXComponent=!0;const zTt={toc:[]},ATt="wrapper";function PTt(t){let{components:e,...n}=t;return(0,s.kt)(ATt,(0,p.Z)({},zTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bound box is in local space of the ",(0,s.kt)("inlineCode",{parentName:"p"},"Code")," node."))}PTt.isMDXComponent=!0;const ITt={toc:[]},WTt="wrapper";function RTt(t){let{components:e,...n}=t;return(0,s.kt)(WTt,(0,p.Z)({},ITt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the bounding box of the given point (character) in the code."))}RTt.isMDXComponent=!0;const STt={toc:[]},BTt="wrapper";function GTt(t){let{components:e,...n}=t;return(0,s.kt)(BTt,(0,p.Z)({},STt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point to get the bounding box for."))}GTt.isMDXComponent=!0;const ETt={toc:[]},OTt="wrapper";function UTt(t){let{components:e,...n}=t;return(0,s.kt)(OTt,(0,p.Z)({},ETt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding boxes are in local space of the ",(0,s.kt)("inlineCode",{parentName:"p"},"Code")," node.\nEach line of code has a separate bounding box."))}UTt.isMDXComponent=!0;const FTt={toc:[]},VTt="wrapper";function qTt(t){let{components:e,...n}=t;return(0,s.kt)(VTt,(0,p.Z)({},FTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return bounding boxes of all characters in the selection."))}qTt.isMDXComponent=!0;const jTt={toc:[]},HTt="wrapper";function YTt(t){let{components:e,...n}=t;return(0,s.kt)(HTt,(0,p.Z)({},jTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The selection to get the bounding boxes for."))}YTt.isMDXComponent=!0;const QTt={toc:[]},$Tt="wrapper";function KTt(t){let{components:e,...n}=t;return(0,s.kt)($Tt,(0,p.Z)({},QTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}KTt.isMDXComponent=!0;const JTt={toc:[]},tCt="wrapper";function eCt(t){let{components:e,...n}=t;return(0,s.kt)(tCt,(0,p.Z)({},JTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}eCt.isMDXComponent=!0;const nCt={toc:[]},oCt="wrapper";function pCt(t){let{components:e,...n}=t;return(0,s.kt)(oCt,(0,p.Z)({},nCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}pCt.isMDXComponent=!0;const rCt={toc:[]},sCt="wrapper";function cCt(t){let{components:e,...n}=t;return(0,s.kt)(sCt,(0,p.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}cCt.isMDXComponent=!0;const aCt={toc:[]},iCt="wrapper";function lCt(t){let{components:e,...n}=t;return(0,s.kt)(iCt,(0,p.Z)({},aCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lCt.isMDXComponent=!0;const uCt={toc:[]},mCt="wrapper";function dCt(t){let{components:e,...n}=t;return(0,s.kt)(mCt,(0,p.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dCt.isMDXComponent=!0;const hCt={toc:[]},fCt="wrapper";function kCt(t){let{components:e,...n}=t;return(0,s.kt)(fCt,(0,p.Z)({},hCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}kCt.isMDXComponent=!0;const yCt={toc:[]},DCt="wrapper";function MCt(t){let{components:e,...n}=t;return(0,s.kt)(DCt,(0,p.Z)({},yCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}MCt.isMDXComponent=!0;const XCt={toc:[]},_Ct="wrapper";function wCt(t){let{components:e,...n}=t;return(0,s.kt)(_Ct,(0,p.Z)({},XCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}wCt.isMDXComponent=!0;const TCt={toc:[]},CCt="wrapper";function gCt(t){let{components:e,...n}=t;return(0,s.kt)(CCt,(0,p.Z)({},TCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}gCt.isMDXComponent=!0;const xCt={toc:[]},vCt="wrapper";function LCt(t){let{components:e,...n}=t;return(0,s.kt)(vCt,(0,p.Z)({},xCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LCt.isMDXComponent=!0;const ZCt={toc:[]},bCt="wrapper";function NCt(t){let{components:e,...n}=t;return(0,s.kt)(bCt,(0,p.Z)({},ZCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}NCt.isMDXComponent=!0;const zCt={toc:[]},ACt="wrapper";function PCt(t){let{components:e,...n}=t;return(0,s.kt)(ACt,(0,p.Z)({},zCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}PCt.isMDXComponent=!0;const ICt={toc:[]},WCt="wrapper";function RCt(t){let{components:e,...n}=t;return(0,s.kt)(WCt,(0,p.Z)({},ICt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}RCt.isMDXComponent=!0;const SCt={toc:[]},BCt="wrapper";function GCt(t){let{components:e,...n}=t;return(0,s.kt)(BCt,(0,p.Z)({},SCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}GCt.isMDXComponent=!0;const ECt={toc:[]},OCt="wrapper";function UCt(t){let{components:e,...n}=t;return(0,s.kt)(OCt,(0,p.Z)({},ECt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}UCt.isMDXComponent=!0;const FCt={toc:[]},VCt="wrapper";function qCt(t){let{components:e,...n}=t;return(0,s.kt)(VCt,(0,p.Z)({},FCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}qCt.isMDXComponent=!0;const jCt={toc:[]},HCt="wrapper";function YCt(t){let{components:e,...n}=t;return(0,s.kt)(HCt,(0,p.Z)({},jCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}YCt.isMDXComponent=!0;const QCt={toc:[]},$Ct="wrapper";function KCt(t){let{components:e,...n}=t;return(0,s.kt)($Ct,(0,p.Z)({},QCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}KCt.isMDXComponent=!0;const JCt={toc:[]},tgt="wrapper";function egt(t){let{components:e,...n}=t;return(0,s.kt)(tgt,(0,p.Z)({},JCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}egt.isMDXComponent=!0;const ngt={toc:[]},ogt="wrapper";function pgt(t){let{components:e,...n}=t;return(0,s.kt)(ogt,(0,p.Z)({},ngt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pgt.isMDXComponent=!0;const rgt={toc:[]},sgt="wrapper";function cgt(t){let{components:e,...n}=t;return(0,s.kt)(sgt,(0,p.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cgt.isMDXComponent=!0;const agt={toc:[]},igt="wrapper";function lgt(t){let{components:e,...n}=t;return(0,s.kt)(igt,(0,p.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lgt.isMDXComponent=!0;const ugt={toc:[]},mgt="wrapper";function dgt(t){let{components:e,...n}=t;return(0,s.kt)(mgt,(0,p.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}dgt.isMDXComponent=!0;const hgt={toc:[]},fgt="wrapper";function kgt(t){let{components:e,...n}=t;return(0,s.kt)(fgt,(0,p.Z)({},hgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kgt.isMDXComponent=!0;const ygt={toc:[]},Dgt="wrapper";function Mgt(t){let{components:e,...n}=t;return(0,s.kt)(Dgt,(0,p.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Mgt.isMDXComponent=!0;const Xgt={toc:[]},_gt="wrapper";function wgt(t){let{components:e,...n}=t;return(0,s.kt)(_gt,(0,p.Z)({},Xgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wgt.isMDXComponent=!0;const Tgt={toc:[]},Cgt="wrapper";function ggt(t){let{components:e,...n}=t;return(0,s.kt)(Cgt,(0,p.Z)({},Tgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}ggt.isMDXComponent=!0;const xgt={toc:[]},vgt="wrapper";function Lgt(t){let{components:e,...n}=t;return(0,s.kt)(vgt,(0,p.Z)({},xgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]},bgt="wrapper";function Ngt(t){let{components:e,...n}=t;return(0,s.kt)(bgt,(0,p.Z)({},Zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Ngt.isMDXComponent=!0;const zgt={toc:[]},Agt="wrapper";function Pgt(t){let{components:e,...n}=t;return(0,s.kt)(Agt,(0,p.Z)({},zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Pgt.isMDXComponent=!0;const Igt={toc:[]},Wgt="wrapper";function Rgt(t){let{components:e,...n}=t;return(0,s.kt)(Wgt,(0,p.Z)({},Igt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Rgt.isMDXComponent=!0;const Sgt={toc:[]},Bgt="wrapper";function Ggt(t){let{components:e,...n}=t;return(0,s.kt)(Bgt,(0,p.Z)({},Sgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Ggt.isMDXComponent=!0;const Egt={toc:[]},Ogt="wrapper";function Ugt(t){let{components:e,...n}=t;return(0,s.kt)(Ogt,(0,p.Z)({},Egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Ugt.isMDXComponent=!0;const Fgt={toc:[]},Vgt="wrapper";function qgt(t){let{components:e,...n}=t;return(0,s.kt)(Vgt,(0,p.Z)({},Fgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}qgt.isMDXComponent=!0;const jgt={toc:[]},Hgt="wrapper";function Ygt(t){let{components:e,...n}=t;return(0,s.kt)(Hgt,(0,p.Z)({},jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ygt.isMDXComponent=!0;const Qgt={toc:[]},$gt="wrapper";function Kgt(t){let{components:e,...n}=t;return(0,s.kt)($gt,(0,p.Z)({},Qgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]},txt="wrapper";function ext(t){let{components:e,...n}=t;return(0,s.kt)(txt,(0,p.Z)({},Jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ext.isMDXComponent=!0;const nxt={toc:[]},oxt="wrapper";function pxt(t){let{components:e,...n}=t;return(0,s.kt)(oxt,(0,p.Z)({},nxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}pxt.isMDXComponent=!0;const rxt={toc:[]},sxt="wrapper";function cxt(t){let{components:e,...n}=t;return(0,s.kt)(sxt,(0,p.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}cxt.isMDXComponent=!0;const axt={toc:[]},ixt="wrapper";function lxt(t){let{components:e,...n}=t;return(0,s.kt)(ixt,(0,p.Z)({},axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}lxt.isMDXComponent=!0;const uxt={toc:[]},mxt="wrapper";function dxt(t){let{components:e,...n}=t;return(0,s.kt)(mxt,(0,p.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}dxt.isMDXComponent=!0;const hxt={toc:[]},fxt="wrapper";function kxt(t){let{components:e,...n}=t;return(0,s.kt)(fxt,(0,p.Z)({},hxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}kxt.isMDXComponent=!0;const yxt={toc:[]},Dxt="wrapper";function Mxt(t){let{components:e,...n}=t;return(0,s.kt)(Dxt,(0,p.Z)({},yxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}Mxt.isMDXComponent=!0;const Xxt={toc:[]},_xt="wrapper";function wxt(t){let{components:e,...n}=t;return(0,s.kt)(_xt,(0,p.Z)({},Xxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}wxt.isMDXComponent=!0;const Txt={toc:[]},Cxt="wrapper";function gxt(t){let{components:e,...n}=t;return(0,s.kt)(Cxt,(0,p.Z)({},Txt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}gxt.isMDXComponent=!0;const xxt={toc:[]},vxt="wrapper";function Lxt(t){let{components:e,...n}=t;return(0,s.kt)(vxt,(0,p.Z)({},xxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the currently displayed code as a string."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]},bxt="wrapper";function Nxt(t){let{components:e,...n}=t;return(0,s.kt)(bxt,(0,p.Z)({},Zxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Nxt.isMDXComponent=!0;const zxt={toc:[]},Axt="wrapper";function Pxt(t){let{components:e,...n}=t;return(0,s.kt)(Axt,(0,p.Z)({},zxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}Pxt.isMDXComponent=!0;const Ixt={toc:[]},Wxt="wrapper";function Rxt(t){let{components:e,...n}=t;return(0,s.kt)(Wxt,(0,p.Z)({},Ixt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Rxt.isMDXComponent=!0;const Sxt={toc:[]},Bxt="wrapper";function Gxt(t){let{components:e,...n}=t;return(0,s.kt)(Bxt,(0,p.Z)({},Sxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Gxt.isMDXComponent=!0;const Ext={toc:[]},Oxt="wrapper";function Uxt(t){let{components:e,...n}=t;return(0,s.kt)(Oxt,(0,p.Z)({},Ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Uxt.isMDXComponent=!0;const Fxt={toc:[]},Vxt="wrapper";function qxt(t){let{components:e,...n}=t;return(0,s.kt)(Vxt,(0,p.Z)({},Fxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}qxt.isMDXComponent=!0;const jxt={toc:[]},Hxt="wrapper";function Yxt(t){let{components:e,...n}=t;return(0,s.kt)(Hxt,(0,p.Z)({},jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Yxt.isMDXComponent=!0;const Qxt={toc:[]},$xt="wrapper";function Kxt(t){let{components:e,...n}=t;return(0,s.kt)($xt,(0,p.Z)({},Qxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]},tvt="wrapper";function evt(t){let{components:e,...n}=t;return(0,s.kt)(tvt,(0,p.Z)({},Jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}evt.isMDXComponent=!0;const nvt={toc:[]},ovt="wrapper";function pvt(t){let{components:e,...n}=t;return(0,s.kt)(ovt,(0,p.Z)({},nvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pvt.isMDXComponent=!0;const rvt={toc:[]},svt="wrapper";function cvt(t){let{components:e,...n}=t;return(0,s.kt)(svt,(0,p.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}cvt.isMDXComponent=!0;const avt={toc:[]},ivt="wrapper";function lvt(t){let{components:e,...n}=t;return(0,s.kt)(ivt,(0,p.Z)({},avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lvt.isMDXComponent=!0;const uvt={toc:[]},mvt="wrapper";function dvt(t){let{components:e,...n}=t;return(0,s.kt)(mvt,(0,p.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}dvt.isMDXComponent=!0;const hvt={toc:[]},fvt="wrapper";function kvt(t){let{components:e,...n}=t;return(0,s.kt)(fvt,(0,p.Z)({},hvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kvt.isMDXComponent=!0;const yvt={toc:[]},Dvt="wrapper";function Mvt(t){let{components:e,...n}=t;return(0,s.kt)(Dvt,(0,p.Z)({},yvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Mvt.isMDXComponent=!0;const Xvt={toc:[]},_vt="wrapper";function wvt(t){let{components:e,...n}=t;return(0,s.kt)(_vt,(0,p.Z)({},Xvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}wvt.isMDXComponent=!0;const Tvt={toc:[]},Cvt="wrapper";function gvt(t){let{components:e,...n}=t;return(0,s.kt)(Cvt,(0,p.Z)({},Tvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gvt.isMDXComponent=!0;const xvt={toc:[]},vvt="wrapper";function Lvt(t){let{components:e,...n}=t;return(0,s.kt)(vvt,(0,p.Z)({},xvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Lvt.isMDXComponent=!0;const Zvt={toc:[]},bvt="wrapper";function Nvt(t){let{components:e,...n}=t;return(0,s.kt)(bvt,(0,p.Z)({},Zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Nvt.isMDXComponent=!0;const zvt={toc:[]},Avt="wrapper";function Pvt(t){let{components:e,...n}=t;return(0,s.kt)(Avt,(0,p.Z)({},zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pvt.isMDXComponent=!0;const Ivt={toc:[]},Wvt="wrapper";function Rvt(t){let{components:e,...n}=t;return(0,s.kt)(Wvt,(0,p.Z)({},Ivt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Rvt.isMDXComponent=!0;const Svt={toc:[]},Bvt="wrapper";function Gvt(t){let{components:e,...n}=t;return(0,s.kt)(Bvt,(0,p.Z)({},Svt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Gvt.isMDXComponent=!0;const Evt={toc:[]},Ovt="wrapper";function Uvt(t){let{components:e,...n}=t;return(0,s.kt)(Ovt,(0,p.Z)({},Evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Uvt.isMDXComponent=!0;const Fvt={toc:[]},Vvt="wrapper";function qvt(t){let{components:e,...n}=t;return(0,s.kt)(Vvt,(0,p.Z)({},Fvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qvt.isMDXComponent=!0;const jvt={toc:[]},Hvt="wrapper";function Yvt(t){let{components:e,...n}=t;return(0,s.kt)(Hvt,(0,p.Z)({},jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Yvt.isMDXComponent=!0;const Qvt={toc:[]},$vt="wrapper";function Kvt(t){let{components:e,...n}=t;return(0,s.kt)($vt,(0,p.Z)({},Qvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]},tLt="wrapper";function eLt(t){let{components:e,...n}=t;return(0,s.kt)(tLt,(0,p.Z)({},Jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}eLt.isMDXComponent=!0;const nLt={toc:[]},oLt="wrapper";function pLt(t){let{components:e,...n}=t;return(0,s.kt)(oLt,(0,p.Z)({},nLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}pLt.isMDXComponent=!0;const rLt={toc:[]},sLt="wrapper";function cLt(t){let{components:e,...n}=t;return(0,s.kt)(sLt,(0,p.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}cLt.isMDXComponent=!0;const aLt={toc:[]},iLt="wrapper";function lLt(t){let{components:e,...n}=t;return(0,s.kt)(iLt,(0,p.Z)({},aLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}lLt.isMDXComponent=!0;const uLt={toc:[]},mLt="wrapper";function dLt(t){let{components:e,...n}=t;return(0,s.kt)(mLt,(0,p.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}dLt.isMDXComponent=!0;const hLt={toc:[]},fLt="wrapper";function kLt(t){let{components:e,...n}=t;return(0,s.kt)(fLt,(0,p.Z)({},hLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}kLt.isMDXComponent=!0;const yLt={toc:[]},DLt="wrapper";function MLt(t){let{components:e,...n}=t;return(0,s.kt)(DLt,(0,p.Z)({},yLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}MLt.isMDXComponent=!0;const XLt={toc:[]},_Lt="wrapper";function wLt(t){let{components:e,...n}=t;return(0,s.kt)(_Lt,(0,p.Z)({},XLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wLt.isMDXComponent=!0;const TLt={toc:[]},CLt="wrapper";function gLt(t){let{components:e,...n}=t;return(0,s.kt)(CLt,(0,p.Z)({},TLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gLt.isMDXComponent=!0;const xLt={toc:[]},vLt="wrapper";function LLt(t){let{components:e,...n}=t;return(0,s.kt)(vLt,(0,p.Z)({},xLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LLt.isMDXComponent=!0;const ZLt={toc:[]},bLt="wrapper";function NLt(t){let{components:e,...n}=t;return(0,s.kt)(bLt,(0,p.Z)({},ZLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}NLt.isMDXComponent=!0;const zLt={toc:[]},ALt="wrapper";function PLt(t){let{components:e,...n}=t;return(0,s.kt)(ALt,(0,p.Z)({},zLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}PLt.isMDXComponent=!0;const ILt={toc:[]},WLt="wrapper";function RLt(t){let{components:e,...n}=t;return(0,s.kt)(WLt,(0,p.Z)({},ILt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Code#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}RLt.isMDXComponent=!0;const SLt={toc:[]},BLt="wrapper";function GLt(t){let{components:e,...n}=t;return(0,s.kt)(BLt,(0,p.Z)({},SLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}GLt.isMDXComponent=!0;const ELt={toc:[]},OLt="wrapper";function ULt(t){let{components:e,...n}=t;return(0,s.kt)(OLt,(0,p.Z)({},ELt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ULt.isMDXComponent=!0;const FLt={toc:[]},VLt="wrapper";function qLt(t){let{components:e,...n}=t;return(0,s.kt)(VLt,(0,p.Z)({},FLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qLt.isMDXComponent=!0;const jLt={toc:[]},HLt="wrapper";function YLt(t){let{components:e,...n}=t;return(0,s.kt)(HLt,(0,p.Z)({},jLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}YLt.isMDXComponent=!0;const QLt={toc:[]},$Lt="wrapper";function KLt(t){let{components:e,...n}=t;return(0,s.kt)($Lt,(0,p.Z)({},QLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}KLt.isMDXComponent=!0;const JLt={toc:[]},tZt="wrapper";function eZt(t){let{components:e,...n}=t;return(0,s.kt)(tZt,(0,p.Z)({},JLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}eZt.isMDXComponent=!0;const nZt={toc:[]},oZt="wrapper";function pZt(t){let{components:e,...n}=t;return(0,s.kt)(oZt,(0,p.Z)({},nZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a standalone code signal."))}pZt.isMDXComponent=!0;const rZt={toc:[]},sZt="wrapper";function cZt(t){let{components:e,...n}=t;return(0,s.kt)(sZt,(0,p.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial code."))}cZt.isMDXComponent=!0;const aZt={toc:[]},iZt="wrapper";function lZt(t){let{components:e,...n}=t;return(0,s.kt)(iZt,(0,p.Z)({},aZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Custom highlighter to use."))}lZt.isMDXComponent=!0;const uZt={toc:[]},mZt="wrapper";function dZt(t){let{components:e,...n}=t;return(0,s.kt)(mZt,(0,p.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}dZt.isMDXComponent=!0;const hZt={toc:[]},fZt="wrapper";function kZt(t){let{components:e,...n}=t;return(0,s.kt)(fZt,(0,p.Z)({},hZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}kZt.isMDXComponent=!0;const yZt={toc:[]},DZt="wrapper";function MZt(t){let{components:e,...n}=t;return(0,s.kt)(DZt,(0,p.Z)({},yZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}MZt.isMDXComponent=!0;const XZt={toc:[]},_Zt="wrapper";function wZt(t){let{components:e,...n}=t;return(0,s.kt)(_Zt,(0,p.Z)({},XZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}wZt.isMDXComponent=!0;const TZt={toc:[]},CZt="wrapper";function gZt(t){let{components:e,...n}=t;return(0,s.kt)(CZt,(0,p.Z)({},TZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}gZt.isMDXComponent=!0;const xZt={toc:[]},vZt="wrapper";function LZt(t){let{components:e,...n}=t;return(0,s.kt)(vZt,(0,p.Z)({},xZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}LZt.isMDXComponent=!0;const ZZt={toc:[]},bZt="wrapper";function NZt(t){let{components:e,...n}=t;return(0,s.kt)(bZt,(0,p.Z)({},ZZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}NZt.isMDXComponent=!0;const zZt={toc:[]},AZt="wrapper";function PZt(t){let{components:e,...n}=t;return(0,s.kt)(AZt,(0,p.Z)({},zZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}PZt.isMDXComponent=!0;const IZt={toc:[]},WZt="wrapper";function RZt(t){let{components:e,...n}=t;return(0,s.kt)(WZt,(0,p.Z)({},IZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}RZt.isMDXComponent=!0;const SZt={toc:[]},BZt="wrapper";function GZt(t){let{components:e,...n}=t;return(0,s.kt)(BZt,(0,p.Z)({},SZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}GZt.isMDXComponent=!0;const EZt={toc:[]},OZt="wrapper";function UZt(t){let{components:e,...n}=t;return(0,s.kt)(OZt,(0,p.Z)({},EZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}UZt.isMDXComponent=!0;const FZt={toc:[]},VZt="wrapper";function qZt(t){let{components:e,...n}=t;return(0,s.kt)(VZt,(0,p.Z)({},FZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qZt.isMDXComponent=!0;const jZt={toc:[]},HZt="wrapper";function YZt(t){let{components:e,...n}=t;return(0,s.kt)(HZt,(0,p.Z)({},jZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}YZt.isMDXComponent=!0;const QZt={toc:[]},$Zt="wrapper";function KZt(t){let{components:e,...n}=t;return(0,s.kt)($Zt,(0,p.Z)({},QZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KZt.isMDXComponent=!0;const JZt={toc:[]},tbt="wrapper";function ebt(t){let{components:e,...n}=t;return(0,s.kt)(tbt,(0,p.Z)({},JZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}ebt.isMDXComponent=!0;const nbt={toc:[]},obt="wrapper";function pbt(t){let{components:e,...n}=t;return(0,s.kt)(obt,(0,p.Z)({},nbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pbt.isMDXComponent=!0;const rbt={toc:[]},sbt="wrapper";function cbt(t){let{components:e,...n}=t;return(0,s.kt)(sbt,(0,p.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}cbt.isMDXComponent=!0;const abt={toc:[]},ibt="wrapper";function lbt(t){let{components:e,...n}=t;return(0,s.kt)(ibt,(0,p.Z)({},abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}lbt.isMDXComponent=!0;const ubt={toc:[]},mbt="wrapper";function dbt(t){let{components:e,...n}=t;return(0,s.kt)(mbt,(0,p.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}dbt.isMDXComponent=!0;const hbt={toc:[]},fbt="wrapper";function kbt(t){let{components:e,...n}=t;return(0,s.kt)(fbt,(0,p.Z)({},hbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}kbt.isMDXComponent=!0;const ybt={toc:[]},Dbt="wrapper";function Mbt(t){let{components:e,...n}=t;return(0,s.kt)(Dbt,(0,p.Z)({},ybt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Mbt.isMDXComponent=!0;const Xbt={toc:[]},_bt="wrapper";function wbt(t){let{components:e,...n}=t;return(0,s.kt)(_bt,(0,p.Z)({},Xbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}wbt.isMDXComponent=!0;const Tbt={toc:[]},Cbt="wrapper";function gbt(t){let{components:e,...n}=t;return(0,s.kt)(Cbt,(0,p.Z)({},Tbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gbt.isMDXComponent=!0;const xbt={toc:[]},vbt="wrapper";function Lbt(t){let{components:e,...n}=t;return(0,s.kt)(vbt,(0,p.Z)({},xbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]},bbt="wrapper";function Nbt(t){let{components:e,...n}=t;return(0,s.kt)(bbt,(0,p.Z)({},Zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Nbt.isMDXComponent=!0;const zbt={toc:[]},Abt="wrapper";function Pbt(t){let{components:e,...n}=t;return(0,s.kt)(Abt,(0,p.Z)({},zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Pbt.isMDXComponent=!0;const Ibt={toc:[]},Wbt="wrapper";function Rbt(t){let{components:e,...n}=t;return(0,s.kt)(Wbt,(0,p.Z)({},Ibt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Rbt.isMDXComponent=!0;const Sbt={toc:[]},Bbt="wrapper";function Gbt(t){let{components:e,...n}=t;return(0,s.kt)(Bbt,(0,p.Z)({},Sbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Gbt.isMDXComponent=!0;const Ebt={toc:[]},Obt="wrapper";function Ubt(t){let{components:e,...n}=t;return(0,s.kt)(Obt,(0,p.Z)({},Ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Ubt.isMDXComponent=!0;const Fbt={toc:[]},Vbt="wrapper";function qbt(t){let{components:e,...n}=t;return(0,s.kt)(Vbt,(0,p.Z)({},Fbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}qbt.isMDXComponent=!0;const jbt={toc:[]},Hbt="wrapper";function Ybt(t){let{components:e,...n}=t;return(0,s.kt)(Hbt,(0,p.Z)({},jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ybt.isMDXComponent=!0;const Qbt={toc:[]},$bt="wrapper";function Kbt(t){let{components:e,...n}=t;return(0,s.kt)($bt,(0,p.Z)({},Qbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]},tNt="wrapper";function eNt(t){let{components:e,...n}=t;return(0,s.kt)(tNt,(0,p.Z)({},Jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}eNt.isMDXComponent=!0;const nNt={toc:[]},oNt="wrapper";function pNt(t){let{components:e,...n}=t;return(0,s.kt)(oNt,(0,p.Z)({},nNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}pNt.isMDXComponent=!0;const rNt={toc:[]},sNt="wrapper";function cNt(t){let{components:e,...n}=t;return(0,s.kt)(sNt,(0,p.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}cNt.isMDXComponent=!0;const aNt={toc:[]},iNt="wrapper";function lNt(t){let{components:e,...n}=t;return(0,s.kt)(iNt,(0,p.Z)({},aNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}lNt.isMDXComponent=!0;const uNt={toc:[]},mNt="wrapper";function dNt(t){let{components:e,...n}=t;return(0,s.kt)(mNt,(0,p.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}dNt.isMDXComponent=!0;const hNt={toc:[]},fNt="wrapper";function kNt(t){let{components:e,...n}=t;return(0,s.kt)(fNt,(0,p.Z)({},hNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}kNt.isMDXComponent=!0;const yNt={toc:[]},DNt="wrapper";function MNt(t){let{components:e,...n}=t;return(0,s.kt)(DNt,(0,p.Z)({},yNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}MNt.isMDXComponent=!0;const XNt={toc:[]},_Nt="wrapper";function wNt(t){let{components:e,...n}=t;return(0,s.kt)(_Nt,(0,p.Z)({},XNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wNt.isMDXComponent=!0;const TNt={toc:[]},CNt="wrapper";function gNt(t){let{components:e,...n}=t;return(0,s.kt)(CNt,(0,p.Z)({},TNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}gNt.isMDXComponent=!0;const xNt={toc:[]},vNt="wrapper";function LNt(t){let{components:e,...n}=t;return(0,s.kt)(vNt,(0,p.Z)({},xNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}LNt.isMDXComponent=!0;const ZNt={toc:[]},bNt="wrapper";function NNt(t){let{components:e,...n}=t;return(0,s.kt)(bNt,(0,p.Z)({},ZNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}NNt.isMDXComponent=!0;const zNt={toc:[]},ANt="wrapper";function PNt(t){let{components:e,...n}=t;return(0,s.kt)(ANt,(0,p.Z)({},zNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}PNt.isMDXComponent=!0;const INt={toc:[]},WNt="wrapper";function RNt(t){let{components:e,...n}=t;return(0,s.kt)(WNt,(0,p.Z)({},INt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}RNt.isMDXComponent=!0;const SNt={toc:[]},BNt="wrapper";function GNt(t){let{components:e,...n}=t;return(0,s.kt)(BNt,(0,p.Z)({},SNt,n,{components:e,mdxType:"MDXLayout"}))}GNt.isMDXComponent=!0;const ENt={toc:[]},ONt="wrapper";function UNt(t){let{components:e,...n}=t;return(0,s.kt)(ONt,(0,p.Z)({},ENt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}UNt.isMDXComponent=!0;const FNt={toc:[]},VNt="wrapper";function qNt(t){let{components:e,...n}=t;return(0,s.kt)(VNt,(0,p.Z)({},FNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qNt.isMDXComponent=!0;const jNt={toc:[]},HNt="wrapper";function YNt(t){let{components:e,...n}=t;return(0,s.kt)(HNt,(0,p.Z)({},jNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}YNt.isMDXComponent=!0;const QNt={toc:[]},$Nt="wrapper";function KNt(t){let{components:e,...n}=t;return(0,s.kt)($Nt,(0,p.Z)({},QNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}KNt.isMDXComponent=!0;const JNt={toc:[]},tzt="wrapper";function ezt(t){let{components:e,...n}=t;return(0,s.kt)(tzt,(0,p.Z)({},JNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}ezt.isMDXComponent=!0;const nzt={toc:[]},ozt="wrapper";function pzt(t){let{components:e,...n}=t;return(0,s.kt)(ozt,(0,p.Z)({},nzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}pzt.isMDXComponent=!0;const rzt={toc:[]},szt="wrapper";function czt(t){let{components:e,...n}=t;return(0,s.kt)(szt,(0,p.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}))}czt.isMDXComponent=!0;const azt={toc:[]},izt="wrapper";function lzt(t){let{components:e,...n}=t;return(0,s.kt)(izt,(0,p.Z)({},azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lzt.isMDXComponent=!0;const uzt={toc:[]},mzt="wrapper";function dzt(t){let{components:e,...n}=t;return(0,s.kt)(mzt,(0,p.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}dzt.isMDXComponent=!0;const hzt={toc:[]},fzt="wrapper";function kzt(t){let{components:e,...n}=t;return(0,s.kt)(fzt,(0,p.Z)({},hzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kzt.isMDXComponent=!0;const yzt={toc:[]},Dzt="wrapper";function Mzt(t){let{components:e,...n}=t;return(0,s.kt)(Dzt,(0,p.Z)({},yzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Mzt.isMDXComponent=!0;const Xzt={toc:[]},_zt="wrapper";function wzt(t){let{components:e,...n}=t;return(0,s.kt)(_zt,(0,p.Z)({},Xzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wzt.isMDXComponent=!0;const Tzt={toc:[]},Czt="wrapper";function gzt(t){let{components:e,...n}=t;return(0,s.kt)(Czt,(0,p.Z)({},Tzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}gzt.isMDXComponent=!0;const xzt={toc:[]},vzt="wrapper";function Lzt(t){let{components:e,...n}=t;return(0,s.kt)(vzt,(0,p.Z)({},xzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]},bzt="wrapper";function Nzt(t){let{components:e,...n}=t;return(0,s.kt)(bzt,(0,p.Z)({},Zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Nzt.isMDXComponent=!0;const zzt={toc:[]},Azt="wrapper";function Pzt(t){let{components:e,...n}=t;return(0,s.kt)(Azt,(0,p.Z)({},zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Pzt.isMDXComponent=!0;const Izt={toc:[]},Wzt="wrapper";function Rzt(t){let{components:e,...n}=t;return(0,s.kt)(Wzt,(0,p.Z)({},Izt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Rzt.isMDXComponent=!0;const Szt={toc:[]},Bzt="wrapper";function Gzt(t){let{components:e,...n}=t;return(0,s.kt)(Bzt,(0,p.Z)({},Szt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Gzt.isMDXComponent=!0;const Ezt={toc:[]},Ozt="wrapper";function Uzt(t){let{components:e,...n}=t;return(0,s.kt)(Ozt,(0,p.Z)({},Ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Uzt.isMDXComponent=!0;const Fzt={toc:[]},Vzt="wrapper";function qzt(t){let{components:e,...n}=t;return(0,s.kt)(Vzt,(0,p.Z)({},Fzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qzt.isMDXComponent=!0;const jzt={toc:[]},Hzt="wrapper";function Yzt(t){let{components:e,...n}=t;return(0,s.kt)(Hzt,(0,p.Z)({},jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Yzt.isMDXComponent=!0;const Qzt={toc:[]},$zt="wrapper";function Kzt(t){let{components:e,...n}=t;return(0,s.kt)($zt,(0,p.Z)({},Qzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Kzt.isMDXComponent=!0;const Jzt={toc:[]},tAt="wrapper";function eAt(t){let{components:e,...n}=t;return(0,s.kt)(tAt,(0,p.Z)({},Jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eAt.isMDXComponent=!0;const nAt={toc:[]},oAt="wrapper";function pAt(t){let{components:e,...n}=t;return(0,s.kt)(oAt,(0,p.Z)({},nAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pAt.isMDXComponent=!0;const rAt={toc:[]},sAt="wrapper";function cAt(t){let{components:e,...n}=t;return(0,s.kt)(sAt,(0,p.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cAt.isMDXComponent=!0;const aAt={toc:[]},iAt="wrapper";function lAt(t){let{components:e,...n}=t;return(0,s.kt)(iAt,(0,p.Z)({},aAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lAt.isMDXComponent=!0;const uAt={toc:[]},mAt="wrapper";function dAt(t){let{components:e,...n}=t;return(0,s.kt)(mAt,(0,p.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}dAt.isMDXComponent=!0;const hAt={toc:[]},fAt="wrapper";function kAt(t){let{components:e,...n}=t;return(0,s.kt)(fAt,(0,p.Z)({},hAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kAt.isMDXComponent=!0;const yAt={toc:[]},DAt="wrapper";function MAt(t){let{components:e,...n}=t;return(0,s.kt)(DAt,(0,p.Z)({},yAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}MAt.isMDXComponent=!0;const XAt={toc:[]},_At="wrapper";function wAt(t){let{components:e,...n}=t;return(0,s.kt)(_At,(0,p.Z)({},XAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}wAt.isMDXComponent=!0;const TAt={toc:[]},CAt="wrapper";function gAt(t){let{components:e,...n}=t;return(0,s.kt)(CAt,(0,p.Z)({},TAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}gAt.isMDXComponent=!0;const xAt={toc:[]},vAt="wrapper";function LAt(t){let{components:e,...n}=t;return(0,s.kt)(vAt,(0,p.Z)({},xAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}LAt.isMDXComponent=!0;const ZAt={toc:[]},bAt="wrapper";function NAt(t){let{components:e,...n}=t;return(0,s.kt)(bAt,(0,p.Z)({},ZAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}NAt.isMDXComponent=!0;const zAt={toc:[]},AAt="wrapper";function PAt(t){let{components:e,...n}=t;return(0,s.kt)(AAt,(0,p.Z)({},zAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}PAt.isMDXComponent=!0;const IAt={toc:[]},WAt="wrapper";function RAt(t){let{components:e,...n}=t;return(0,s.kt)(WAt,(0,p.Z)({},IAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}RAt.isMDXComponent=!0;const SAt={toc:[]},BAt="wrapper";function GAt(t){let{components:e,...n}=t;return(0,s.kt)(BAt,(0,p.Z)({},SAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}GAt.isMDXComponent=!0;const EAt={toc:[]},OAt="wrapper";function UAt(t){let{components:e,...n}=t;return(0,s.kt)(OAt,(0,p.Z)({},EAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}UAt.isMDXComponent=!0;const FAt={toc:[]},VAt="wrapper";function qAt(t){let{components:e,...n}=t;return(0,s.kt)(VAt,(0,p.Z)({},FAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}qAt.isMDXComponent=!0;const jAt={toc:[]},HAt="wrapper";function YAt(t){let{components:e,...n}=t;return(0,s.kt)(HAt,(0,p.Z)({},jAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}YAt.isMDXComponent=!0;const QAt={toc:[]},$At="wrapper";function KAt(t){let{components:e,...n}=t;return(0,s.kt)($At,(0,p.Z)({},QAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}KAt.isMDXComponent=!0;const JAt={toc:[]},tPt="wrapper";function ePt(t){let{components:e,...n}=t;return(0,s.kt)(tPt,(0,p.Z)({},JAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}ePt.isMDXComponent=!0;const nPt={toc:[]},oPt="wrapper";function pPt(t){let{components:e,...n}=t;return(0,s.kt)(oPt,(0,p.Z)({},nPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pPt.isMDXComponent=!0;const rPt={toc:[]},sPt="wrapper";function cPt(t){let{components:e,...n}=t;return(0,s.kt)(sPt,(0,p.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}cPt.isMDXComponent=!0;const aPt={toc:[]},iPt="wrapper";function lPt(t){let{components:e,...n}=t;return(0,s.kt)(iPt,(0,p.Z)({},aPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lPt.isMDXComponent=!0;const uPt={toc:[]},mPt="wrapper";function dPt(t){let{components:e,...n}=t;return(0,s.kt)(mPt,(0,p.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}dPt.isMDXComponent=!0;const hPt={toc:[]},fPt="wrapper";function kPt(t){let{components:e,...n}=t;return(0,s.kt)(fPt,(0,p.Z)({},hPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}kPt.isMDXComponent=!0;const yPt={toc:[]},DPt="wrapper";function MPt(t){let{components:e,...n}=t;return(0,s.kt)(DPt,(0,p.Z)({},yPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}MPt.isMDXComponent=!0;const XPt={toc:[]},_Pt="wrapper";function wPt(t){let{components:e,...n}=t;return(0,s.kt)(_Pt,(0,p.Z)({},XPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wPt.isMDXComponent=!0;const TPt={toc:[]},CPt="wrapper";function gPt(t){let{components:e,...n}=t;return(0,s.kt)(CPt,(0,p.Z)({},TPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}gPt.isMDXComponent=!0;const xPt={toc:[]},vPt="wrapper";function LPt(t){let{components:e,...n}=t;return(0,s.kt)(vPt,(0,p.Z)({},xPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}LPt.isMDXComponent=!0;const ZPt={toc:[]},bPt="wrapper";function NPt(t){let{components:e,...n}=t;return(0,s.kt)(bPt,(0,p.Z)({},ZPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}NPt.isMDXComponent=!0;const zPt={toc:[]},APt="wrapper";function PPt(t){let{components:e,...n}=t;return(0,s.kt)(APt,(0,p.Z)({},zPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}PPt.isMDXComponent=!0;const IPt={toc:[]},WPt="wrapper";function RPt(t){let{components:e,...n}=t;return(0,s.kt)(WPt,(0,p.Z)({},IPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}RPt.isMDXComponent=!0;const SPt={toc:[]},BPt="wrapper";function GPt(t){let{components:e,...n}=t;return(0,s.kt)(BPt,(0,p.Z)({},SPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}GPt.isMDXComponent=!0;const EPt={toc:[]},OPt="wrapper";function UPt(t){let{components:e,...n}=t;return(0,s.kt)(OPt,(0,p.Z)({},EPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}UPt.isMDXComponent=!0;const FPt={toc:[]},VPt="wrapper";function qPt(t){let{components:e,...n}=t;return(0,s.kt)(VPt,(0,p.Z)({},FPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qPt.isMDXComponent=!0;const jPt={toc:[]},HPt="wrapper";function YPt(t){let{components:e,...n}=t;return(0,s.kt)(HPt,(0,p.Z)({},jPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YPt.isMDXComponent=!0;const QPt={toc:[]},$Pt="wrapper";function KPt(t){let{components:e,...n}=t;return(0,s.kt)($Pt,(0,p.Z)({},QPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KPt.isMDXComponent=!0;const JPt={toc:[]},tIt="wrapper";function eIt(t){let{components:e,...n}=t;return(0,s.kt)(tIt,(0,p.Z)({},JPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}eIt.isMDXComponent=!0;const nIt={toc:[]},oIt="wrapper";function pIt(t){let{components:e,...n}=t;return(0,s.kt)(oIt,(0,p.Z)({},nIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pIt.isMDXComponent=!0;const rIt={toc:[]},sIt="wrapper";function cIt(t){let{components:e,...n}=t;return(0,s.kt)(sIt,(0,p.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}cIt.isMDXComponent=!0;const aIt={toc:[]},iIt="wrapper";function lIt(t){let{components:e,...n}=t;return(0,s.kt)(iIt,(0,p.Z)({},aIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lIt.isMDXComponent=!0;const uIt={toc:[]},mIt="wrapper";function dIt(t){let{components:e,...n}=t;return(0,s.kt)(mIt,(0,p.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dIt.isMDXComponent=!0;const hIt={toc:[]},fIt="wrapper";function kIt(t){let{components:e,...n}=t;return(0,s.kt)(fIt,(0,p.Z)({},hIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}kIt.isMDXComponent=!0;const yIt={toc:[]},DIt="wrapper";function MIt(t){let{components:e,...n}=t;return(0,s.kt)(DIt,(0,p.Z)({},yIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MIt.isMDXComponent=!0;const XIt={toc:[]},_It="wrapper";function wIt(t){let{components:e,...n}=t;return(0,s.kt)(_It,(0,p.Z)({},XIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wIt.isMDXComponent=!0;const TIt={toc:[]},CIt="wrapper";function gIt(t){let{components:e,...n}=t;return(0,s.kt)(CIt,(0,p.Z)({},TIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gIt.isMDXComponent=!0;const xIt={toc:[]},vIt="wrapper";function LIt(t){let{components:e,...n}=t;return(0,s.kt)(vIt,(0,p.Z)({},xIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}LIt.isMDXComponent=!0;const ZIt={toc:[]},bIt="wrapper";function NIt(t){let{components:e,...n}=t;return(0,s.kt)(bIt,(0,p.Z)({},ZIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NIt.isMDXComponent=!0;const zIt={toc:[]},AIt="wrapper";function PIt(t){let{components:e,...n}=t;return(0,s.kt)(AIt,(0,p.Z)({},zIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}PIt.isMDXComponent=!0;const IIt={toc:[]},WIt="wrapper";function RIt(t){let{components:e,...n}=t;return(0,s.kt)(WIt,(0,p.Z)({},IIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}RIt.isMDXComponent=!0;const SIt={toc:[]},BIt="wrapper";function GIt(t){let{components:e,...n}=t;return(0,s.kt)(BIt,(0,p.Z)({},SIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}GIt.isMDXComponent=!0;const EIt={toc:[]},OIt="wrapper";function UIt(t){let{components:e,...n}=t;return(0,s.kt)(OIt,(0,p.Z)({},EIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}UIt.isMDXComponent=!0;const FIt={toc:[]},VIt="wrapper";function qIt(t){let{components:e,...n}=t;return(0,s.kt)(VIt,(0,p.Z)({},FIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qIt.isMDXComponent=!0;const jIt={toc:[]},HIt="wrapper";function YIt(t){let{components:e,...n}=t;return(0,s.kt)(HIt,(0,p.Z)({},jIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}YIt.isMDXComponent=!0;const QIt={toc:[]},$It="wrapper";function KIt(t){let{components:e,...n}=t;return(0,s.kt)($It,(0,p.Z)({},QIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}KIt.isMDXComponent=!0;const JIt={toc:[]},tWt="wrapper";function eWt(t){let{components:e,...n}=t;return(0,s.kt)(tWt,(0,p.Z)({},JIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eWt.isMDXComponent=!0;const nWt={toc:[]},oWt="wrapper";function pWt(t){let{components:e,...n}=t;return(0,s.kt)(oWt,(0,p.Z)({},nWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pWt.isMDXComponent=!0;const rWt={toc:[]},sWt="wrapper";function cWt(t){let{components:e,...n}=t;return(0,s.kt)(sWt,(0,p.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cWt.isMDXComponent=!0;const aWt={toc:[]},iWt="wrapper";function lWt(t){let{components:e,...n}=t;return(0,s.kt)(iWt,(0,p.Z)({},aWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lWt.isMDXComponent=!0;const uWt={toc:[]},mWt="wrapper";function dWt(t){let{components:e,...n}=t;return(0,s.kt)(mWt,(0,p.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}dWt.isMDXComponent=!0;const hWt={toc:[]},fWt="wrapper";function kWt(t){let{components:e,...n}=t;return(0,s.kt)(fWt,(0,p.Z)({},hWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kWt.isMDXComponent=!0;const yWt={toc:[]},DWt="wrapper";function MWt(t){let{components:e,...n}=t;return(0,s.kt)(DWt,(0,p.Z)({},yWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}MWt.isMDXComponent=!0;const XWt={toc:[]},_Wt="wrapper";function wWt(t){let{components:e,...n}=t;return(0,s.kt)(_Wt,(0,p.Z)({},XWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wWt.isMDXComponent=!0;const TWt={toc:[]},CWt="wrapper";function gWt(t){let{components:e,...n}=t;return(0,s.kt)(CWt,(0,p.Z)({},TWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}gWt.isMDXComponent=!0;const xWt={toc:[]},vWt="wrapper";function LWt(t){let{components:e,...n}=t;return(0,s.kt)(vWt,(0,p.Z)({},xWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}LWt.isMDXComponent=!0;const ZWt={toc:[]},bWt="wrapper";function NWt(t){let{components:e,...n}=t;return(0,s.kt)(bWt,(0,p.Z)({},ZWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}NWt.isMDXComponent=!0;const zWt={toc:[]},AWt="wrapper";function PWt(t){let{components:e,...n}=t;return(0,s.kt)(AWt,(0,p.Z)({},zWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}PWt.isMDXComponent=!0;const IWt={toc:[]},WWt="wrapper";function RWt(t){let{components:e,...n}=t;return(0,s.kt)(WWt,(0,p.Z)({},IWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}RWt.isMDXComponent=!0;const SWt={toc:[]},BWt="wrapper";function GWt(t){let{components:e,...n}=t;return(0,s.kt)(BWt,(0,p.Z)({},SWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}GWt.isMDXComponent=!0;const EWt={toc:[]},OWt="wrapper";function UWt(t){let{components:e,...n}=t;return(0,s.kt)(OWt,(0,p.Z)({},EWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}UWt.isMDXComponent=!0;const FWt={toc:[]},VWt="wrapper";function qWt(t){let{components:e,...n}=t;return(0,s.kt)(VWt,(0,p.Z)({},FWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qWt.isMDXComponent=!0;const jWt={toc:[]},HWt="wrapper";function YWt(t){let{components:e,...n}=t;return(0,s.kt)(HWt,(0,p.Z)({},jWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}YWt.isMDXComponent=!0;const QWt={toc:[]},$Wt="wrapper";function KWt(t){let{components:e,...n}=t;return(0,s.kt)($Wt,(0,p.Z)({},QWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}KWt.isMDXComponent=!0;const JWt={toc:[]},tRt="wrapper";function eRt(t){let{components:e,...n}=t;return(0,s.kt)(tRt,(0,p.Z)({},JWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}eRt.isMDXComponent=!0;const nRt={toc:[]},oRt="wrapper";function pRt(t){let{components:e,...n}=t;return(0,s.kt)(oRt,(0,p.Z)({},nRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pRt.isMDXComponent=!0;const rRt={toc:[]},sRt="wrapper";function cRt(t){let{components:e,...n}=t;return(0,s.kt)(sRt,(0,p.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cRt.isMDXComponent=!0;const aRt={toc:[]},iRt="wrapper";function lRt(t){let{components:e,...n}=t;return(0,s.kt)(iRt,(0,p.Z)({},aRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lRt.isMDXComponent=!0;const uRt={toc:[]},mRt="wrapper";function dRt(t){let{components:e,...n}=t;return(0,s.kt)(mRt,(0,p.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dRt.isMDXComponent=!0;const hRt={toc:[]},fRt="wrapper";function kRt(t){let{components:e,...n}=t;return(0,s.kt)(fRt,(0,p.Z)({},hRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kRt.isMDXComponent=!0;const yRt={toc:[]},DRt="wrapper";function MRt(t){let{components:e,...n}=t;return(0,s.kt)(DRt,(0,p.Z)({},yRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}MRt.isMDXComponent=!0;const XRt={toc:[]},_Rt="wrapper";function wRt(t){let{components:e,...n}=t;return(0,s.kt)(_Rt,(0,p.Z)({},XRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wRt.isMDXComponent=!0;const TRt={toc:[]},CRt="wrapper";function gRt(t){let{components:e,...n}=t;return(0,s.kt)(CRt,(0,p.Z)({},TRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}gRt.isMDXComponent=!0;const xRt={toc:[]},vRt="wrapper";function LRt(t){let{components:e,...n}=t;return(0,s.kt)(vRt,(0,p.Z)({},xRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LRt.isMDXComponent=!0;const ZRt={toc:[]},bRt="wrapper";function NRt(t){let{components:e,...n}=t;return(0,s.kt)(bRt,(0,p.Z)({},ZRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}NRt.isMDXComponent=!0;const zRt={toc:[]},ARt="wrapper";function PRt(t){let{components:e,...n}=t;return(0,s.kt)(ARt,(0,p.Z)({},zRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}PRt.isMDXComponent=!0;const IRt={toc:[]},WRt="wrapper";function RRt(t){let{components:e,...n}=t;return(0,s.kt)(WRt,(0,p.Z)({},IRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}RRt.isMDXComponent=!0;const SRt={toc:[]},BRt="wrapper";function GRt(t){let{components:e,...n}=t;return(0,s.kt)(BRt,(0,p.Z)({},SRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}GRt.isMDXComponent=!0;const ERt={toc:[]},ORt="wrapper";function URt(t){let{components:e,...n}=t;return(0,s.kt)(ORt,(0,p.Z)({},ERt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}URt.isMDXComponent=!0;const FRt={toc:[]},VRt="wrapper";function qRt(t){let{components:e,...n}=t;return(0,s.kt)(VRt,(0,p.Z)({},FRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qRt.isMDXComponent=!0;const jRt={toc:[]},HRt="wrapper";function YRt(t){let{components:e,...n}=t;return(0,s.kt)(HRt,(0,p.Z)({},jRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}YRt.isMDXComponent=!0;const QRt={toc:[]},$Rt="wrapper";function KRt(t){let{components:e,...n}=t;return(0,s.kt)($Rt,(0,p.Z)({},QRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}KRt.isMDXComponent=!0;const JRt={toc:[]},tSt="wrapper";function eSt(t){let{components:e,...n}=t;return(0,s.kt)(tSt,(0,p.Z)({},JRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}eSt.isMDXComponent=!0;const nSt={toc:[]},oSt="wrapper";function pSt(t){let{components:e,...n}=t;return(0,s.kt)(oSt,(0,p.Z)({},nSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pSt.isMDXComponent=!0;const rSt={toc:[]},sSt="wrapper";function cSt(t){let{components:e,...n}=t;return(0,s.kt)(sSt,(0,p.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}cSt.isMDXComponent=!0;const aSt={toc:[]},iSt="wrapper";function lSt(t){let{components:e,...n}=t;return(0,s.kt)(iSt,(0,p.Z)({},aSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lSt.isMDXComponent=!0;const uSt={toc:[]},mSt="wrapper";function dSt(t){let{components:e,...n}=t;return(0,s.kt)(mSt,(0,p.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dSt.isMDXComponent=!0;const hSt={toc:[]},fSt="wrapper";function kSt(t){let{components:e,...n}=t;return(0,s.kt)(fSt,(0,p.Z)({},hSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kSt.isMDXComponent=!0;const ySt={toc:[]},DSt="wrapper";function MSt(t){let{components:e,...n}=t;return(0,s.kt)(DSt,(0,p.Z)({},ySt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}MSt.isMDXComponent=!0;const XSt={toc:[]},_St="wrapper";function wSt(t){let{components:e,...n}=t;return(0,s.kt)(_St,(0,p.Z)({},XSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wSt.isMDXComponent=!0;const TSt={toc:[]},CSt="wrapper";function gSt(t){let{components:e,...n}=t;return(0,s.kt)(CSt,(0,p.Z)({},TSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gSt.isMDXComponent=!0;const xSt={toc:[]},vSt="wrapper";function LSt(t){let{components:e,...n}=t;return(0,s.kt)(vSt,(0,p.Z)({},xSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}LSt.isMDXComponent=!0;const ZSt={toc:[]},bSt="wrapper";function NSt(t){let{components:e,...n}=t;return(0,s.kt)(bSt,(0,p.Z)({},ZSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}NSt.isMDXComponent=!0;const zSt={toc:[]},ASt="wrapper";function PSt(t){let{components:e,...n}=t;return(0,s.kt)(ASt,(0,p.Z)({},zSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}PSt.isMDXComponent=!0;const ISt={toc:[]},WSt="wrapper";function RSt(t){let{components:e,...n}=t;return(0,s.kt)(WSt,(0,p.Z)({},ISt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}RSt.isMDXComponent=!0;const SSt={toc:[]},BSt="wrapper";function GSt(t){let{components:e,...n}=t;return(0,s.kt)(BSt,(0,p.Z)({},SSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}GSt.isMDXComponent=!0;const ESt={toc:[]},OSt="wrapper";function USt(t){let{components:e,...n}=t;return(0,s.kt)(OSt,(0,p.Z)({},ESt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}USt.isMDXComponent=!0;const FSt={toc:[]},VSt="wrapper";function qSt(t){let{components:e,...n}=t;return(0,s.kt)(VSt,(0,p.Z)({},FSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}qSt.isMDXComponent=!0;const jSt={toc:[]},HSt="wrapper";function YSt(t){let{components:e,...n}=t;return(0,s.kt)(HSt,(0,p.Z)({},jSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}YSt.isMDXComponent=!0;const QSt={toc:[]},$St="wrapper";function KSt(t){let{components:e,...n}=t;return(0,s.kt)($St,(0,p.Z)({},QSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}KSt.isMDXComponent=!0;const JSt={toc:[]},tBt="wrapper";function eBt(t){let{components:e,...n}=t;return(0,s.kt)(tBt,(0,p.Z)({},JSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}eBt.isMDXComponent=!0;const nBt={toc:[]},oBt="wrapper";function pBt(t){let{components:e,...n}=t;return(0,s.kt)(oBt,(0,p.Z)({},nBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pBt.isMDXComponent=!0;const rBt={toc:[]},sBt="wrapper";function cBt(t){let{components:e,...n}=t;return(0,s.kt)(sBt,(0,p.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}cBt.isMDXComponent=!0;const aBt={toc:[]},iBt="wrapper";function lBt(t){let{components:e,...n}=t;return(0,s.kt)(iBt,(0,p.Z)({},aBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}lBt.isMDXComponent=!0;const uBt={toc:[]},mBt="wrapper";function dBt(t){let{components:e,...n}=t;return(0,s.kt)(mBt,(0,p.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dBt.isMDXComponent=!0;const hBt={toc:[]},fBt="wrapper";function kBt(t){let{components:e,...n}=t;return(0,s.kt)(fBt,(0,p.Z)({},hBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}kBt.isMDXComponent=!0;const yBt={toc:[]},DBt="wrapper";function MBt(t){let{components:e,...n}=t;return(0,s.kt)(DBt,(0,p.Z)({},yBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MBt.isMDXComponent=!0;const XBt={toc:[]},_Bt="wrapper";function wBt(t){let{components:e,...n}=t;return(0,s.kt)(_Bt,(0,p.Z)({},XBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wBt.isMDXComponent=!0;const TBt={toc:[]},CBt="wrapper";function gBt(t){let{components:e,...n}=t;return(0,s.kt)(CBt,(0,p.Z)({},TBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}gBt.isMDXComponent=!0;const xBt={toc:[]},vBt="wrapper";function LBt(t){let{components:e,...n}=t;return(0,s.kt)(vBt,(0,p.Z)({},xBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}LBt.isMDXComponent=!0;const ZBt={toc:[]},bBt="wrapper";function NBt(t){let{components:e,...n}=t;return(0,s.kt)(bBt,(0,p.Z)({},ZBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}NBt.isMDXComponent=!0;const zBt={toc:[]},ABt="wrapper";function PBt(t){let{components:e,...n}=t;return(0,s.kt)(ABt,(0,p.Z)({},zBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PBt.isMDXComponent=!0;const IBt={toc:[]},WBt="wrapper";function RBt(t){let{components:e,...n}=t;return(0,s.kt)(WBt,(0,p.Z)({},IBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}RBt.isMDXComponent=!0;const SBt={toc:[]},BBt="wrapper";function GBt(t){let{components:e,...n}=t;return(0,s.kt)(BBt,(0,p.Z)({},SBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}GBt.isMDXComponent=!0;const EBt={toc:[]},OBt="wrapper";function UBt(t){let{components:e,...n}=t;return(0,s.kt)(OBt,(0,p.Z)({},EBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}UBt.isMDXComponent=!0;const FBt={toc:[]},VBt="wrapper";function qBt(t){let{components:e,...n}=t;return(0,s.kt)(VBt,(0,p.Z)({},FBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qBt.isMDXComponent=!0;const jBt={toc:[]},HBt="wrapper";function YBt(t){let{components:e,...n}=t;return(0,s.kt)(HBt,(0,p.Z)({},jBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}YBt.isMDXComponent=!0;const QBt={toc:[]},$Bt="wrapper";function KBt(t){let{components:e,...n}=t;return(0,s.kt)($Bt,(0,p.Z)({},QBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}KBt.isMDXComponent=!0;const JBt={toc:[]},tGt="wrapper";function eGt(t){let{components:e,...n}=t;return(0,s.kt)(tGt,(0,p.Z)({},JBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}eGt.isMDXComponent=!0;const nGt={toc:[]},oGt="wrapper";function pGt(t){let{components:e,...n}=t;return(0,s.kt)(oGt,(0,p.Z)({},nGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}pGt.isMDXComponent=!0;const rGt={toc:[]},sGt="wrapper";function cGt(t){let{components:e,...n}=t;return(0,s.kt)(sGt,(0,p.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}cGt.isMDXComponent=!0;const aGt={toc:[]},iGt="wrapper";function lGt(t){let{components:e,...n}=t;return(0,s.kt)(iGt,(0,p.Z)({},aGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}lGt.isMDXComponent=!0;const uGt={toc:[]},mGt="wrapper";function dGt(t){let{components:e,...n}=t;return(0,s.kt)(mGt,(0,p.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}dGt.isMDXComponent=!0;const hGt={toc:[]},fGt="wrapper";function kGt(t){let{components:e,...n}=t;return(0,s.kt)(fGt,(0,p.Z)({},hGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kGt.isMDXComponent=!0;const yGt={toc:[]},DGt="wrapper";function MGt(t){let{components:e,...n}=t;return(0,s.kt)(DGt,(0,p.Z)({},yGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}MGt.isMDXComponent=!0;const XGt={toc:[]},_Gt="wrapper";function wGt(t){let{components:e,...n}=t;return(0,s.kt)(_Gt,(0,p.Z)({},XGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}wGt.isMDXComponent=!0;const TGt={toc:[]},CGt="wrapper";function gGt(t){let{components:e,...n}=t;return(0,s.kt)(CGt,(0,p.Z)({},TGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gGt.isMDXComponent=!0;const xGt={toc:[]},vGt="wrapper";function LGt(t){let{components:e,...n}=t;return(0,s.kt)(vGt,(0,p.Z)({},xGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}LGt.isMDXComponent=!0;const ZGt={toc:[]},bGt="wrapper";function NGt(t){let{components:e,...n}=t;return(0,s.kt)(bGt,(0,p.Z)({},ZGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}NGt.isMDXComponent=!0;const zGt={toc:[]},AGt="wrapper";function PGt(t){let{components:e,...n}=t;return(0,s.kt)(AGt,(0,p.Z)({},zGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}PGt.isMDXComponent=!0;const IGt={toc:[]},WGt="wrapper";function RGt(t){let{components:e,...n}=t;return(0,s.kt)(WGt,(0,p.Z)({},IGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}RGt.isMDXComponent=!0;const SGt={toc:[]},BGt="wrapper";function GGt(t){let{components:e,...n}=t;return(0,s.kt)(BGt,(0,p.Z)({},SGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}GGt.isMDXComponent=!0;const EGt={toc:[]},OGt="wrapper";function UGt(t){let{components:e,...n}=t;return(0,s.kt)(OGt,(0,p.Z)({},EGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}UGt.isMDXComponent=!0;const FGt={toc:[]},VGt="wrapper";function qGt(t){let{components:e,...n}=t;return(0,s.kt)(VGt,(0,p.Z)({},FGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qGt.isMDXComponent=!0;const jGt={toc:[]},HGt="wrapper";function YGt(t){let{components:e,...n}=t;return(0,s.kt)(HGt,(0,p.Z)({},jGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}YGt.isMDXComponent=!0;const QGt={toc:[]},$Gt="wrapper";function KGt(t){let{components:e,...n}=t;return(0,s.kt)($Gt,(0,p.Z)({},QGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}KGt.isMDXComponent=!0;const JGt={toc:[]},tEt="wrapper";function eEt(t){let{components:e,...n}=t;return(0,s.kt)(tEt,(0,p.Z)({},JGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}eEt.isMDXComponent=!0;const nEt={toc:[]},oEt="wrapper";function pEt(t){let{components:e,...n}=t;return(0,s.kt)(oEt,(0,p.Z)({},nEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pEt.isMDXComponent=!0;const rEt={toc:[]},sEt="wrapper";function cEt(t){let{components:e,...n}=t;return(0,s.kt)(sEt,(0,p.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cEt.isMDXComponent=!0;const aEt={toc:[]},iEt="wrapper";function lEt(t){let{components:e,...n}=t;return(0,s.kt)(iEt,(0,p.Z)({},aEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lEt.isMDXComponent=!0;const uEt={toc:[]},mEt="wrapper";function dEt(t){let{components:e,...n}=t;return(0,s.kt)(mEt,(0,p.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dEt.isMDXComponent=!0;const hEt={toc:[]},fEt="wrapper";function kEt(t){let{components:e,...n}=t;return(0,s.kt)(fEt,(0,p.Z)({},hEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}kEt.isMDXComponent=!0;const yEt={toc:[]},DEt="wrapper";function MEt(t){let{components:e,...n}=t;return(0,s.kt)(DEt,(0,p.Z)({},yEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}MEt.isMDXComponent=!0;const XEt={toc:[]},_Et="wrapper";function wEt(t){let{components:e,...n}=t;return(0,s.kt)(_Et,(0,p.Z)({},XEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wEt.isMDXComponent=!0;const TEt={toc:[]},CEt="wrapper";function gEt(t){let{components:e,...n}=t;return(0,s.kt)(CEt,(0,p.Z)({},TEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}gEt.isMDXComponent=!0;const xEt={toc:[]},vEt="wrapper";function LEt(t){let{components:e,...n}=t;return(0,s.kt)(vEt,(0,p.Z)({},xEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}LEt.isMDXComponent=!0;const ZEt={toc:[]},bEt="wrapper";function NEt(t){let{components:e,...n}=t;return(0,s.kt)(bEt,(0,p.Z)({},ZEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}NEt.isMDXComponent=!0;const zEt={toc:[]},AEt="wrapper";function PEt(t){let{components:e,...n}=t;return(0,s.kt)(AEt,(0,p.Z)({},zEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}PEt.isMDXComponent=!0;const IEt={toc:[]},WEt="wrapper";function REt(t){let{components:e,...n}=t;return(0,s.kt)(WEt,(0,p.Z)({},IEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}REt.isMDXComponent=!0;const SEt={toc:[]},BEt="wrapper";function GEt(t){let{components:e,...n}=t;return(0,s.kt)(BEt,(0,p.Z)({},SEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}GEt.isMDXComponent=!0;const EEt={toc:[]},OEt="wrapper";function UEt(t){let{components:e,...n}=t;return(0,s.kt)(OEt,(0,p.Z)({},EEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}UEt.isMDXComponent=!0;const FEt={toc:[]},VEt="wrapper";function qEt(t){let{components:e,...n}=t;return(0,s.kt)(VEt,(0,p.Z)({},FEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qEt.isMDXComponent=!0;const jEt={toc:[]},HEt="wrapper";function YEt(t){let{components:e,...n}=t;return(0,s.kt)(HEt,(0,p.Z)({},jEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}YEt.isMDXComponent=!0;const QEt={toc:[]},$Et="wrapper";function KEt(t){let{components:e,...n}=t;return(0,s.kt)($Et,(0,p.Z)({},QEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}KEt.isMDXComponent=!0;const JEt={toc:[]},tOt="wrapper";function eOt(t){let{components:e,...n}=t;return(0,s.kt)(tOt,(0,p.Z)({},JEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}eOt.isMDXComponent=!0;const nOt={toc:[]},oOt="wrapper";function pOt(t){let{components:e,...n}=t;return(0,s.kt)(oOt,(0,p.Z)({},nOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}pOt.isMDXComponent=!0;const rOt={toc:[]},sOt="wrapper";function cOt(t){let{components:e,...n}=t;return(0,s.kt)(sOt,(0,p.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}cOt.isMDXComponent=!0;const aOt={toc:[]},iOt="wrapper";function lOt(t){let{components:e,...n}=t;return(0,s.kt)(iOt,(0,p.Z)({},aOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lOt.isMDXComponent=!0;const uOt={toc:[]},mOt="wrapper";function dOt(t){let{components:e,...n}=t;return(0,s.kt)(mOt,(0,p.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}dOt.isMDXComponent=!0;const hOt={toc:[]},fOt="wrapper";function kOt(t){let{components:e,...n}=t;return(0,s.kt)(fOt,(0,p.Z)({},hOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}kOt.isMDXComponent=!0;const yOt={toc:[]},DOt="wrapper";function MOt(t){let{components:e,...n}=t;return(0,s.kt)(DOt,(0,p.Z)({},yOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}MOt.isMDXComponent=!0;const XOt={toc:[]},_Ot="wrapper";function wOt(t){let{components:e,...n}=t;return(0,s.kt)(_Ot,(0,p.Z)({},XOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}wOt.isMDXComponent=!0;const TOt={toc:[]},COt="wrapper";function gOt(t){let{components:e,...n}=t;return(0,s.kt)(COt,(0,p.Z)({},TOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}gOt.isMDXComponent=!0;const xOt={toc:[]},vOt="wrapper";function LOt(t){let{components:e,...n}=t;return(0,s.kt)(vOt,(0,p.Z)({},xOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}LOt.isMDXComponent=!0;const ZOt={toc:[]},bOt="wrapper";function NOt(t){let{components:e,...n}=t;return(0,s.kt)(bOt,(0,p.Z)({},ZOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}NOt.isMDXComponent=!0;const zOt={toc:[]},AOt="wrapper";function POt(t){let{components:e,...n}=t;return(0,s.kt)(AOt,(0,p.Z)({},zOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}POt.isMDXComponent=!0;const IOt={toc:[]},WOt="wrapper";function ROt(t){let{components:e,...n}=t;return(0,s.kt)(WOt,(0,p.Z)({},IOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}ROt.isMDXComponent=!0;const SOt={toc:[]},BOt="wrapper";function GOt(t){let{components:e,...n}=t;return(0,s.kt)(BOt,(0,p.Z)({},SOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}GOt.isMDXComponent=!0;const EOt={toc:[]},OOt="wrapper";function UOt(t){let{components:e,...n}=t;return(0,s.kt)(OOt,(0,p.Z)({},EOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}UOt.isMDXComponent=!0;const FOt={toc:[]},VOt="wrapper";function qOt(t){let{components:e,...n}=t;return(0,s.kt)(VOt,(0,p.Z)({},FOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qOt.isMDXComponent=!0;const jOt={toc:[]},HOt="wrapper";function YOt(t){let{components:e,...n}=t;return(0,s.kt)(HOt,(0,p.Z)({},jOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}YOt.isMDXComponent=!0;const QOt={toc:[]},$Ot="wrapper";function KOt(t){let{components:e,...n}=t;return(0,s.kt)($Ot,(0,p.Z)({},QOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}KOt.isMDXComponent=!0;const JOt={toc:[]},tUt="wrapper";function eUt(t){let{components:e,...n}=t;return(0,s.kt)(tUt,(0,p.Z)({},JOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eUt.isMDXComponent=!0;const nUt={toc:[]},oUt="wrapper";function pUt(t){let{components:e,...n}=t;return(0,s.kt)(oUt,(0,p.Z)({},nUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pUt.isMDXComponent=!0;const rUt={toc:[]},sUt="wrapper";function cUt(t){let{components:e,...n}=t;return(0,s.kt)(sUt,(0,p.Z)({},rUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cUt.isMDXComponent=!0;const aUt={toc:[]},iUt="wrapper";function lUt(t){let{components:e,...n}=t;return(0,s.kt)(iUt,(0,p.Z)({},aUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}lUt.isMDXComponent=!0;const uUt={toc:[]},mUt="wrapper";function dUt(t){let{components:e,...n}=t;return(0,s.kt)(mUt,(0,p.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dUt.isMDXComponent=!0;const hUt={toc:[]},fUt="wrapper";function kUt(t){let{components:e,...n}=t;return(0,s.kt)(fUt,(0,p.Z)({},hUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kUt.isMDXComponent=!0;const yUt={toc:[]},DUt="wrapper";function MUt(t){let{components:e,...n}=t;return(0,s.kt)(DUt,(0,p.Z)({},yUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}MUt.isMDXComponent=!0;const XUt={toc:[]},_Ut="wrapper";function wUt(t){let{components:e,...n}=t;return(0,s.kt)(_Ut,(0,p.Z)({},XUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}wUt.isMDXComponent=!0;const TUt={toc:[]},CUt="wrapper";function gUt(t){let{components:e,...n}=t;return(0,s.kt)(CUt,(0,p.Z)({},TUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}gUt.isMDXComponent=!0;const xUt={toc:[]},vUt="wrapper";function LUt(t){let{components:e,...n}=t;return(0,s.kt)(vUt,(0,p.Z)({},xUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}LUt.isMDXComponent=!0;const ZUt={toc:[]},bUt="wrapper";function NUt(t){let{components:e,...n}=t;return(0,s.kt)(bUt,(0,p.Z)({},ZUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}NUt.isMDXComponent=!0;const zUt={toc:[]},AUt="wrapper";function PUt(t){let{components:e,...n}=t;return(0,s.kt)(AUt,(0,p.Z)({},zUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}PUt.isMDXComponent=!0;const IUt={toc:[]},WUt="wrapper";function RUt(t){let{components:e,...n}=t;return(0,s.kt)(WUt,(0,p.Z)({},IUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}RUt.isMDXComponent=!0;const SUt={toc:[]},BUt="wrapper";function GUt(t){let{components:e,...n}=t;return(0,s.kt)(BUt,(0,p.Z)({},SUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}GUt.isMDXComponent=!0;const EUt={toc:[]},OUt="wrapper";function UUt(t){let{components:e,...n}=t;return(0,s.kt)(OUt,(0,p.Z)({},EUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}UUt.isMDXComponent=!0;const FUt={toc:[]},VUt="wrapper";function qUt(t){let{components:e,...n}=t;return(0,s.kt)(VUt,(0,p.Z)({},FUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}qUt.isMDXComponent=!0;const jUt={toc:[]},HUt="wrapper";function YUt(t){let{components:e,...n}=t;return(0,s.kt)(HUt,(0,p.Z)({},jUt,n,{components:e,mdxType:"MDXLayout"}))}YUt.isMDXComponent=!0;const QUt={toc:[]},$Ut="wrapper";function KUt(t){let{components:e,...n}=t;return(0,s.kt)($Ut,(0,p.Z)({},QUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}KUt.isMDXComponent=!0;const JUt={toc:[]},tFt="wrapper";function eFt(t){let{components:e,...n}=t;return(0,s.kt)(tFt,(0,p.Z)({},JUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}eFt.isMDXComponent=!0;const nFt={toc:[]},oFt="wrapper";function pFt(t){let{components:e,...n}=t;return(0,s.kt)(oFt,(0,p.Z)({},nFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}pFt.isMDXComponent=!0;const rFt={toc:[]},sFt="wrapper";function cFt(t){let{components:e,...n}=t;return(0,s.kt)(sFt,(0,p.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}cFt.isMDXComponent=!0;const aFt={toc:[]},iFt="wrapper";function lFt(t){let{components:e,...n}=t;return(0,s.kt)(iFt,(0,p.Z)({},aFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}lFt.isMDXComponent=!0;const uFt={toc:[]},mFt="wrapper";function dFt(t){let{components:e,...n}=t;return(0,s.kt)(mFt,(0,p.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}dFt.isMDXComponent=!0;const hFt={toc:[]},fFt="wrapper";function kFt(t){let{components:e,...n}=t;return(0,s.kt)(fFt,(0,p.Z)({},hFt,n,{components:e,mdxType:"MDXLayout"}))}kFt.isMDXComponent=!0;const yFt={toc:[]},DFt="wrapper";function MFt(t){let{components:e,...n}=t;return(0,s.kt)(DFt,(0,p.Z)({},yFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MFt.isMDXComponent=!0;const XFt={toc:[]},_Ft="wrapper";function wFt(t){let{components:e,...n}=t;return(0,s.kt)(_Ft,(0,p.Z)({},XFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wFt.isMDXComponent=!0;const TFt={toc:[]},CFt="wrapper";function gFt(t){let{components:e,...n}=t;return(0,s.kt)(CFt,(0,p.Z)({},TFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gFt.isMDXComponent=!0;const xFt={toc:[]},vFt="wrapper";function LFt(t){let{components:e,...n}=t;return(0,s.kt)(vFt,(0,p.Z)({},xFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}LFt.isMDXComponent=!0;const ZFt={toc:[]},bFt="wrapper";function NFt(t){let{components:e,...n}=t;return(0,s.kt)(bFt,(0,p.Z)({},ZFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}NFt.isMDXComponent=!0;const zFt={toc:[]},AFt="wrapper";function PFt(t){let{components:e,...n}=t;return(0,s.kt)(AFt,(0,p.Z)({},zFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}PFt.isMDXComponent=!0;const IFt={toc:[]},WFt="wrapper";function RFt(t){let{components:e,...n}=t;return(0,s.kt)(WFt,(0,p.Z)({},IFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}RFt.isMDXComponent=!0;const SFt={toc:[]},BFt="wrapper";function GFt(t){let{components:e,...n}=t;return(0,s.kt)(BFt,(0,p.Z)({},SFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}GFt.isMDXComponent=!0;const EFt={toc:[]},OFt="wrapper";function UFt(t){let{components:e,...n}=t;return(0,s.kt)(OFt,(0,p.Z)({},EFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}UFt.isMDXComponent=!0;const FFt={toc:[]},VFt="wrapper";function qFt(t){let{components:e,...n}=t;return(0,s.kt)(VFt,(0,p.Z)({},FFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}qFt.isMDXComponent=!0;const jFt={toc:[]},HFt="wrapper";function YFt(t){let{components:e,...n}=t;return(0,s.kt)(HFt,(0,p.Z)({},jFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}YFt.isMDXComponent=!0;const QFt={toc:[]},$Ft="wrapper";function KFt(t){let{components:e,...n}=t;return(0,s.kt)($Ft,(0,p.Z)({},QFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}KFt.isMDXComponent=!0;const JFt={toc:[]},tVt="wrapper";function eVt(t){let{components:e,...n}=t;return(0,s.kt)(tVt,(0,p.Z)({},JFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}eVt.isMDXComponent=!0;const nVt={toc:[]},oVt="wrapper";function pVt(t){let{components:e,...n}=t;return(0,s.kt)(oVt,(0,p.Z)({},nVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}pVt.isMDXComponent=!0;const rVt={toc:[]},sVt="wrapper";function cVt(t){let{components:e,...n}=t;return(0,s.kt)(sVt,(0,p.Z)({},rVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}cVt.isMDXComponent=!0;const aVt={toc:[]},iVt="wrapper";function lVt(t){let{components:e,...n}=t;return(0,s.kt)(iVt,(0,p.Z)({},aVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}lVt.isMDXComponent=!0;const uVt={toc:[]},mVt="wrapper";function dVt(t){let{components:e,...n}=t;return(0,s.kt)(mVt,(0,p.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}dVt.isMDXComponent=!0;const hVt={toc:[]},fVt="wrapper";function kVt(t){let{components:e,...n}=t;return(0,s.kt)(fVt,(0,p.Z)({},hVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}kVt.isMDXComponent=!0;const yVt={toc:[]},DVt="wrapper";function MVt(t){let{components:e,...n}=t;return(0,s.kt)(DVt,(0,p.Z)({},yVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}MVt.isMDXComponent=!0;const XVt={toc:[]},_Vt="wrapper";function wVt(t){let{components:e,...n}=t;return(0,s.kt)(_Vt,(0,p.Z)({},XVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}wVt.isMDXComponent=!0;const TVt={toc:[]},CVt="wrapper";function gVt(t){let{components:e,...n}=t;return(0,s.kt)(CVt,(0,p.Z)({},TVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gVt.isMDXComponent=!0;const xVt={toc:[]},vVt="wrapper";function LVt(t){let{components:e,...n}=t;return(0,s.kt)(vVt,(0,p.Z)({},xVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}LVt.isMDXComponent=!0;const ZVt={toc:[]},bVt="wrapper";function NVt(t){let{components:e,...n}=t;return(0,s.kt)(bVt,(0,p.Z)({},ZVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}NVt.isMDXComponent=!0;const zVt={toc:[]},AVt="wrapper";function PVt(t){let{components:e,...n}=t;return(0,s.kt)(AVt,(0,p.Z)({},zVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}PVt.isMDXComponent=!0;const IVt={toc:[]},WVt="wrapper";function RVt(t){let{components:e,...n}=t;return(0,s.kt)(WVt,(0,p.Z)({},IVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}RVt.isMDXComponent=!0;const SVt={toc:[]},BVt="wrapper";function GVt(t){let{components:e,...n}=t;return(0,s.kt)(BVt,(0,p.Z)({},SVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}GVt.isMDXComponent=!0;const EVt={toc:[]},OVt="wrapper";function UVt(t){let{components:e,...n}=t;return(0,s.kt)(OVt,(0,p.Z)({},EVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}UVt.isMDXComponent=!0;const FVt={toc:[]},VVt="wrapper";function qVt(t){let{components:e,...n}=t;return(0,s.kt)(VVt,(0,p.Z)({},FVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qVt.isMDXComponent=!0;const jVt={toc:[]},HVt="wrapper";function YVt(t){let{components:e,...n}=t;return(0,s.kt)(HVt,(0,p.Z)({},jVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}YVt.isMDXComponent=!0;const QVt={toc:[]},$Vt="wrapper";function KVt(t){let{components:e,...n}=t;return(0,s.kt)($Vt,(0,p.Z)({},QVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}KVt.isMDXComponent=!0;const JVt={toc:[]},tqt="wrapper";function eqt(t){let{components:e,...n}=t;return(0,s.kt)(tqt,(0,p.Z)({},JVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}eqt.isMDXComponent=!0;const nqt={toc:[]},oqt="wrapper";function pqt(t){let{components:e,...n}=t;return(0,s.kt)(oqt,(0,p.Z)({},nqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}pqt.isMDXComponent=!0;const rqt={toc:[]},sqt="wrapper";function cqt(t){let{components:e,...n}=t;return(0,s.kt)(sqt,(0,p.Z)({},rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}cqt.isMDXComponent=!0;const aqt={toc:[]},iqt="wrapper";function lqt(t){let{components:e,...n}=t;return(0,s.kt)(iqt,(0,p.Z)({},aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lqt.isMDXComponent=!0;const uqt={toc:[]},mqt="wrapper";function dqt(t){let{components:e,...n}=t;return(0,s.kt)(mqt,(0,p.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dqt.isMDXComponent=!0;const hqt={toc:[]},fqt="wrapper";function kqt(t){let{components:e,...n}=t;return(0,s.kt)(fqt,(0,p.Z)({},hqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}kqt.isMDXComponent=!0;const yqt={toc:[]},Dqt="wrapper";function Mqt(t){let{components:e,...n}=t;return(0,s.kt)(Dqt,(0,p.Z)({},yqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Mqt.isMDXComponent=!0;const Xqt={toc:[]},_qt="wrapper";function wqt(t){let{components:e,...n}=t;return(0,s.kt)(_qt,(0,p.Z)({},Xqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}wqt.isMDXComponent=!0;const Tqt={toc:[]},Cqt="wrapper";function gqt(t){let{components:e,...n}=t;return(0,s.kt)(Cqt,(0,p.Z)({},Tqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}gqt.isMDXComponent=!0;const xqt={toc:[]},vqt="wrapper";function Lqt(t){let{components:e,...n}=t;return(0,s.kt)(vqt,(0,p.Z)({},xqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Lqt.isMDXComponent=!0;const Zqt={toc:[]},bqt="wrapper";function Nqt(t){let{components:e,...n}=t;return(0,s.kt)(bqt,(0,p.Z)({},Zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Nqt.isMDXComponent=!0;const zqt={toc:[]},Aqt="wrapper";function Pqt(t){let{components:e,...n}=t;return(0,s.kt)(Aqt,(0,p.Z)({},zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Pqt.isMDXComponent=!0;const Iqt={toc:[]},Wqt="wrapper";function Rqt(t){let{components:e,...n}=t;return(0,s.kt)(Wqt,(0,p.Z)({},Iqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Rqt.isMDXComponent=!0;const Sqt={toc:[]},Bqt="wrapper";function Gqt(t){let{components:e,...n}=t;return(0,s.kt)(Bqt,(0,p.Z)({},Sqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Gqt.isMDXComponent=!0;const Eqt={toc:[]},Oqt="wrapper";function Uqt(t){let{components:e,...n}=t;return(0,s.kt)(Oqt,(0,p.Z)({},Eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Uqt.isMDXComponent=!0;const Fqt={toc:[]},Vqt="wrapper";function qqt(t){let{components:e,...n}=t;return(0,s.kt)(Vqt,(0,p.Z)({},Fqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}qqt.isMDXComponent=!0;const jqt={toc:[]},Hqt="wrapper";function Yqt(t){let{components:e,...n}=t;return(0,s.kt)(Hqt,(0,p.Z)({},jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Yqt.isMDXComponent=!0;const Qqt={toc:[]},$qt="wrapper";function Kqt(t){let{components:e,...n}=t;return(0,s.kt)($qt,(0,p.Z)({},Qqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]},tjt="wrapper";function ejt(t){let{components:e,...n}=t;return(0,s.kt)(tjt,(0,p.Z)({},Jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}ejt.isMDXComponent=!0;const njt={toc:[]},ojt="wrapper";function pjt(t){let{components:e,...n}=t;return(0,s.kt)(ojt,(0,p.Z)({},njt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pjt.isMDXComponent=!0;const rjt={toc:[]},sjt="wrapper";function cjt(t){let{components:e,...n}=t;return(0,s.kt)(sjt,(0,p.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}cjt.isMDXComponent=!0;const ajt={toc:[]},ijt="wrapper";function ljt(t){let{components:e,...n}=t;return(0,s.kt)(ijt,(0,p.Z)({},ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}ljt.isMDXComponent=!0;const ujt={toc:[]},mjt="wrapper";function djt(t){let{components:e,...n}=t;return(0,s.kt)(mjt,(0,p.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}djt.isMDXComponent=!0;const hjt={toc:[]},fjt="wrapper";function kjt(t){let{components:e,...n}=t;return(0,s.kt)(fjt,(0,p.Z)({},hjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}kjt.isMDXComponent=!0;const yjt={toc:[]},Djt="wrapper";function Mjt(t){let{components:e,...n}=t;return(0,s.kt)(Djt,(0,p.Z)({},yjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Mjt.isMDXComponent=!0;const Xjt={toc:[]},_jt="wrapper";function wjt(t){let{components:e,...n}=t;return(0,s.kt)(_jt,(0,p.Z)({},Xjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wjt.isMDXComponent=!0;const Tjt={toc:[]},Cjt="wrapper";function gjt(t){let{components:e,...n}=t;return(0,s.kt)(Cjt,(0,p.Z)({},Tjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}gjt.isMDXComponent=!0;const xjt={toc:[]},vjt="wrapper";function Ljt(t){let{components:e,...n}=t;return(0,s.kt)(vjt,(0,p.Z)({},xjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]},bjt="wrapper";function Njt(t){let{components:e,...n}=t;return(0,s.kt)(bjt,(0,p.Z)({},Zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Njt.isMDXComponent=!0;const zjt={toc:[]},Ajt="wrapper";function Pjt(t){let{components:e,...n}=t;return(0,s.kt)(Ajt,(0,p.Z)({},zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pjt.isMDXComponent=!0;const Ijt={toc:[]},Wjt="wrapper";function Rjt(t){let{components:e,...n}=t;return(0,s.kt)(Wjt,(0,p.Z)({},Ijt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Rjt.isMDXComponent=!0;const Sjt={toc:[]},Bjt="wrapper";function Gjt(t){let{components:e,...n}=t;return(0,s.kt)(Bjt,(0,p.Z)({},Sjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gjt.isMDXComponent=!0;const Ejt={toc:[]},Ojt="wrapper";function Ujt(t){let{components:e,...n}=t;return(0,s.kt)(Ojt,(0,p.Z)({},Ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ujt.isMDXComponent=!0;const Fjt={toc:[]},Vjt="wrapper";function qjt(t){let{components:e,...n}=t;return(0,s.kt)(Vjt,(0,p.Z)({},Fjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qjt.isMDXComponent=!0;const jjt={toc:[]},Hjt="wrapper";function Yjt(t){let{components:e,...n}=t;return(0,s.kt)(Hjt,(0,p.Z)({},jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Yjt.isMDXComponent=!0;const Qjt={toc:[]},$jt="wrapper";function Kjt(t){let{components:e,...n}=t;return(0,s.kt)($jt,(0,p.Z)({},Qjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]},tHt="wrapper";function eHt(t){let{components:e,...n}=t;return(0,s.kt)(tHt,(0,p.Z)({},Jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}eHt.isMDXComponent=!0;const nHt={toc:[]},oHt="wrapper";function pHt(t){let{components:e,...n}=t;return(0,s.kt)(oHt,(0,p.Z)({},nHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pHt.isMDXComponent=!0;const rHt={toc:[]},sHt="wrapper";function cHt(t){let{components:e,...n}=t;return(0,s.kt)(sHt,(0,p.Z)({},rHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cHt.isMDXComponent=!0;const aHt={toc:[]},iHt="wrapper";function lHt(t){let{components:e,...n}=t;return(0,s.kt)(iHt,(0,p.Z)({},aHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lHt.isMDXComponent=!0;const uHt={toc:[]},mHt="wrapper";function dHt(t){let{components:e,...n}=t;return(0,s.kt)(mHt,(0,p.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}dHt.isMDXComponent=!0;const hHt={toc:[]},fHt="wrapper";function kHt(t){let{components:e,...n}=t;return(0,s.kt)(fHt,(0,p.Z)({},hHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kHt.isMDXComponent=!0;const yHt={toc:[]},DHt="wrapper";function MHt(t){let{components:e,...n}=t;return(0,s.kt)(DHt,(0,p.Z)({},yHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}MHt.isMDXComponent=!0;const XHt={toc:[]},_Ht="wrapper";function wHt(t){let{components:e,...n}=t;return(0,s.kt)(_Ht,(0,p.Z)({},XHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wHt.isMDXComponent=!0;const THt={toc:[]},CHt="wrapper";function gHt(t){let{components:e,...n}=t;return(0,s.kt)(CHt,(0,p.Z)({},THt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}gHt.isMDXComponent=!0;const xHt={toc:[]},vHt="wrapper";function LHt(t){let{components:e,...n}=t;return(0,s.kt)(vHt,(0,p.Z)({},xHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}LHt.isMDXComponent=!0;const ZHt={toc:[]},bHt="wrapper";function NHt(t){let{components:e,...n}=t;return(0,s.kt)(bHt,(0,p.Z)({},ZHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}NHt.isMDXComponent=!0;const zHt={toc:[]},AHt="wrapper";function PHt(t){let{components:e,...n}=t;return(0,s.kt)(AHt,(0,p.Z)({},zHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}PHt.isMDXComponent=!0;const IHt={toc:[]},WHt="wrapper";function RHt(t){let{components:e,...n}=t;return(0,s.kt)(WHt,(0,p.Z)({},IHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}RHt.isMDXComponent=!0;const SHt={toc:[]},BHt="wrapper";function GHt(t){let{components:e,...n}=t;return(0,s.kt)(BHt,(0,p.Z)({},SHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}GHt.isMDXComponent=!0;const EHt={toc:[]},OHt="wrapper";function UHt(t){let{components:e,...n}=t;return(0,s.kt)(OHt,(0,p.Z)({},EHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}UHt.isMDXComponent=!0;const FHt={toc:[]},VHt="wrapper";function qHt(t){let{components:e,...n}=t;return(0,s.kt)(VHt,(0,p.Z)({},FHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}qHt.isMDXComponent=!0;const jHt={toc:[]},HHt="wrapper";function YHt(t){let{components:e,...n}=t;return(0,s.kt)(HHt,(0,p.Z)({},jHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}YHt.isMDXComponent=!0;const QHt={toc:[]},$Ht="wrapper";function KHt(t){let{components:e,...n}=t;return(0,s.kt)($Ht,(0,p.Z)({},QHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}KHt.isMDXComponent=!0;const JHt={toc:[]},tYt="wrapper";function eYt(t){let{components:e,...n}=t;return(0,s.kt)(tYt,(0,p.Z)({},JHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}eYt.isMDXComponent=!0;const nYt={toc:[]},oYt="wrapper";function pYt(t){let{components:e,...n}=t;return(0,s.kt)(oYt,(0,p.Z)({},nYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}pYt.isMDXComponent=!0;const rYt={toc:[]},sYt="wrapper";function cYt(t){let{components:e,...n}=t;return(0,s.kt)(sYt,(0,p.Z)({},rYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cYt.isMDXComponent=!0;const aYt={toc:[]},iYt="wrapper";function lYt(t){let{components:e,...n}=t;return(0,s.kt)(iYt,(0,p.Z)({},aYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}lYt.isMDXComponent=!0;const uYt={toc:[]},mYt="wrapper";function dYt(t){let{components:e,...n}=t;return(0,s.kt)(mYt,(0,p.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}dYt.isMDXComponent=!0;const hYt={toc:[]},fYt="wrapper";function kYt(t){let{components:e,...n}=t;return(0,s.kt)(fYt,(0,p.Z)({},hYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kYt.isMDXComponent=!0;const yYt={toc:[]},DYt="wrapper";function MYt(t){let{components:e,...n}=t;return(0,s.kt)(DYt,(0,p.Z)({},yYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}MYt.isMDXComponent=!0;const XYt={toc:[]},_Yt="wrapper";function wYt(t){let{components:e,...n}=t;return(0,s.kt)(_Yt,(0,p.Z)({},XYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wYt.isMDXComponent=!0;const TYt={toc:[]},CYt="wrapper";function gYt(t){let{components:e,...n}=t;return(0,s.kt)(CYt,(0,p.Z)({},TYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}gYt.isMDXComponent=!0;const xYt={toc:[]},vYt="wrapper";function LYt(t){let{components:e,...n}=t;return(0,s.kt)(vYt,(0,p.Z)({},xYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}LYt.isMDXComponent=!0;const ZYt={toc:[]},bYt="wrapper";function NYt(t){let{components:e,...n}=t;return(0,s.kt)(bYt,(0,p.Z)({},ZYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}NYt.isMDXComponent=!0;const zYt={toc:[]},AYt="wrapper";function PYt(t){let{components:e,...n}=t;return(0,s.kt)(AYt,(0,p.Z)({},zYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}PYt.isMDXComponent=!0;const IYt={toc:[]},WYt="wrapper";function RYt(t){let{components:e,...n}=t;return(0,s.kt)(WYt,(0,p.Z)({},IYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}RYt.isMDXComponent=!0;const SYt={toc:[]},BYt="wrapper";function GYt(t){let{components:e,...n}=t;return(0,s.kt)(BYt,(0,p.Z)({},SYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}GYt.isMDXComponent=!0;const EYt={toc:[]},OYt="wrapper";function UYt(t){let{components:e,...n}=t;return(0,s.kt)(OYt,(0,p.Z)({},EYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}UYt.isMDXComponent=!0;const FYt={toc:[]},VYt="wrapper";function qYt(t){let{components:e,...n}=t;return(0,s.kt)(VYt,(0,p.Z)({},FYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qYt.isMDXComponent=!0;const jYt={toc:[]},HYt="wrapper";function YYt(t){let{components:e,...n}=t;return(0,s.kt)(HYt,(0,p.Z)({},jYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}YYt.isMDXComponent=!0;const QYt={toc:[]},$Yt="wrapper";function KYt(t){let{components:e,...n}=t;return(0,s.kt)($Yt,(0,p.Z)({},QYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}KYt.isMDXComponent=!0;const JYt={toc:[]},tQt="wrapper";function eQt(t){let{components:e,...n}=t;return(0,s.kt)(tQt,(0,p.Z)({},JYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eQt.isMDXComponent=!0;const nQt={toc:[]},oQt="wrapper";function pQt(t){let{components:e,...n}=t;return(0,s.kt)(oQt,(0,p.Z)({},nQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}pQt.isMDXComponent=!0;const rQt={toc:[]},sQt="wrapper";function cQt(t){let{components:e,...n}=t;return(0,s.kt)(sQt,(0,p.Z)({},rQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}cQt.isMDXComponent=!0;const aQt={toc:[]},iQt="wrapper";function lQt(t){let{components:e,...n}=t;return(0,s.kt)(iQt,(0,p.Z)({},aQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}lQt.isMDXComponent=!0;const uQt={toc:[]},mQt="wrapper";function dQt(t){let{components:e,...n}=t;return(0,s.kt)(mQt,(0,p.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dQt.isMDXComponent=!0;const hQt={toc:[]},fQt="wrapper";function kQt(t){let{components:e,...n}=t;return(0,s.kt)(fQt,(0,p.Z)({},hQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}kQt.isMDXComponent=!0;const yQt={toc:[]},DQt="wrapper";function MQt(t){let{components:e,...n}=t;return(0,s.kt)(DQt,(0,p.Z)({},yQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}MQt.isMDXComponent=!0;const XQt={toc:[]},_Qt="wrapper";function wQt(t){let{components:e,...n}=t;return(0,s.kt)(_Qt,(0,p.Z)({},XQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}wQt.isMDXComponent=!0;const TQt={toc:[]},CQt="wrapper";function gQt(t){let{components:e,...n}=t;return(0,s.kt)(CQt,(0,p.Z)({},TQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}gQt.isMDXComponent=!0;const xQt={toc:[]},vQt="wrapper";function LQt(t){let{components:e,...n}=t;return(0,s.kt)(vQt,(0,p.Z)({},xQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LQt.isMDXComponent=!0;const ZQt={toc:[]},bQt="wrapper";function NQt(t){let{components:e,...n}=t;return(0,s.kt)(bQt,(0,p.Z)({},ZQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}NQt.isMDXComponent=!0;const zQt={toc:[]},AQt="wrapper";function PQt(t){let{components:e,...n}=t;return(0,s.kt)(AQt,(0,p.Z)({},zQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}PQt.isMDXComponent=!0;const IQt={toc:[]},WQt="wrapper";function RQt(t){let{components:e,...n}=t;return(0,s.kt)(WQt,(0,p.Z)({},IQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}RQt.isMDXComponent=!0;const SQt={toc:[]},BQt="wrapper";function GQt(t){let{components:e,...n}=t;return(0,s.kt)(BQt,(0,p.Z)({},SQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}GQt.isMDXComponent=!0;const EQt={toc:[]},OQt="wrapper";function UQt(t){let{components:e,...n}=t;return(0,s.kt)(OQt,(0,p.Z)({},EQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}UQt.isMDXComponent=!0;const FQt={toc:[]},VQt="wrapper";function qQt(t){let{components:e,...n}=t;return(0,s.kt)(VQt,(0,p.Z)({},FQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}qQt.isMDXComponent=!0;const jQt={toc:[]},HQt="wrapper";function YQt(t){let{components:e,...n}=t;return(0,s.kt)(HQt,(0,p.Z)({},jQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}YQt.isMDXComponent=!0;const QQt={toc:[]},$Qt="wrapper";function KQt(t){let{components:e,...n}=t;return(0,s.kt)($Qt,(0,p.Z)({},QQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}KQt.isMDXComponent=!0;const JQt={toc:[]},t$t="wrapper";function e$t(t){let{components:e,...n}=t;return(0,s.kt)(t$t,(0,p.Z)({},JQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}e$t.isMDXComponent=!0;const n$t={toc:[]},o$t="wrapper";function p$t(t){let{components:e,...n}=t;return(0,s.kt)(o$t,(0,p.Z)({},n$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}p$t.isMDXComponent=!0;const r$t={toc:[]},s$t="wrapper";function c$t(t){let{components:e,...n}=t;return(0,s.kt)(s$t,(0,p.Z)({},r$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}c$t.isMDXComponent=!0;const a$t={toc:[]},i$t="wrapper";function l$t(t){let{components:e,...n}=t;return(0,s.kt)(i$t,(0,p.Z)({},a$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}l$t.isMDXComponent=!0;const u$t={toc:[]},m$t="wrapper";function d$t(t){let{components:e,...n}=t;return(0,s.kt)(m$t,(0,p.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}d$t.isMDXComponent=!0;const h$t={toc:[]},f$t="wrapper";function k$t(t){let{components:e,...n}=t;return(0,s.kt)(f$t,(0,p.Z)({},h$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}k$t.isMDXComponent=!0;const y$t={toc:[]},D$t="wrapper";function M$t(t){let{components:e,...n}=t;return(0,s.kt)(D$t,(0,p.Z)({},y$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}M$t.isMDXComponent=!0;const X$t={toc:[]},_$t="wrapper";function w$t(t){let{components:e,...n}=t;return(0,s.kt)(_$t,(0,p.Z)({},X$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}w$t.isMDXComponent=!0;const T$t={toc:[]},C$t="wrapper";function g$t(t){let{components:e,...n}=t;return(0,s.kt)(C$t,(0,p.Z)({},T$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}g$t.isMDXComponent=!0;const x$t={toc:[]},v$t="wrapper";function L$t(t){let{components:e,...n}=t;return(0,s.kt)(v$t,(0,p.Z)({},x$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}L$t.isMDXComponent=!0;const Z$t={toc:[]},b$t="wrapper";function N$t(t){let{components:e,...n}=t;return(0,s.kt)(b$t,(0,p.Z)({},Z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}N$t.isMDXComponent=!0;const z$t={toc:[]},A$t="wrapper";function P$t(t){let{components:e,...n}=t;return(0,s.kt)(A$t,(0,p.Z)({},z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}P$t.isMDXComponent=!0;const I$t={toc:[]},W$t="wrapper";function R$t(t){let{components:e,...n}=t;return(0,s.kt)(W$t,(0,p.Z)({},I$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}R$t.isMDXComponent=!0;const S$t={toc:[]},B$t="wrapper";function G$t(t){let{components:e,...n}=t;return(0,s.kt)(B$t,(0,p.Z)({},S$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}G$t.isMDXComponent=!0;const E$t={toc:[]},O$t="wrapper";function U$t(t){let{components:e,...n}=t;return(0,s.kt)(O$t,(0,p.Z)({},E$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}U$t.isMDXComponent=!0;const F$t={toc:[]},V$t="wrapper";function q$t(t){let{components:e,...n}=t;return(0,s.kt)(V$t,(0,p.Z)({},F$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}q$t.isMDXComponent=!0;const j$t={toc:[]},H$t="wrapper";function Y$t(t){let{components:e,...n}=t;return(0,s.kt)(H$t,(0,p.Z)({},j$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Y$t.isMDXComponent=!0;const Q$t={toc:[]},$$t="wrapper";function K$t(t){let{components:e,...n}=t;return(0,s.kt)($$t,(0,p.Z)({},Q$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}K$t.isMDXComponent=!0;const J$t={toc:[]},tKt="wrapper";function eKt(t){let{components:e,...n}=t;return(0,s.kt)(tKt,(0,p.Z)({},J$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}eKt.isMDXComponent=!0;const nKt={toc:[]},oKt="wrapper";function pKt(t){let{components:e,...n}=t;return(0,s.kt)(oKt,(0,p.Z)({},nKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}pKt.isMDXComponent=!0;const rKt={toc:[]},sKt="wrapper";function cKt(t){let{components:e,...n}=t;return(0,s.kt)(sKt,(0,p.Z)({},rKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}cKt.isMDXComponent=!0;const aKt={toc:[]},iKt="wrapper";function lKt(t){let{components:e,...n}=t;return(0,s.kt)(iKt,(0,p.Z)({},aKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}lKt.isMDXComponent=!0;const uKt={toc:[]},mKt="wrapper";function dKt(t){let{components:e,...n}=t;return(0,s.kt)(mKt,(0,p.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}dKt.isMDXComponent=!0;const hKt={toc:[]},fKt="wrapper";function kKt(t){let{components:e,...n}=t;return(0,s.kt)(fKt,(0,p.Z)({},hKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kKt.isMDXComponent=!0;const yKt={toc:[]},DKt="wrapper";function MKt(t){let{components:e,...n}=t;return(0,s.kt)(DKt,(0,p.Z)({},yKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}MKt.isMDXComponent=!0;const XKt={toc:[]},_Kt="wrapper";function wKt(t){let{components:e,...n}=t;return(0,s.kt)(_Kt,(0,p.Z)({},XKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}wKt.isMDXComponent=!0;const TKt={toc:[]},CKt="wrapper";function gKt(t){let{components:e,...n}=t;return(0,s.kt)(CKt,(0,p.Z)({},TKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gKt.isMDXComponent=!0;const xKt={toc:[]},vKt="wrapper";function LKt(t){let{components:e,...n}=t;return(0,s.kt)(vKt,(0,p.Z)({},xKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}LKt.isMDXComponent=!0;const ZKt={toc:[]},bKt="wrapper";function NKt(t){let{components:e,...n}=t;return(0,s.kt)(bKt,(0,p.Z)({},ZKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}NKt.isMDXComponent=!0;const zKt={toc:[]},AKt="wrapper";function PKt(t){let{components:e,...n}=t;return(0,s.kt)(AKt,(0,p.Z)({},zKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}PKt.isMDXComponent=!0;const IKt={toc:[]},WKt="wrapper";function RKt(t){let{components:e,...n}=t;return(0,s.kt)(WKt,(0,p.Z)({},IKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}RKt.isMDXComponent=!0;const SKt={toc:[]},BKt="wrapper";function GKt(t){let{components:e,...n}=t;return(0,s.kt)(BKt,(0,p.Z)({},SKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}GKt.isMDXComponent=!0;const EKt={toc:[]},OKt="wrapper";function UKt(t){let{components:e,...n}=t;return(0,s.kt)(OKt,(0,p.Z)({},EKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}UKt.isMDXComponent=!0;const FKt={toc:[]},VKt="wrapper";function qKt(t){let{components:e,...n}=t;return(0,s.kt)(VKt,(0,p.Z)({},FKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}qKt.isMDXComponent=!0;const jKt={toc:[]},HKt="wrapper";function YKt(t){let{components:e,...n}=t;return(0,s.kt)(HKt,(0,p.Z)({},jKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}YKt.isMDXComponent=!0;const QKt={toc:[]},$Kt="wrapper";function KKt(t){let{components:e,...n}=t;return(0,s.kt)($Kt,(0,p.Z)({},QKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}KKt.isMDXComponent=!0;const JKt={toc:[]},tJt="wrapper";function eJt(t){let{components:e,...n}=t;return(0,s.kt)(tJt,(0,p.Z)({},JKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}eJt.isMDXComponent=!0;const nJt={toc:[]},oJt="wrapper";function pJt(t){let{components:e,...n}=t;return(0,s.kt)(oJt,(0,p.Z)({},nJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pJt.isMDXComponent=!0;const rJt={toc:[]},sJt="wrapper";function cJt(t){let{components:e,...n}=t;return(0,s.kt)(sJt,(0,p.Z)({},rJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}cJt.isMDXComponent=!0;const aJt={toc:[]},iJt="wrapper";function lJt(t){let{components:e,...n}=t;return(0,s.kt)(iJt,(0,p.Z)({},aJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lJt.isMDXComponent=!0;const uJt={toc:[]},mJt="wrapper";function dJt(t){let{components:e,...n}=t;return(0,s.kt)(mJt,(0,p.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dJt.isMDXComponent=!0;const hJt={toc:[]},fJt="wrapper";function kJt(t){let{components:e,...n}=t;return(0,s.kt)(fJt,(0,p.Z)({},hJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kJt.isMDXComponent=!0;const yJt={toc:[]},DJt="wrapper";function MJt(t){let{components:e,...n}=t;return(0,s.kt)(DJt,(0,p.Z)({},yJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}MJt.isMDXComponent=!0;const XJt={toc:[]},_Jt="wrapper";function wJt(t){let{components:e,...n}=t;return(0,s.kt)(_Jt,(0,p.Z)({},XJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wJt.isMDXComponent=!0;const TJt={toc:[]},CJt="wrapper";function gJt(t){let{components:e,...n}=t;return(0,s.kt)(CJt,(0,p.Z)({},TJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}gJt.isMDXComponent=!0;const xJt={toc:[]},vJt="wrapper";function LJt(t){let{components:e,...n}=t;return(0,s.kt)(vJt,(0,p.Z)({},xJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}LJt.isMDXComponent=!0;const ZJt={toc:[]},bJt="wrapper";function NJt(t){let{components:e,...n}=t;return(0,s.kt)(bJt,(0,p.Z)({},ZJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}NJt.isMDXComponent=!0;const zJt={toc:[]},AJt="wrapper";function PJt(t){let{components:e,...n}=t;return(0,s.kt)(AJt,(0,p.Z)({},zJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}PJt.isMDXComponent=!0;const IJt={toc:[]},WJt="wrapper";function RJt(t){let{components:e,...n}=t;return(0,s.kt)(WJt,(0,p.Z)({},IJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}RJt.isMDXComponent=!0;const SJt={toc:[]},BJt="wrapper";function GJt(t){let{components:e,...n}=t;return(0,s.kt)(BJt,(0,p.Z)({},SJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}GJt.isMDXComponent=!0;const EJt={toc:[]},OJt="wrapper";function UJt(t){let{components:e,...n}=t;return(0,s.kt)(OJt,(0,p.Z)({},EJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}UJt.isMDXComponent=!0;const FJt={toc:[]},VJt="wrapper";function qJt(t){let{components:e,...n}=t;return(0,s.kt)(VJt,(0,p.Z)({},FJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}qJt.isMDXComponent=!0;const jJt={toc:[]},HJt="wrapper";function YJt(t){let{components:e,...n}=t;return(0,s.kt)(HJt,(0,p.Z)({},jJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@motion-canvas/2d';\nimport {all, createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}YJt.isMDXComponent=!0;const QJt={toc:[]},$Jt="wrapper";function KJt(t){let{components:e,...n}=t;return(0,s.kt)($Jt,(0,p.Z)({},QJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a two-dimensional grid."))}KJt.isMDXComponent=!0;const JJt={toc:[]},t0t="wrapper";function e0t(t){let{components:e,...n}=t;return(0,s.kt)(t0t,(0,p.Z)({},JJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}e0t.isMDXComponent=!0;const n0t={toc:[]},o0t="wrapper";function p0t(t){let{components:e,...n}=t;return(0,s.kt)(o0t,(0,p.Z)({},n0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}p0t.isMDXComponent=!0;const r0t={toc:[]},s0t="wrapper";function c0t(t){let{components:e,...n}=t;return(0,s.kt)(s0t,(0,p.Z)({},r0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}c0t.isMDXComponent=!0;const a0t={toc:[]},i0t="wrapper";function l0t(t){let{components:e,...n}=t;return(0,s.kt)(i0t,(0,p.Z)({},a0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}l0t.isMDXComponent=!0;const u0t={toc:[]},m0t="wrapper";function d0t(t){let{components:e,...n}=t;return(0,s.kt)(m0t,(0,p.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}d0t.isMDXComponent=!0;const h0t={toc:[]},f0t="wrapper";function k0t(t){let{components:e,...n}=t;return(0,s.kt)(f0t,(0,p.Z)({},h0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}k0t.isMDXComponent=!0;const y0t={toc:[]},D0t="wrapper";function M0t(t){let{components:e,...n}=t;return(0,s.kt)(D0t,(0,p.Z)({},y0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}M0t.isMDXComponent=!0;const X0t={toc:[]},_0t="wrapper";function w0t(t){let{components:e,...n}=t;return(0,s.kt)(_0t,(0,p.Z)({},X0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}w0t.isMDXComponent=!0;const T0t={toc:[]},C0t="wrapper";function g0t(t){let{components:e,...n}=t;return(0,s.kt)(C0t,(0,p.Z)({},T0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}g0t.isMDXComponent=!0;const x0t={toc:[]},v0t="wrapper";function L0t(t){let{components:e,...n}=t;return(0,s.kt)(v0t,(0,p.Z)({},x0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}L0t.isMDXComponent=!0;const Z0t={toc:[]},b0t="wrapper";function N0t(t){let{components:e,...n}=t;return(0,s.kt)(b0t,(0,p.Z)({},Z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}N0t.isMDXComponent=!0;const z0t={toc:[]},A0t="wrapper";function P0t(t){let{components:e,...n}=t;return(0,s.kt)(A0t,(0,p.Z)({},z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}P0t.isMDXComponent=!0;const I0t={toc:[]},W0t="wrapper";function R0t(t){let{components:e,...n}=t;return(0,s.kt)(W0t,(0,p.Z)({},I0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}R0t.isMDXComponent=!0;const S0t={toc:[]},B0t="wrapper";function G0t(t){let{components:e,...n}=t;return(0,s.kt)(B0t,(0,p.Z)({},S0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}G0t.isMDXComponent=!0;const E0t={toc:[]},O0t="wrapper";function U0t(t){let{components:e,...n}=t;return(0,s.kt)(O0t,(0,p.Z)({},E0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}U0t.isMDXComponent=!0;const F0t={toc:[]},V0t="wrapper";function q0t(t){let{components:e,...n}=t;return(0,s.kt)(V0t,(0,p.Z)({},F0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}q0t.isMDXComponent=!0;const j0t={toc:[]},H0t="wrapper";function Y0t(t){let{components:e,...n}=t;return(0,s.kt)(H0t,(0,p.Z)({},j0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Y0t.isMDXComponent=!0;const Q0t={toc:[]},$0t="wrapper";function K0t(t){let{components:e,...n}=t;return(0,s.kt)($0t,(0,p.Z)({},Q0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}K0t.isMDXComponent=!0;const J0t={toc:[]},t3t="wrapper";function e3t(t){let{components:e,...n}=t;return(0,s.kt)(t3t,(0,p.Z)({},J0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}e3t.isMDXComponent=!0;const n3t={toc:[]},o3t="wrapper";function p3t(t){let{components:e,...n}=t;return(0,s.kt)(o3t,(0,p.Z)({},n3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}p3t.isMDXComponent=!0;const r3t={toc:[]},s3t="wrapper";function c3t(t){let{components:e,...n}=t;return(0,s.kt)(s3t,(0,p.Z)({},r3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}c3t.isMDXComponent=!0;const a3t={toc:[]},i3t="wrapper";function l3t(t){let{components:e,...n}=t;return(0,s.kt)(i3t,(0,p.Z)({},a3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}l3t.isMDXComponent=!0;const u3t={toc:[]},m3t="wrapper";function d3t(t){let{components:e,...n}=t;return(0,s.kt)(m3t,(0,p.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}d3t.isMDXComponent=!0;const h3t={toc:[]},f3t="wrapper";function k3t(t){let{components:e,...n}=t;return(0,s.kt)(f3t,(0,p.Z)({},h3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}k3t.isMDXComponent=!0;const y3t={toc:[]},D3t="wrapper";function M3t(t){let{components:e,...n}=t;return(0,s.kt)(D3t,(0,p.Z)({},y3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}M3t.isMDXComponent=!0;const X3t={toc:[]},_3t="wrapper";function w3t(t){let{components:e,...n}=t;return(0,s.kt)(_3t,(0,p.Z)({},X3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}w3t.isMDXComponent=!0;const T3t={toc:[]},C3t="wrapper";function g3t(t){let{components:e,...n}=t;return(0,s.kt)(C3t,(0,p.Z)({},T3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}g3t.isMDXComponent=!0;const x3t={toc:[]},v3t="wrapper";function L3t(t){let{components:e,...n}=t;return(0,s.kt)(v3t,(0,p.Z)({},x3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}L3t.isMDXComponent=!0;const Z3t={toc:[]},b3t="wrapper";function N3t(t){let{components:e,...n}=t;return(0,s.kt)(b3t,(0,p.Z)({},Z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}N3t.isMDXComponent=!0;const z3t={toc:[]},A3t="wrapper";function P3t(t){let{components:e,...n}=t;return(0,s.kt)(A3t,(0,p.Z)({},z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}P3t.isMDXComponent=!0;const I3t={toc:[]},W3t="wrapper";function R3t(t){let{components:e,...n}=t;return(0,s.kt)(W3t,(0,p.Z)({},I3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}R3t.isMDXComponent=!0;const S3t={toc:[]},B3t="wrapper";function G3t(t){let{components:e,...n}=t;return(0,s.kt)(B3t,(0,p.Z)({},S3t,n,{components:e,mdxType:"MDXLayout"}))}G3t.isMDXComponent=!0;const E3t={toc:[]},O3t="wrapper";function U3t(t){let{components:e,...n}=t;return(0,s.kt)(O3t,(0,p.Z)({},E3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}U3t.isMDXComponent=!0;const F3t={toc:[]},V3t="wrapper";function q3t(t){let{components:e,...n}=t;return(0,s.kt)(V3t,(0,p.Z)({},F3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}q3t.isMDXComponent=!0;const j3t={toc:[]},H3t="wrapper";function Y3t(t){let{components:e,...n}=t;return(0,s.kt)(H3t,(0,p.Z)({},j3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Y3t.isMDXComponent=!0;const Q3t={toc:[]},$3t="wrapper";function K3t(t){let{components:e,...n}=t;return(0,s.kt)($3t,(0,p.Z)({},Q3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}K3t.isMDXComponent=!0;const J3t={toc:[]},t1t="wrapper";function e1t(t){let{components:e,...n}=t;return(0,s.kt)(t1t,(0,p.Z)({},J3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}e1t.isMDXComponent=!0;const n1t={toc:[]},o1t="wrapper";function p1t(t){let{components:e,...n}=t;return(0,s.kt)(o1t,(0,p.Z)({},n1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}p1t.isMDXComponent=!0;const r1t={toc:[]},s1t="wrapper";function c1t(t){let{components:e,...n}=t;return(0,s.kt)(s1t,(0,p.Z)({},r1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}c1t.isMDXComponent=!0;const a1t={toc:[]},i1t="wrapper";function l1t(t){let{components:e,...n}=t;return(0,s.kt)(i1t,(0,p.Z)({},a1t,n,{components:e,mdxType:"MDXLayout"}))}l1t.isMDXComponent=!0;const u1t={toc:[]},m1t="wrapper";function d1t(t){let{components:e,...n}=t;return(0,s.kt)(m1t,(0,p.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}d1t.isMDXComponent=!0;const h1t={toc:[]},f1t="wrapper";function k1t(t){let{components:e,...n}=t;return(0,s.kt)(f1t,(0,p.Z)({},h1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}k1t.isMDXComponent=!0;const y1t={toc:[]},D1t="wrapper";function M1t(t){let{components:e,...n}=t;return(0,s.kt)(D1t,(0,p.Z)({},y1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}M1t.isMDXComponent=!0;const X1t={toc:[]},_1t="wrapper";function w1t(t){let{components:e,...n}=t;return(0,s.kt)(_1t,(0,p.Z)({},X1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}w1t.isMDXComponent=!0;const T1t={toc:[]},C1t="wrapper";function g1t(t){let{components:e,...n}=t;return(0,s.kt)(C1t,(0,p.Z)({},T1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}g1t.isMDXComponent=!0;const x1t={toc:[]},v1t="wrapper";function L1t(t){let{components:e,...n}=t;return(0,s.kt)(v1t,(0,p.Z)({},x1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}L1t.isMDXComponent=!0;const Z1t={toc:[]},b1t="wrapper";function N1t(t){let{components:e,...n}=t;return(0,s.kt)(b1t,(0,p.Z)({},Z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}N1t.isMDXComponent=!0;const z1t={toc:[]},A1t="wrapper";function P1t(t){let{components:e,...n}=t;return(0,s.kt)(A1t,(0,p.Z)({},z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}P1t.isMDXComponent=!0;const I1t={toc:[]},W1t="wrapper";function R1t(t){let{components:e,...n}=t;return(0,s.kt)(W1t,(0,p.Z)({},I1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}R1t.isMDXComponent=!0;const S1t={toc:[]},B1t="wrapper";function G1t(t){let{components:e,...n}=t;return(0,s.kt)(B1t,(0,p.Z)({},S1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}G1t.isMDXComponent=!0;const E1t={toc:[]},O1t="wrapper";function U1t(t){let{components:e,...n}=t;return(0,s.kt)(O1t,(0,p.Z)({},E1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}U1t.isMDXComponent=!0;const F1t={toc:[]},V1t="wrapper";function q1t(t){let{components:e,...n}=t;return(0,s.kt)(V1t,(0,p.Z)({},F1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}q1t.isMDXComponent=!0;const j1t={toc:[]},H1t="wrapper";function Y1t(t){let{components:e,...n}=t;return(0,s.kt)(H1t,(0,p.Z)({},j1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Y1t.isMDXComponent=!0;const Q1t={toc:[]},$1t="wrapper";function K1t(t){let{components:e,...n}=t;return(0,s.kt)($1t,(0,p.Z)({},Q1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}K1t.isMDXComponent=!0;const J1t={toc:[]},t8t="wrapper";function e8t(t){let{components:e,...n}=t;return(0,s.kt)(t8t,(0,p.Z)({},J1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}e8t.isMDXComponent=!0;const n8t={toc:[]},o8t="wrapper";function p8t(t){let{components:e,...n}=t;return(0,s.kt)(o8t,(0,p.Z)({},n8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}p8t.isMDXComponent=!0;const r8t={toc:[]},s8t="wrapper";function c8t(t){let{components:e,...n}=t;return(0,s.kt)(s8t,(0,p.Z)({},r8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}c8t.isMDXComponent=!0;const a8t={toc:[]},i8t="wrapper";function l8t(t){let{components:e,...n}=t;return(0,s.kt)(i8t,(0,p.Z)({},a8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}l8t.isMDXComponent=!0;const u8t={toc:[]},m8t="wrapper";function d8t(t){let{components:e,...n}=t;return(0,s.kt)(m8t,(0,p.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}d8t.isMDXComponent=!0;const h8t={toc:[]},f8t="wrapper";function k8t(t){let{components:e,...n}=t;return(0,s.kt)(f8t,(0,p.Z)({},h8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}k8t.isMDXComponent=!0;const y8t={toc:[]},D8t="wrapper";function M8t(t){let{components:e,...n}=t;return(0,s.kt)(D8t,(0,p.Z)({},y8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}M8t.isMDXComponent=!0;const X8t={toc:[]},_8t="wrapper";function w8t(t){let{components:e,...n}=t;return(0,s.kt)(_8t,(0,p.Z)({},X8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}w8t.isMDXComponent=!0;const T8t={toc:[]},C8t="wrapper";function g8t(t){let{components:e,...n}=t;return(0,s.kt)(C8t,(0,p.Z)({},T8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}g8t.isMDXComponent=!0;const x8t={toc:[]},v8t="wrapper";function L8t(t){let{components:e,...n}=t;return(0,s.kt)(v8t,(0,p.Z)({},x8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}L8t.isMDXComponent=!0;const Z8t={toc:[]},b8t="wrapper";function N8t(t){let{components:e,...n}=t;return(0,s.kt)(b8t,(0,p.Z)({},Z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}N8t.isMDXComponent=!0;const z8t={toc:[]},A8t="wrapper";function P8t(t){let{components:e,...n}=t;return(0,s.kt)(A8t,(0,p.Z)({},z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}P8t.isMDXComponent=!0;const I8t={toc:[]},W8t="wrapper";function R8t(t){let{components:e,...n}=t;return(0,s.kt)(W8t,(0,p.Z)({},I8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}R8t.isMDXComponent=!0;const S8t={toc:[]},B8t="wrapper";function G8t(t){let{components:e,...n}=t;return(0,s.kt)(B8t,(0,p.Z)({},S8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}G8t.isMDXComponent=!0;const E8t={toc:[]},O8t="wrapper";function U8t(t){let{components:e,...n}=t;return(0,s.kt)(O8t,(0,p.Z)({},E8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}U8t.isMDXComponent=!0;const F8t={toc:[]},V8t="wrapper";function q8t(t){let{components:e,...n}=t;return(0,s.kt)(V8t,(0,p.Z)({},F8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}q8t.isMDXComponent=!0;const j8t={toc:[]},H8t="wrapper";function Y8t(t){let{components:e,...n}=t;return(0,s.kt)(H8t,(0,p.Z)({},j8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Y8t.isMDXComponent=!0;const Q8t={toc:[]},$8t="wrapper";function K8t(t){let{components:e,...n}=t;return(0,s.kt)($8t,(0,p.Z)({},Q8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}K8t.isMDXComponent=!0;const J8t={toc:[]},t2t="wrapper";function e2t(t){let{components:e,...n}=t;return(0,s.kt)(t2t,(0,p.Z)({},J8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}e2t.isMDXComponent=!0;const n2t={toc:[]},o2t="wrapper";function p2t(t){let{components:e,...n}=t;return(0,s.kt)(o2t,(0,p.Z)({},n2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}p2t.isMDXComponent=!0;const r2t={toc:[]},s2t="wrapper";function c2t(t){let{components:e,...n}=t;return(0,s.kt)(s2t,(0,p.Z)({},r2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}c2t.isMDXComponent=!0;const a2t={toc:[]},i2t="wrapper";function l2t(t){let{components:e,...n}=t;return(0,s.kt)(i2t,(0,p.Z)({},a2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}l2t.isMDXComponent=!0;const u2t={toc:[]},m2t="wrapper";function d2t(t){let{components:e,...n}=t;return(0,s.kt)(m2t,(0,p.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}d2t.isMDXComponent=!0;const h2t={toc:[]},f2t="wrapper";function k2t(t){let{components:e,...n}=t;return(0,s.kt)(f2t,(0,p.Z)({},h2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}k2t.isMDXComponent=!0;const y2t={toc:[]},D2t="wrapper";function M2t(t){let{components:e,...n}=t;return(0,s.kt)(D2t,(0,p.Z)({},y2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}M2t.isMDXComponent=!0;const X2t={toc:[]},_2t="wrapper";function w2t(t){let{components:e,...n}=t;return(0,s.kt)(_2t,(0,p.Z)({},X2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}w2t.isMDXComponent=!0;const T2t={toc:[]},C2t="wrapper";function g2t(t){let{components:e,...n}=t;return(0,s.kt)(C2t,(0,p.Z)({},T2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}g2t.isMDXComponent=!0;const x2t={toc:[]},v2t="wrapper";function L2t(t){let{components:e,...n}=t;return(0,s.kt)(v2t,(0,p.Z)({},x2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}L2t.isMDXComponent=!0;const Z2t={toc:[]},b2t="wrapper";function N2t(t){let{components:e,...n}=t;return(0,s.kt)(b2t,(0,p.Z)({},Z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N2t.isMDXComponent=!0;const z2t={toc:[]},A2t="wrapper";function P2t(t){let{components:e,...n}=t;return(0,s.kt)(A2t,(0,p.Z)({},z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}P2t.isMDXComponent=!0;const I2t={toc:[]},W2t="wrapper";function R2t(t){let{components:e,...n}=t;return(0,s.kt)(W2t,(0,p.Z)({},I2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}R2t.isMDXComponent=!0;const S2t={toc:[]},B2t="wrapper";function G2t(t){let{components:e,...n}=t;return(0,s.kt)(B2t,(0,p.Z)({},S2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}G2t.isMDXComponent=!0;const E2t={toc:[]},O2t="wrapper";function U2t(t){let{components:e,...n}=t;return(0,s.kt)(O2t,(0,p.Z)({},E2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}U2t.isMDXComponent=!0;const F2t={toc:[]},V2t="wrapper";function q2t(t){let{components:e,...n}=t;return(0,s.kt)(V2t,(0,p.Z)({},F2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}q2t.isMDXComponent=!0;const j2t={toc:[]},H2t="wrapper";function Y2t(t){let{components:e,...n}=t;return(0,s.kt)(H2t,(0,p.Z)({},j2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Y2t.isMDXComponent=!0;const Q2t={toc:[]},$2t="wrapper";function K2t(t){let{components:e,...n}=t;return(0,s.kt)($2t,(0,p.Z)({},Q2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}K2t.isMDXComponent=!0;const J2t={toc:[]},t4t="wrapper";function e4t(t){let{components:e,...n}=t;return(0,s.kt)(t4t,(0,p.Z)({},J2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}e4t.isMDXComponent=!0;const n4t={toc:[]},o4t="wrapper";function p4t(t){let{components:e,...n}=t;return(0,s.kt)(o4t,(0,p.Z)({},n4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}p4t.isMDXComponent=!0;const r4t={toc:[]},s4t="wrapper";function c4t(t){let{components:e,...n}=t;return(0,s.kt)(s4t,(0,p.Z)({},r4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}c4t.isMDXComponent=!0;const a4t={toc:[]},i4t="wrapper";function l4t(t){let{components:e,...n}=t;return(0,s.kt)(i4t,(0,p.Z)({},a4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}l4t.isMDXComponent=!0;const u4t={toc:[]},m4t="wrapper";function d4t(t){let{components:e,...n}=t;return(0,s.kt)(m4t,(0,p.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d4t.isMDXComponent=!0;const h4t={toc:[]},f4t="wrapper";function k4t(t){let{components:e,...n}=t;return(0,s.kt)(f4t,(0,p.Z)({},h4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}k4t.isMDXComponent=!0;const y4t={toc:[]},D4t="wrapper";function M4t(t){let{components:e,...n}=t;return(0,s.kt)(D4t,(0,p.Z)({},y4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}M4t.isMDXComponent=!0;const X4t={toc:[]},_4t="wrapper";function w4t(t){let{components:e,...n}=t;return(0,s.kt)(_4t,(0,p.Z)({},X4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}w4t.isMDXComponent=!0;const T4t={toc:[]},C4t="wrapper";function g4t(t){let{components:e,...n}=t;return(0,s.kt)(C4t,(0,p.Z)({},T4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}g4t.isMDXComponent=!0;const x4t={toc:[]},v4t="wrapper";function L4t(t){let{components:e,...n}=t;return(0,s.kt)(v4t,(0,p.Z)({},x4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}L4t.isMDXComponent=!0;const Z4t={toc:[]},b4t="wrapper";function N4t(t){let{components:e,...n}=t;return(0,s.kt)(b4t,(0,p.Z)({},Z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}N4t.isMDXComponent=!0;const z4t={toc:[]},A4t="wrapper";function P4t(t){let{components:e,...n}=t;return(0,s.kt)(A4t,(0,p.Z)({},z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}P4t.isMDXComponent=!0;const I4t={toc:[]},W4t="wrapper";function R4t(t){let{components:e,...n}=t;return(0,s.kt)(W4t,(0,p.Z)({},I4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}R4t.isMDXComponent=!0;const S4t={toc:[]},B4t="wrapper";function G4t(t){let{components:e,...n}=t;return(0,s.kt)(B4t,(0,p.Z)({},S4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}G4t.isMDXComponent=!0;const E4t={toc:[]},O4t="wrapper";function U4t(t){let{components:e,...n}=t;return(0,s.kt)(O4t,(0,p.Z)({},E4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}U4t.isMDXComponent=!0;const F4t={toc:[]},V4t="wrapper";function q4t(t){let{components:e,...n}=t;return(0,s.kt)(V4t,(0,p.Z)({},F4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}q4t.isMDXComponent=!0;const j4t={toc:[]},H4t="wrapper";function Y4t(t){let{components:e,...n}=t;return(0,s.kt)(H4t,(0,p.Z)({},j4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Y4t.isMDXComponent=!0;const Q4t={toc:[]},$4t="wrapper";function K4t(t){let{components:e,...n}=t;return(0,s.kt)($4t,(0,p.Z)({},Q4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}K4t.isMDXComponent=!0;const J4t={toc:[]},t6t="wrapper";function e6t(t){let{components:e,...n}=t;return(0,s.kt)(t6t,(0,p.Z)({},J4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}e6t.isMDXComponent=!0;const n6t={toc:[]},o6t="wrapper";function p6t(t){let{components:e,...n}=t;return(0,s.kt)(o6t,(0,p.Z)({},n6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}p6t.isMDXComponent=!0;const r6t={toc:[]},s6t="wrapper";function c6t(t){let{components:e,...n}=t;return(0,s.kt)(s6t,(0,p.Z)({},r6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}c6t.isMDXComponent=!0;const a6t={toc:[]},i6t="wrapper";function l6t(t){let{components:e,...n}=t;return(0,s.kt)(i6t,(0,p.Z)({},a6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}l6t.isMDXComponent=!0;const u6t={toc:[]},m6t="wrapper";function d6t(t){let{components:e,...n}=t;return(0,s.kt)(m6t,(0,p.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}d6t.isMDXComponent=!0;const h6t={toc:[]},f6t="wrapper";function k6t(t){let{components:e,...n}=t;return(0,s.kt)(f6t,(0,p.Z)({},h6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}k6t.isMDXComponent=!0;const y6t={toc:[]},D6t="wrapper";function M6t(t){let{components:e,...n}=t;return(0,s.kt)(D6t,(0,p.Z)({},y6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}M6t.isMDXComponent=!0;const X6t={toc:[]},_6t="wrapper";function w6t(t){let{components:e,...n}=t;return(0,s.kt)(_6t,(0,p.Z)({},X6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}w6t.isMDXComponent=!0;const T6t={toc:[]},C6t="wrapper";function g6t(t){let{components:e,...n}=t;return(0,s.kt)(C6t,(0,p.Z)({},T6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}g6t.isMDXComponent=!0;const x6t={toc:[]},v6t="wrapper";function L6t(t){let{components:e,...n}=t;return(0,s.kt)(v6t,(0,p.Z)({},x6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}L6t.isMDXComponent=!0;const Z6t={toc:[]},b6t="wrapper";function N6t(t){let{components:e,...n}=t;return(0,s.kt)(b6t,(0,p.Z)({},Z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}N6t.isMDXComponent=!0;const z6t={toc:[]},A6t="wrapper";function P6t(t){let{components:e,...n}=t;return(0,s.kt)(A6t,(0,p.Z)({},z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}P6t.isMDXComponent=!0;const I6t={toc:[]},W6t="wrapper";function R6t(t){let{components:e,...n}=t;return(0,s.kt)(W6t,(0,p.Z)({},I6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}R6t.isMDXComponent=!0;const S6t={toc:[]},B6t="wrapper";function G6t(t){let{components:e,...n}=t;return(0,s.kt)(B6t,(0,p.Z)({},S6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}G6t.isMDXComponent=!0;const E6t={toc:[]},O6t="wrapper";function U6t(t){let{components:e,...n}=t;return(0,s.kt)(O6t,(0,p.Z)({},E6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}U6t.isMDXComponent=!0;const F6t={toc:[]},V6t="wrapper";function q6t(t){let{components:e,...n}=t;return(0,s.kt)(V6t,(0,p.Z)({},F6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}q6t.isMDXComponent=!0;const j6t={toc:[]},H6t="wrapper";function Y6t(t){let{components:e,...n}=t;return(0,s.kt)(H6t,(0,p.Z)({},j6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Y6t.isMDXComponent=!0;const Q6t={toc:[]},$6t="wrapper";function K6t(t){let{components:e,...n}=t;return(0,s.kt)($6t,(0,p.Z)({},Q6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}K6t.isMDXComponent=!0;const J6t={toc:[]},t5t="wrapper";function e5t(t){let{components:e,...n}=t;return(0,s.kt)(t5t,(0,p.Z)({},J6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}e5t.isMDXComponent=!0;const n5t={toc:[]},o5t="wrapper";function p5t(t){let{components:e,...n}=t;return(0,s.kt)(o5t,(0,p.Z)({},n5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}p5t.isMDXComponent=!0;const r5t={toc:[]},s5t="wrapper";function c5t(t){let{components:e,...n}=t;return(0,s.kt)(s5t,(0,p.Z)({},r5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}c5t.isMDXComponent=!0;const a5t={toc:[]},i5t="wrapper";function l5t(t){let{components:e,...n}=t;return(0,s.kt)(i5t,(0,p.Z)({},a5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}l5t.isMDXComponent=!0;const u5t={toc:[]},m5t="wrapper";function d5t(t){let{components:e,...n}=t;return(0,s.kt)(m5t,(0,p.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}d5t.isMDXComponent=!0;const h5t={toc:[]},f5t="wrapper";function k5t(t){let{components:e,...n}=t;return(0,s.kt)(f5t,(0,p.Z)({},h5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}k5t.isMDXComponent=!0;const y5t={toc:[]},D5t="wrapper";function M5t(t){let{components:e,...n}=t;return(0,s.kt)(D5t,(0,p.Z)({},y5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}M5t.isMDXComponent=!0;const X5t={toc:[]},_5t="wrapper";function w5t(t){let{components:e,...n}=t;return(0,s.kt)(_5t,(0,p.Z)({},X5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}w5t.isMDXComponent=!0;const T5t={toc:[]},C5t="wrapper";function g5t(t){let{components:e,...n}=t;return(0,s.kt)(C5t,(0,p.Z)({},T5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}g5t.isMDXComponent=!0;const x5t={toc:[]},v5t="wrapper";function L5t(t){let{components:e,...n}=t;return(0,s.kt)(v5t,(0,p.Z)({},x5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}L5t.isMDXComponent=!0;const Z5t={toc:[]},b5t="wrapper";function N5t(t){let{components:e,...n}=t;return(0,s.kt)(b5t,(0,p.Z)({},Z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}N5t.isMDXComponent=!0;const z5t={toc:[]},A5t="wrapper";function P5t(t){let{components:e,...n}=t;return(0,s.kt)(A5t,(0,p.Z)({},z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}P5t.isMDXComponent=!0;const I5t={toc:[]},W5t="wrapper";function R5t(t){let{components:e,...n}=t;return(0,s.kt)(W5t,(0,p.Z)({},I5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}R5t.isMDXComponent=!0;const S5t={toc:[]},B5t="wrapper";function G5t(t){let{components:e,...n}=t;return(0,s.kt)(B5t,(0,p.Z)({},S5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}G5t.isMDXComponent=!0;const E5t={toc:[]},O5t="wrapper";function U5t(t){let{components:e,...n}=t;return(0,s.kt)(O5t,(0,p.Z)({},E5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}U5t.isMDXComponent=!0;const F5t={toc:[]},V5t="wrapper";function q5t(t){let{components:e,...n}=t;return(0,s.kt)(V5t,(0,p.Z)({},F5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}q5t.isMDXComponent=!0;const j5t={toc:[]},H5t="wrapper";function Y5t(t){let{components:e,...n}=t;return(0,s.kt)(H5t,(0,p.Z)({},j5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Y5t.isMDXComponent=!0;const Q5t={toc:[]},$5t="wrapper";function K5t(t){let{components:e,...n}=t;return(0,s.kt)($5t,(0,p.Z)({},Q5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}K5t.isMDXComponent=!0;const J5t={toc:[]},t7t="wrapper";function e7t(t){let{components:e,...n}=t;return(0,s.kt)(t7t,(0,p.Z)({},J5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}e7t.isMDXComponent=!0;const n7t={toc:[]},o7t="wrapper";function p7t(t){let{components:e,...n}=t;return(0,s.kt)(o7t,(0,p.Z)({},n7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}p7t.isMDXComponent=!0;const r7t={toc:[]},s7t="wrapper";function c7t(t){let{components:e,...n}=t;return(0,s.kt)(s7t,(0,p.Z)({},r7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}c7t.isMDXComponent=!0;const a7t={toc:[]},i7t="wrapper";function l7t(t){let{components:e,...n}=t;return(0,s.kt)(i7t,(0,p.Z)({},a7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}l7t.isMDXComponent=!0;const u7t={toc:[]},m7t="wrapper";function d7t(t){let{components:e,...n}=t;return(0,s.kt)(m7t,(0,p.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}d7t.isMDXComponent=!0;const h7t={toc:[]},f7t="wrapper";function k7t(t){let{components:e,...n}=t;return(0,s.kt)(f7t,(0,p.Z)({},h7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}k7t.isMDXComponent=!0;const y7t={toc:[]},D7t="wrapper";function M7t(t){let{components:e,...n}=t;return(0,s.kt)(D7t,(0,p.Z)({},y7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}M7t.isMDXComponent=!0;const X7t={toc:[]},_7t="wrapper";function w7t(t){let{components:e,...n}=t;return(0,s.kt)(_7t,(0,p.Z)({},X7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}w7t.isMDXComponent=!0;const T7t={toc:[]},C7t="wrapper";function g7t(t){let{components:e,...n}=t;return(0,s.kt)(C7t,(0,p.Z)({},T7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}g7t.isMDXComponent=!0;const x7t={toc:[]},v7t="wrapper";function L7t(t){let{components:e,...n}=t;return(0,s.kt)(v7t,(0,p.Z)({},x7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}L7t.isMDXComponent=!0;const Z7t={toc:[]},b7t="wrapper";function N7t(t){let{components:e,...n}=t;return(0,s.kt)(b7t,(0,p.Z)({},Z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}N7t.isMDXComponent=!0;const z7t={toc:[]},A7t="wrapper";function P7t(t){let{components:e,...n}=t;return(0,s.kt)(A7t,(0,p.Z)({},z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}P7t.isMDXComponent=!0;const I7t={toc:[]},W7t="wrapper";function R7t(t){let{components:e,...n}=t;return(0,s.kt)(W7t,(0,p.Z)({},I7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}R7t.isMDXComponent=!0;const S7t={toc:[]},B7t="wrapper";function G7t(t){let{components:e,...n}=t;return(0,s.kt)(B7t,(0,p.Z)({},S7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}G7t.isMDXComponent=!0;const E7t={toc:[]},O7t="wrapper";function U7t(t){let{components:e,...n}=t;return(0,s.kt)(O7t,(0,p.Z)({},E7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}U7t.isMDXComponent=!0;const F7t={toc:[]},V7t="wrapper";function q7t(t){let{components:e,...n}=t;return(0,s.kt)(V7t,(0,p.Z)({},F7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}q7t.isMDXComponent=!0;const j7t={toc:[]},H7t="wrapper";function Y7t(t){let{components:e,...n}=t;return(0,s.kt)(H7t,(0,p.Z)({},j7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Y7t.isMDXComponent=!0;const Q7t={toc:[]},$7t="wrapper";function K7t(t){let{components:e,...n}=t;return(0,s.kt)($7t,(0,p.Z)({},Q7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}K7t.isMDXComponent=!0;const J7t={toc:[]},t9t="wrapper";function e9t(t){let{components:e,...n}=t;return(0,s.kt)(t9t,(0,p.Z)({},J7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}e9t.isMDXComponent=!0;const n9t={toc:[]},o9t="wrapper";function p9t(t){let{components:e,...n}=t;return(0,s.kt)(o9t,(0,p.Z)({},n9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}p9t.isMDXComponent=!0;const r9t={toc:[]},s9t="wrapper";function c9t(t){let{components:e,...n}=t;return(0,s.kt)(s9t,(0,p.Z)({},r9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}c9t.isMDXComponent=!0;const a9t={toc:[]},i9t="wrapper";function l9t(t){let{components:e,...n}=t;return(0,s.kt)(i9t,(0,p.Z)({},a9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}l9t.isMDXComponent=!0;const u9t={toc:[]},m9t="wrapper";function d9t(t){let{components:e,...n}=t;return(0,s.kt)(m9t,(0,p.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}d9t.isMDXComponent=!0;const h9t={toc:[]},f9t="wrapper";function k9t(t){let{components:e,...n}=t;return(0,s.kt)(f9t,(0,p.Z)({},h9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}k9t.isMDXComponent=!0;const y9t={toc:[]},D9t="wrapper";function M9t(t){let{components:e,...n}=t;return(0,s.kt)(D9t,(0,p.Z)({},y9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}M9t.isMDXComponent=!0;const X9t={toc:[]},_9t="wrapper";function w9t(t){let{components:e,...n}=t;return(0,s.kt)(_9t,(0,p.Z)({},X9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}w9t.isMDXComponent=!0;const T9t={toc:[]},C9t="wrapper";function g9t(t){let{components:e,...n}=t;return(0,s.kt)(C9t,(0,p.Z)({},T9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}g9t.isMDXComponent=!0;const x9t={toc:[]},v9t="wrapper";function L9t(t){let{components:e,...n}=t;return(0,s.kt)(v9t,(0,p.Z)({},x9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}L9t.isMDXComponent=!0;const Z9t={toc:[]},b9t="wrapper";function N9t(t){let{components:e,...n}=t;return(0,s.kt)(b9t,(0,p.Z)({},Z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}N9t.isMDXComponent=!0;const z9t={toc:[]},A9t="wrapper";function P9t(t){let{components:e,...n}=t;return(0,s.kt)(A9t,(0,p.Z)({},z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}P9t.isMDXComponent=!0;const I9t={toc:[]},W9t="wrapper";function R9t(t){let{components:e,...n}=t;return(0,s.kt)(W9t,(0,p.Z)({},I9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}R9t.isMDXComponent=!0;const S9t={toc:[]},B9t="wrapper";function G9t(t){let{components:e,...n}=t;return(0,s.kt)(B9t,(0,p.Z)({},S9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}G9t.isMDXComponent=!0;const E9t={toc:[]},O9t="wrapper";function U9t(t){let{components:e,...n}=t;return(0,s.kt)(O9t,(0,p.Z)({},E9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}U9t.isMDXComponent=!0;const F9t={toc:[]},V9t="wrapper";function q9t(t){let{components:e,...n}=t;return(0,s.kt)(V9t,(0,p.Z)({},F9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}q9t.isMDXComponent=!0;const j9t={toc:[]},H9t="wrapper";function Y9t(t){let{components:e,...n}=t;return(0,s.kt)(H9t,(0,p.Z)({},j9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Y9t.isMDXComponent=!0;const Q9t={toc:[]},$9t="wrapper";function K9t(t){let{components:e,...n}=t;return(0,s.kt)($9t,(0,p.Z)({},Q9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}K9t.isMDXComponent=!0;const J9t={toc:[]},tte="wrapper";function ete(t){let{components:e,...n}=t;return(0,s.kt)(tte,(0,p.Z)({},J9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}ete.isMDXComponent=!0;const nte={toc:[]},ote="wrapper";function pte(t){let{components:e,...n}=t;return(0,s.kt)(ote,(0,p.Z)({},nte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pte.isMDXComponent=!0;const rte={toc:[]},ste="wrapper";function cte(t){let{components:e,...n}=t;return(0,s.kt)(ste,(0,p.Z)({},rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cte.isMDXComponent=!0;const ate={toc:[]},ite="wrapper";function lte(t){let{components:e,...n}=t;return(0,s.kt)(ite,(0,p.Z)({},ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lte.isMDXComponent=!0;const ute={toc:[]},mte="wrapper";function dte(t){let{components:e,...n}=t;return(0,s.kt)(mte,(0,p.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}dte.isMDXComponent=!0;const hte={toc:[]},fte="wrapper";function kte(t){let{components:e,...n}=t;return(0,s.kt)(fte,(0,p.Z)({},hte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kte.isMDXComponent=!0;const yte={toc:[]},Dte="wrapper";function Mte(t){let{components:e,...n}=t;return(0,s.kt)(Dte,(0,p.Z)({},yte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Mte.isMDXComponent=!0;const Xte={toc:[]},_te="wrapper";function wte(t){let{components:e,...n}=t;return(0,s.kt)(_te,(0,p.Z)({},Xte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wte.isMDXComponent=!0;const Tte={toc:[]},Cte="wrapper";function gte(t){let{components:e,...n}=t;return(0,s.kt)(Cte,(0,p.Z)({},Tte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gte.isMDXComponent=!0;const xte={toc:[]},vte="wrapper";function Lte(t){let{components:e,...n}=t;return(0,s.kt)(vte,(0,p.Z)({},xte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Lte.isMDXComponent=!0;const Zte={toc:[]},bte="wrapper";function Nte(t){let{components:e,...n}=t;return(0,s.kt)(bte,(0,p.Z)({},Zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Nte.isMDXComponent=!0;const zte={toc:[]},Ate="wrapper";function Pte(t){let{components:e,...n}=t;return(0,s.kt)(Ate,(0,p.Z)({},zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Pte.isMDXComponent=!0;const Ite={toc:[]},Wte="wrapper";function Rte(t){let{components:e,...n}=t;return(0,s.kt)(Wte,(0,p.Z)({},Ite,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}Rte.isMDXComponent=!0;const Ste={toc:[]},Bte="wrapper";function Gte(t){let{components:e,...n}=t;return(0,s.kt)(Bte,(0,p.Z)({},Ste,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Gte.isMDXComponent=!0;const Ete={toc:[]},Ote="wrapper";function Ute(t){let{components:e,...n}=t;return(0,s.kt)(Ote,(0,p.Z)({},Ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Ute.isMDXComponent=!0;const Fte={toc:[]},Vte="wrapper";function qte(t){let{components:e,...n}=t;return(0,s.kt)(Vte,(0,p.Z)({},Fte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qte.isMDXComponent=!0;const jte={toc:[]},Hte="wrapper";function Yte(t){let{components:e,...n}=t;return(0,s.kt)(Hte,(0,p.Z)({},jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Yte.isMDXComponent=!0;const Qte={toc:[]},$te="wrapper";function Kte(t){let{components:e,...n}=t;return(0,s.kt)($te,(0,p.Z)({},Qte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kte.isMDXComponent=!0;const Jte={toc:[]},tee="wrapper";function eee(t){let{components:e,...n}=t;return(0,s.kt)(tee,(0,p.Z)({},Jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}eee.isMDXComponent=!0;const nee={toc:[]},oee="wrapper";function pee(t){let{components:e,...n}=t;return(0,s.kt)(oee,(0,p.Z)({},nee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}pee.isMDXComponent=!0;const ree={toc:[]},see="wrapper";function cee(t){let{components:e,...n}=t;return(0,s.kt)(see,(0,p.Z)({},ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}cee.isMDXComponent=!0;const aee={toc:[]},iee="wrapper";function lee(t){let{components:e,...n}=t;return(0,s.kt)(iee,(0,p.Z)({},aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lee.isMDXComponent=!0;const uee={toc:[]},mee="wrapper";function dee(t){let{components:e,...n}=t;return(0,s.kt)(mee,(0,p.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}dee.isMDXComponent=!0;const hee={toc:[]},fee="wrapper";function kee(t){let{components:e,...n}=t;return(0,s.kt)(fee,(0,p.Z)({},hee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}kee.isMDXComponent=!0;const yee={toc:[]},Dee="wrapper";function Mee(t){let{components:e,...n}=t;return(0,s.kt)(Dee,(0,p.Z)({},yee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Mee.isMDXComponent=!0;const Xee={toc:[]},_ee="wrapper";function wee(t){let{components:e,...n}=t;return(0,s.kt)(_ee,(0,p.Z)({},Xee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wee.isMDXComponent=!0;const Tee={toc:[]},Cee="wrapper";function gee(t){let{components:e,...n}=t;return(0,s.kt)(Cee,(0,p.Z)({},Tee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}gee.isMDXComponent=!0;const xee={toc:[]},vee="wrapper";function Lee(t){let{components:e,...n}=t;return(0,s.kt)(vee,(0,p.Z)({},xee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Lee.isMDXComponent=!0;const Zee={toc:[]},bee="wrapper";function Nee(t){let{components:e,...n}=t;return(0,s.kt)(bee,(0,p.Z)({},Zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Nee.isMDXComponent=!0;const zee={toc:[]},Aee="wrapper";function Pee(t){let{components:e,...n}=t;return(0,s.kt)(Aee,(0,p.Z)({},zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Pee.isMDXComponent=!0;const Iee={toc:[]},Wee="wrapper";function Ree(t){let{components:e,...n}=t;return(0,s.kt)(Wee,(0,p.Z)({},Iee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Ree.isMDXComponent=!0;const See={toc:[]},Bee="wrapper";function Gee(t){let{components:e,...n}=t;return(0,s.kt)(Bee,(0,p.Z)({},See,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Gee.isMDXComponent=!0;const Eee={toc:[]},Oee="wrapper";function Uee(t){let{components:e,...n}=t;return(0,s.kt)(Oee,(0,p.Z)({},Eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Uee.isMDXComponent=!0;const Fee={toc:[]},Vee="wrapper";function qee(t){let{components:e,...n}=t;return(0,s.kt)(Vee,(0,p.Z)({},Fee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}qee.isMDXComponent=!0;const jee={toc:[]},Hee="wrapper";function Yee(t){let{components:e,...n}=t;return(0,s.kt)(Hee,(0,p.Z)({},jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}Yee.isMDXComponent=!0;const Qee={toc:[]},$ee="wrapper";function Kee(t){let{components:e,...n}=t;return(0,s.kt)($ee,(0,p.Z)({},Qee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}Kee.isMDXComponent=!0;const Jee={toc:[]},tne="wrapper";function ene(t){let{components:e,...n}=t;return(0,s.kt)(tne,(0,p.Z)({},Jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ene.isMDXComponent=!0;const nne={toc:[]},one="wrapper";function pne(t){let{components:e,...n}=t;return(0,s.kt)(one,(0,p.Z)({},nne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}pne.isMDXComponent=!0;const rne={toc:[]},sne="wrapper";function cne(t){let{components:e,...n}=t;return(0,s.kt)(sne,(0,p.Z)({},rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}cne.isMDXComponent=!0;const ane={toc:[]},ine="wrapper";function lne(t){let{components:e,...n}=t;return(0,s.kt)(ine,(0,p.Z)({},ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lne.isMDXComponent=!0;const une={toc:[]},mne="wrapper";function dne(t){let{components:e,...n}=t;return(0,s.kt)(mne,(0,p.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}dne.isMDXComponent=!0;const hne={toc:[]},fne="wrapper";function kne(t){let{components:e,...n}=t;return(0,s.kt)(fne,(0,p.Z)({},hne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kne.isMDXComponent=!0;const yne={toc:[]},Dne="wrapper";function Mne(t){let{components:e,...n}=t;return(0,s.kt)(Dne,(0,p.Z)({},yne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Mne.isMDXComponent=!0;const Xne={toc:[]},_ne="wrapper";function wne(t){let{components:e,...n}=t;return(0,s.kt)(_ne,(0,p.Z)({},Xne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wne.isMDXComponent=!0;const Tne={toc:[]},Cne="wrapper";function gne(t){let{components:e,...n}=t;return(0,s.kt)(Cne,(0,p.Z)({},Tne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}gne.isMDXComponent=!0;const xne={toc:[]},vne="wrapper";function Lne(t){let{components:e,...n}=t;return(0,s.kt)(vne,(0,p.Z)({},xne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Lne.isMDXComponent=!0;const Zne={toc:[]},bne="wrapper";function Nne(t){let{components:e,...n}=t;return(0,s.kt)(bne,(0,p.Z)({},Zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}Nne.isMDXComponent=!0;const zne={toc:[]},Ane="wrapper";function Pne(t){let{components:e,...n}=t;return(0,s.kt)(Ane,(0,p.Z)({},zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Pne.isMDXComponent=!0;const Ine={toc:[]},Wne="wrapper";function Rne(t){let{components:e,...n}=t;return(0,s.kt)(Wne,(0,p.Z)({},Ine,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Rne.isMDXComponent=!0;const Sne={toc:[]},Bne="wrapper";function Gne(t){let{components:e,...n}=t;return(0,s.kt)(Bne,(0,p.Z)({},Sne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Gne.isMDXComponent=!0;const Ene={toc:[]},One="wrapper";function Une(t){let{components:e,...n}=t;return(0,s.kt)(One,(0,p.Z)({},Ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Une.isMDXComponent=!0;const Fne={toc:[]},Vne="wrapper";function qne(t){let{components:e,...n}=t;return(0,s.kt)(Vne,(0,p.Z)({},Fne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qne.isMDXComponent=!0;const jne={toc:[]},Hne="wrapper";function Yne(t){let{components:e,...n}=t;return(0,s.kt)(Hne,(0,p.Z)({},jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Yne.isMDXComponent=!0;const Qne={toc:[]},$ne="wrapper";function Kne(t){let{components:e,...n}=t;return(0,s.kt)($ne,(0,p.Z)({},Qne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Kne.isMDXComponent=!0;const Jne={toc:[]},toe="wrapper";function eoe(t){let{components:e,...n}=t;return(0,s.kt)(toe,(0,p.Z)({},Jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}eoe.isMDXComponent=!0;const noe={toc:[]},ooe="wrapper";function poe(t){let{components:e,...n}=t;return(0,s.kt)(ooe,(0,p.Z)({},noe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}poe.isMDXComponent=!0;const roe={toc:[]},soe="wrapper";function coe(t){let{components:e,...n}=t;return(0,s.kt)(soe,(0,p.Z)({},roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}coe.isMDXComponent=!0;const aoe={toc:[]},ioe="wrapper";function loe(t){let{components:e,...n}=t;return(0,s.kt)(ioe,(0,p.Z)({},aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}loe.isMDXComponent=!0;const uoe={toc:[]},moe="wrapper";function doe(t){let{components:e,...n}=t;return(0,s.kt)(moe,(0,p.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}doe.isMDXComponent=!0;const hoe={toc:[]},foe="wrapper";function koe(t){let{components:e,...n}=t;return(0,s.kt)(foe,(0,p.Z)({},hoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}koe.isMDXComponent=!0;const yoe={toc:[]},Doe="wrapper";function Moe(t){let{components:e,...n}=t;return(0,s.kt)(Doe,(0,p.Z)({},yoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Moe.isMDXComponent=!0;const Xoe={toc:[]},_oe="wrapper";function woe(t){let{components:e,...n}=t;return(0,s.kt)(_oe,(0,p.Z)({},Xoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}woe.isMDXComponent=!0;const Toe={toc:[]},Coe="wrapper";function goe(t){let{components:e,...n}=t;return(0,s.kt)(Coe,(0,p.Z)({},Toe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}goe.isMDXComponent=!0;const xoe={toc:[]},voe="wrapper";function Loe(t){let{components:e,...n}=t;return(0,s.kt)(voe,(0,p.Z)({},xoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Loe.isMDXComponent=!0;const Zoe={toc:[]},boe="wrapper";function Noe(t){let{components:e,...n}=t;return(0,s.kt)(boe,(0,p.Z)({},Zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Noe.isMDXComponent=!0;const zoe={toc:[]},Aoe="wrapper";function Poe(t){let{components:e,...n}=t;return(0,s.kt)(Aoe,(0,p.Z)({},zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Poe.isMDXComponent=!0;const Ioe={toc:[]},Woe="wrapper";function Roe(t){let{components:e,...n}=t;return(0,s.kt)(Woe,(0,p.Z)({},Ioe,n,{components:e,mdxType:"MDXLayout"}))}Roe.isMDXComponent=!0;const Soe={toc:[]},Boe="wrapper";function Goe(t){let{components:e,...n}=t;return(0,s.kt)(Boe,(0,p.Z)({},Soe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Goe.isMDXComponent=!0;const Eoe={toc:[]},Ooe="wrapper";function Uoe(t){let{components:e,...n}=t;return(0,s.kt)(Ooe,(0,p.Z)({},Eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Uoe.isMDXComponent=!0;const Foe={toc:[]},Voe="wrapper";function qoe(t){let{components:e,...n}=t;return(0,s.kt)(Voe,(0,p.Z)({},Foe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}qoe.isMDXComponent=!0;const joe={toc:[]},Hoe="wrapper";function Yoe(t){let{components:e,...n}=t;return(0,s.kt)(Hoe,(0,p.Z)({},joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Yoe.isMDXComponent=!0;const Qoe={toc:[]},$oe="wrapper";function Koe(t){let{components:e,...n}=t;return(0,s.kt)($oe,(0,p.Z)({},Qoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Koe.isMDXComponent=!0;const Joe={toc:[]},tpe="wrapper";function epe(t){let{components:e,...n}=t;return(0,s.kt)(tpe,(0,p.Z)({},Joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}epe.isMDXComponent=!0;const npe={toc:[]},ope="wrapper";function ppe(t){let{components:e,...n}=t;return(0,s.kt)(ope,(0,p.Z)({},npe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}ppe.isMDXComponent=!0;const rpe={toc:[]},spe="wrapper";function cpe(t){let{components:e,...n}=t;return(0,s.kt)(spe,(0,p.Z)({},rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}cpe.isMDXComponent=!0;const ape={toc:[]},ipe="wrapper";function lpe(t){let{components:e,...n}=t;return(0,s.kt)(ipe,(0,p.Z)({},ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}lpe.isMDXComponent=!0;const upe={toc:[]},mpe="wrapper";function dpe(t){let{components:e,...n}=t;return(0,s.kt)(mpe,(0,p.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}dpe.isMDXComponent=!0;const hpe={toc:[]},fpe="wrapper";function kpe(t){let{components:e,...n}=t;return(0,s.kt)(fpe,(0,p.Z)({},hpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}kpe.isMDXComponent=!0;const ype={toc:[]},Dpe="wrapper";function Mpe(t){let{components:e,...n}=t;return(0,s.kt)(Dpe,(0,p.Z)({},ype,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Mpe.isMDXComponent=!0;const Xpe={toc:[]},_pe="wrapper";function wpe(t){let{components:e,...n}=t;return(0,s.kt)(_pe,(0,p.Z)({},Xpe,n,{components:e,mdxType:"MDXLayout"}))}wpe.isMDXComponent=!0;const Tpe={toc:[]},Cpe="wrapper";function gpe(t){let{components:e,...n}=t;return(0,s.kt)(Cpe,(0,p.Z)({},Tpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}gpe.isMDXComponent=!0;const xpe={toc:[]},vpe="wrapper";function Lpe(t){let{components:e,...n}=t;return(0,s.kt)(vpe,(0,p.Z)({},xpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Lpe.isMDXComponent=!0;const Zpe={toc:[]},bpe="wrapper";function Npe(t){let{components:e,...n}=t;return(0,s.kt)(bpe,(0,p.Z)({},Zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Npe.isMDXComponent=!0;const zpe={toc:[]},Ape="wrapper";function Ppe(t){let{components:e,...n}=t;return(0,s.kt)(Ape,(0,p.Z)({},zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Ppe.isMDXComponent=!0;const Ipe={toc:[]},Wpe="wrapper";function Rpe(t){let{components:e,...n}=t;return(0,s.kt)(Wpe,(0,p.Z)({},Ipe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Rpe.isMDXComponent=!0;const Spe={toc:[]},Bpe="wrapper";function Gpe(t){let{components:e,...n}=t;return(0,s.kt)(Bpe,(0,p.Z)({},Spe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Gpe.isMDXComponent=!0;const Epe={toc:[]},Ope="wrapper";function Upe(t){let{components:e,...n}=t;return(0,s.kt)(Ope,(0,p.Z)({},Epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Upe.isMDXComponent=!0;const Fpe={toc:[]},Vpe="wrapper";function qpe(t){let{components:e,...n}=t;return(0,s.kt)(Vpe,(0,p.Z)({},Fpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}qpe.isMDXComponent=!0;const jpe={toc:[]},Hpe="wrapper";function Ype(t){let{components:e,...n}=t;return(0,s.kt)(Hpe,(0,p.Z)({},jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ype.isMDXComponent=!0;const Qpe={toc:[]},$pe="wrapper";function Kpe(t){let{components:e,...n}=t;return(0,s.kt)($pe,(0,p.Z)({},Qpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]},tre="wrapper";function ere(t){let{components:e,...n}=t;return(0,s.kt)(tre,(0,p.Z)({},Jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}ere.isMDXComponent=!0;const nre={toc:[]},ore="wrapper";function pre(t){let{components:e,...n}=t;return(0,s.kt)(ore,(0,p.Z)({},nre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pre.isMDXComponent=!0;const rre={toc:[]},sre="wrapper";function cre(t){let{components:e,...n}=t;return(0,s.kt)(sre,(0,p.Z)({},rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}cre.isMDXComponent=!0;const are={toc:[]},ire="wrapper";function lre(t){let{components:e,...n}=t;return(0,s.kt)(ire,(0,p.Z)({},are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lre.isMDXComponent=!0;const ure={toc:[]},mre="wrapper";function dre(t){let{components:e,...n}=t;return(0,s.kt)(mre,(0,p.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}dre.isMDXComponent=!0;const hre={toc:[]},fre="wrapper";function kre(t){let{components:e,...n}=t;return(0,s.kt)(fre,(0,p.Z)({},hre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kre.isMDXComponent=!0;const yre={toc:[]},Dre="wrapper";function Mre(t){let{components:e,...n}=t;return(0,s.kt)(Dre,(0,p.Z)({},yre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Mre.isMDXComponent=!0;const Xre={toc:[]},_re="wrapper";function wre(t){let{components:e,...n}=t;return(0,s.kt)(_re,(0,p.Z)({},Xre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}wre.isMDXComponent=!0;const Tre={toc:[]},Cre="wrapper";function gre(t){let{components:e,...n}=t;return(0,s.kt)(Cre,(0,p.Z)({},Tre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}gre.isMDXComponent=!0;const xre={toc:[]},vre="wrapper";function Lre(t){let{components:e,...n}=t;return(0,s.kt)(vre,(0,p.Z)({},xre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Lre.isMDXComponent=!0;const Zre={toc:[]},bre="wrapper";function Nre(t){let{components:e,...n}=t;return(0,s.kt)(bre,(0,p.Z)({},Zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Nre.isMDXComponent=!0;const zre={toc:[]},Are="wrapper";function Pre(t){let{components:e,...n}=t;return(0,s.kt)(Are,(0,p.Z)({},zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Pre.isMDXComponent=!0;const Ire={toc:[]},Wre="wrapper";function Rre(t){let{components:e,...n}=t;return(0,s.kt)(Wre,(0,p.Z)({},Ire,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Rre.isMDXComponent=!0;const Sre={toc:[]},Bre="wrapper";function Gre(t){let{components:e,...n}=t;return(0,s.kt)(Bre,(0,p.Z)({},Sre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Gre.isMDXComponent=!0;const Ere={toc:[]},Ore="wrapper";function Ure(t){let{components:e,...n}=t;return(0,s.kt)(Ore,(0,p.Z)({},Ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Ure.isMDXComponent=!0;const Fre={toc:[]},Vre="wrapper";function qre(t){let{components:e,...n}=t;return(0,s.kt)(Vre,(0,p.Z)({},Fre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}qre.isMDXComponent=!0;const jre={toc:[]},Hre="wrapper";function Yre(t){let{components:e,...n}=t;return(0,s.kt)(Hre,(0,p.Z)({},jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Yre.isMDXComponent=!0;const Qre={toc:[]},$re="wrapper";function Kre(t){let{components:e,...n}=t;return(0,s.kt)($re,(0,p.Z)({},Qre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Kre.isMDXComponent=!0;const Jre={toc:[]},tse="wrapper";function ese(t){let{components:e,...n}=t;return(0,s.kt)(tse,(0,p.Z)({},Jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ese.isMDXComponent=!0;const nse={toc:[]},ose="wrapper";function pse(t){let{components:e,...n}=t;return(0,s.kt)(ose,(0,p.Z)({},nse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pse.isMDXComponent=!0;const rse={toc:[]},sse="wrapper";function cse(t){let{components:e,...n}=t;return(0,s.kt)(sse,(0,p.Z)({},rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}cse.isMDXComponent=!0;const ase={toc:[]},ise="wrapper";function lse(t){let{components:e,...n}=t;return(0,s.kt)(ise,(0,p.Z)({},ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}lse.isMDXComponent=!0;const use={toc:[]},mse="wrapper";function dse(t){let{components:e,...n}=t;return(0,s.kt)(mse,(0,p.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}dse.isMDXComponent=!0;const hse={toc:[]},fse="wrapper";function kse(t){let{components:e,...n}=t;return(0,s.kt)(fse,(0,p.Z)({},hse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}kse.isMDXComponent=!0;const yse={toc:[]},Dse="wrapper";function Mse(t){let{components:e,...n}=t;return(0,s.kt)(Dse,(0,p.Z)({},yse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Mse.isMDXComponent=!0;const Xse={toc:[]},_se="wrapper";function wse(t){let{components:e,...n}=t;return(0,s.kt)(_se,(0,p.Z)({},Xse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wse.isMDXComponent=!0;const Tse={toc:[]},Cse="wrapper";function gse(t){let{components:e,...n}=t;return(0,s.kt)(Cse,(0,p.Z)({},Tse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gse.isMDXComponent=!0;const xse={toc:[]},vse="wrapper";function Lse(t){let{components:e,...n}=t;return(0,s.kt)(vse,(0,p.Z)({},xse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Lse.isMDXComponent=!0;const Zse={toc:[]},bse="wrapper";function Nse(t){let{components:e,...n}=t;return(0,s.kt)(bse,(0,p.Z)({},Zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Nse.isMDXComponent=!0;const zse={toc:[]},Ase="wrapper";function Pse(t){let{components:e,...n}=t;return(0,s.kt)(Ase,(0,p.Z)({},zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Pse.isMDXComponent=!0;const Ise={toc:[]},Wse="wrapper";function Rse(t){let{components:e,...n}=t;return(0,s.kt)(Wse,(0,p.Z)({},Ise,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Rse.isMDXComponent=!0;const Sse={toc:[]},Bse="wrapper";function Gse(t){let{components:e,...n}=t;return(0,s.kt)(Bse,(0,p.Z)({},Sse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Gse.isMDXComponent=!0;const Ese={toc:[]},Ose="wrapper";function Use(t){let{components:e,...n}=t;return(0,s.kt)(Ose,(0,p.Z)({},Ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Use.isMDXComponent=!0;const Fse={toc:[]},Vse="wrapper";function qse(t){let{components:e,...n}=t;return(0,s.kt)(Vse,(0,p.Z)({},Fse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}qse.isMDXComponent=!0;const jse={toc:[]},Hse="wrapper";function Yse(t){let{components:e,...n}=t;return(0,s.kt)(Hse,(0,p.Z)({},jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Yse.isMDXComponent=!0;const Qse={toc:[]},$se="wrapper";function Kse(t){let{components:e,...n}=t;return(0,s.kt)($se,(0,p.Z)({},Qse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Kse.isMDXComponent=!0;const Jse={toc:[]},tce="wrapper";function ece(t){let{components:e,...n}=t;return(0,s.kt)(tce,(0,p.Z)({},Jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}ece.isMDXComponent=!0;const nce={toc:[]},oce="wrapper";function pce(t){let{components:e,...n}=t;return(0,s.kt)(oce,(0,p.Z)({},nce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}pce.isMDXComponent=!0;const rce={toc:[]},sce="wrapper";function cce(t){let{components:e,...n}=t;return(0,s.kt)(sce,(0,p.Z)({},rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}cce.isMDXComponent=!0;const ace={toc:[]},ice="wrapper";function lce(t){let{components:e,...n}=t;return(0,s.kt)(ice,(0,p.Z)({},ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}lce.isMDXComponent=!0;const uce={toc:[]},mce="wrapper";function dce(t){let{components:e,...n}=t;return(0,s.kt)(mce,(0,p.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}dce.isMDXComponent=!0;const hce={toc:[]},fce="wrapper";function kce(t){let{components:e,...n}=t;return(0,s.kt)(fce,(0,p.Z)({},hce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kce.isMDXComponent=!0;const yce={toc:[]},Dce="wrapper";function Mce(t){let{components:e,...n}=t;return(0,s.kt)(Dce,(0,p.Z)({},yce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Mce.isMDXComponent=!0;const Xce={toc:[]},_ce="wrapper";function wce(t){let{components:e,...n}=t;return(0,s.kt)(_ce,(0,p.Z)({},Xce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}wce.isMDXComponent=!0;const Tce={toc:[]},Cce="wrapper";function gce(t){let{components:e,...n}=t;return(0,s.kt)(Cce,(0,p.Z)({},Tce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}gce.isMDXComponent=!0;const xce={toc:[]},vce="wrapper";function Lce(t){let{components:e,...n}=t;return(0,s.kt)(vce,(0,p.Z)({},xce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Lce.isMDXComponent=!0;const Zce={toc:[]},bce="wrapper";function Nce(t){let{components:e,...n}=t;return(0,s.kt)(bce,(0,p.Z)({},Zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Nce.isMDXComponent=!0;const zce={toc:[]},Ace="wrapper";function Pce(t){let{components:e,...n}=t;return(0,s.kt)(Ace,(0,p.Z)({},zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pce.isMDXComponent=!0;const Ice={toc:[]},Wce="wrapper";function Rce(t){let{components:e,...n}=t;return(0,s.kt)(Wce,(0,p.Z)({},Ice,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Rce.isMDXComponent=!0;const Sce={toc:[]},Bce="wrapper";function Gce(t){let{components:e,...n}=t;return(0,s.kt)(Bce,(0,p.Z)({},Sce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gce.isMDXComponent=!0;const Ece={toc:[]},Oce="wrapper";function Uce(t){let{components:e,...n}=t;return(0,s.kt)(Oce,(0,p.Z)({},Ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Uce.isMDXComponent=!0;const Fce={toc:[]},Vce="wrapper";function qce(t){let{components:e,...n}=t;return(0,s.kt)(Vce,(0,p.Z)({},Fce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qce.isMDXComponent=!0;const jce={toc:[]},Hce="wrapper";function Yce(t){let{components:e,...n}=t;return(0,s.kt)(Hce,(0,p.Z)({},jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Yce.isMDXComponent=!0;const Qce={toc:[]},$ce="wrapper";function Kce(t){let{components:e,...n}=t;return(0,s.kt)($ce,(0,p.Z)({},Qce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kce.isMDXComponent=!0;const Jce={toc:[]},tae="wrapper";function eae(t){let{components:e,...n}=t;return(0,s.kt)(tae,(0,p.Z)({},Jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}eae.isMDXComponent=!0;const nae={toc:[]},oae="wrapper";function pae(t){let{components:e,...n}=t;return(0,s.kt)(oae,(0,p.Z)({},nae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pae.isMDXComponent=!0;const rae={toc:[]},sae="wrapper";function cae(t){let{components:e,...n}=t;return(0,s.kt)(sae,(0,p.Z)({},rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}cae.isMDXComponent=!0;const aae={toc:[]},iae="wrapper";function lae(t){let{components:e,...n}=t;return(0,s.kt)(iae,(0,p.Z)({},aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lae.isMDXComponent=!0;const uae={toc:[]},mae="wrapper";function dae(t){let{components:e,...n}=t;return(0,s.kt)(mae,(0,p.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dae.isMDXComponent=!0;const hae={toc:[]},fae="wrapper";function kae(t){let{components:e,...n}=t;return(0,s.kt)(fae,(0,p.Z)({},hae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kae.isMDXComponent=!0;const yae={toc:[]},Dae="wrapper";function Mae(t){let{components:e,...n}=t;return(0,s.kt)(Dae,(0,p.Z)({},yae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mae.isMDXComponent=!0;const Xae={toc:[]},_ae="wrapper";function wae(t){let{components:e,...n}=t;return(0,s.kt)(_ae,(0,p.Z)({},Xae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wae.isMDXComponent=!0;const Tae={toc:[]},Cae="wrapper";function gae(t){let{components:e,...n}=t;return(0,s.kt)(Cae,(0,p.Z)({},Tae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}gae.isMDXComponent=!0;const xae={toc:[]},vae="wrapper";function Lae(t){let{components:e,...n}=t;return(0,s.kt)(vae,(0,p.Z)({},xae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lae.isMDXComponent=!0;const Zae={toc:[]},bae="wrapper";function Nae(t){let{components:e,...n}=t;return(0,s.kt)(bae,(0,p.Z)({},Zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Nae.isMDXComponent=!0;const zae={toc:[]},Aae="wrapper";function Pae(t){let{components:e,...n}=t;return(0,s.kt)(Aae,(0,p.Z)({},zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Pae.isMDXComponent=!0;const Iae={toc:[]},Wae="wrapper";function Rae(t){let{components:e,...n}=t;return(0,s.kt)(Wae,(0,p.Z)({},Iae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Rae.isMDXComponent=!0;const Sae={toc:[]},Bae="wrapper";function Gae(t){let{components:e,...n}=t;return(0,s.kt)(Bae,(0,p.Z)({},Sae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Gae.isMDXComponent=!0;const Eae={toc:[]},Oae="wrapper";function Uae(t){let{components:e,...n}=t;return(0,s.kt)(Oae,(0,p.Z)({},Eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}Uae.isMDXComponent=!0;const Fae={toc:[]},Vae="wrapper";function qae(t){let{components:e,...n}=t;return(0,s.kt)(Vae,(0,p.Z)({},Fae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}qae.isMDXComponent=!0;const jae={toc:[]},Hae="wrapper";function Yae(t){let{components:e,...n}=t;return(0,s.kt)(Hae,(0,p.Z)({},jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}Yae.isMDXComponent=!0;const Qae={toc:[]},$ae="wrapper";function Kae(t){let{components:e,...n}=t;return(0,s.kt)($ae,(0,p.Z)({},Qae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Kae.isMDXComponent=!0;const Jae={toc:[]},tie="wrapper";function eie(t){let{components:e,...n}=t;return(0,s.kt)(tie,(0,p.Z)({},Jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}eie.isMDXComponent=!0;const nie={toc:[]},oie="wrapper";function pie(t){let{components:e,...n}=t;return(0,s.kt)(oie,(0,p.Z)({},nie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}pie.isMDXComponent=!0;const rie={toc:[]},sie="wrapper";function cie(t){let{components:e,...n}=t;return(0,s.kt)(sie,(0,p.Z)({},rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}cie.isMDXComponent=!0;const aie={toc:[]},iie="wrapper";function lie(t){let{components:e,...n}=t;return(0,s.kt)(iie,(0,p.Z)({},aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lie.isMDXComponent=!0;const uie={toc:[]},mie="wrapper";function die(t){let{components:e,...n}=t;return(0,s.kt)(mie,(0,p.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}die.isMDXComponent=!0;const hie={toc:[]},fie="wrapper";function kie(t){let{components:e,...n}=t;return(0,s.kt)(fie,(0,p.Z)({},hie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}kie.isMDXComponent=!0;const yie={toc:[]},Die="wrapper";function Mie(t){let{components:e,...n}=t;return(0,s.kt)(Die,(0,p.Z)({},yie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Mie.isMDXComponent=!0;const Xie={toc:[]},_ie="wrapper";function wie(t){let{components:e,...n}=t;return(0,s.kt)(_ie,(0,p.Z)({},Xie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}wie.isMDXComponent=!0;const Tie={toc:[]},Cie="wrapper";function gie(t){let{components:e,...n}=t;return(0,s.kt)(Cie,(0,p.Z)({},Tie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}gie.isMDXComponent=!0;const xie={toc:[]},vie="wrapper";function Lie(t){let{components:e,...n}=t;return(0,s.kt)(vie,(0,p.Z)({},xie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Lie.isMDXComponent=!0;const Zie={toc:[]},bie="wrapper";function Nie(t){let{components:e,...n}=t;return(0,s.kt)(bie,(0,p.Z)({},Zie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Nie.isMDXComponent=!0;const zie={toc:[]},Aie="wrapper";function Pie(t){let{components:e,...n}=t;return(0,s.kt)(Aie,(0,p.Z)({},zie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Pie.isMDXComponent=!0;const Iie={toc:[]},Wie="wrapper";function Rie(t){let{components:e,...n}=t;return(0,s.kt)(Wie,(0,p.Z)({},Iie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Rie.isMDXComponent=!0;const Sie={toc:[]},Bie="wrapper";function Gie(t){let{components:e,...n}=t;return(0,s.kt)(Bie,(0,p.Z)({},Sie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Gie.isMDXComponent=!0;const Eie={toc:[]},Oie="wrapper";function Uie(t){let{components:e,...n}=t;return(0,s.kt)(Oie,(0,p.Z)({},Eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Uie.isMDXComponent=!0;const Fie={toc:[]},Vie="wrapper";function qie(t){let{components:e,...n}=t;return(0,s.kt)(Vie,(0,p.Z)({},Fie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}qie.isMDXComponent=!0;const jie={toc:[]},Hie="wrapper";function Yie(t){let{components:e,...n}=t;return(0,s.kt)(Hie,(0,p.Z)({},jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Yie.isMDXComponent=!0;const Qie={toc:[]},$ie="wrapper";function Kie(t){let{components:e,...n}=t;return(0,s.kt)($ie,(0,p.Z)({},Qie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Kie.isMDXComponent=!0;const Jie={toc:[]},tle="wrapper";function ele(t){let{components:e,...n}=t;return(0,s.kt)(tle,(0,p.Z)({},Jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}ele.isMDXComponent=!0;const nle={toc:[]},ole="wrapper";function ple(t){let{components:e,...n}=t;return(0,s.kt)(ole,(0,p.Z)({},nle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ple.isMDXComponent=!0;const rle={toc:[]},sle="wrapper";function cle(t){let{components:e,...n}=t;return(0,s.kt)(sle,(0,p.Z)({},rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cle.isMDXComponent=!0;const ale={toc:[]},ile="wrapper";function lle(t){let{components:e,...n}=t;return(0,s.kt)(ile,(0,p.Z)({},ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lle.isMDXComponent=!0;const ule={toc:[]},mle="wrapper";function dle(t){let{components:e,...n}=t;return(0,s.kt)(mle,(0,p.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}dle.isMDXComponent=!0;const hle={toc:[]},fle="wrapper";function kle(t){let{components:e,...n}=t;return(0,s.kt)(fle,(0,p.Z)({},hle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kle.isMDXComponent=!0;const yle={toc:[]},Dle="wrapper";function Mle(t){let{components:e,...n}=t;return(0,s.kt)(Dle,(0,p.Z)({},yle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Mle.isMDXComponent=!0;const Xle={toc:[]},_le="wrapper";function wle(t){let{components:e,...n}=t;return(0,s.kt)(_le,(0,p.Z)({},Xle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wle.isMDXComponent=!0;const Tle={toc:[]},Cle="wrapper";function gle(t){let{components:e,...n}=t;return(0,s.kt)(Cle,(0,p.Z)({},Tle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gle.isMDXComponent=!0;const xle={toc:[]},vle="wrapper";function Lle(t){let{components:e,...n}=t;return(0,s.kt)(vle,(0,p.Z)({},xle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Lle.isMDXComponent=!0;const Zle={toc:[]},ble="wrapper";function Nle(t){let{components:e,...n}=t;return(0,s.kt)(ble,(0,p.Z)({},Zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Nle.isMDXComponent=!0;const zle={toc:[]},Ale="wrapper";function Ple(t){let{components:e,...n}=t;return(0,s.kt)(Ale,(0,p.Z)({},zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ple.isMDXComponent=!0;const Ile={toc:[]},Wle="wrapper";function Rle(t){let{components:e,...n}=t;return(0,s.kt)(Wle,(0,p.Z)({},Ile,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Rle.isMDXComponent=!0;const Sle={toc:[]},Ble="wrapper";function Gle(t){let{components:e,...n}=t;return(0,s.kt)(Ble,(0,p.Z)({},Sle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Gle.isMDXComponent=!0;const Ele={toc:[]},Ole="wrapper";function Ule(t){let{components:e,...n}=t;return(0,s.kt)(Ole,(0,p.Z)({},Ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Ule.isMDXComponent=!0;const Fle={toc:[]},Vle="wrapper";function qle(t){let{components:e,...n}=t;return(0,s.kt)(Vle,(0,p.Z)({},Fle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}qle.isMDXComponent=!0;const jle={toc:[]},Hle="wrapper";function Yle(t){let{components:e,...n}=t;return(0,s.kt)(Hle,(0,p.Z)({},jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Yle.isMDXComponent=!0;const Qle={toc:[]},$le="wrapper";function Kle(t){let{components:e,...n}=t;return(0,s.kt)($le,(0,p.Z)({},Qle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Kle.isMDXComponent=!0;const Jle={toc:[]},tue="wrapper";function eue(t){let{components:e,...n}=t;return(0,s.kt)(tue,(0,p.Z)({},Jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}eue.isMDXComponent=!0;const nue={toc:[]},oue="wrapper";function pue(t){let{components:e,...n}=t;return(0,s.kt)(oue,(0,p.Z)({},nue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}pue.isMDXComponent=!0;const rue={toc:[]},sue="wrapper";function cue(t){let{components:e,...n}=t;return(0,s.kt)(sue,(0,p.Z)({},rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}cue.isMDXComponent=!0;const aue={toc:[]},iue="wrapper";function lue(t){let{components:e,...n}=t;return(0,s.kt)(iue,(0,p.Z)({},aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}lue.isMDXComponent=!0;const uue={toc:[]},mue="wrapper";function due(t){let{components:e,...n}=t;return(0,s.kt)(mue,(0,p.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}due.isMDXComponent=!0;const hue={toc:[]},fue="wrapper";function kue(t){let{components:e,...n}=t;return(0,s.kt)(fue,(0,p.Z)({},hue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}kue.isMDXComponent=!0;const yue={toc:[]},Due="wrapper";function Mue(t){let{components:e,...n}=t;return(0,s.kt)(Due,(0,p.Z)({},yue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Mue.isMDXComponent=!0;const Xue={toc:[]},_ue="wrapper";function wue(t){let{components:e,...n}=t;return(0,s.kt)(_ue,(0,p.Z)({},Xue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}wue.isMDXComponent=!0;const Tue={toc:[]},Cue="wrapper";function gue(t){let{components:e,...n}=t;return(0,s.kt)(Cue,(0,p.Z)({},Tue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}gue.isMDXComponent=!0;const xue={toc:[]},vue="wrapper";function Lue(t){let{components:e,...n}=t;return(0,s.kt)(vue,(0,p.Z)({},xue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}Lue.isMDXComponent=!0;const Zue={toc:[]},bue="wrapper";function Nue(t){let{components:e,...n}=t;return(0,s.kt)(bue,(0,p.Z)({},Zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}Nue.isMDXComponent=!0;const zue={toc:[]},Aue="wrapper";function Pue(t){let{components:e,...n}=t;return(0,s.kt)(Aue,(0,p.Z)({},zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Pue.isMDXComponent=!0;const Iue={toc:[]},Wue="wrapper";function Rue(t){let{components:e,...n}=t;return(0,s.kt)(Wue,(0,p.Z)({},Iue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Rue.isMDXComponent=!0;const Sue={toc:[]},Bue="wrapper";function Gue(t){let{components:e,...n}=t;return(0,s.kt)(Bue,(0,p.Z)({},Sue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Gue.isMDXComponent=!0;const Eue={toc:[]},Oue="wrapper";function Uue(t){let{components:e,...n}=t;return(0,s.kt)(Oue,(0,p.Z)({},Eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}Uue.isMDXComponent=!0;const Fue={toc:[]},Vue="wrapper";function que(t){let{components:e,...n}=t;return(0,s.kt)(Vue,(0,p.Z)({},Fue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}que.isMDXComponent=!0;const jue={toc:[]},Hue="wrapper";function Yue(t){let{components:e,...n}=t;return(0,s.kt)(Hue,(0,p.Z)({},jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Yue.isMDXComponent=!0;const Que={toc:[]},$ue="wrapper";function Kue(t){let{components:e,...n}=t;return(0,s.kt)($ue,(0,p.Z)({},Que,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Kue.isMDXComponent=!0;const Jue={toc:[]},tme="wrapper";function eme(t){let{components:e,...n}=t;return(0,s.kt)(tme,(0,p.Z)({},Jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}eme.isMDXComponent=!0;const nme={toc:[]},ome="wrapper";function pme(t){let{components:e,...n}=t;return(0,s.kt)(ome,(0,p.Z)({},nme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pme.isMDXComponent=!0;const rme={toc:[]},sme="wrapper";function cme(t){let{components:e,...n}=t;return(0,s.kt)(sme,(0,p.Z)({},rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cme.isMDXComponent=!0;const ame={toc:[]},ime="wrapper";function lme(t){let{components:e,...n}=t;return(0,s.kt)(ime,(0,p.Z)({},ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lme.isMDXComponent=!0;const ume={toc:[]},mme="wrapper";function dme(t){let{components:e,...n}=t;return(0,s.kt)(mme,(0,p.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dme.isMDXComponent=!0;const hme={toc:[]},fme="wrapper";function kme(t){let{components:e,...n}=t;return(0,s.kt)(fme,(0,p.Z)({},hme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kme.isMDXComponent=!0;const yme={toc:[]},Dme="wrapper";function Mme(t){let{components:e,...n}=t;return(0,s.kt)(Dme,(0,p.Z)({},yme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Mme.isMDXComponent=!0;const Xme={toc:[]},_me="wrapper";function wme(t){let{components:e,...n}=t;return(0,s.kt)(_me,(0,p.Z)({},Xme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wme.isMDXComponent=!0;const Tme={toc:[]},Cme="wrapper";function gme(t){let{components:e,...n}=t;return(0,s.kt)(Cme,(0,p.Z)({},Tme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gme.isMDXComponent=!0;const xme={toc:[]},vme="wrapper";function Lme(t){let{components:e,...n}=t;return(0,s.kt)(vme,(0,p.Z)({},xme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lme.isMDXComponent=!0;const Zme={toc:[]},bme="wrapper";function Nme(t){let{components:e,...n}=t;return(0,s.kt)(bme,(0,p.Z)({},Zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Nme.isMDXComponent=!0;const zme={toc:[]},Ame="wrapper";function Pme(t){let{components:e,...n}=t;return(0,s.kt)(Ame,(0,p.Z)({},zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Pme.isMDXComponent=!0;const Ime={toc:[]},Wme="wrapper";function Rme(t){let{components:e,...n}=t;return(0,s.kt)(Wme,(0,p.Z)({},Ime,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Rme.isMDXComponent=!0;const Sme={toc:[]},Bme="wrapper";function Gme(t){let{components:e,...n}=t;return(0,s.kt)(Bme,(0,p.Z)({},Sme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Gme.isMDXComponent=!0;const Eme={toc:[]},Ome="wrapper";function Ume(t){let{components:e,...n}=t;return(0,s.kt)(Ome,(0,p.Z)({},Eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Ume.isMDXComponent=!0;const Fme={toc:[]},Vme="wrapper";function qme(t){let{components:e,...n}=t;return(0,s.kt)(Vme,(0,p.Z)({},Fme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}qme.isMDXComponent=!0;const jme={toc:[]},Hme="wrapper";function Yme(t){let{components:e,...n}=t;return(0,s.kt)(Hme,(0,p.Z)({},jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Yme.isMDXComponent=!0;const Qme={toc:[]},$me="wrapper";function Kme(t){let{components:e,...n}=t;return(0,s.kt)($me,(0,p.Z)({},Qme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Kme.isMDXComponent=!0;const Jme={toc:[]},tde="wrapper";function ede(t){let{components:e,...n}=t;return(0,s.kt)(tde,(0,p.Z)({},Jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ede.isMDXComponent=!0;const nde={toc:[]},ode="wrapper";function pde(t){let{components:e,...n}=t;return(0,s.kt)(ode,(0,p.Z)({},nde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pde.isMDXComponent=!0;const rde={toc:[]},sde="wrapper";function cde(t){let{components:e,...n}=t;return(0,s.kt)(sde,(0,p.Z)({},rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cde.isMDXComponent=!0;const ade={toc:[]},ide="wrapper";function lde(t){let{components:e,...n}=t;return(0,s.kt)(ide,(0,p.Z)({},ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lde.isMDXComponent=!0;const ude={toc:[]},mde="wrapper";function dde(t){let{components:e,...n}=t;return(0,s.kt)(mde,(0,p.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dde.isMDXComponent=!0;const hde={toc:[]},fde="wrapper";function kde(t){let{components:e,...n}=t;return(0,s.kt)(fde,(0,p.Z)({},hde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}kde.isMDXComponent=!0;const yde={toc:[]},Dde="wrapper";function Mde(t){let{components:e,...n}=t;return(0,s.kt)(Dde,(0,p.Z)({},yde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Mde.isMDXComponent=!0;const Xde={toc:[]},_de="wrapper";function wde(t){let{components:e,...n}=t;return(0,s.kt)(_de,(0,p.Z)({},Xde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wde.isMDXComponent=!0;const Tde={toc:[]},Cde="wrapper";function gde(t){let{components:e,...n}=t;return(0,s.kt)(Cde,(0,p.Z)({},Tde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}gde.isMDXComponent=!0;const xde={toc:[]},vde="wrapper";function Lde(t){let{components:e,...n}=t;return(0,s.kt)(vde,(0,p.Z)({},xde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Lde.isMDXComponent=!0;const Zde={toc:[]},bde="wrapper";function Nde(t){let{components:e,...n}=t;return(0,s.kt)(bde,(0,p.Z)({},Zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Nde.isMDXComponent=!0;const zde={toc:[]},Ade="wrapper";function Pde(t){let{components:e,...n}=t;return(0,s.kt)(Ade,(0,p.Z)({},zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}Pde.isMDXComponent=!0;const Ide={toc:[]},Wde="wrapper";function Rde(t){let{components:e,...n}=t;return(0,s.kt)(Wde,(0,p.Z)({},Ide,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Rde.isMDXComponent=!0;const Sde={toc:[]},Bde="wrapper";function Gde(t){let{components:e,...n}=t;return(0,s.kt)(Bde,(0,p.Z)({},Sde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Gde.isMDXComponent=!0;const Ede={toc:[]},Ode="wrapper";function Ude(t){let{components:e,...n}=t;return(0,s.kt)(Ode,(0,p.Z)({},Ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Ude.isMDXComponent=!0;const Fde={toc:[]},Vde="wrapper";function qde(t){let{components:e,...n}=t;return(0,s.kt)(Vde,(0,p.Z)({},Fde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}qde.isMDXComponent=!0;const jde={toc:[]},Hde="wrapper";function Yde(t){let{components:e,...n}=t;return(0,s.kt)(Hde,(0,p.Z)({},jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Yde.isMDXComponent=!0;const Qde={toc:[]},$de="wrapper";function Kde(t){let{components:e,...n}=t;return(0,s.kt)($de,(0,p.Z)({},Qde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Kde.isMDXComponent=!0;const Jde={toc:[]},the="wrapper";function ehe(t){let{components:e,...n}=t;return(0,s.kt)(the,(0,p.Z)({},Jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}ehe.isMDXComponent=!0;const nhe={toc:[]},ohe="wrapper";function phe(t){let{components:e,...n}=t;return(0,s.kt)(ohe,(0,p.Z)({},nhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}phe.isMDXComponent=!0;const rhe={toc:[]},she="wrapper";function che(t){let{components:e,...n}=t;return(0,s.kt)(she,(0,p.Z)({},rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}che.isMDXComponent=!0;const ahe={toc:[]},ihe="wrapper";function lhe(t){let{components:e,...n}=t;return(0,s.kt)(ihe,(0,p.Z)({},ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lhe.isMDXComponent=!0;const uhe={toc:[]},mhe="wrapper";function dhe(t){let{components:e,...n}=t;return(0,s.kt)(mhe,(0,p.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}dhe.isMDXComponent=!0;const hhe={toc:[]},fhe="wrapper";function khe(t){let{components:e,...n}=t;return(0,s.kt)(fhe,(0,p.Z)({},hhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}khe.isMDXComponent=!0;const yhe={toc:[]},Dhe="wrapper";function Mhe(t){let{components:e,...n}=t;return(0,s.kt)(Dhe,(0,p.Z)({},yhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Mhe.isMDXComponent=!0;const Xhe={toc:[]},_he="wrapper";function whe(t){let{components:e,...n}=t;return(0,s.kt)(_he,(0,p.Z)({},Xhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}whe.isMDXComponent=!0;const The={toc:[]},Che="wrapper";function ghe(t){let{components:e,...n}=t;return(0,s.kt)(Che,(0,p.Z)({},The,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ghe.isMDXComponent=!0;const xhe={toc:[]},vhe="wrapper";function Lhe(t){let{components:e,...n}=t;return(0,s.kt)(vhe,(0,p.Z)({},xhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Lhe.isMDXComponent=!0;const Zhe={toc:[]},bhe="wrapper";function Nhe(t){let{components:e,...n}=t;return(0,s.kt)(bhe,(0,p.Z)({},Zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Nhe.isMDXComponent=!0;const zhe={toc:[]},Ahe="wrapper";function Phe(t){let{components:e,...n}=t;return(0,s.kt)(Ahe,(0,p.Z)({},zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Phe.isMDXComponent=!0;const Ihe={toc:[]},Whe="wrapper";function Rhe(t){let{components:e,...n}=t;return(0,s.kt)(Whe,(0,p.Z)({},Ihe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d';\nimport {all, waitFor} from '@motion-canvas/core';\nimport {createRef} from '@motion-canvas/core';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}Rhe.isMDXComponent=!0;const She={toc:[]},Bhe="wrapper";function Ghe(t){let{components:e,...n}=t;return(0,s.kt)(Bhe,(0,p.Z)({},She,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}Ghe.isMDXComponent=!0;const Ehe={toc:[]},Ohe="wrapper";function Uhe(t){let{components:e,...n}=t;return(0,s.kt)(Ohe,(0,p.Z)({},Ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Uhe.isMDXComponent=!0;const Fhe={toc:[]},Vhe="wrapper";function qhe(t){let{components:e,...n}=t;return(0,s.kt)(Vhe,(0,p.Z)({},Fhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}qhe.isMDXComponent=!0;const jhe={toc:[]},Hhe="wrapper";function Yhe(t){let{components:e,...n}=t;return(0,s.kt)(Hhe,(0,p.Z)({},jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Yhe.isMDXComponent=!0;const Qhe={toc:[]},$he="wrapper";function Khe(t){let{components:e,...n}=t;return(0,s.kt)($he,(0,p.Z)({},Qhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Khe.isMDXComponent=!0;const Jhe={toc:[]},tfe="wrapper";function efe(t){let{components:e,...n}=t;return(0,s.kt)(tfe,(0,p.Z)({},Jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}efe.isMDXComponent=!0;const nfe={toc:[]},ofe="wrapper";function pfe(t){let{components:e,...n}=t;return(0,s.kt)(ofe,(0,p.Z)({},nfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}pfe.isMDXComponent=!0;const rfe={toc:[]},sfe="wrapper";function cfe(t){let{components:e,...n}=t;return(0,s.kt)(sfe,(0,p.Z)({},rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}cfe.isMDXComponent=!0;const afe={toc:[]},ife="wrapper";function lfe(t){let{components:e,...n}=t;return(0,s.kt)(ife,(0,p.Z)({},afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}lfe.isMDXComponent=!0;const ufe={toc:[]},mfe="wrapper";function dfe(t){let{components:e,...n}=t;return(0,s.kt)(mfe,(0,p.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}dfe.isMDXComponent=!0;const hfe={toc:[]},ffe="wrapper";function kfe(t){let{components:e,...n}=t;return(0,s.kt)(ffe,(0,p.Z)({},hfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}kfe.isMDXComponent=!0;const yfe={toc:[]},Dfe="wrapper";function Mfe(t){let{components:e,...n}=t;return(0,s.kt)(Dfe,(0,p.Z)({},yfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Mfe.isMDXComponent=!0;const Xfe={toc:[]},_fe="wrapper";function wfe(t){let{components:e,...n}=t;return(0,s.kt)(_fe,(0,p.Z)({},Xfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wfe.isMDXComponent=!0;const Tfe={toc:[]},Cfe="wrapper";function gfe(t){let{components:e,...n}=t;return(0,s.kt)(Cfe,(0,p.Z)({},Tfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}gfe.isMDXComponent=!0;const xfe={toc:[]},vfe="wrapper";function Lfe(t){let{components:e,...n}=t;return(0,s.kt)(vfe,(0,p.Z)({},xfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Lfe.isMDXComponent=!0;const Zfe={toc:[]},bfe="wrapper";function Nfe(t){let{components:e,...n}=t;return(0,s.kt)(bfe,(0,p.Z)({},Zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Nfe.isMDXComponent=!0;const zfe={toc:[]},Afe="wrapper";function Pfe(t){let{components:e,...n}=t;return(0,s.kt)(Afe,(0,p.Z)({},zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Pfe.isMDXComponent=!0;const Ife={toc:[]},Wfe="wrapper";function Rfe(t){let{components:e,...n}=t;return(0,s.kt)(Wfe,(0,p.Z)({},Ife,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Rfe.isMDXComponent=!0;const Sfe={toc:[]},Bfe="wrapper";function Gfe(t){let{components:e,...n}=t;return(0,s.kt)(Bfe,(0,p.Z)({},Sfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Gfe.isMDXComponent=!0;const Efe={toc:[]},Ofe="wrapper";function Ufe(t){let{components:e,...n}=t;return(0,s.kt)(Ofe,(0,p.Z)({},Efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Ufe.isMDXComponent=!0;const Ffe={toc:[]},Vfe="wrapper";function qfe(t){let{components:e,...n}=t;return(0,s.kt)(Vfe,(0,p.Z)({},Ffe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}qfe.isMDXComponent=!0;const jfe={toc:[]},Hfe="wrapper";function Yfe(t){let{components:e,...n}=t;return(0,s.kt)(Hfe,(0,p.Z)({},jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Yfe.isMDXComponent=!0;const Qfe={toc:[]},$fe="wrapper";function Kfe(t){let{components:e,...n}=t;return(0,s.kt)($fe,(0,p.Z)({},Qfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Kfe.isMDXComponent=!0;const Jfe={toc:[]},tke="wrapper";function eke(t){let{components:e,...n}=t;return(0,s.kt)(tke,(0,p.Z)({},Jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}eke.isMDXComponent=!0;const nke={toc:[]},oke="wrapper";function pke(t){let{components:e,...n}=t;return(0,s.kt)(oke,(0,p.Z)({},nke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pke.isMDXComponent=!0;const rke={toc:[]},ske="wrapper";function cke(t){let{components:e,...n}=t;return(0,s.kt)(ske,(0,p.Z)({},rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}cke.isMDXComponent=!0;const ake={toc:[]},ike="wrapper";function lke(t){let{components:e,...n}=t;return(0,s.kt)(ike,(0,p.Z)({},ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lke.isMDXComponent=!0;const uke={toc:[]},mke="wrapper";function dke(t){let{components:e,...n}=t;return(0,s.kt)(mke,(0,p.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}dke.isMDXComponent=!0;const hke={toc:[]},fke="wrapper";function kke(t){let{components:e,...n}=t;return(0,s.kt)(fke,(0,p.Z)({},hke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kke.isMDXComponent=!0;const yke={toc:[]},Dke="wrapper";function Mke(t){let{components:e,...n}=t;return(0,s.kt)(Dke,(0,p.Z)({},yke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Mke.isMDXComponent=!0;const Xke={toc:[]},_ke="wrapper";function wke(t){let{components:e,...n}=t;return(0,s.kt)(_ke,(0,p.Z)({},Xke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}wke.isMDXComponent=!0;const Tke={toc:[]},Cke="wrapper";function gke(t){let{components:e,...n}=t;return(0,s.kt)(Cke,(0,p.Z)({},Tke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}gke.isMDXComponent=!0;const xke={toc:[]},vke="wrapper";function Lke(t){let{components:e,...n}=t;return(0,s.kt)(vke,(0,p.Z)({},xke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Lke.isMDXComponent=!0;const Zke={toc:[]},bke="wrapper";function Nke(t){let{components:e,...n}=t;return(0,s.kt)(bke,(0,p.Z)({},Zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Nke.isMDXComponent=!0;const zke={toc:[]},Ake="wrapper";function Pke(t){let{components:e,...n}=t;return(0,s.kt)(Ake,(0,p.Z)({},zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Pke.isMDXComponent=!0;const Ike={toc:[]},Wke="wrapper";function Rke(t){let{components:e,...n}=t;return(0,s.kt)(Wke,(0,p.Z)({},Ike,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Rke.isMDXComponent=!0;const Ske={toc:[]},Bke="wrapper";function Gke(t){let{components:e,...n}=t;return(0,s.kt)(Bke,(0,p.Z)({},Ske,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Gke.isMDXComponent=!0;const Eke={toc:[]},Oke="wrapper";function Uke(t){let{components:e,...n}=t;return(0,s.kt)(Oke,(0,p.Z)({},Eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Uke.isMDXComponent=!0;const Fke={toc:[]},Vke="wrapper";function qke(t){let{components:e,...n}=t;return(0,s.kt)(Vke,(0,p.Z)({},Fke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}qke.isMDXComponent=!0;const jke={toc:[]},Hke="wrapper";function Yke(t){let{components:e,...n}=t;return(0,s.kt)(Hke,(0,p.Z)({},jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Yke.isMDXComponent=!0;const Qke={toc:[]},$ke="wrapper";function Kke(t){let{components:e,...n}=t;return(0,s.kt)($ke,(0,p.Z)({},Qke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Kke.isMDXComponent=!0;const Jke={toc:[]},tye="wrapper";function eye(t){let{components:e,...n}=t;return(0,s.kt)(tye,(0,p.Z)({},Jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}eye.isMDXComponent=!0;const nye={toc:[]},oye="wrapper";function pye(t){let{components:e,...n}=t;return(0,s.kt)(oye,(0,p.Z)({},nye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}pye.isMDXComponent=!0;const rye={toc:[]},sye="wrapper";function cye(t){let{components:e,...n}=t;return(0,s.kt)(sye,(0,p.Z)({},rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}cye.isMDXComponent=!0;const aye={toc:[]},iye="wrapper";function lye(t){let{components:e,...n}=t;return(0,s.kt)(iye,(0,p.Z)({},aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lye.isMDXComponent=!0;const uye={toc:[]},mye="wrapper";function dye(t){let{components:e,...n}=t;return(0,s.kt)(mye,(0,p.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}dye.isMDXComponent=!0;const hye={toc:[]},fye="wrapper";function kye(t){let{components:e,...n}=t;return(0,s.kt)(fye,(0,p.Z)({},hye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kye.isMDXComponent=!0;const yye={toc:[]},Dye="wrapper";function Mye(t){let{components:e,...n}=t;return(0,s.kt)(Dye,(0,p.Z)({},yye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Mye.isMDXComponent=!0;const Xye={toc:[]},_ye="wrapper";function wye(t){let{components:e,...n}=t;return(0,s.kt)(_ye,(0,p.Z)({},Xye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wye.isMDXComponent=!0;const Tye={toc:[]},Cye="wrapper";function gye(t){let{components:e,...n}=t;return(0,s.kt)(Cye,(0,p.Z)({},Tye,n,{components:e,mdxType:"MDXLayout"}))}gye.isMDXComponent=!0;const xye={toc:[]},vye="wrapper";function Lye(t){let{components:e,...n}=t;return(0,s.kt)(vye,(0,p.Z)({},xye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Lye.isMDXComponent=!0;const Zye={toc:[]},bye="wrapper";function Nye(t){let{components:e,...n}=t;return(0,s.kt)(bye,(0,p.Z)({},Zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Nye.isMDXComponent=!0;const zye={toc:[]},Aye="wrapper";function Pye(t){let{components:e,...n}=t;return(0,s.kt)(Aye,(0,p.Z)({},zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Pye.isMDXComponent=!0;const Iye={toc:[]},Wye="wrapper";function Rye(t){let{components:e,...n}=t;return(0,s.kt)(Wye,(0,p.Z)({},Iye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Rye.isMDXComponent=!0;const Sye={toc:[]},Bye="wrapper";function Gye(t){let{components:e,...n}=t;return(0,s.kt)(Bye,(0,p.Z)({},Sye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Gye.isMDXComponent=!0;const Eye={toc:[]},Oye="wrapper";function Uye(t){let{components:e,...n}=t;return(0,s.kt)(Oye,(0,p.Z)({},Eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Uye.isMDXComponent=!0;const Fye={toc:[]},Vye="wrapper";function qye(t){let{components:e,...n}=t;return(0,s.kt)(Vye,(0,p.Z)({},Fye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}qye.isMDXComponent=!0;const jye={toc:[]},Hye="wrapper";function Yye(t){let{components:e,...n}=t;return(0,s.kt)(Hye,(0,p.Z)({},jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Yye.isMDXComponent=!0;const Qye={toc:[]},$ye="wrapper";function Kye(t){let{components:e,...n}=t;return(0,s.kt)($ye,(0,p.Z)({},Qye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Kye.isMDXComponent=!0;const Jye={toc:[]},tDe="wrapper";function eDe(t){let{components:e,...n}=t;return(0,s.kt)(tDe,(0,p.Z)({},Jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}eDe.isMDXComponent=!0;const nDe={toc:[]},oDe="wrapper";function pDe(t){let{components:e,...n}=t;return(0,s.kt)(oDe,(0,p.Z)({},nDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}pDe.isMDXComponent=!0;const rDe={toc:[]},sDe="wrapper";function cDe(t){let{components:e,...n}=t;return(0,s.kt)(sDe,(0,p.Z)({},rDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}cDe.isMDXComponent=!0;const aDe={toc:[]},iDe="wrapper";function lDe(t){let{components:e,...n}=t;return(0,s.kt)(iDe,(0,p.Z)({},aDe,n,{components:e,mdxType:"MDXLayout"}))}lDe.isMDXComponent=!0;const uDe={toc:[]},mDe="wrapper";function dDe(t){let{components:e,...n}=t;return(0,s.kt)(mDe,(0,p.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}dDe.isMDXComponent=!0;const hDe={toc:[]},fDe="wrapper";function kDe(t){let{components:e,...n}=t;return(0,s.kt)(fDe,(0,p.Z)({},hDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}kDe.isMDXComponent=!0;const yDe={toc:[]},DDe="wrapper";function MDe(t){let{components:e,...n}=t;return(0,s.kt)(DDe,(0,p.Z)({},yDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MDe.isMDXComponent=!0;const XDe={toc:[]},_De="wrapper";function wDe(t){let{components:e,...n}=t;return(0,s.kt)(_De,(0,p.Z)({},XDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wDe.isMDXComponent=!0;const TDe={toc:[]},CDe="wrapper";function gDe(t){let{components:e,...n}=t;return(0,s.kt)(CDe,(0,p.Z)({},TDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gDe.isMDXComponent=!0;const xDe={toc:[]},vDe="wrapper";function LDe(t){let{components:e,...n}=t;return(0,s.kt)(vDe,(0,p.Z)({},xDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}LDe.isMDXComponent=!0;const ZDe={toc:[]},bDe="wrapper";function NDe(t){let{components:e,...n}=t;return(0,s.kt)(bDe,(0,p.Z)({},ZDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}NDe.isMDXComponent=!0;const zDe={toc:[]},ADe="wrapper";function PDe(t){let{components:e,...n}=t;return(0,s.kt)(ADe,(0,p.Z)({},zDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}PDe.isMDXComponent=!0;const IDe={toc:[]},WDe="wrapper";function RDe(t){let{components:e,...n}=t;return(0,s.kt)(WDe,(0,p.Z)({},IDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}RDe.isMDXComponent=!0;const SDe={toc:[]},BDe="wrapper";function GDe(t){let{components:e,...n}=t;return(0,s.kt)(BDe,(0,p.Z)({},SDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}GDe.isMDXComponent=!0;const EDe={toc:[]},ODe="wrapper";function UDe(t){let{components:e,...n}=t;return(0,s.kt)(ODe,(0,p.Z)({},EDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}UDe.isMDXComponent=!0;const FDe={toc:[]},VDe="wrapper";function qDe(t){let{components:e,...n}=t;return(0,s.kt)(VDe,(0,p.Z)({},FDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}qDe.isMDXComponent=!0;const jDe={toc:[]},HDe="wrapper";function YDe(t){let{components:e,...n}=t;return(0,s.kt)(HDe,(0,p.Z)({},jDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}YDe.isMDXComponent=!0;const QDe={toc:[]},$De="wrapper";function KDe(t){let{components:e,...n}=t;return(0,s.kt)($De,(0,p.Z)({},QDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}KDe.isMDXComponent=!0;const JDe={toc:[]},tMe="wrapper";function eMe(t){let{components:e,...n}=t;return(0,s.kt)(tMe,(0,p.Z)({},JDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}eMe.isMDXComponent=!0;const nMe={toc:[]},oMe="wrapper";function pMe(t){let{components:e,...n}=t;return(0,s.kt)(oMe,(0,p.Z)({},nMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}pMe.isMDXComponent=!0;const rMe={toc:[]},sMe="wrapper";function cMe(t){let{components:e,...n}=t;return(0,s.kt)(sMe,(0,p.Z)({},rMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}cMe.isMDXComponent=!0;const aMe={toc:[]},iMe="wrapper";function lMe(t){let{components:e,...n}=t;return(0,s.kt)(iMe,(0,p.Z)({},aMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}lMe.isMDXComponent=!0;const uMe={toc:[]},mMe="wrapper";function dMe(t){let{components:e,...n}=t;return(0,s.kt)(mMe,(0,p.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}dMe.isMDXComponent=!0;const hMe={toc:[]},fMe="wrapper";function kMe(t){let{components:e,...n}=t;return(0,s.kt)(fMe,(0,p.Z)({},hMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}kMe.isMDXComponent=!0;const yMe={toc:[]},DMe="wrapper";function MMe(t){let{components:e,...n}=t;return(0,s.kt)(DMe,(0,p.Z)({},yMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}MMe.isMDXComponent=!0;const XMe={toc:[]},_Me="wrapper";function wMe(t){let{components:e,...n}=t;return(0,s.kt)(_Me,(0,p.Z)({},XMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}wMe.isMDXComponent=!0;const TMe={toc:[]},CMe="wrapper";function gMe(t){let{components:e,...n}=t;return(0,s.kt)(CMe,(0,p.Z)({},TMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gMe.isMDXComponent=!0;const xMe={toc:[]},vMe="wrapper";function LMe(t){let{components:e,...n}=t;return(0,s.kt)(vMe,(0,p.Z)({},xMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}LMe.isMDXComponent=!0;const ZMe={toc:[]},bMe="wrapper";function NMe(t){let{components:e,...n}=t;return(0,s.kt)(bMe,(0,p.Z)({},ZMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}NMe.isMDXComponent=!0;const zMe={toc:[]},AMe="wrapper";function PMe(t){let{components:e,...n}=t;return(0,s.kt)(AMe,(0,p.Z)({},zMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}PMe.isMDXComponent=!0;const IMe={toc:[]},WMe="wrapper";function RMe(t){let{components:e,...n}=t;return(0,s.kt)(WMe,(0,p.Z)({},IMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}RMe.isMDXComponent=!0;const SMe={toc:[]},BMe="wrapper";function GMe(t){let{components:e,...n}=t;return(0,s.kt)(BMe,(0,p.Z)({},SMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}GMe.isMDXComponent=!0;const EMe={toc:[]},OMe="wrapper";function UMe(t){let{components:e,...n}=t;return(0,s.kt)(OMe,(0,p.Z)({},EMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}UMe.isMDXComponent=!0;const FMe={toc:[]},VMe="wrapper";function qMe(t){let{components:e,...n}=t;return(0,s.kt)(VMe,(0,p.Z)({},FMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qMe.isMDXComponent=!0;const jMe={toc:[]},HMe="wrapper";function YMe(t){let{components:e,...n}=t;return(0,s.kt)(HMe,(0,p.Z)({},jMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}YMe.isMDXComponent=!0;const QMe={toc:[]},$Me="wrapper";function KMe(t){let{components:e,...n}=t;return(0,s.kt)($Me,(0,p.Z)({},QMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}KMe.isMDXComponent=!0;const JMe={toc:[]},tXe="wrapper";function eXe(t){let{components:e,...n}=t;return(0,s.kt)(tXe,(0,p.Z)({},JMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}eXe.isMDXComponent=!0;const nXe={toc:[]},oXe="wrapper";function pXe(t){let{components:e,...n}=t;return(0,s.kt)(oXe,(0,p.Z)({},nXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}pXe.isMDXComponent=!0;const rXe={toc:[]},sXe="wrapper";function cXe(t){let{components:e,...n}=t;return(0,s.kt)(sXe,(0,p.Z)({},rXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}cXe.isMDXComponent=!0;const aXe={toc:[]},iXe="wrapper";function lXe(t){let{components:e,...n}=t;return(0,s.kt)(iXe,(0,p.Z)({},aXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lXe.isMDXComponent=!0;const uXe={toc:[]},mXe="wrapper";function dXe(t){let{components:e,...n}=t;return(0,s.kt)(mXe,(0,p.Z)({},uXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dXe.isMDXComponent=!0;const hXe={toc:[]},fXe="wrapper";function kXe(t){let{components:e,...n}=t;return(0,s.kt)(fXe,(0,p.Z)({},hXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}kXe.isMDXComponent=!0;const yXe={toc:[]},DXe="wrapper";function MXe(t){let{components:e,...n}=t;return(0,s.kt)(DXe,(0,p.Z)({},yXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}MXe.isMDXComponent=!0;const XXe={toc:[]},_Xe="wrapper";function wXe(t){let{components:e,...n}=t;return(0,s.kt)(_Xe,(0,p.Z)({},XXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}wXe.isMDXComponent=!0;const TXe={toc:[]},CXe="wrapper";function gXe(t){let{components:e,...n}=t;return(0,s.kt)(CXe,(0,p.Z)({},TXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}gXe.isMDXComponent=!0;const xXe={toc:[]},vXe="wrapper";function LXe(t){let{components:e,...n}=t;return(0,s.kt)(vXe,(0,p.Z)({},xXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}LXe.isMDXComponent=!0;const ZXe={toc:[]},bXe="wrapper";function NXe(t){let{components:e,...n}=t;return(0,s.kt)(bXe,(0,p.Z)({},ZXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}NXe.isMDXComponent=!0;const zXe={toc:[]},AXe="wrapper";function PXe(t){let{components:e,...n}=t;return(0,s.kt)(AXe,(0,p.Z)({},zXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}PXe.isMDXComponent=!0;const IXe={toc:[]},WXe="wrapper";function RXe(t){let{components:e,...n}=t;return(0,s.kt)(WXe,(0,p.Z)({},IXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}RXe.isMDXComponent=!0;const SXe={toc:[]},BXe="wrapper";function GXe(t){let{components:e,...n}=t;return(0,s.kt)(BXe,(0,p.Z)({},SXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}GXe.isMDXComponent=!0;const EXe={toc:[]},OXe="wrapper";function UXe(t){let{components:e,...n}=t;return(0,s.kt)(OXe,(0,p.Z)({},EXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}UXe.isMDXComponent=!0;const FXe={toc:[]},VXe="wrapper";function qXe(t){let{components:e,...n}=t;return(0,s.kt)(VXe,(0,p.Z)({},FXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}qXe.isMDXComponent=!0;const jXe={toc:[]},HXe="wrapper";function YXe(t){let{components:e,...n}=t;return(0,s.kt)(HXe,(0,p.Z)({},jXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}YXe.isMDXComponent=!0;const QXe={toc:[]},$Xe="wrapper";function KXe(t){let{components:e,...n}=t;return(0,s.kt)($Xe,(0,p.Z)({},QXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}KXe.isMDXComponent=!0;const JXe={toc:[]},t_e="wrapper";function e_e(t){let{components:e,...n}=t;return(0,s.kt)(t_e,(0,p.Z)({},JXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}e_e.isMDXComponent=!0;const n_e={toc:[]},o_e="wrapper";function p_e(t){let{components:e,...n}=t;return(0,s.kt)(o_e,(0,p.Z)({},n_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}p_e.isMDXComponent=!0;const r_e={toc:[]},s_e="wrapper";function c_e(t){let{components:e,...n}=t;return(0,s.kt)(s_e,(0,p.Z)({},r_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}c_e.isMDXComponent=!0;const a_e={toc:[]},i_e="wrapper";function l_e(t){let{components:e,...n}=t;return(0,s.kt)(i_e,(0,p.Z)({},a_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}l_e.isMDXComponent=!0;const u_e={toc:[]},m_e="wrapper";function d_e(t){let{components:e,...n}=t;return(0,s.kt)(m_e,(0,p.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}d_e.isMDXComponent=!0;const h_e={toc:[]},f_e="wrapper";function k_e(t){let{components:e,...n}=t;return(0,s.kt)(f_e,(0,p.Z)({},h_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}k_e.isMDXComponent=!0;const y_e={toc:[]},D_e="wrapper";function M_e(t){let{components:e,...n}=t;return(0,s.kt)(D_e,(0,p.Z)({},y_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}M_e.isMDXComponent=!0;const X_e={toc:[]},__e="wrapper";function w_e(t){let{components:e,...n}=t;return(0,s.kt)(__e,(0,p.Z)({},X_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}w_e.isMDXComponent=!0;const T_e={toc:[]},C_e="wrapper";function g_e(t){let{components:e,...n}=t;return(0,s.kt)(C_e,(0,p.Z)({},T_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}g_e.isMDXComponent=!0;const x_e={toc:[]},v_e="wrapper";function L_e(t){let{components:e,...n}=t;return(0,s.kt)(v_e,(0,p.Z)({},x_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}L_e.isMDXComponent=!0;const Z_e={toc:[]},b_e="wrapper";function N_e(t){let{components:e,...n}=t;return(0,s.kt)(b_e,(0,p.Z)({},Z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}N_e.isMDXComponent=!0;const z_e={toc:[]},A_e="wrapper";function P_e(t){let{components:e,...n}=t;return(0,s.kt)(A_e,(0,p.Z)({},z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}P_e.isMDXComponent=!0;const I_e={toc:[]},W_e="wrapper";function R_e(t){let{components:e,...n}=t;return(0,s.kt)(W_e,(0,p.Z)({},I_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}R_e.isMDXComponent=!0;const S_e={toc:[]},B_e="wrapper";function G_e(t){let{components:e,...n}=t;return(0,s.kt)(B_e,(0,p.Z)({},S_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}G_e.isMDXComponent=!0;const E_e={toc:[]},O_e="wrapper";function U_e(t){let{components:e,...n}=t;return(0,s.kt)(O_e,(0,p.Z)({},E_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}U_e.isMDXComponent=!0;const F_e={toc:[]},V_e="wrapper";function q_e(t){let{components:e,...n}=t;return(0,s.kt)(V_e,(0,p.Z)({},F_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}q_e.isMDXComponent=!0;const j_e={toc:[]},H_e="wrapper";function Y_e(t){let{components:e,...n}=t;return(0,s.kt)(H_e,(0,p.Z)({},j_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Y_e.isMDXComponent=!0;const Q_e={toc:[]},$_e="wrapper";function K_e(t){let{components:e,...n}=t;return(0,s.kt)($_e,(0,p.Z)({},Q_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}K_e.isMDXComponent=!0;const J_e={toc:[]},twe="wrapper";function ewe(t){let{components:e,...n}=t;return(0,s.kt)(twe,(0,p.Z)({},J_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}ewe.isMDXComponent=!0;const nwe={toc:[]},owe="wrapper";function pwe(t){let{components:e,...n}=t;return(0,s.kt)(owe,(0,p.Z)({},nwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pwe.isMDXComponent=!0;const rwe={toc:[]},swe="wrapper";function cwe(t){let{components:e,...n}=t;return(0,s.kt)(swe,(0,p.Z)({},rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cwe.isMDXComponent=!0;const awe={toc:[]},iwe="wrapper";function lwe(t){let{components:e,...n}=t;return(0,s.kt)(iwe,(0,p.Z)({},awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lwe.isMDXComponent=!0;const uwe={toc:[]},mwe="wrapper";function dwe(t){let{components:e,...n}=t;return(0,s.kt)(mwe,(0,p.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}dwe.isMDXComponent=!0;const hwe={toc:[]},fwe="wrapper";function kwe(t){let{components:e,...n}=t;return(0,s.kt)(fwe,(0,p.Z)({},hwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kwe.isMDXComponent=!0;const ywe={toc:[]},Dwe="wrapper";function Mwe(t){let{components:e,...n}=t;return(0,s.kt)(Dwe,(0,p.Z)({},ywe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mwe.isMDXComponent=!0;const Xwe={toc:[]},_we="wrapper";function wwe(t){let{components:e,...n}=t;return(0,s.kt)(_we,(0,p.Z)({},Xwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wwe.isMDXComponent=!0;const Twe={toc:[]},Cwe="wrapper";function gwe(t){let{components:e,...n}=t;return(0,s.kt)(Cwe,(0,p.Z)({},Twe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}gwe.isMDXComponent=!0;const xwe={toc:[]},vwe="wrapper";function Lwe(t){let{components:e,...n}=t;return(0,s.kt)(vwe,(0,p.Z)({},xwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Lwe.isMDXComponent=!0;const Zwe={toc:[]},bwe="wrapper";function Nwe(t){let{components:e,...n}=t;return(0,s.kt)(bwe,(0,p.Z)({},Zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}Nwe.isMDXComponent=!0;const zwe={toc:[]},Awe="wrapper";function Pwe(t){let{components:e,...n}=t;return(0,s.kt)(Awe,(0,p.Z)({},zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Pwe.isMDXComponent=!0;const Iwe={toc:[]},Wwe="wrapper";function Rwe(t){let{components:e,...n}=t;return(0,s.kt)(Wwe,(0,p.Z)({},Iwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Rwe.isMDXComponent=!0;const Swe={toc:[]},Bwe="wrapper";function Gwe(t){let{components:e,...n}=t;return(0,s.kt)(Bwe,(0,p.Z)({},Swe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Gwe.isMDXComponent=!0;const Ewe={toc:[]},Owe="wrapper";function Uwe(t){let{components:e,...n}=t;return(0,s.kt)(Owe,(0,p.Z)({},Ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Uwe.isMDXComponent=!0;const Fwe={toc:[]},Vwe="wrapper";function qwe(t){let{components:e,...n}=t;return(0,s.kt)(Vwe,(0,p.Z)({},Fwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}qwe.isMDXComponent=!0;const jwe={toc:[]},Hwe="wrapper";function Ywe(t){let{components:e,...n}=t;return(0,s.kt)(Hwe,(0,p.Z)({},jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Ywe.isMDXComponent=!0;const Qwe={toc:[]},$we="wrapper";function Kwe(t){let{components:e,...n}=t;return(0,s.kt)($we,(0,p.Z)({},Qwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]},tTe="wrapper";function eTe(t){let{components:e,...n}=t;return(0,s.kt)(tTe,(0,p.Z)({},Jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}eTe.isMDXComponent=!0;const nTe={toc:[]},oTe="wrapper";function pTe(t){let{components:e,...n}=t;return(0,s.kt)(oTe,(0,p.Z)({},nTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}pTe.isMDXComponent=!0;const rTe={toc:[]},sTe="wrapper";function cTe(t){let{components:e,...n}=t;return(0,s.kt)(sTe,(0,p.Z)({},rTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}cTe.isMDXComponent=!0;const aTe={toc:[]},iTe="wrapper";function lTe(t){let{components:e,...n}=t;return(0,s.kt)(iTe,(0,p.Z)({},aTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}lTe.isMDXComponent=!0;const uTe={toc:[]},mTe="wrapper";function dTe(t){let{components:e,...n}=t;return(0,s.kt)(mTe,(0,p.Z)({},uTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}dTe.isMDXComponent=!0;const hTe={toc:[]},fTe="wrapper";function kTe(t){let{components:e,...n}=t;return(0,s.kt)(fTe,(0,p.Z)({},hTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}kTe.isMDXComponent=!0;const yTe={toc:[]},DTe="wrapper";function MTe(t){let{components:e,...n}=t;return(0,s.kt)(DTe,(0,p.Z)({},yTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}MTe.isMDXComponent=!0;const XTe={toc:[]},_Te="wrapper";function wTe(t){let{components:e,...n}=t;return(0,s.kt)(_Te,(0,p.Z)({},XTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}wTe.isMDXComponent=!0;const TTe={toc:[]},CTe="wrapper";function gTe(t){let{components:e,...n}=t;return(0,s.kt)(CTe,(0,p.Z)({},TTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}gTe.isMDXComponent=!0;const xTe={toc:[]},vTe="wrapper";function LTe(t){let{components:e,...n}=t;return(0,s.kt)(vTe,(0,p.Z)({},xTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}LTe.isMDXComponent=!0;const ZTe={toc:[]},bTe="wrapper";function NTe(t){let{components:e,...n}=t;return(0,s.kt)(bTe,(0,p.Z)({},ZTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}NTe.isMDXComponent=!0;const zTe={toc:[]},ATe="wrapper";function PTe(t){let{components:e,...n}=t;return(0,s.kt)(ATe,(0,p.Z)({},zTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}PTe.isMDXComponent=!0;const ITe={toc:[]},WTe="wrapper";function RTe(t){let{components:e,...n}=t;return(0,s.kt)(WTe,(0,p.Z)({},ITe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}RTe.isMDXComponent=!0;const STe={toc:[]},BTe="wrapper";function GTe(t){let{components:e,...n}=t;return(0,s.kt)(BTe,(0,p.Z)({},STe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}GTe.isMDXComponent=!0;const ETe={toc:[]},OTe="wrapper";function UTe(t){let{components:e,...n}=t;return(0,s.kt)(OTe,(0,p.Z)({},ETe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}UTe.isMDXComponent=!0;const FTe={toc:[]},VTe="wrapper";function qTe(t){let{components:e,...n}=t;return(0,s.kt)(VTe,(0,p.Z)({},FTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}qTe.isMDXComponent=!0;const jTe={toc:[]},HTe="wrapper";function YTe(t){let{components:e,...n}=t;return(0,s.kt)(HTe,(0,p.Z)({},jTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}YTe.isMDXComponent=!0;const QTe={toc:[]},$Te="wrapper";function KTe(t){let{components:e,...n}=t;return(0,s.kt)($Te,(0,p.Z)({},QTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}KTe.isMDXComponent=!0;const JTe={toc:[]},tCe="wrapper";function eCe(t){let{components:e,...n}=t;return(0,s.kt)(tCe,(0,p.Z)({},JTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eCe.isMDXComponent=!0;const nCe={toc:[]},oCe="wrapper";function pCe(t){let{components:e,...n}=t;return(0,s.kt)(oCe,(0,p.Z)({},nCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pCe.isMDXComponent=!0;const rCe={toc:[]},sCe="wrapper";function cCe(t){let{components:e,...n}=t;return(0,s.kt)(sCe,(0,p.Z)({},rCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}cCe.isMDXComponent=!0;const aCe={toc:[]},iCe="wrapper";function lCe(t){let{components:e,...n}=t;return(0,s.kt)(iCe,(0,p.Z)({},aCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lCe.isMDXComponent=!0;const uCe={toc:[]},mCe="wrapper";function dCe(t){let{components:e,...n}=t;return(0,s.kt)(mCe,(0,p.Z)({},uCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}dCe.isMDXComponent=!0;const hCe={toc:[]},fCe="wrapper";function kCe(t){let{components:e,...n}=t;return(0,s.kt)(fCe,(0,p.Z)({},hCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}kCe.isMDXComponent=!0;const yCe={toc:[]},DCe="wrapper";function MCe(t){let{components:e,...n}=t;return(0,s.kt)(DCe,(0,p.Z)({},yCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}MCe.isMDXComponent=!0;const XCe={toc:[]},_Ce="wrapper";function wCe(t){let{components:e,...n}=t;return(0,s.kt)(_Ce,(0,p.Z)({},XCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}wCe.isMDXComponent=!0;const TCe={toc:[]},CCe="wrapper";function gCe(t){let{components:e,...n}=t;return(0,s.kt)(CCe,(0,p.Z)({},TCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}gCe.isMDXComponent=!0;const xCe={toc:[]},vCe="wrapper";function LCe(t){let{components:e,...n}=t;return(0,s.kt)(vCe,(0,p.Z)({},xCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}LCe.isMDXComponent=!0;const ZCe={toc:[]},bCe="wrapper";function NCe(t){let{components:e,...n}=t;return(0,s.kt)(bCe,(0,p.Z)({},ZCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}NCe.isMDXComponent=!0;const zCe={toc:[]},ACe="wrapper";function PCe(t){let{components:e,...n}=t;return(0,s.kt)(ACe,(0,p.Z)({},zCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}PCe.isMDXComponent=!0;const ICe={toc:[]},WCe="wrapper";function RCe(t){let{components:e,...n}=t;return(0,s.kt)(WCe,(0,p.Z)({},ICe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}RCe.isMDXComponent=!0;const SCe={toc:[]},BCe="wrapper";function GCe(t){let{components:e,...n}=t;return(0,s.kt)(BCe,(0,p.Z)({},SCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}GCe.isMDXComponent=!0;const ECe={toc:[]},OCe="wrapper";function UCe(t){let{components:e,...n}=t;return(0,s.kt)(OCe,(0,p.Z)({},ECe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}UCe.isMDXComponent=!0;const FCe={toc:[]},VCe="wrapper";function qCe(t){let{components:e,...n}=t;return(0,s.kt)(VCe,(0,p.Z)({},FCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qCe.isMDXComponent=!0;const jCe={toc:[]},HCe="wrapper";function YCe(t){let{components:e,...n}=t;return(0,s.kt)(HCe,(0,p.Z)({},jCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}YCe.isMDXComponent=!0;const QCe={toc:[]},$Ce="wrapper";function KCe(t){let{components:e,...n}=t;return(0,s.kt)($Ce,(0,p.Z)({},QCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}KCe.isMDXComponent=!0;const JCe={toc:[]},tge="wrapper";function ege(t){let{components:e,...n}=t;return(0,s.kt)(tge,(0,p.Z)({},JCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}ege.isMDXComponent=!0;const nge={toc:[]},oge="wrapper";function pge(t){let{components:e,...n}=t;return(0,s.kt)(oge,(0,p.Z)({},nge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pge.isMDXComponent=!0;const rge={toc:[]},sge="wrapper";function cge(t){let{components:e,...n}=t;return(0,s.kt)(sge,(0,p.Z)({},rge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}cge.isMDXComponent=!0;const age={toc:[]},ige="wrapper";function lge(t){let{components:e,...n}=t;return(0,s.kt)(ige,(0,p.Z)({},age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}lge.isMDXComponent=!0;const uge={toc:[]},mge="wrapper";function dge(t){let{components:e,...n}=t;return(0,s.kt)(mge,(0,p.Z)({},uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}dge.isMDXComponent=!0;const hge={toc:[]},fge="wrapper";function kge(t){let{components:e,...n}=t;return(0,s.kt)(fge,(0,p.Z)({},hge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}kge.isMDXComponent=!0;const yge={toc:[]},Dge="wrapper";function Mge(t){let{components:e,...n}=t;return(0,s.kt)(Dge,(0,p.Z)({},yge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Mge.isMDXComponent=!0;const Xge={toc:[]},_ge="wrapper";function wge(t){let{components:e,...n}=t;return(0,s.kt)(_ge,(0,p.Z)({},Xge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}wge.isMDXComponent=!0;const Tge={toc:[]},Cge="wrapper";function gge(t){let{components:e,...n}=t;return(0,s.kt)(Cge,(0,p.Z)({},Tge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}gge.isMDXComponent=!0;const xge={toc:[]},vge="wrapper";function Lge(t){let{components:e,...n}=t;return(0,s.kt)(vge,(0,p.Z)({},xge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}Lge.isMDXComponent=!0;const Zge={toc:[]},bge="wrapper";function Nge(t){let{components:e,...n}=t;return(0,s.kt)(bge,(0,p.Z)({},Zge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Nge.isMDXComponent=!0;const zge={toc:[]},Age="wrapper";function Pge(t){let{components:e,...n}=t;return(0,s.kt)(Age,(0,p.Z)({},zge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Pge.isMDXComponent=!0;const Ige={toc:[]},Wge="wrapper";function Rge(t){let{components:e,...n}=t;return(0,s.kt)(Wge,(0,p.Z)({},Ige,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Rge.isMDXComponent=!0;const Sge={toc:[]},Bge="wrapper";function Gge(t){let{components:e,...n}=t;return(0,s.kt)(Bge,(0,p.Z)({},Sge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Gge.isMDXComponent=!0;const Ege={toc:[]},Oge="wrapper";function Uge(t){let{components:e,...n}=t;return(0,s.kt)(Oge,(0,p.Z)({},Ege,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Uge.isMDXComponent=!0;const Fge={toc:[]},Vge="wrapper";function qge(t){let{components:e,...n}=t;return(0,s.kt)(Vge,(0,p.Z)({},Fge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qge.isMDXComponent=!0;const jge={toc:[]},Hge="wrapper";function Yge(t){let{components:e,...n}=t;return(0,s.kt)(Hge,(0,p.Z)({},jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Yge.isMDXComponent=!0;const Qge={toc:[]},$ge="wrapper";function Kge(t){let{components:e,...n}=t;return(0,s.kt)($ge,(0,p.Z)({},Qge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Kge.isMDXComponent=!0;const Jge={toc:[]},txe="wrapper";function exe(t){let{components:e,...n}=t;return(0,s.kt)(txe,(0,p.Z)({},Jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}exe.isMDXComponent=!0;const nxe={toc:[]},oxe="wrapper";function pxe(t){let{components:e,...n}=t;return(0,s.kt)(oxe,(0,p.Z)({},nxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pxe.isMDXComponent=!0;const rxe={toc:[]},sxe="wrapper";function cxe(t){let{components:e,...n}=t;return(0,s.kt)(sxe,(0,p.Z)({},rxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cxe.isMDXComponent=!0;const axe={toc:[]},ixe="wrapper";function lxe(t){let{components:e,...n}=t;return(0,s.kt)(ixe,(0,p.Z)({},axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lxe.isMDXComponent=!0;const uxe={toc:[]},mxe="wrapper";function dxe(t){let{components:e,...n}=t;return(0,s.kt)(mxe,(0,p.Z)({},uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dxe.isMDXComponent=!0;const hxe={toc:[]},fxe="wrapper";function kxe(t){let{components:e,...n}=t;return(0,s.kt)(fxe,(0,p.Z)({},hxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}kxe.isMDXComponent=!0;const yxe={toc:[]},Dxe="wrapper";function Mxe(t){let{components:e,...n}=t;return(0,s.kt)(Dxe,(0,p.Z)({},yxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Mxe.isMDXComponent=!0;const Xxe={toc:[]},_xe="wrapper";function wxe(t){let{components:e,...n}=t;return(0,s.kt)(_xe,(0,p.Z)({},Xxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wxe.isMDXComponent=!0;const Txe={toc:[]},Cxe="wrapper";function gxe(t){let{components:e,...n}=t;return(0,s.kt)(Cxe,(0,p.Z)({},Txe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}gxe.isMDXComponent=!0;const xxe={toc:[]},vxe="wrapper";function Lxe(t){let{components:e,...n}=t;return(0,s.kt)(vxe,(0,p.Z)({},xxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Lxe.isMDXComponent=!0;const Zxe={toc:[]},bxe="wrapper";function Nxe(t){let{components:e,...n}=t;return(0,s.kt)(bxe,(0,p.Z)({},Zxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Nxe.isMDXComponent=!0;const zxe={toc:[]},Axe="wrapper";function Pxe(t){let{components:e,...n}=t;return(0,s.kt)(Axe,(0,p.Z)({},zxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pxe.isMDXComponent=!0;const Ixe={toc:[]},Wxe="wrapper";function Rxe(t){let{components:e,...n}=t;return(0,s.kt)(Wxe,(0,p.Z)({},Ixe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Rxe.isMDXComponent=!0;const Sxe={toc:[]},Bxe="wrapper";function Gxe(t){let{components:e,...n}=t;return(0,s.kt)(Bxe,(0,p.Z)({},Sxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Gxe.isMDXComponent=!0;const Exe={toc:[]},Oxe="wrapper";function Uxe(t){let{components:e,...n}=t;return(0,s.kt)(Oxe,(0,p.Z)({},Exe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Uxe.isMDXComponent=!0;const Fxe={toc:[]},Vxe="wrapper";function qxe(t){let{components:e,...n}=t;return(0,s.kt)(Vxe,(0,p.Z)({},Fxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qxe.isMDXComponent=!0;const jxe={toc:[]},Hxe="wrapper";function Yxe(t){let{components:e,...n}=t;return(0,s.kt)(Hxe,(0,p.Z)({},jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Yxe.isMDXComponent=!0;const Qxe={toc:[]},$xe="wrapper";function Kxe(t){let{components:e,...n}=t;return(0,s.kt)($xe,(0,p.Z)({},Qxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Kxe.isMDXComponent=!0;const Jxe={toc:[]},tve="wrapper";function eve(t){let{components:e,...n}=t;return(0,s.kt)(tve,(0,p.Z)({},Jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}eve.isMDXComponent=!0;const nve={toc:[]},ove="wrapper";function pve(t){let{components:e,...n}=t;return(0,s.kt)(ove,(0,p.Z)({},nve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pve.isMDXComponent=!0;const rve={toc:[]},sve="wrapper";function cve(t){let{components:e,...n}=t;return(0,s.kt)(sve,(0,p.Z)({},rve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cve.isMDXComponent=!0;const ave={toc:[]},ive="wrapper";function lve(t){let{components:e,...n}=t;return(0,s.kt)(ive,(0,p.Z)({},ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lve.isMDXComponent=!0;const uve={toc:[]},mve="wrapper";function dve(t){let{components:e,...n}=t;return(0,s.kt)(mve,(0,p.Z)({},uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}dve.isMDXComponent=!0;const hve={toc:[]},fve="wrapper";function kve(t){let{components:e,...n}=t;return(0,s.kt)(fve,(0,p.Z)({},hve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}kve.isMDXComponent=!0;const yve={toc:[]},Dve="wrapper";function Mve(t){let{components:e,...n}=t;return(0,s.kt)(Dve,(0,p.Z)({},yve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Mve.isMDXComponent=!0;const Xve={toc:[]},_ve="wrapper";function wve(t){let{components:e,...n}=t;return(0,s.kt)(_ve,(0,p.Z)({},Xve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wve.isMDXComponent=!0;const Tve={toc:[]},Cve="wrapper";function gve(t){let{components:e,...n}=t;return(0,s.kt)(Cve,(0,p.Z)({},Tve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}gve.isMDXComponent=!0;const xve={toc:[]},vve="wrapper";function Lve(t){let{components:e,...n}=t;return(0,s.kt)(vve,(0,p.Z)({},xve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Lve.isMDXComponent=!0;const Zve={toc:[]},bve="wrapper";function Nve(t){let{components:e,...n}=t;return(0,s.kt)(bve,(0,p.Z)({},Zve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Nve.isMDXComponent=!0;const zve={toc:[]},Ave="wrapper";function Pve(t){let{components:e,...n}=t;return(0,s.kt)(Ave,(0,p.Z)({},zve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pve.isMDXComponent=!0;const Ive={toc:[]},Wve="wrapper";function Rve(t){let{components:e,...n}=t;return(0,s.kt)(Wve,(0,p.Z)({},Ive,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Rve.isMDXComponent=!0;const Sve={toc:[]},Bve="wrapper";function Gve(t){let{components:e,...n}=t;return(0,s.kt)(Bve,(0,p.Z)({},Sve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Gve.isMDXComponent=!0;const Eve={toc:[]},Ove="wrapper";function Uve(t){let{components:e,...n}=t;return(0,s.kt)(Ove,(0,p.Z)({},Eve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Uve.isMDXComponent=!0;const Fve={toc:[]},Vve="wrapper";function qve(t){let{components:e,...n}=t;return(0,s.kt)(Vve,(0,p.Z)({},Fve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qve.isMDXComponent=!0;const jve={toc:[]},Hve="wrapper";function Yve(t){let{components:e,...n}=t;return(0,s.kt)(Hve,(0,p.Z)({},jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Yve.isMDXComponent=!0;const Qve={toc:[]},$ve="wrapper";function Kve(t){let{components:e,...n}=t;return(0,s.kt)($ve,(0,p.Z)({},Qve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Kve.isMDXComponent=!0;const Jve={toc:[]},tLe="wrapper";function eLe(t){let{components:e,...n}=t;return(0,s.kt)(tLe,(0,p.Z)({},Jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eLe.isMDXComponent=!0;const nLe={toc:[]},oLe="wrapper";function pLe(t){let{components:e,...n}=t;return(0,s.kt)(oLe,(0,p.Z)({},nLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pLe.isMDXComponent=!0;const rLe={toc:[]},sLe="wrapper";function cLe(t){let{components:e,...n}=t;return(0,s.kt)(sLe,(0,p.Z)({},rLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cLe.isMDXComponent=!0;const aLe={toc:[]},iLe="wrapper";function lLe(t){let{components:e,...n}=t;return(0,s.kt)(iLe,(0,p.Z)({},aLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lLe.isMDXComponent=!0;const uLe={toc:[]},mLe="wrapper";function dLe(t){let{components:e,...n}=t;return(0,s.kt)(mLe,(0,p.Z)({},uLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}dLe.isMDXComponent=!0;const hLe={toc:[]},fLe="wrapper";function kLe(t){let{components:e,...n}=t;return(0,s.kt)(fLe,(0,p.Z)({},hLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kLe.isMDXComponent=!0;const yLe={toc:[]},DLe="wrapper";function MLe(t){let{components:e,...n}=t;return(0,s.kt)(DLe,(0,p.Z)({},yLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}MLe.isMDXComponent=!0;const XLe={toc:[]},_Le="wrapper";function wLe(t){let{components:e,...n}=t;return(0,s.kt)(_Le,(0,p.Z)({},XLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wLe.isMDXComponent=!0;const TLe={toc:[]},CLe="wrapper";function gLe(t){let{components:e,...n}=t;return(0,s.kt)(CLe,(0,p.Z)({},TLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}gLe.isMDXComponent=!0;const xLe={toc:[]},vLe="wrapper";function LLe(t){let{components:e,...n}=t;return(0,s.kt)(vLe,(0,p.Z)({},xLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LLe.isMDXComponent=!0;const ZLe={toc:[]},bLe="wrapper";function NLe(t){let{components:e,...n}=t;return(0,s.kt)(bLe,(0,p.Z)({},ZLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}NLe.isMDXComponent=!0;const zLe={toc:[]},ALe="wrapper";function PLe(t){let{components:e,...n}=t;return(0,s.kt)(ALe,(0,p.Z)({},zLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}PLe.isMDXComponent=!0;const ILe={toc:[]},WLe="wrapper";function RLe(t){let{components:e,...n}=t;return(0,s.kt)(WLe,(0,p.Z)({},ILe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}RLe.isMDXComponent=!0;const SLe={toc:[]},BLe="wrapper";function GLe(t){let{components:e,...n}=t;return(0,s.kt)(BLe,(0,p.Z)({},SLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}GLe.isMDXComponent=!0;const ELe={toc:[]},OLe="wrapper";function ULe(t){let{components:e,...n}=t;return(0,s.kt)(OLe,(0,p.Z)({},ELe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}ULe.isMDXComponent=!0;const FLe={toc:[]},VLe="wrapper";function qLe(t){let{components:e,...n}=t;return(0,s.kt)(VLe,(0,p.Z)({},FLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qLe.isMDXComponent=!0;const jLe={toc:[]},HLe="wrapper";function YLe(t){let{components:e,...n}=t;return(0,s.kt)(HLe,(0,p.Z)({},jLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}YLe.isMDXComponent=!0;const QLe={toc:[]},$Le="wrapper";function KLe(t){let{components:e,...n}=t;return(0,s.kt)($Le,(0,p.Z)({},QLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}KLe.isMDXComponent=!0;const JLe={toc:[]},tZe="wrapper";function eZe(t){let{components:e,...n}=t;return(0,s.kt)(tZe,(0,p.Z)({},JLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}eZe.isMDXComponent=!0;const nZe={toc:[]},oZe="wrapper";function pZe(t){let{components:e,...n}=t;return(0,s.kt)(oZe,(0,p.Z)({},nZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}pZe.isMDXComponent=!0;const rZe={toc:[]},sZe="wrapper";function cZe(t){let{components:e,...n}=t;return(0,s.kt)(sZe,(0,p.Z)({},rZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}cZe.isMDXComponent=!0;const aZe={toc:[]},iZe="wrapper";function lZe(t){let{components:e,...n}=t;return(0,s.kt)(iZe,(0,p.Z)({},aZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lZe.isMDXComponent=!0;const uZe={toc:[]},mZe="wrapper";function dZe(t){let{components:e,...n}=t;return(0,s.kt)(mZe,(0,p.Z)({},uZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}dZe.isMDXComponent=!0;const hZe={toc:[]},fZe="wrapper";function kZe(t){let{components:e,...n}=t;return(0,s.kt)(fZe,(0,p.Z)({},hZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kZe.isMDXComponent=!0;const yZe={toc:[]},DZe="wrapper";function MZe(t){let{components:e,...n}=t;return(0,s.kt)(DZe,(0,p.Z)({},yZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}MZe.isMDXComponent=!0;const XZe={toc:[]},_Ze="wrapper";function wZe(t){let{components:e,...n}=t;return(0,s.kt)(_Ze,(0,p.Z)({},XZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wZe.isMDXComponent=!0;const TZe={toc:[]},CZe="wrapper";function gZe(t){let{components:e,...n}=t;return(0,s.kt)(CZe,(0,p.Z)({},TZe,n,{components:e,mdxType:"MDXLayout"}))}gZe.isMDXComponent=!0;const xZe={toc:[]},vZe="wrapper";function LZe(t){let{components:e,...n}=t;return(0,s.kt)(vZe,(0,p.Z)({},xZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}LZe.isMDXComponent=!0;const ZZe={toc:[]},bZe="wrapper";function NZe(t){let{components:e,...n}=t;return(0,s.kt)(bZe,(0,p.Z)({},ZZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}NZe.isMDXComponent=!0;const zZe={toc:[]},AZe="wrapper";function PZe(t){let{components:e,...n}=t;return(0,s.kt)(AZe,(0,p.Z)({},zZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}PZe.isMDXComponent=!0;const IZe={toc:[]},WZe="wrapper";function RZe(t){let{components:e,...n}=t;return(0,s.kt)(WZe,(0,p.Z)({},IZe,n,{components:e,mdxType:"MDXLayout"}))}RZe.isMDXComponent=!0;const SZe={toc:[]},BZe="wrapper";function GZe(t){let{components:e,...n}=t;return(0,s.kt)(BZe,(0,p.Z)({},SZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}GZe.isMDXComponent=!0;const EZe={toc:[]},OZe="wrapper";function UZe(t){let{components:e,...n}=t;return(0,s.kt)(OZe,(0,p.Z)({},EZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}UZe.isMDXComponent=!0;const FZe={toc:[]},VZe="wrapper";function qZe(t){let{components:e,...n}=t;return(0,s.kt)(VZe,(0,p.Z)({},FZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}qZe.isMDXComponent=!0;const jZe={toc:[]},HZe="wrapper";function YZe(t){let{components:e,...n}=t;return(0,s.kt)(HZe,(0,p.Z)({},jZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}YZe.isMDXComponent=!0;const QZe={toc:[]},$Ze="wrapper";function KZe(t){let{components:e,...n}=t;return(0,s.kt)($Ze,(0,p.Z)({},QZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KZe.isMDXComponent=!0;const JZe={toc:[]},tbe="wrapper";function ebe(t){let{components:e,...n}=t;return(0,s.kt)(tbe,(0,p.Z)({},JZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}ebe.isMDXComponent=!0;const nbe={toc:[]},obe="wrapper";function pbe(t){let{components:e,...n}=t;return(0,s.kt)(obe,(0,p.Z)({},nbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}pbe.isMDXComponent=!0;const rbe={toc:[]},sbe="wrapper";function cbe(t){let{components:e,...n}=t;return(0,s.kt)(sbe,(0,p.Z)({},rbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cbe.isMDXComponent=!0;const abe={toc:[]},ibe="wrapper";function lbe(t){let{components:e,...n}=t;return(0,s.kt)(ibe,(0,p.Z)({},abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lbe.isMDXComponent=!0;const ube={toc:[]},mbe="wrapper";function dbe(t){let{components:e,...n}=t;return(0,s.kt)(mbe,(0,p.Z)({},ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}dbe.isMDXComponent=!0;const hbe={toc:[]},fbe="wrapper";function kbe(t){let{components:e,...n}=t;return(0,s.kt)(fbe,(0,p.Z)({},hbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}kbe.isMDXComponent=!0;const ybe={toc:[]},Dbe="wrapper";function Mbe(t){let{components:e,...n}=t;return(0,s.kt)(Dbe,(0,p.Z)({},ybe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Mbe.isMDXComponent=!0;const Xbe={toc:[]},_be="wrapper";function wbe(t){let{components:e,...n}=t;return(0,s.kt)(_be,(0,p.Z)({},Xbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}wbe.isMDXComponent=!0;const Tbe={toc:[]},Cbe="wrapper";function gbe(t){let{components:e,...n}=t;return(0,s.kt)(Cbe,(0,p.Z)({},Tbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}gbe.isMDXComponent=!0;const xbe={toc:[]},vbe="wrapper";function Lbe(t){let{components:e,...n}=t;return(0,s.kt)(vbe,(0,p.Z)({},xbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Lbe.isMDXComponent=!0;const Zbe={toc:[]},bbe="wrapper";function Nbe(t){let{components:e,...n}=t;return(0,s.kt)(bbe,(0,p.Z)({},Zbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Nbe.isMDXComponent=!0;const zbe={toc:[]},Abe="wrapper";function Pbe(t){let{components:e,...n}=t;return(0,s.kt)(Abe,(0,p.Z)({},zbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Pbe.isMDXComponent=!0;const Ibe={toc:[]},Wbe="wrapper";function Rbe(t){let{components:e,...n}=t;return(0,s.kt)(Wbe,(0,p.Z)({},Ibe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Rbe.isMDXComponent=!0;const Sbe={toc:[]},Bbe="wrapper";function Gbe(t){let{components:e,...n}=t;return(0,s.kt)(Bbe,(0,p.Z)({},Sbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Gbe.isMDXComponent=!0;const Ebe={toc:[]},Obe="wrapper";function Ube(t){let{components:e,...n}=t;return(0,s.kt)(Obe,(0,p.Z)({},Ebe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ube.isMDXComponent=!0;const Fbe={toc:[]},Vbe="wrapper";function qbe(t){let{components:e,...n}=t;return(0,s.kt)(Vbe,(0,p.Z)({},Fbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}qbe.isMDXComponent=!0;const jbe={toc:[]},Hbe="wrapper";function Ybe(t){let{components:e,...n}=t;return(0,s.kt)(Hbe,(0,p.Z)({},jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Ybe.isMDXComponent=!0;const Qbe={toc:[]},$be="wrapper";function Kbe(t){let{components:e,...n}=t;return(0,s.kt)($be,(0,p.Z)({},Qbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Kbe.isMDXComponent=!0;const Jbe={toc:[]},tNe="wrapper";function eNe(t){let{components:e,...n}=t;return(0,s.kt)(tNe,(0,p.Z)({},Jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}eNe.isMDXComponent=!0;const nNe={toc:[]},oNe="wrapper";function pNe(t){let{components:e,...n}=t;return(0,s.kt)(oNe,(0,p.Z)({},nNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}pNe.isMDXComponent=!0;const rNe={toc:[]},sNe="wrapper";function cNe(t){let{components:e,...n}=t;return(0,s.kt)(sNe,(0,p.Z)({},rNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cNe.isMDXComponent=!0;const aNe={toc:[]},iNe="wrapper";function lNe(t){let{components:e,...n}=t;return(0,s.kt)(iNe,(0,p.Z)({},aNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}lNe.isMDXComponent=!0;const uNe={toc:[]},mNe="wrapper";function dNe(t){let{components:e,...n}=t;return(0,s.kt)(mNe,(0,p.Z)({},uNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dNe.isMDXComponent=!0;const hNe={toc:[]},fNe="wrapper";function kNe(t){let{components:e,...n}=t;return(0,s.kt)(fNe,(0,p.Z)({},hNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kNe.isMDXComponent=!0;const yNe={toc:[]},DNe="wrapper";function MNe(t){let{components:e,...n}=t;return(0,s.kt)(DNe,(0,p.Z)({},yNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}MNe.isMDXComponent=!0;const XNe={toc:[]},_Ne="wrapper";function wNe(t){let{components:e,...n}=t;return(0,s.kt)(_Ne,(0,p.Z)({},XNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wNe.isMDXComponent=!0;const TNe={toc:[]},CNe="wrapper";function gNe(t){let{components:e,...n}=t;return(0,s.kt)(CNe,(0,p.Z)({},TNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}gNe.isMDXComponent=!0;const xNe={toc:[]},vNe="wrapper";function LNe(t){let{components:e,...n}=t;return(0,s.kt)(vNe,(0,p.Z)({},xNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}LNe.isMDXComponent=!0;const ZNe={toc:[]},bNe="wrapper";function NNe(t){let{components:e,...n}=t;return(0,s.kt)(bNe,(0,p.Z)({},ZNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NNe.isMDXComponent=!0;const zNe={toc:[]},ANe="wrapper";function PNe(t){let{components:e,...n}=t;return(0,s.kt)(ANe,(0,p.Z)({},zNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}PNe.isMDXComponent=!0;const INe={toc:[]},WNe="wrapper";function RNe(t){let{components:e,...n}=t;return(0,s.kt)(WNe,(0,p.Z)({},INe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}RNe.isMDXComponent=!0;const SNe={toc:[]},BNe="wrapper";function GNe(t){let{components:e,...n}=t;return(0,s.kt)(BNe,(0,p.Z)({},SNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}GNe.isMDXComponent=!0;const ENe={toc:[]},ONe="wrapper";function UNe(t){let{components:e,...n}=t;return(0,s.kt)(ONe,(0,p.Z)({},ENe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}UNe.isMDXComponent=!0;const FNe={toc:[]},VNe="wrapper";function qNe(t){let{components:e,...n}=t;return(0,s.kt)(VNe,(0,p.Z)({},FNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qNe.isMDXComponent=!0;const jNe={toc:[]},HNe="wrapper";function YNe(t){let{components:e,...n}=t;return(0,s.kt)(HNe,(0,p.Z)({},jNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}YNe.isMDXComponent=!0;const QNe={toc:[]},$Ne="wrapper";function KNe(t){let{components:e,...n}=t;return(0,s.kt)($Ne,(0,p.Z)({},QNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}KNe.isMDXComponent=!0;const JNe={toc:[]},tze="wrapper";function eze(t){let{components:e,...n}=t;return(0,s.kt)(tze,(0,p.Z)({},JNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eze.isMDXComponent=!0;const nze={toc:[]},oze="wrapper";function pze(t){let{components:e,...n}=t;return(0,s.kt)(oze,(0,p.Z)({},nze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}pze.isMDXComponent=!0;const rze={toc:[]},sze="wrapper";function cze(t){let{components:e,...n}=t;return(0,s.kt)(sze,(0,p.Z)({},rze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cze.isMDXComponent=!0;const aze={toc:[]},ize="wrapper";function lze(t){let{components:e,...n}=t;return(0,s.kt)(ize,(0,p.Z)({},aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}lze.isMDXComponent=!0;const uze={toc:[]},mze="wrapper";function dze(t){let{components:e,...n}=t;return(0,s.kt)(mze,(0,p.Z)({},uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dze.isMDXComponent=!0;const hze={toc:[]},fze="wrapper";function kze(t){let{components:e,...n}=t;return(0,s.kt)(fze,(0,p.Z)({},hze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}kze.isMDXComponent=!0;const yze={toc:[]},Dze="wrapper";function Mze(t){let{components:e,...n}=t;return(0,s.kt)(Dze,(0,p.Z)({},yze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mze.isMDXComponent=!0;const Xze={toc:[]},_ze="wrapper";function wze(t){let{components:e,...n}=t;return(0,s.kt)(_ze,(0,p.Z)({},Xze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wze.isMDXComponent=!0;const Tze={toc:[]},Cze="wrapper";function gze(t){let{components:e,...n}=t;return(0,s.kt)(Cze,(0,p.Z)({},Tze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}gze.isMDXComponent=!0;const xze={toc:[]},vze="wrapper";function Lze(t){let{components:e,...n}=t;return(0,s.kt)(vze,(0,p.Z)({},xze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Lze.isMDXComponent=!0;const Zze={toc:[]},bze="wrapper";function Nze(t){let{components:e,...n}=t;return(0,s.kt)(bze,(0,p.Z)({},Zze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Nze.isMDXComponent=!0;const zze={toc:[]},Aze="wrapper";function Pze(t){let{components:e,...n}=t;return(0,s.kt)(Aze,(0,p.Z)({},zze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Pze.isMDXComponent=!0;const Ize={toc:[]},Wze="wrapper";function Rze(t){let{components:e,...n}=t;return(0,s.kt)(Wze,(0,p.Z)({},Ize,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Rze.isMDXComponent=!0;const Sze={toc:[]},Bze="wrapper";function Gze(t){let{components:e,...n}=t;return(0,s.kt)(Bze,(0,p.Z)({},Sze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Gze.isMDXComponent=!0;const Eze={toc:[]},Oze="wrapper";function Uze(t){let{components:e,...n}=t;return(0,s.kt)(Oze,(0,p.Z)({},Eze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Uze.isMDXComponent=!0;const Fze={toc:[]},Vze="wrapper";function qze(t){let{components:e,...n}=t;return(0,s.kt)(Vze,(0,p.Z)({},Fze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qze.isMDXComponent=!0;const jze={toc:[]},Hze="wrapper";function Yze(t){let{components:e,...n}=t;return(0,s.kt)(Hze,(0,p.Z)({},jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Yze.isMDXComponent=!0;const Qze={toc:[]},$ze="wrapper";function Kze(t){let{components:e,...n}=t;return(0,s.kt)($ze,(0,p.Z)({},Qze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Kze.isMDXComponent=!0;const Jze={toc:[]},tAe="wrapper";function eAe(t){let{components:e,...n}=t;return(0,s.kt)(tAe,(0,p.Z)({},Jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}eAe.isMDXComponent=!0;const nAe={toc:[]},oAe="wrapper";function pAe(t){let{components:e,...n}=t;return(0,s.kt)(oAe,(0,p.Z)({},nAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}pAe.isMDXComponent=!0;const rAe={toc:[]},sAe="wrapper";function cAe(t){let{components:e,...n}=t;return(0,s.kt)(sAe,(0,p.Z)({},rAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}cAe.isMDXComponent=!0;const aAe={toc:[]},iAe="wrapper";function lAe(t){let{components:e,...n}=t;return(0,s.kt)(iAe,(0,p.Z)({},aAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}lAe.isMDXComponent=!0;const uAe={toc:[]},mAe="wrapper";function dAe(t){let{components:e,...n}=t;return(0,s.kt)(mAe,(0,p.Z)({},uAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}dAe.isMDXComponent=!0;const hAe={toc:[]},fAe="wrapper";function kAe(t){let{components:e,...n}=t;return(0,s.kt)(fAe,(0,p.Z)({},hAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}kAe.isMDXComponent=!0;const yAe={toc:[]},DAe="wrapper";function MAe(t){let{components:e,...n}=t;return(0,s.kt)(DAe,(0,p.Z)({},yAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}MAe.isMDXComponent=!0;const XAe={toc:[]},_Ae="wrapper";function wAe(t){let{components:e,...n}=t;return(0,s.kt)(_Ae,(0,p.Z)({},XAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}wAe.isMDXComponent=!0;const TAe={toc:[]},CAe="wrapper";function gAe(t){let{components:e,...n}=t;return(0,s.kt)(CAe,(0,p.Z)({},TAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}gAe.isMDXComponent=!0;const xAe={toc:[]},vAe="wrapper";function LAe(t){let{components:e,...n}=t;return(0,s.kt)(vAe,(0,p.Z)({},xAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}LAe.isMDXComponent=!0;const ZAe={toc:[]},bAe="wrapper";function NAe(t){let{components:e,...n}=t;return(0,s.kt)(bAe,(0,p.Z)({},ZAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}NAe.isMDXComponent=!0;const zAe={toc:[]},AAe="wrapper";function PAe(t){let{components:e,...n}=t;return(0,s.kt)(AAe,(0,p.Z)({},zAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}PAe.isMDXComponent=!0;const IAe={toc:[]},WAe="wrapper";function RAe(t){let{components:e,...n}=t;return(0,s.kt)(WAe,(0,p.Z)({},IAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}RAe.isMDXComponent=!0;const SAe={toc:[]},BAe="wrapper";function GAe(t){let{components:e,...n}=t;return(0,s.kt)(BAe,(0,p.Z)({},SAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}GAe.isMDXComponent=!0;const EAe={toc:[]},OAe="wrapper";function UAe(t){let{components:e,...n}=t;return(0,s.kt)(OAe,(0,p.Z)({},EAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}UAe.isMDXComponent=!0;const FAe={toc:[]},VAe="wrapper";function qAe(t){let{components:e,...n}=t;return(0,s.kt)(VAe,(0,p.Z)({},FAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}qAe.isMDXComponent=!0;const jAe={toc:[]},HAe="wrapper";function YAe(t){let{components:e,...n}=t;return(0,s.kt)(HAe,(0,p.Z)({},jAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}YAe.isMDXComponent=!0;const QAe={toc:[]},$Ae="wrapper";function KAe(t){let{components:e,...n}=t;return(0,s.kt)($Ae,(0,p.Z)({},QAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}KAe.isMDXComponent=!0;const JAe={toc:[]},tPe="wrapper";function ePe(t){let{components:e,...n}=t;return(0,s.kt)(tPe,(0,p.Z)({},JAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}ePe.isMDXComponent=!0;const nPe={toc:[]},oPe="wrapper";function pPe(t){let{components:e,...n}=t;return(0,s.kt)(oPe,(0,p.Z)({},nPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}pPe.isMDXComponent=!0;const rPe={toc:[]},sPe="wrapper";function cPe(t){let{components:e,...n}=t;return(0,s.kt)(sPe,(0,p.Z)({},rPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}cPe.isMDXComponent=!0;const aPe={toc:[]},iPe="wrapper";function lPe(t){let{components:e,...n}=t;return(0,s.kt)(iPe,(0,p.Z)({},aPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}lPe.isMDXComponent=!0;const uPe={toc:[]},mPe="wrapper";function dPe(t){let{components:e,...n}=t;return(0,s.kt)(mPe,(0,p.Z)({},uPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}dPe.isMDXComponent=!0;const hPe={toc:[]},fPe="wrapper";function kPe(t){let{components:e,...n}=t;return(0,s.kt)(fPe,(0,p.Z)({},hPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}kPe.isMDXComponent=!0;const yPe={toc:[]},DPe="wrapper";function MPe(t){let{components:e,...n}=t;return(0,s.kt)(DPe,(0,p.Z)({},yPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}MPe.isMDXComponent=!0;const XPe={toc:[]},_Pe="wrapper";function wPe(t){let{components:e,...n}=t;return(0,s.kt)(_Pe,(0,p.Z)({},XPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}wPe.isMDXComponent=!0;const TPe={toc:[]},CPe="wrapper";function gPe(t){let{components:e,...n}=t;return(0,s.kt)(CPe,(0,p.Z)({},TPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gPe.isMDXComponent=!0;const xPe={toc:[]},vPe="wrapper";function LPe(t){let{components:e,...n}=t;return(0,s.kt)(vPe,(0,p.Z)({},xPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}LPe.isMDXComponent=!0;const ZPe={toc:[]},bPe="wrapper";function NPe(t){let{components:e,...n}=t;return(0,s.kt)(bPe,(0,p.Z)({},ZPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NPe.isMDXComponent=!0;const zPe={toc:[]},APe="wrapper";function PPe(t){let{components:e,...n}=t;return(0,s.kt)(APe,(0,p.Z)({},zPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}PPe.isMDXComponent=!0;const IPe={toc:[]},WPe="wrapper";function RPe(t){let{components:e,...n}=t;return(0,s.kt)(WPe,(0,p.Z)({},IPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}RPe.isMDXComponent=!0;const SPe={toc:[]},BPe="wrapper";function GPe(t){let{components:e,...n}=t;return(0,s.kt)(BPe,(0,p.Z)({},SPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}GPe.isMDXComponent=!0;const EPe={toc:[]},OPe="wrapper";function UPe(t){let{components:e,...n}=t;return(0,s.kt)(OPe,(0,p.Z)({},EPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}UPe.isMDXComponent=!0;const FPe={toc:[]},VPe="wrapper";function qPe(t){let{components:e,...n}=t;return(0,s.kt)(VPe,(0,p.Z)({},FPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}qPe.isMDXComponent=!0;const jPe={toc:[]},HPe="wrapper";function YPe(t){let{components:e,...n}=t;return(0,s.kt)(HPe,(0,p.Z)({},jPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}YPe.isMDXComponent=!0;const QPe={toc:[]},$Pe="wrapper";function KPe(t){let{components:e,...n}=t;return(0,s.kt)($Pe,(0,p.Z)({},QPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}KPe.isMDXComponent=!0;const JPe={toc:[]},tIe="wrapper";function eIe(t){let{components:e,...n}=t;return(0,s.kt)(tIe,(0,p.Z)({},JPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}eIe.isMDXComponent=!0;const nIe={toc:[]},oIe="wrapper";function pIe(t){let{components:e,...n}=t;return(0,s.kt)(oIe,(0,p.Z)({},nIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pIe.isMDXComponent=!0;const rIe={toc:[]},sIe="wrapper";function cIe(t){let{components:e,...n}=t;return(0,s.kt)(sIe,(0,p.Z)({},rIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}cIe.isMDXComponent=!0;const aIe={toc:[]},iIe="wrapper";function lIe(t){let{components:e,...n}=t;return(0,s.kt)(iIe,(0,p.Z)({},aIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lIe.isMDXComponent=!0;const uIe={toc:[]},mIe="wrapper";function dIe(t){let{components:e,...n}=t;return(0,s.kt)(mIe,(0,p.Z)({},uIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}dIe.isMDXComponent=!0;const hIe={toc:[]},fIe="wrapper";function kIe(t){let{components:e,...n}=t;return(0,s.kt)(fIe,(0,p.Z)({},hIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}kIe.isMDXComponent=!0;const yIe={toc:[]},DIe="wrapper";function MIe(t){let{components:e,...n}=t;return(0,s.kt)(DIe,(0,p.Z)({},yIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}MIe.isMDXComponent=!0;const XIe={toc:[]},_Ie="wrapper";function wIe(t){let{components:e,...n}=t;return(0,s.kt)(_Ie,(0,p.Z)({},XIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wIe.isMDXComponent=!0;const TIe={toc:[]},CIe="wrapper";function gIe(t){let{components:e,...n}=t;return(0,s.kt)(CIe,(0,p.Z)({},TIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}gIe.isMDXComponent=!0;const xIe={toc:[]},vIe="wrapper";function LIe(t){let{components:e,...n}=t;return(0,s.kt)(vIe,(0,p.Z)({},xIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}LIe.isMDXComponent=!0;const ZIe={toc:[]},bIe="wrapper";function NIe(t){let{components:e,...n}=t;return(0,s.kt)(bIe,(0,p.Z)({},ZIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}NIe.isMDXComponent=!0;const zIe={toc:[]},AIe="wrapper";function PIe(t){let{components:e,...n}=t;return(0,s.kt)(AIe,(0,p.Z)({},zIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}PIe.isMDXComponent=!0;const IIe={toc:[]},WIe="wrapper";function RIe(t){let{components:e,...n}=t;return(0,s.kt)(WIe,(0,p.Z)({},IIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}RIe.isMDXComponent=!0;const SIe={toc:[]},BIe="wrapper";function GIe(t){let{components:e,...n}=t;return(0,s.kt)(BIe,(0,p.Z)({},SIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}GIe.isMDXComponent=!0;const EIe={toc:[]},OIe="wrapper";function UIe(t){let{components:e,...n}=t;return(0,s.kt)(OIe,(0,p.Z)({},EIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}UIe.isMDXComponent=!0;const FIe={toc:[]},VIe="wrapper";function qIe(t){let{components:e,...n}=t;return(0,s.kt)(VIe,(0,p.Z)({},FIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}qIe.isMDXComponent=!0;const jIe={toc:[]},HIe="wrapper";function YIe(t){let{components:e,...n}=t;return(0,s.kt)(HIe,(0,p.Z)({},jIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}YIe.isMDXComponent=!0;const QIe={toc:[]},$Ie="wrapper";function KIe(t){let{components:e,...n}=t;return(0,s.kt)($Ie,(0,p.Z)({},QIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}KIe.isMDXComponent=!0;const JIe={toc:[]},tWe="wrapper";function eWe(t){let{components:e,...n}=t;return(0,s.kt)(tWe,(0,p.Z)({},JIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}eWe.isMDXComponent=!0;const nWe={toc:[]},oWe="wrapper";function pWe(t){let{components:e,...n}=t;return(0,s.kt)(oWe,(0,p.Z)({},nWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pWe.isMDXComponent=!0;const rWe={toc:[]},sWe="wrapper";function cWe(t){let{components:e,...n}=t;return(0,s.kt)(sWe,(0,p.Z)({},rWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cWe.isMDXComponent=!0;const aWe={toc:[]},iWe="wrapper";function lWe(t){let{components:e,...n}=t;return(0,s.kt)(iWe,(0,p.Z)({},aWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}lWe.isMDXComponent=!0;const uWe={toc:[]},mWe="wrapper";function dWe(t){let{components:e,...n}=t;return(0,s.kt)(mWe,(0,p.Z)({},uWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}dWe.isMDXComponent=!0;const hWe={toc:[]},fWe="wrapper";function kWe(t){let{components:e,...n}=t;return(0,s.kt)(fWe,(0,p.Z)({},hWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}kWe.isMDXComponent=!0;const yWe={toc:[]},DWe="wrapper";function MWe(t){let{components:e,...n}=t;return(0,s.kt)(DWe,(0,p.Z)({},yWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}MWe.isMDXComponent=!0;const XWe={toc:[]},_We="wrapper";function wWe(t){let{components:e,...n}=t;return(0,s.kt)(_We,(0,p.Z)({},XWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}wWe.isMDXComponent=!0;const TWe={toc:[]},CWe="wrapper";function gWe(t){let{components:e,...n}=t;return(0,s.kt)(CWe,(0,p.Z)({},TWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gWe.isMDXComponent=!0;const xWe={toc:[]},vWe="wrapper";function LWe(t){let{components:e,...n}=t;return(0,s.kt)(vWe,(0,p.Z)({},xWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}LWe.isMDXComponent=!0;const ZWe={toc:[]},bWe="wrapper";function NWe(t){let{components:e,...n}=t;return(0,s.kt)(bWe,(0,p.Z)({},ZWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}NWe.isMDXComponent=!0;const zWe={toc:[]},AWe="wrapper";function PWe(t){let{components:e,...n}=t;return(0,s.kt)(AWe,(0,p.Z)({},zWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PWe.isMDXComponent=!0;const IWe={toc:[]},WWe="wrapper";function RWe(t){let{components:e,...n}=t;return(0,s.kt)(WWe,(0,p.Z)({},IWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}RWe.isMDXComponent=!0;const SWe={toc:[]},BWe="wrapper";function GWe(t){let{components:e,...n}=t;return(0,s.kt)(BWe,(0,p.Z)({},SWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}GWe.isMDXComponent=!0;const EWe={toc:[]},OWe="wrapper";function UWe(t){let{components:e,...n}=t;return(0,s.kt)(OWe,(0,p.Z)({},EWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}UWe.isMDXComponent=!0;const FWe={toc:[]},VWe="wrapper";function qWe(t){let{components:e,...n}=t;return(0,s.kt)(VWe,(0,p.Z)({},FWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qWe.isMDXComponent=!0;const jWe={toc:[]},HWe="wrapper";function YWe(t){let{components:e,...n}=t;return(0,s.kt)(HWe,(0,p.Z)({},jWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}YWe.isMDXComponent=!0;const QWe={toc:[]},$We="wrapper";function KWe(t){let{components:e,...n}=t;return(0,s.kt)($We,(0,p.Z)({},QWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}KWe.isMDXComponent=!0;const JWe={toc:[]},tRe="wrapper";function eRe(t){let{components:e,...n}=t;return(0,s.kt)(tRe,(0,p.Z)({},JWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}eRe.isMDXComponent=!0;const nRe={toc:[]},oRe="wrapper";function pRe(t){let{components:e,...n}=t;return(0,s.kt)(oRe,(0,p.Z)({},nRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pRe.isMDXComponent=!0;const rRe={toc:[]},sRe="wrapper";function cRe(t){let{components:e,...n}=t;return(0,s.kt)(sRe,(0,p.Z)({},rRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}cRe.isMDXComponent=!0;const aRe={toc:[]},iRe="wrapper";function lRe(t){let{components:e,...n}=t;return(0,s.kt)(iRe,(0,p.Z)({},aRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lRe.isMDXComponent=!0;const uRe={toc:[]},mRe="wrapper";function dRe(t){let{components:e,...n}=t;return(0,s.kt)(mRe,(0,p.Z)({},uRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}dRe.isMDXComponent=!0;const hRe={toc:[]},fRe="wrapper";function kRe(t){let{components:e,...n}=t;return(0,s.kt)(fRe,(0,p.Z)({},hRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}kRe.isMDXComponent=!0;const yRe={toc:[]},DRe="wrapper";function MRe(t){let{components:e,...n}=t;return(0,s.kt)(DRe,(0,p.Z)({},yRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for rendering equations with LaTeX."))}MRe.isMDXComponent=!0;const XRe={toc:[]},_Re="wrapper";function wRe(t){let{components:e,...n}=t;return(0,s.kt)(_Re,(0,p.Z)({},XRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wRe.isMDXComponent=!0;const TRe={toc:[]},CRe="wrapper";function gRe(t){let{components:e,...n}=t;return(0,s.kt)(CRe,(0,p.Z)({},TRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}gRe.isMDXComponent=!0;const xRe={toc:[]},vRe="wrapper";function LRe(t){let{components:e,...n}=t;return(0,s.kt)(vRe,(0,p.Z)({},xRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}LRe.isMDXComponent=!0;const ZRe={toc:[]},bRe="wrapper";function NRe(t){let{components:e,...n}=t;return(0,s.kt)(bRe,(0,p.Z)({},ZRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NRe.isMDXComponent=!0;const zRe={toc:[]},ARe="wrapper";function PRe(t){let{components:e,...n}=t;return(0,s.kt)(ARe,(0,p.Z)({},zRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}PRe.isMDXComponent=!0;const IRe={toc:[]},WRe="wrapper";function RRe(t){let{components:e,...n}=t;return(0,s.kt)(WRe,(0,p.Z)({},IRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}RRe.isMDXComponent=!0;const SRe={toc:[]},BRe="wrapper";function GRe(t){let{components:e,...n}=t;return(0,s.kt)(BRe,(0,p.Z)({},SRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}GRe.isMDXComponent=!0;const ERe={toc:[]},ORe="wrapper";function URe(t){let{components:e,...n}=t;return(0,s.kt)(ORe,(0,p.Z)({},ERe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}URe.isMDXComponent=!0;const FRe={toc:[]},VRe="wrapper";function qRe(t){let{components:e,...n}=t;return(0,s.kt)(VRe,(0,p.Z)({},FRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}qRe.isMDXComponent=!0;const jRe={toc:[]},HRe="wrapper";function YRe(t){let{components:e,...n}=t;return(0,s.kt)(HRe,(0,p.Z)({},jRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}YRe.isMDXComponent=!0;const QRe={toc:[]},$Re="wrapper";function KRe(t){let{components:e,...n}=t;return(0,s.kt)($Re,(0,p.Z)({},QRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}KRe.isMDXComponent=!0;const JRe={toc:[]},tSe="wrapper";function eSe(t){let{components:e,...n}=t;return(0,s.kt)(tSe,(0,p.Z)({},JRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}eSe.isMDXComponent=!0;const nSe={toc:[]},oSe="wrapper";function pSe(t){let{components:e,...n}=t;return(0,s.kt)(oSe,(0,p.Z)({},nSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pSe.isMDXComponent=!0;const rSe={toc:[]},sSe="wrapper";function cSe(t){let{components:e,...n}=t;return(0,s.kt)(sSe,(0,p.Z)({},rSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}cSe.isMDXComponent=!0;const aSe={toc:[]},iSe="wrapper";function lSe(t){let{components:e,...n}=t;return(0,s.kt)(iSe,(0,p.Z)({},aSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lSe.isMDXComponent=!0;const uSe={toc:[]},mSe="wrapper";function dSe(t){let{components:e,...n}=t;return(0,s.kt)(mSe,(0,p.Z)({},uSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dSe.isMDXComponent=!0;const hSe={toc:[]},fSe="wrapper";function kSe(t){let{components:e,...n}=t;return(0,s.kt)(fSe,(0,p.Z)({},hSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kSe.isMDXComponent=!0;const ySe={toc:[]},DSe="wrapper";function MSe(t){let{components:e,...n}=t;return(0,s.kt)(DSe,(0,p.Z)({},ySe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}MSe.isMDXComponent=!0;const XSe={toc:[]},_Se="wrapper";function wSe(t){let{components:e,...n}=t;return(0,s.kt)(_Se,(0,p.Z)({},XSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}wSe.isMDXComponent=!0;const TSe={toc:[]},CSe="wrapper";function gSe(t){let{components:e,...n}=t;return(0,s.kt)(CSe,(0,p.Z)({},TSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}gSe.isMDXComponent=!0;const xSe={toc:[]},vSe="wrapper";function LSe(t){let{components:e,...n}=t;return(0,s.kt)(vSe,(0,p.Z)({},xSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}LSe.isMDXComponent=!0;const ZSe={toc:[]},bSe="wrapper";function NSe(t){let{components:e,...n}=t;return(0,s.kt)(bSe,(0,p.Z)({},ZSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}NSe.isMDXComponent=!0;const zSe={toc:[]},ASe="wrapper";function PSe(t){let{components:e,...n}=t;return(0,s.kt)(ASe,(0,p.Z)({},zSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}PSe.isMDXComponent=!0;const ISe={toc:[]},WSe="wrapper";function RSe(t){let{components:e,...n}=t;return(0,s.kt)(WSe,(0,p.Z)({},ISe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}RSe.isMDXComponent=!0;const SSe={toc:[]},BSe="wrapper";function GSe(t){let{components:e,...n}=t;return(0,s.kt)(BSe,(0,p.Z)({},SSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}GSe.isMDXComponent=!0;const ESe={toc:[]},OSe="wrapper";function USe(t){let{components:e,...n}=t;return(0,s.kt)(OSe,(0,p.Z)({},ESe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}USe.isMDXComponent=!0;const FSe={toc:[]},VSe="wrapper";function qSe(t){let{components:e,...n}=t;return(0,s.kt)(VSe,(0,p.Z)({},FSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}qSe.isMDXComponent=!0;const jSe={toc:[]},HSe="wrapper";function YSe(t){let{components:e,...n}=t;return(0,s.kt)(HSe,(0,p.Z)({},jSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}YSe.isMDXComponent=!0;const QSe={toc:[]},$Se="wrapper";function KSe(t){let{components:e,...n}=t;return(0,s.kt)($Se,(0,p.Z)({},QSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}KSe.isMDXComponent=!0;const JSe={toc:[]},tBe="wrapper";function eBe(t){let{components:e,...n}=t;return(0,s.kt)(tBe,(0,p.Z)({},JSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}eBe.isMDXComponent=!0;const nBe={toc:[]},oBe="wrapper";function pBe(t){let{components:e,...n}=t;return(0,s.kt)(oBe,(0,p.Z)({},nBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pBe.isMDXComponent=!0;const rBe={toc:[]},sBe="wrapper";function cBe(t){let{components:e,...n}=t;return(0,s.kt)(sBe,(0,p.Z)({},rBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}cBe.isMDXComponent=!0;const aBe={toc:[]},iBe="wrapper";function lBe(t){let{components:e,...n}=t;return(0,s.kt)(iBe,(0,p.Z)({},aBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}lBe.isMDXComponent=!0;const uBe={toc:[]},mBe="wrapper";function dBe(t){let{components:e,...n}=t;return(0,s.kt)(mBe,(0,p.Z)({},uBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}dBe.isMDXComponent=!0;const hBe={toc:[]},fBe="wrapper";function kBe(t){let{components:e,...n}=t;return(0,s.kt)(fBe,(0,p.Z)({},hBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}kBe.isMDXComponent=!0;const yBe={toc:[]},DBe="wrapper";function MBe(t){let{components:e,...n}=t;return(0,s.kt)(DBe,(0,p.Z)({},yBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}MBe.isMDXComponent=!0;const XBe={toc:[]},_Be="wrapper";function wBe(t){let{components:e,...n}=t;return(0,s.kt)(_Be,(0,p.Z)({},XBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}wBe.isMDXComponent=!0;const TBe={toc:[]},CBe="wrapper";function gBe(t){let{components:e,...n}=t;return(0,s.kt)(CBe,(0,p.Z)({},TBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gBe.isMDXComponent=!0;const xBe={toc:[]},vBe="wrapper";function LBe(t){let{components:e,...n}=t;return(0,s.kt)(vBe,(0,p.Z)({},xBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}LBe.isMDXComponent=!0;const ZBe={toc:[]},bBe="wrapper";function NBe(t){let{components:e,...n}=t;return(0,s.kt)(bBe,(0,p.Z)({},ZBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}NBe.isMDXComponent=!0;const zBe={toc:[]},ABe="wrapper";function PBe(t){let{components:e,...n}=t;return(0,s.kt)(ABe,(0,p.Z)({},zBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}PBe.isMDXComponent=!0;const IBe={toc:[]},WBe="wrapper";function RBe(t){let{components:e,...n}=t;return(0,s.kt)(WBe,(0,p.Z)({},IBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}RBe.isMDXComponent=!0;const SBe={toc:[]},BBe="wrapper";function GBe(t){let{components:e,...n}=t;return(0,s.kt)(BBe,(0,p.Z)({},SBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}GBe.isMDXComponent=!0;const EBe={toc:[]},OBe="wrapper";function UBe(t){let{components:e,...n}=t;return(0,s.kt)(OBe,(0,p.Z)({},EBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}UBe.isMDXComponent=!0;const FBe={toc:[]},VBe="wrapper";function qBe(t){let{components:e,...n}=t;return(0,s.kt)(VBe,(0,p.Z)({},FBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qBe.isMDXComponent=!0;const jBe={toc:[]},HBe="wrapper";function YBe(t){let{components:e,...n}=t;return(0,s.kt)(HBe,(0,p.Z)({},jBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}YBe.isMDXComponent=!0;const QBe={toc:[]},$Be="wrapper";function KBe(t){let{components:e,...n}=t;return(0,s.kt)($Be,(0,p.Z)({},QBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}KBe.isMDXComponent=!0;const JBe={toc:[]},tGe="wrapper";function eGe(t){let{components:e,...n}=t;return(0,s.kt)(tGe,(0,p.Z)({},JBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}eGe.isMDXComponent=!0;const nGe={toc:[]},oGe="wrapper";function pGe(t){let{components:e,...n}=t;return(0,s.kt)(oGe,(0,p.Z)({},nGe,n,{components:e,mdxType:"MDXLayout"}))}pGe.isMDXComponent=!0;const rGe={toc:[]},sGe="wrapper";function cGe(t){let{components:e,...n}=t;return(0,s.kt)(sGe,(0,p.Z)({},rGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cGe.isMDXComponent=!0;const aGe={toc:[]},iGe="wrapper";function lGe(t){let{components:e,...n}=t;return(0,s.kt)(iGe,(0,p.Z)({},aGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lGe.isMDXComponent=!0;const uGe={toc:[]},mGe="wrapper";function dGe(t){let{components:e,...n}=t;return(0,s.kt)(mGe,(0,p.Z)({},uGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}dGe.isMDXComponent=!0;const hGe={toc:[]},fGe="wrapper";function kGe(t){let{components:e,...n}=t;return(0,s.kt)(fGe,(0,p.Z)({},hGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}kGe.isMDXComponent=!0;const yGe={toc:[]},DGe="wrapper";function MGe(t){let{components:e,...n}=t;return(0,s.kt)(DGe,(0,p.Z)({},yGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}MGe.isMDXComponent=!0;const XGe={toc:[]},_Ge="wrapper";function wGe(t){let{components:e,...n}=t;return(0,s.kt)(_Ge,(0,p.Z)({},XGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}wGe.isMDXComponent=!0;const TGe={toc:[]},CGe="wrapper";function gGe(t){let{components:e,...n}=t;return(0,s.kt)(CGe,(0,p.Z)({},TGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}gGe.isMDXComponent=!0;const xGe={toc:[]},vGe="wrapper";function LGe(t){let{components:e,...n}=t;return(0,s.kt)(vGe,(0,p.Z)({},xGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}LGe.isMDXComponent=!0;const ZGe={toc:[]},bGe="wrapper";function NGe(t){let{components:e,...n}=t;return(0,s.kt)(bGe,(0,p.Z)({},ZGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}NGe.isMDXComponent=!0;const zGe={toc:[]},AGe="wrapper";function PGe(t){let{components:e,...n}=t;return(0,s.kt)(AGe,(0,p.Z)({},zGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}PGe.isMDXComponent=!0;const IGe={toc:[]},WGe="wrapper";function RGe(t){let{components:e,...n}=t;return(0,s.kt)(WGe,(0,p.Z)({},IGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}RGe.isMDXComponent=!0;const SGe={toc:[]},BGe="wrapper";function GGe(t){let{components:e,...n}=t;return(0,s.kt)(BGe,(0,p.Z)({},SGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}GGe.isMDXComponent=!0;const EGe={toc:[]},OGe="wrapper";function UGe(t){let{components:e,...n}=t;return(0,s.kt)(OGe,(0,p.Z)({},EGe,n,{components:e,mdxType:"MDXLayout"}))}UGe.isMDXComponent=!0;const FGe={toc:[]},VGe="wrapper";function qGe(t){let{components:e,...n}=t;return(0,s.kt)(VGe,(0,p.Z)({},FGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}qGe.isMDXComponent=!0;const jGe={toc:[]},HGe="wrapper";function YGe(t){let{components:e,...n}=t;return(0,s.kt)(HGe,(0,p.Z)({},jGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}YGe.isMDXComponent=!0;const QGe={toc:[]},$Ge="wrapper";function KGe(t){let{components:e,...n}=t;return(0,s.kt)($Ge,(0,p.Z)({},QGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KGe.isMDXComponent=!0;const JGe={toc:[]},tEe="wrapper";function eEe(t){let{components:e,...n}=t;return(0,s.kt)(tEe,(0,p.Z)({},JGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}eEe.isMDXComponent=!0;const nEe={toc:[]},oEe="wrapper";function pEe(t){let{components:e,...n}=t;return(0,s.kt)(oEe,(0,p.Z)({},nEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pEe.isMDXComponent=!0;const rEe={toc:[]},sEe="wrapper";function cEe(t){let{components:e,...n}=t;return(0,s.kt)(sEe,(0,p.Z)({},rEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cEe.isMDXComponent=!0;const aEe={toc:[]},iEe="wrapper";function lEe(t){let{components:e,...n}=t;return(0,s.kt)(iEe,(0,p.Z)({},aEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lEe.isMDXComponent=!0;const uEe={toc:[]},mEe="wrapper";function dEe(t){let{components:e,...n}=t;return(0,s.kt)(mEe,(0,p.Z)({},uEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}dEe.isMDXComponent=!0;const hEe={toc:[]},fEe="wrapper";function kEe(t){let{components:e,...n}=t;return(0,s.kt)(fEe,(0,p.Z)({},hEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kEe.isMDXComponent=!0;const yEe={toc:[]},DEe="wrapper";function MEe(t){let{components:e,...n}=t;return(0,s.kt)(DEe,(0,p.Z)({},yEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}MEe.isMDXComponent=!0;const XEe={toc:[]},_Ee="wrapper";function wEe(t){let{components:e,...n}=t;return(0,s.kt)(_Ee,(0,p.Z)({},XEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wEe.isMDXComponent=!0;const TEe={toc:[]},CEe="wrapper";function gEe(t){let{components:e,...n}=t;return(0,s.kt)(CEe,(0,p.Z)({},TEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}gEe.isMDXComponent=!0;const xEe={toc:[]},vEe="wrapper";function LEe(t){let{components:e,...n}=t;return(0,s.kt)(vEe,(0,p.Z)({},xEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LEe.isMDXComponent=!0;const ZEe={toc:[]},bEe="wrapper";function NEe(t){let{components:e,...n}=t;return(0,s.kt)(bEe,(0,p.Z)({},ZEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NEe.isMDXComponent=!0;const zEe={toc:[]},AEe="wrapper";function PEe(t){let{components:e,...n}=t;return(0,s.kt)(AEe,(0,p.Z)({},zEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}PEe.isMDXComponent=!0;const IEe={toc:[]},WEe="wrapper";function REe(t){let{components:e,...n}=t;return(0,s.kt)(WEe,(0,p.Z)({},IEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}REe.isMDXComponent=!0;const SEe={toc:[]},BEe="wrapper";function GEe(t){let{components:e,...n}=t;return(0,s.kt)(BEe,(0,p.Z)({},SEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}GEe.isMDXComponent=!0;const EEe={toc:[]},OEe="wrapper";function UEe(t){let{components:e,...n}=t;return(0,s.kt)(OEe,(0,p.Z)({},EEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}UEe.isMDXComponent=!0;const FEe={toc:[]},VEe="wrapper";function qEe(t){let{components:e,...n}=t;return(0,s.kt)(VEe,(0,p.Z)({},FEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qEe.isMDXComponent=!0;const jEe={toc:[]},HEe="wrapper";function YEe(t){let{components:e,...n}=t;return(0,s.kt)(HEe,(0,p.Z)({},jEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}YEe.isMDXComponent=!0;const QEe={toc:[]},$Ee="wrapper";function KEe(t){let{components:e,...n}=t;return(0,s.kt)($Ee,(0,p.Z)({},QEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}KEe.isMDXComponent=!0;const JEe={toc:[]},tOe="wrapper";function eOe(t){let{components:e,...n}=t;return(0,s.kt)(tOe,(0,p.Z)({},JEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}eOe.isMDXComponent=!0;const nOe={toc:[]},oOe="wrapper";function pOe(t){let{components:e,...n}=t;return(0,s.kt)(oOe,(0,p.Z)({},nOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pOe.isMDXComponent=!0;const rOe={toc:[]},sOe="wrapper";function cOe(t){let{components:e,...n}=t;return(0,s.kt)(sOe,(0,p.Z)({},rOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cOe.isMDXComponent=!0;const aOe={toc:[]},iOe="wrapper";function lOe(t){let{components:e,...n}=t;return(0,s.kt)(iOe,(0,p.Z)({},aOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}lOe.isMDXComponent=!0;const uOe={toc:[]},mOe="wrapper";function dOe(t){let{components:e,...n}=t;return(0,s.kt)(mOe,(0,p.Z)({},uOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}dOe.isMDXComponent=!0;const hOe={toc:[]},fOe="wrapper";function kOe(t){let{components:e,...n}=t;return(0,s.kt)(fOe,(0,p.Z)({},hOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kOe.isMDXComponent=!0;const yOe={toc:[]},DOe="wrapper";function MOe(t){let{components:e,...n}=t;return(0,s.kt)(DOe,(0,p.Z)({},yOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}MOe.isMDXComponent=!0;const XOe={toc:[]},_Oe="wrapper";function wOe(t){let{components:e,...n}=t;return(0,s.kt)(_Oe,(0,p.Z)({},XOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wOe.isMDXComponent=!0;const TOe={toc:[]},COe="wrapper";function gOe(t){let{components:e,...n}=t;return(0,s.kt)(COe,(0,p.Z)({},TOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gOe.isMDXComponent=!0;const xOe={toc:[]},vOe="wrapper";function LOe(t){let{components:e,...n}=t;return(0,s.kt)(vOe,(0,p.Z)({},xOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}LOe.isMDXComponent=!0;const ZOe={toc:[]},bOe="wrapper";function NOe(t){let{components:e,...n}=t;return(0,s.kt)(bOe,(0,p.Z)({},ZOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}NOe.isMDXComponent=!0;const zOe={toc:[]},AOe="wrapper";function POe(t){let{components:e,...n}=t;return(0,s.kt)(AOe,(0,p.Z)({},zOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}POe.isMDXComponent=!0;const IOe={toc:[]},WOe="wrapper";function ROe(t){let{components:e,...n}=t;return(0,s.kt)(WOe,(0,p.Z)({},IOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}ROe.isMDXComponent=!0;const SOe={toc:[]},BOe="wrapper";function GOe(t){let{components:e,...n}=t;return(0,s.kt)(BOe,(0,p.Z)({},SOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}GOe.isMDXComponent=!0;const EOe={toc:[]},OOe="wrapper";function UOe(t){let{components:e,...n}=t;return(0,s.kt)(OOe,(0,p.Z)({},EOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}UOe.isMDXComponent=!0;const FOe={toc:[]},VOe="wrapper";function qOe(t){let{components:e,...n}=t;return(0,s.kt)(VOe,(0,p.Z)({},FOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qOe.isMDXComponent=!0;const jOe={toc:[]},HOe="wrapper";function YOe(t){let{components:e,...n}=t;return(0,s.kt)(HOe,(0,p.Z)({},jOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}YOe.isMDXComponent=!0;const QOe={toc:[]},$Oe="wrapper";function KOe(t){let{components:e,...n}=t;return(0,s.kt)($Oe,(0,p.Z)({},QOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}KOe.isMDXComponent=!0;const JOe={toc:[]},tUe="wrapper";function eUe(t){let{components:e,...n}=t;return(0,s.kt)(tUe,(0,p.Z)({},JOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}eUe.isMDXComponent=!0;const nUe={toc:[]},oUe="wrapper";function pUe(t){let{components:e,...n}=t;return(0,s.kt)(oUe,(0,p.Z)({},nUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}pUe.isMDXComponent=!0;const rUe={toc:[]},sUe="wrapper";function cUe(t){let{components:e,...n}=t;return(0,s.kt)(sUe,(0,p.Z)({},rUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}cUe.isMDXComponent=!0;const aUe={toc:[]},iUe="wrapper";function lUe(t){let{components:e,...n}=t;return(0,s.kt)(iUe,(0,p.Z)({},aUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lUe.isMDXComponent=!0;const uUe={toc:[]},mUe="wrapper";function dUe(t){let{components:e,...n}=t;return(0,s.kt)(mUe,(0,p.Z)({},uUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}dUe.isMDXComponent=!0;const hUe={toc:[]},fUe="wrapper";function kUe(t){let{components:e,...n}=t;return(0,s.kt)(fUe,(0,p.Z)({},hUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kUe.isMDXComponent=!0;const yUe={toc:[]},DUe="wrapper";function MUe(t){let{components:e,...n}=t;return(0,s.kt)(DUe,(0,p.Z)({},yUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}MUe.isMDXComponent=!0;const XUe={toc:[]},_Ue="wrapper";function wUe(t){let{components:e,...n}=t;return(0,s.kt)(_Ue,(0,p.Z)({},XUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wUe.isMDXComponent=!0;const TUe={toc:[]},CUe="wrapper";function gUe(t){let{components:e,...n}=t;return(0,s.kt)(CUe,(0,p.Z)({},TUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}gUe.isMDXComponent=!0;const xUe={toc:[]},vUe="wrapper";function LUe(t){let{components:e,...n}=t;return(0,s.kt)(vUe,(0,p.Z)({},xUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}LUe.isMDXComponent=!0;const ZUe={toc:[]},bUe="wrapper";function NUe(t){let{components:e,...n}=t;return(0,s.kt)(bUe,(0,p.Z)({},ZUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}NUe.isMDXComponent=!0;const zUe={toc:[]},AUe="wrapper";function PUe(t){let{components:e,...n}=t;return(0,s.kt)(AUe,(0,p.Z)({},zUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}PUe.isMDXComponent=!0;const IUe={toc:[]},WUe="wrapper";function RUe(t){let{components:e,...n}=t;return(0,s.kt)(WUe,(0,p.Z)({},IUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}RUe.isMDXComponent=!0;const SUe={toc:[]},BUe="wrapper";function GUe(t){let{components:e,...n}=t;return(0,s.kt)(BUe,(0,p.Z)({},SUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}GUe.isMDXComponent=!0;const EUe={toc:[]},OUe="wrapper";function UUe(t){let{components:e,...n}=t;return(0,s.kt)(OUe,(0,p.Z)({},EUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}UUe.isMDXComponent=!0;const FUe={toc:[]},VUe="wrapper";function qUe(t){let{components:e,...n}=t;return(0,s.kt)(VUe,(0,p.Z)({},FUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qUe.isMDXComponent=!0;const jUe={toc:[]},HUe="wrapper";function YUe(t){let{components:e,...n}=t;return(0,s.kt)(HUe,(0,p.Z)({},jUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}YUe.isMDXComponent=!0;const QUe={toc:[]},$Ue="wrapper";function KUe(t){let{components:e,...n}=t;return(0,s.kt)($Ue,(0,p.Z)({},QUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}KUe.isMDXComponent=!0;const JUe={toc:[]},tFe="wrapper";function eFe(t){let{components:e,...n}=t;return(0,s.kt)(tFe,(0,p.Z)({},JUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eFe.isMDXComponent=!0;const nFe={toc:[]},oFe="wrapper";function pFe(t){let{components:e,...n}=t;return(0,s.kt)(oFe,(0,p.Z)({},nFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}pFe.isMDXComponent=!0;const rFe={toc:[]},sFe="wrapper";function cFe(t){let{components:e,...n}=t;return(0,s.kt)(sFe,(0,p.Z)({},rFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cFe.isMDXComponent=!0;const aFe={toc:[]},iFe="wrapper";function lFe(t){let{components:e,...n}=t;return(0,s.kt)(iFe,(0,p.Z)({},aFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lFe.isMDXComponent=!0;const uFe={toc:[]},mFe="wrapper";function dFe(t){let{components:e,...n}=t;return(0,s.kt)(mFe,(0,p.Z)({},uFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dFe.isMDXComponent=!0;const hFe={toc:[]},fFe="wrapper";function kFe(t){let{components:e,...n}=t;return(0,s.kt)(fFe,(0,p.Z)({},hFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kFe.isMDXComponent=!0;const yFe={toc:[]},DFe="wrapper";function MFe(t){let{components:e,...n}=t;return(0,s.kt)(DFe,(0,p.Z)({},yFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MFe.isMDXComponent=!0;const XFe={toc:[]},_Fe="wrapper";function wFe(t){let{components:e,...n}=t;return(0,s.kt)(_Fe,(0,p.Z)({},XFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wFe.isMDXComponent=!0;const TFe={toc:[]},CFe="wrapper";function gFe(t){let{components:e,...n}=t;return(0,s.kt)(CFe,(0,p.Z)({},TFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gFe.isMDXComponent=!0;const xFe={toc:[]},vFe="wrapper";function LFe(t){let{components:e,...n}=t;return(0,s.kt)(vFe,(0,p.Z)({},xFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}LFe.isMDXComponent=!0;const ZFe={toc:[]},bFe="wrapper";function NFe(t){let{components:e,...n}=t;return(0,s.kt)(bFe,(0,p.Z)({},ZFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NFe.isMDXComponent=!0;const zFe={toc:[]},AFe="wrapper";function PFe(t){let{components:e,...n}=t;return(0,s.kt)(AFe,(0,p.Z)({},zFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}PFe.isMDXComponent=!0;const IFe={toc:[]},WFe="wrapper";function RFe(t){let{components:e,...n}=t;return(0,s.kt)(WFe,(0,p.Z)({},IFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}RFe.isMDXComponent=!0;const SFe={toc:[]},BFe="wrapper";function GFe(t){let{components:e,...n}=t;return(0,s.kt)(BFe,(0,p.Z)({},SFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}GFe.isMDXComponent=!0;const EFe={toc:[]},OFe="wrapper";function UFe(t){let{components:e,...n}=t;return(0,s.kt)(OFe,(0,p.Z)({},EFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}UFe.isMDXComponent=!0;const FFe={toc:[]},VFe="wrapper";function qFe(t){let{components:e,...n}=t;return(0,s.kt)(VFe,(0,p.Z)({},FFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qFe.isMDXComponent=!0;const jFe={toc:[]},HFe="wrapper";function YFe(t){let{components:e,...n}=t;return(0,s.kt)(HFe,(0,p.Z)({},jFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}YFe.isMDXComponent=!0;const QFe={toc:[]},$Fe="wrapper";function KFe(t){let{components:e,...n}=t;return(0,s.kt)($Fe,(0,p.Z)({},QFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}KFe.isMDXComponent=!0;const JFe={toc:[]},tVe="wrapper";function eVe(t){let{components:e,...n}=t;return(0,s.kt)(tVe,(0,p.Z)({},JFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}eVe.isMDXComponent=!0;const nVe={toc:[]},oVe="wrapper";function pVe(t){let{components:e,...n}=t;return(0,s.kt)(oVe,(0,p.Z)({},nVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}pVe.isMDXComponent=!0;const rVe={toc:[]},sVe="wrapper";function cVe(t){let{components:e,...n}=t;return(0,s.kt)(sVe,(0,p.Z)({},rVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}cVe.isMDXComponent=!0;const aVe={toc:[]},iVe="wrapper";function lVe(t){let{components:e,...n}=t;return(0,s.kt)(iVe,(0,p.Z)({},aVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}lVe.isMDXComponent=!0;const uVe={toc:[]},mVe="wrapper";function dVe(t){let{components:e,...n}=t;return(0,s.kt)(mVe,(0,p.Z)({},uVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}dVe.isMDXComponent=!0;const hVe={toc:[]},fVe="wrapper";function kVe(t){let{components:e,...n}=t;return(0,s.kt)(fVe,(0,p.Z)({},hVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kVe.isMDXComponent=!0;const yVe={toc:[]},DVe="wrapper";function MVe(t){let{components:e,...n}=t;return(0,s.kt)(DVe,(0,p.Z)({},yVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}MVe.isMDXComponent=!0;const XVe={toc:[]},_Ve="wrapper";function wVe(t){let{components:e,...n}=t;return(0,s.kt)(_Ve,(0,p.Z)({},XVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wVe.isMDXComponent=!0;const TVe={toc:[]},CVe="wrapper";function gVe(t){let{components:e,...n}=t;return(0,s.kt)(CVe,(0,p.Z)({},TVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}gVe.isMDXComponent=!0;const xVe={toc:[]},vVe="wrapper";function LVe(t){let{components:e,...n}=t;return(0,s.kt)(vVe,(0,p.Z)({},xVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}LVe.isMDXComponent=!0;const ZVe={toc:[]},bVe="wrapper";function NVe(t){let{components:e,...n}=t;return(0,s.kt)(bVe,(0,p.Z)({},ZVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}NVe.isMDXComponent=!0;const zVe={toc:[]},AVe="wrapper";function PVe(t){let{components:e,...n}=t;return(0,s.kt)(AVe,(0,p.Z)({},zVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}PVe.isMDXComponent=!0;const IVe={toc:[]},WVe="wrapper";function RVe(t){let{components:e,...n}=t;return(0,s.kt)(WVe,(0,p.Z)({},IVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}RVe.isMDXComponent=!0;const SVe={toc:[]},BVe="wrapper";function GVe(t){let{components:e,...n}=t;return(0,s.kt)(BVe,(0,p.Z)({},SVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}GVe.isMDXComponent=!0;const EVe={toc:[]},OVe="wrapper";function UVe(t){let{components:e,...n}=t;return(0,s.kt)(OVe,(0,p.Z)({},EVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}UVe.isMDXComponent=!0;const FVe={toc:[]},VVe="wrapper";function qVe(t){let{components:e,...n}=t;return(0,s.kt)(VVe,(0,p.Z)({},FVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qVe.isMDXComponent=!0;const jVe={toc:[]},HVe="wrapper";function YVe(t){let{components:e,...n}=t;return(0,s.kt)(HVe,(0,p.Z)({},jVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}YVe.isMDXComponent=!0;const QVe={toc:[]},$Ve="wrapper";function KVe(t){let{components:e,...n}=t;return(0,s.kt)($Ve,(0,p.Z)({},QVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}KVe.isMDXComponent=!0;const JVe={toc:[]},tqe="wrapper";function eqe(t){let{components:e,...n}=t;return(0,s.kt)(tqe,(0,p.Z)({},JVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}eqe.isMDXComponent=!0;const nqe={toc:[]},oqe="wrapper";function pqe(t){let{components:e,...n}=t;return(0,s.kt)(oqe,(0,p.Z)({},nqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pqe.isMDXComponent=!0;const rqe={toc:[]},sqe="wrapper";function cqe(t){let{components:e,...n}=t;return(0,s.kt)(sqe,(0,p.Z)({},rqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cqe.isMDXComponent=!0;const aqe={toc:[]},iqe="wrapper";function lqe(t){let{components:e,...n}=t;return(0,s.kt)(iqe,(0,p.Z)({},aqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lqe.isMDXComponent=!0;const uqe={toc:[]},mqe="wrapper";function dqe(t){let{components:e,...n}=t;return(0,s.kt)(mqe,(0,p.Z)({},uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dqe.isMDXComponent=!0;const hqe={toc:[]},fqe="wrapper";function kqe(t){let{components:e,...n}=t;return(0,s.kt)(fqe,(0,p.Z)({},hqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kqe.isMDXComponent=!0;const yqe={toc:[]},Dqe="wrapper";function Mqe(t){let{components:e,...n}=t;return(0,s.kt)(Dqe,(0,p.Z)({},yqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Mqe.isMDXComponent=!0;const Xqe={toc:[]},_qe="wrapper";function wqe(t){let{components:e,...n}=t;return(0,s.kt)(_qe,(0,p.Z)({},Xqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wqe.isMDXComponent=!0;const Tqe={toc:[]},Cqe="wrapper";function gqe(t){let{components:e,...n}=t;return(0,s.kt)(Cqe,(0,p.Z)({},Tqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}gqe.isMDXComponent=!0;const xqe={toc:[]},vqe="wrapper";function Lqe(t){let{components:e,...n}=t;return(0,s.kt)(vqe,(0,p.Z)({},xqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Lqe.isMDXComponent=!0;const Zqe={toc:[]},bqe="wrapper";function Nqe(t){let{components:e,...n}=t;return(0,s.kt)(bqe,(0,p.Z)({},Zqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Nqe.isMDXComponent=!0;const zqe={toc:[]},Aqe="wrapper";function Pqe(t){let{components:e,...n}=t;return(0,s.kt)(Aqe,(0,p.Z)({},zqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Pqe.isMDXComponent=!0;const Iqe={toc:[]},Wqe="wrapper";function Rqe(t){let{components:e,...n}=t;return(0,s.kt)(Wqe,(0,p.Z)({},Iqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Rqe.isMDXComponent=!0;const Sqe={toc:[]},Bqe="wrapper";function Gqe(t){let{components:e,...n}=t;return(0,s.kt)(Bqe,(0,p.Z)({},Sqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Gqe.isMDXComponent=!0;const Eqe={toc:[]},Oqe="wrapper";function Uqe(t){let{components:e,...n}=t;return(0,s.kt)(Oqe,(0,p.Z)({},Eqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Uqe.isMDXComponent=!0;const Fqe={toc:[]},Vqe="wrapper";function qqe(t){let{components:e,...n}=t;return(0,s.kt)(Vqe,(0,p.Z)({},Fqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qqe.isMDXComponent=!0;const jqe={toc:[]},Hqe="wrapper";function Yqe(t){let{components:e,...n}=t;return(0,s.kt)(Hqe,(0,p.Z)({},jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Yqe.isMDXComponent=!0;const Qqe={toc:[]},$qe="wrapper";function Kqe(t){let{components:e,...n}=t;return(0,s.kt)($qe,(0,p.Z)({},Qqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Kqe.isMDXComponent=!0;const Jqe={toc:[]},tje="wrapper";function eje(t){let{components:e,...n}=t;return(0,s.kt)(tje,(0,p.Z)({},Jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}eje.isMDXComponent=!0;const nje={toc:[]},oje="wrapper";function pje(t){let{components:e,...n}=t;return(0,s.kt)(oje,(0,p.Z)({},nje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pje.isMDXComponent=!0;const rje={toc:[]},sje="wrapper";function cje(t){let{components:e,...n}=t;return(0,s.kt)(sje,(0,p.Z)({},rje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}cje.isMDXComponent=!0;const aje={toc:[]},ije="wrapper";function lje(t){let{components:e,...n}=t;return(0,s.kt)(ije,(0,p.Z)({},aje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lje.isMDXComponent=!0;const uje={toc:[]},mje="wrapper";function dje(t){let{components:e,...n}=t;return(0,s.kt)(mje,(0,p.Z)({},uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dje.isMDXComponent=!0;const hje={toc:[]},fje="wrapper";function kje(t){let{components:e,...n}=t;return(0,s.kt)(fje,(0,p.Z)({},hje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kje.isMDXComponent=!0;const yje={toc:[]},Dje="wrapper";function Mje(t){let{components:e,...n}=t;return(0,s.kt)(Dje,(0,p.Z)({},yje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Mje.isMDXComponent=!0;const Xje={toc:[]},_je="wrapper";function wje(t){let{components:e,...n}=t;return(0,s.kt)(_je,(0,p.Z)({},Xje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wje.isMDXComponent=!0;const Tje={toc:[]},Cje="wrapper";function gje(t){let{components:e,...n}=t;return(0,s.kt)(Cje,(0,p.Z)({},Tje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gje.isMDXComponent=!0;const xje={toc:[]},vje="wrapper";function Lje(t){let{components:e,...n}=t;return(0,s.kt)(vje,(0,p.Z)({},xje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Lje.isMDXComponent=!0;const Zje={toc:[]},bje="wrapper";function Nje(t){let{components:e,...n}=t;return(0,s.kt)(bje,(0,p.Z)({},Zje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Nje.isMDXComponent=!0;const zje={toc:[]},Aje="wrapper";function Pje(t){let{components:e,...n}=t;return(0,s.kt)(Aje,(0,p.Z)({},zje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Pje.isMDXComponent=!0;const Ije={toc:[]},Wje="wrapper";function Rje(t){let{components:e,...n}=t;return(0,s.kt)(Wje,(0,p.Z)({},Ije,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Rje.isMDXComponent=!0;const Sje={toc:[]},Bje="wrapper";function Gje(t){let{components:e,...n}=t;return(0,s.kt)(Bje,(0,p.Z)({},Sje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Gje.isMDXComponent=!0;const Eje={toc:[]},Oje="wrapper";function Uje(t){let{components:e,...n}=t;return(0,s.kt)(Oje,(0,p.Z)({},Eje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Uje.isMDXComponent=!0;const Fje={toc:[]},Vje="wrapper";function qje(t){let{components:e,...n}=t;return(0,s.kt)(Vje,(0,p.Z)({},Fje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}qje.isMDXComponent=!0;const jje={toc:[]},Hje="wrapper";function Yje(t){let{components:e,...n}=t;return(0,s.kt)(Hje,(0,p.Z)({},jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}Yje.isMDXComponent=!0;const Qje={toc:[]},$je="wrapper";function Kje(t){let{components:e,...n}=t;return(0,s.kt)($je,(0,p.Z)({},Qje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Kje.isMDXComponent=!0;const Jje={toc:[]},tHe="wrapper";function eHe(t){let{components:e,...n}=t;return(0,s.kt)(tHe,(0,p.Z)({},Jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}eHe.isMDXComponent=!0;const nHe={toc:[]},oHe="wrapper";function pHe(t){let{components:e,...n}=t;return(0,s.kt)(oHe,(0,p.Z)({},nHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}pHe.isMDXComponent=!0;const rHe={toc:[]},sHe="wrapper";function cHe(t){let{components:e,...n}=t;return(0,s.kt)(sHe,(0,p.Z)({},rHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}cHe.isMDXComponent=!0;const aHe={toc:[]},iHe="wrapper";function lHe(t){let{components:e,...n}=t;return(0,s.kt)(iHe,(0,p.Z)({},aHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lHe.isMDXComponent=!0;const uHe={toc:[]},mHe="wrapper";function dHe(t){let{components:e,...n}=t;return(0,s.kt)(mHe,(0,p.Z)({},uHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}dHe.isMDXComponent=!0;const hHe={toc:[]},fHe="wrapper";function kHe(t){let{components:e,...n}=t;return(0,s.kt)(fHe,(0,p.Z)({},hHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}kHe.isMDXComponent=!0;const yHe={toc:[]},DHe="wrapper";function MHe(t){let{components:e,...n}=t;return(0,s.kt)(DHe,(0,p.Z)({},yHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}MHe.isMDXComponent=!0;const XHe={toc:[]},_He="wrapper";function wHe(t){let{components:e,...n}=t;return(0,s.kt)(_He,(0,p.Z)({},XHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wHe.isMDXComponent=!0;const THe={toc:[]},CHe="wrapper";function gHe(t){let{components:e,...n}=t;return(0,s.kt)(CHe,(0,p.Z)({},THe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gHe.isMDXComponent=!0;const xHe={toc:[]},vHe="wrapper";function LHe(t){let{components:e,...n}=t;return(0,s.kt)(vHe,(0,p.Z)({},xHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}LHe.isMDXComponent=!0;const ZHe={toc:[]},bHe="wrapper";function NHe(t){let{components:e,...n}=t;return(0,s.kt)(bHe,(0,p.Z)({},ZHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}NHe.isMDXComponent=!0;const zHe={toc:[]},AHe="wrapper";function PHe(t){let{components:e,...n}=t;return(0,s.kt)(AHe,(0,p.Z)({},zHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}PHe.isMDXComponent=!0;const IHe={toc:[]},WHe="wrapper";function RHe(t){let{components:e,...n}=t;return(0,s.kt)(WHe,(0,p.Z)({},IHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}RHe.isMDXComponent=!0;const SHe={toc:[]},BHe="wrapper";function GHe(t){let{components:e,...n}=t;return(0,s.kt)(BHe,(0,p.Z)({},SHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}GHe.isMDXComponent=!0;const EHe={toc:[]},OHe="wrapper";function UHe(t){let{components:e,...n}=t;return(0,s.kt)(OHe,(0,p.Z)({},EHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}UHe.isMDXComponent=!0;const FHe={toc:[]},VHe="wrapper";function qHe(t){let{components:e,...n}=t;return(0,s.kt)(VHe,(0,p.Z)({},FHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}qHe.isMDXComponent=!0;const jHe={toc:[]},HHe="wrapper";function YHe(t){let{components:e,...n}=t;return(0,s.kt)(HHe,(0,p.Z)({},jHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}YHe.isMDXComponent=!0;const QHe={toc:[]},$He="wrapper";function KHe(t){let{components:e,...n}=t;return(0,s.kt)($He,(0,p.Z)({},QHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}KHe.isMDXComponent=!0;const JHe={toc:[]},tYe="wrapper";function eYe(t){let{components:e,...n}=t;return(0,s.kt)(tYe,(0,p.Z)({},JHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eYe.isMDXComponent=!0;const nYe={toc:[]},oYe="wrapper";function pYe(t){let{components:e,...n}=t;return(0,s.kt)(oYe,(0,p.Z)({},nYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pYe.isMDXComponent=!0;const rYe={toc:[]},sYe="wrapper";function cYe(t){let{components:e,...n}=t;return(0,s.kt)(sYe,(0,p.Z)({},rYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}cYe.isMDXComponent=!0;const aYe={toc:[]},iYe="wrapper";function lYe(t){let{components:e,...n}=t;return(0,s.kt)(iYe,(0,p.Z)({},aYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}lYe.isMDXComponent=!0;const uYe={toc:[]},mYe="wrapper";function dYe(t){let{components:e,...n}=t;return(0,s.kt)(mYe,(0,p.Z)({},uYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}dYe.isMDXComponent=!0;const hYe={toc:[]},fYe="wrapper";function kYe(t){let{components:e,...n}=t;return(0,s.kt)(fYe,(0,p.Z)({},hYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}kYe.isMDXComponent=!0;const yYe={toc:[]},DYe="wrapper";function MYe(t){let{components:e,...n}=t;return(0,s.kt)(DYe,(0,p.Z)({},yYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}MYe.isMDXComponent=!0;const XYe={toc:[]},_Ye="wrapper";function wYe(t){let{components:e,...n}=t;return(0,s.kt)(_Ye,(0,p.Z)({},XYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wYe.isMDXComponent=!0;const TYe={toc:[]},CYe="wrapper";function gYe(t){let{components:e,...n}=t;return(0,s.kt)(CYe,(0,p.Z)({},TYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gYe.isMDXComponent=!0;const xYe={toc:[]},vYe="wrapper";function LYe(t){let{components:e,...n}=t;return(0,s.kt)(vYe,(0,p.Z)({},xYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}LYe.isMDXComponent=!0;const ZYe={toc:[]},bYe="wrapper";function NYe(t){let{components:e,...n}=t;return(0,s.kt)(bYe,(0,p.Z)({},ZYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}NYe.isMDXComponent=!0;const zYe={toc:[]},AYe="wrapper";function PYe(t){let{components:e,...n}=t;return(0,s.kt)(AYe,(0,p.Z)({},zYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}PYe.isMDXComponent=!0;const IYe={toc:[]},WYe="wrapper";function RYe(t){let{components:e,...n}=t;return(0,s.kt)(WYe,(0,p.Z)({},IYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}RYe.isMDXComponent=!0;const SYe={toc:[]},BYe="wrapper";function GYe(t){let{components:e,...n}=t;return(0,s.kt)(BYe,(0,p.Z)({},SYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}GYe.isMDXComponent=!0;const EYe={toc:[]},OYe="wrapper";function UYe(t){let{components:e,...n}=t;return(0,s.kt)(OYe,(0,p.Z)({},EYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}UYe.isMDXComponent=!0;const FYe={toc:[]},VYe="wrapper";function qYe(t){let{components:e,...n}=t;return(0,s.kt)(VYe,(0,p.Z)({},FYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}qYe.isMDXComponent=!0;const jYe={toc:[]},HYe="wrapper";function YYe(t){let{components:e,...n}=t;return(0,s.kt)(HYe,(0,p.Z)({},jYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}YYe.isMDXComponent=!0;const QYe={toc:[]},$Ye="wrapper";function KYe(t){let{components:e,...n}=t;return(0,s.kt)($Ye,(0,p.Z)({},QYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}KYe.isMDXComponent=!0;const JYe={toc:[]},tQe="wrapper";function eQe(t){let{components:e,...n}=t;return(0,s.kt)(tQe,(0,p.Z)({},JYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}eQe.isMDXComponent=!0;const nQe={toc:[]},oQe="wrapper";function pQe(t){let{components:e,...n}=t;return(0,s.kt)(oQe,(0,p.Z)({},nQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}pQe.isMDXComponent=!0;const rQe={toc:[]},sQe="wrapper";function cQe(t){let{components:e,...n}=t;return(0,s.kt)(sQe,(0,p.Z)({},rQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}cQe.isMDXComponent=!0;const aQe={toc:[]},iQe="wrapper";function lQe(t){let{components:e,...n}=t;return(0,s.kt)(iQe,(0,p.Z)({},aQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lQe.isMDXComponent=!0;const uQe={toc:[]},mQe="wrapper";function dQe(t){let{components:e,...n}=t;return(0,s.kt)(mQe,(0,p.Z)({},uQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dQe.isMDXComponent=!0;const hQe={toc:[]},fQe="wrapper";function kQe(t){let{components:e,...n}=t;return(0,s.kt)(fQe,(0,p.Z)({},hQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kQe.isMDXComponent=!0;const yQe={toc:[]},DQe="wrapper";function MQe(t){let{components:e,...n}=t;return(0,s.kt)(DQe,(0,p.Z)({},yQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}MQe.isMDXComponent=!0;const XQe={toc:[]},_Qe="wrapper";function wQe(t){let{components:e,...n}=t;return(0,s.kt)(_Qe,(0,p.Z)({},XQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}wQe.isMDXComponent=!0;const TQe={toc:[]},CQe="wrapper";function gQe(t){let{components:e,...n}=t;return(0,s.kt)(CQe,(0,p.Z)({},TQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gQe.isMDXComponent=!0;const xQe={toc:[]},vQe="wrapper";function LQe(t){let{components:e,...n}=t;return(0,s.kt)(vQe,(0,p.Z)({},xQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}LQe.isMDXComponent=!0;const ZQe={toc:[]},bQe="wrapper";function NQe(t){let{components:e,...n}=t;return(0,s.kt)(bQe,(0,p.Z)({},ZQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}NQe.isMDXComponent=!0;const zQe={toc:[]},AQe="wrapper";function PQe(t){let{components:e,...n}=t;return(0,s.kt)(AQe,(0,p.Z)({},zQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}PQe.isMDXComponent=!0;const IQe={toc:[]},WQe="wrapper";function RQe(t){let{components:e,...n}=t;return(0,s.kt)(WQe,(0,p.Z)({},IQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}RQe.isMDXComponent=!0;const SQe={toc:[]},BQe="wrapper";function GQe(t){let{components:e,...n}=t;return(0,s.kt)(BQe,(0,p.Z)({},SQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}GQe.isMDXComponent=!0;const EQe={toc:[]},OQe="wrapper";function UQe(t){let{components:e,...n}=t;return(0,s.kt)(OQe,(0,p.Z)({},EQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}UQe.isMDXComponent=!0;const FQe={toc:[]},VQe="wrapper";function qQe(t){let{components:e,...n}=t;return(0,s.kt)(VQe,(0,p.Z)({},FQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}qQe.isMDXComponent=!0;const jQe={toc:[]},HQe="wrapper";function YQe(t){let{components:e,...n}=t;return(0,s.kt)(HQe,(0,p.Z)({},jQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}YQe.isMDXComponent=!0;const QQe={toc:[]},$Qe="wrapper";function KQe(t){let{components:e,...n}=t;return(0,s.kt)($Qe,(0,p.Z)({},QQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}KQe.isMDXComponent=!0;const JQe={toc:[]},t$e="wrapper";function e$e(t){let{components:e,...n}=t;return(0,s.kt)(t$e,(0,p.Z)({},JQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}e$e.isMDXComponent=!0;const n$e={toc:[]},o$e="wrapper";function p$e(t){let{components:e,...n}=t;return(0,s.kt)(o$e,(0,p.Z)({},n$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}p$e.isMDXComponent=!0;const r$e={toc:[]},s$e="wrapper";function c$e(t){let{components:e,...n}=t;return(0,s.kt)(s$e,(0,p.Z)({},r$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}c$e.isMDXComponent=!0;const a$e={toc:[]},i$e="wrapper";function l$e(t){let{components:e,...n}=t;return(0,s.kt)(i$e,(0,p.Z)({},a$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}l$e.isMDXComponent=!0;const u$e={toc:[]},m$e="wrapper";function d$e(t){let{components:e,...n}=t;return(0,s.kt)(m$e,(0,p.Z)({},u$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}d$e.isMDXComponent=!0;const h$e={toc:[]},f$e="wrapper";function k$e(t){let{components:e,...n}=t;return(0,s.kt)(f$e,(0,p.Z)({},h$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}k$e.isMDXComponent=!0;const y$e={toc:[]},D$e="wrapper";function M$e(t){let{components:e,...n}=t;return(0,s.kt)(D$e,(0,p.Z)({},y$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}M$e.isMDXComponent=!0;const X$e={toc:[]},_$e="wrapper";function w$e(t){let{components:e,...n}=t;return(0,s.kt)(_$e,(0,p.Z)({},X$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}w$e.isMDXComponent=!0;const T$e={toc:[]},C$e="wrapper";function g$e(t){let{components:e,...n}=t;return(0,s.kt)(C$e,(0,p.Z)({},T$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}g$e.isMDXComponent=!0;const x$e={toc:[]},v$e="wrapper";function L$e(t){let{components:e,...n}=t;return(0,s.kt)(v$e,(0,p.Z)({},x$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}L$e.isMDXComponent=!0;const Z$e={toc:[]},b$e="wrapper";function N$e(t){let{components:e,...n}=t;return(0,s.kt)(b$e,(0,p.Z)({},Z$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}N$e.isMDXComponent=!0;const z$e={toc:[]},A$e="wrapper";function P$e(t){let{components:e,...n}=t;return(0,s.kt)(A$e,(0,p.Z)({},z$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}P$e.isMDXComponent=!0;const I$e={toc:[]},W$e="wrapper";function R$e(t){let{components:e,...n}=t;return(0,s.kt)(W$e,(0,p.Z)({},I$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}R$e.isMDXComponent=!0;const S$e={toc:[]},B$e="wrapper";function G$e(t){let{components:e,...n}=t;return(0,s.kt)(B$e,(0,p.Z)({},S$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}G$e.isMDXComponent=!0;const E$e={toc:[]},O$e="wrapper";function U$e(t){let{components:e,...n}=t;return(0,s.kt)(O$e,(0,p.Z)({},E$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}U$e.isMDXComponent=!0;const F$e={toc:[]},V$e="wrapper";function q$e(t){let{components:e,...n}=t;return(0,s.kt)(V$e,(0,p.Z)({},F$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}q$e.isMDXComponent=!0;const j$e={toc:[]},H$e="wrapper";function Y$e(t){let{components:e,...n}=t;return(0,s.kt)(H$e,(0,p.Z)({},j$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Y$e.isMDXComponent=!0;const Q$e={toc:[]},$$e="wrapper";function K$e(t){let{components:e,...n}=t;return(0,s.kt)($$e,(0,p.Z)({},Q$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}K$e.isMDXComponent=!0;const J$e={toc:[]},tKe="wrapper";function eKe(t){let{components:e,...n}=t;return(0,s.kt)(tKe,(0,p.Z)({},J$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}eKe.isMDXComponent=!0;const nKe={toc:[]},oKe="wrapper";function pKe(t){let{components:e,...n}=t;return(0,s.kt)(oKe,(0,p.Z)({},nKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pKe.isMDXComponent=!0;const rKe={toc:[]},sKe="wrapper";function cKe(t){let{components:e,...n}=t;return(0,s.kt)(sKe,(0,p.Z)({},rKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}cKe.isMDXComponent=!0;const aKe={toc:[]},iKe="wrapper";function lKe(t){let{components:e,...n}=t;return(0,s.kt)(iKe,(0,p.Z)({},aKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lKe.isMDXComponent=!0;const uKe={toc:[]},mKe="wrapper";function dKe(t){let{components:e,...n}=t;return(0,s.kt)(mKe,(0,p.Z)({},uKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}dKe.isMDXComponent=!0;const hKe={toc:[]},fKe="wrapper";function kKe(t){let{components:e,...n}=t;return(0,s.kt)(fKe,(0,p.Z)({},hKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kKe.isMDXComponent=!0;const yKe={toc:[]},DKe="wrapper";function MKe(t){let{components:e,...n}=t;return(0,s.kt)(DKe,(0,p.Z)({},yKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}MKe.isMDXComponent=!0;const XKe={toc:[]},_Ke="wrapper";function wKe(t){let{components:e,...n}=t;return(0,s.kt)(_Ke,(0,p.Z)({},XKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wKe.isMDXComponent=!0;const TKe={toc:[]},CKe="wrapper";function gKe(t){let{components:e,...n}=t;return(0,s.kt)(CKe,(0,p.Z)({},TKe,n,{components:e,mdxType:"MDXLayout"}))}gKe.isMDXComponent=!0;const xKe={toc:[]},vKe="wrapper";function LKe(t){let{components:e,...n}=t;return(0,s.kt)(vKe,(0,p.Z)({},xKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}LKe.isMDXComponent=!0;const ZKe={toc:[]},bKe="wrapper";function NKe(t){let{components:e,...n}=t;return(0,s.kt)(bKe,(0,p.Z)({},ZKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}NKe.isMDXComponent=!0;const zKe={toc:[]},AKe="wrapper";function PKe(t){let{components:e,...n}=t;return(0,s.kt)(AKe,(0,p.Z)({},zKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}PKe.isMDXComponent=!0;const IKe={toc:[]},WKe="wrapper";function RKe(t){let{components:e,...n}=t;return(0,s.kt)(WKe,(0,p.Z)({},IKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}RKe.isMDXComponent=!0;const SKe={toc:[]},BKe="wrapper";function GKe(t){let{components:e,...n}=t;return(0,s.kt)(BKe,(0,p.Z)({},SKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}GKe.isMDXComponent=!0;const EKe={toc:[]},OKe="wrapper";function UKe(t){let{components:e,...n}=t;return(0,s.kt)(OKe,(0,p.Z)({},EKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}UKe.isMDXComponent=!0;const FKe={toc:[]},VKe="wrapper";function qKe(t){let{components:e,...n}=t;return(0,s.kt)(VKe,(0,p.Z)({},FKe,n,{components:e,mdxType:"MDXLayout"}))}qKe.isMDXComponent=!0;const jKe={toc:[]},HKe="wrapper";function YKe(t){let{components:e,...n}=t;return(0,s.kt)(HKe,(0,p.Z)({},jKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}YKe.isMDXComponent=!0;const QKe={toc:[]},$Ke="wrapper";function KKe(t){let{components:e,...n}=t;return(0,s.kt)($Ke,(0,p.Z)({},QKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}KKe.isMDXComponent=!0;const JKe={toc:[]},tJe="wrapper";function eJe(t){let{components:e,...n}=t;return(0,s.kt)(tJe,(0,p.Z)({},JKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}eJe.isMDXComponent=!0;const nJe={toc:[]},oJe="wrapper";function pJe(t){let{components:e,...n}=t;return(0,s.kt)(oJe,(0,p.Z)({},nJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pJe.isMDXComponent=!0;const rJe={toc:[]},sJe="wrapper";function cJe(t){let{components:e,...n}=t;return(0,s.kt)(sJe,(0,p.Z)({},rJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}cJe.isMDXComponent=!0;const aJe={toc:[]},iJe="wrapper";function lJe(t){let{components:e,...n}=t;return(0,s.kt)(iJe,(0,p.Z)({},aJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lJe.isMDXComponent=!0;const uJe={toc:[]},mJe="wrapper";function dJe(t){let{components:e,...n}=t;return(0,s.kt)(mJe,(0,p.Z)({},uJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}dJe.isMDXComponent=!0;const hJe={toc:[]},fJe="wrapper";function kJe(t){let{components:e,...n}=t;return(0,s.kt)(fJe,(0,p.Z)({},hJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kJe.isMDXComponent=!0;const yJe={toc:[]},DJe="wrapper";function MJe(t){let{components:e,...n}=t;return(0,s.kt)(DJe,(0,p.Z)({},yJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}MJe.isMDXComponent=!0;const XJe={toc:[]},_Je="wrapper";function wJe(t){let{components:e,...n}=t;return(0,s.kt)(_Je,(0,p.Z)({},XJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}wJe.isMDXComponent=!0;const TJe={toc:[]},CJe="wrapper";function gJe(t){let{components:e,...n}=t;return(0,s.kt)(CJe,(0,p.Z)({},TJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}gJe.isMDXComponent=!0;const xJe={toc:[]},vJe="wrapper";function LJe(t){let{components:e,...n}=t;return(0,s.kt)(vJe,(0,p.Z)({},xJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}LJe.isMDXComponent=!0;const ZJe={toc:[]},bJe="wrapper";function NJe(t){let{components:e,...n}=t;return(0,s.kt)(bJe,(0,p.Z)({},ZJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}NJe.isMDXComponent=!0;const zJe={toc:[]},AJe="wrapper";function PJe(t){let{components:e,...n}=t;return(0,s.kt)(AJe,(0,p.Z)({},zJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}PJe.isMDXComponent=!0;const IJe={toc:[]},WJe="wrapper";function RJe(t){let{components:e,...n}=t;return(0,s.kt)(WJe,(0,p.Z)({},IJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}RJe.isMDXComponent=!0;const SJe={toc:[]},BJe="wrapper";function GJe(t){let{components:e,...n}=t;return(0,s.kt)(BJe,(0,p.Z)({},SJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}GJe.isMDXComponent=!0;const EJe={toc:[]},OJe="wrapper";function UJe(t){let{components:e,...n}=t;return(0,s.kt)(OJe,(0,p.Z)({},EJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}UJe.isMDXComponent=!0;const FJe={toc:[]},VJe="wrapper";function qJe(t){let{components:e,...n}=t;return(0,s.kt)(VJe,(0,p.Z)({},FJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qJe.isMDXComponent=!0;const jJe={toc:[]},HJe="wrapper";function YJe(t){let{components:e,...n}=t;return(0,s.kt)(HJe,(0,p.Z)({},jJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}YJe.isMDXComponent=!0;const QJe={toc:[]},$Je="wrapper";function KJe(t){let{components:e,...n}=t;return(0,s.kt)($Je,(0,p.Z)({},QJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}KJe.isMDXComponent=!0;const JJe={toc:[]},t0e="wrapper";function e0e(t){let{components:e,...n}=t;return(0,s.kt)(t0e,(0,p.Z)({},JJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}e0e.isMDXComponent=!0;const n0e={toc:[]},o0e="wrapper";function p0e(t){let{components:e,...n}=t;return(0,s.kt)(o0e,(0,p.Z)({},n0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}p0e.isMDXComponent=!0;const r0e={toc:[]},s0e="wrapper";function c0e(t){let{components:e,...n}=t;return(0,s.kt)(s0e,(0,p.Z)({},r0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}c0e.isMDXComponent=!0;const a0e={toc:[]},i0e="wrapper";function l0e(t){let{components:e,...n}=t;return(0,s.kt)(i0e,(0,p.Z)({},a0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}l0e.isMDXComponent=!0;const u0e={toc:[]},m0e="wrapper";function d0e(t){let{components:e,...n}=t;return(0,s.kt)(m0e,(0,p.Z)({},u0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}d0e.isMDXComponent=!0;const h0e={toc:[]},f0e="wrapper";function k0e(t){let{components:e,...n}=t;return(0,s.kt)(f0e,(0,p.Z)({},h0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}k0e.isMDXComponent=!0;const y0e={toc:[]},D0e="wrapper";function M0e(t){let{components:e,...n}=t;return(0,s.kt)(D0e,(0,p.Z)({},y0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}M0e.isMDXComponent=!0;const X0e={toc:[]},_0e="wrapper";function w0e(t){let{components:e,...n}=t;return(0,s.kt)(_0e,(0,p.Z)({},X0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}w0e.isMDXComponent=!0;const T0e={toc:[]},C0e="wrapper";function g0e(t){let{components:e,...n}=t;return(0,s.kt)(C0e,(0,p.Z)({},T0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}g0e.isMDXComponent=!0;const x0e={toc:[]},v0e="wrapper";function L0e(t){let{components:e,...n}=t;return(0,s.kt)(v0e,(0,p.Z)({},x0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}L0e.isMDXComponent=!0;const Z0e={toc:[]},b0e="wrapper";function N0e(t){let{components:e,...n}=t;return(0,s.kt)(b0e,(0,p.Z)({},Z0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}N0e.isMDXComponent=!0;const z0e={toc:[]},A0e="wrapper";function P0e(t){let{components:e,...n}=t;return(0,s.kt)(A0e,(0,p.Z)({},z0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}P0e.isMDXComponent=!0;const I0e={toc:[]},W0e="wrapper";function R0e(t){let{components:e,...n}=t;return(0,s.kt)(W0e,(0,p.Z)({},I0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}R0e.isMDXComponent=!0;const S0e={toc:[]},B0e="wrapper";function G0e(t){let{components:e,...n}=t;return(0,s.kt)(B0e,(0,p.Z)({},S0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}G0e.isMDXComponent=!0;const E0e={toc:[]},O0e="wrapper";function U0e(t){let{components:e,...n}=t;return(0,s.kt)(O0e,(0,p.Z)({},E0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}U0e.isMDXComponent=!0;const F0e={toc:[]},V0e="wrapper";function q0e(t){let{components:e,...n}=t;return(0,s.kt)(V0e,(0,p.Z)({},F0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}q0e.isMDXComponent=!0;const j0e={toc:[]},H0e="wrapper";function Y0e(t){let{components:e,...n}=t;return(0,s.kt)(H0e,(0,p.Z)({},j0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Y0e.isMDXComponent=!0;const Q0e={toc:[]},$0e="wrapper";function K0e(t){let{components:e,...n}=t;return(0,s.kt)($0e,(0,p.Z)({},Q0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}K0e.isMDXComponent=!0;const J0e={toc:[]},t3e="wrapper";function e3e(t){let{components:e,...n}=t;return(0,s.kt)(t3e,(0,p.Z)({},J0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}e3e.isMDXComponent=!0;const n3e={toc:[]},o3e="wrapper";function p3e(t){let{components:e,...n}=t;return(0,s.kt)(o3e,(0,p.Z)({},n3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}p3e.isMDXComponent=!0;const r3e={toc:[]},s3e="wrapper";function c3e(t){let{components:e,...n}=t;return(0,s.kt)(s3e,(0,p.Z)({},r3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}c3e.isMDXComponent=!0;const a3e={toc:[]},i3e="wrapper";function l3e(t){let{components:e,...n}=t;return(0,s.kt)(i3e,(0,p.Z)({},a3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}l3e.isMDXComponent=!0;const u3e={toc:[]},m3e="wrapper";function d3e(t){let{components:e,...n}=t;return(0,s.kt)(m3e,(0,p.Z)({},u3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d3e.isMDXComponent=!0;const h3e={toc:[]},f3e="wrapper";function k3e(t){let{components:e,...n}=t;return(0,s.kt)(f3e,(0,p.Z)({},h3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}k3e.isMDXComponent=!0;const y3e={toc:[]},D3e="wrapper";function M3e(t){let{components:e,...n}=t;return(0,s.kt)(D3e,(0,p.Z)({},y3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}M3e.isMDXComponent=!0;const X3e={toc:[]},_3e="wrapper";function w3e(t){let{components:e,...n}=t;return(0,s.kt)(_3e,(0,p.Z)({},X3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}w3e.isMDXComponent=!0;const T3e={toc:[]},C3e="wrapper";function g3e(t){let{components:e,...n}=t;return(0,s.kt)(C3e,(0,p.Z)({},T3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}g3e.isMDXComponent=!0;const x3e={toc:[]},v3e="wrapper";function L3e(t){let{components:e,...n}=t;return(0,s.kt)(v3e,(0,p.Z)({},x3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}L3e.isMDXComponent=!0;const Z3e={toc:[]},b3e="wrapper";function N3e(t){let{components:e,...n}=t;return(0,s.kt)(b3e,(0,p.Z)({},Z3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N3e.isMDXComponent=!0;const z3e={toc:[]},A3e="wrapper";function P3e(t){let{components:e,...n}=t;return(0,s.kt)(A3e,(0,p.Z)({},z3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}P3e.isMDXComponent=!0;const I3e={toc:[]},W3e="wrapper";function R3e(t){let{components:e,...n}=t;return(0,s.kt)(W3e,(0,p.Z)({},I3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}R3e.isMDXComponent=!0;const S3e={toc:[]},B3e="wrapper";function G3e(t){let{components:e,...n}=t;return(0,s.kt)(B3e,(0,p.Z)({},S3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}G3e.isMDXComponent=!0;const E3e={toc:[]},O3e="wrapper";function U3e(t){let{components:e,...n}=t;return(0,s.kt)(O3e,(0,p.Z)({},E3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}U3e.isMDXComponent=!0;const F3e={toc:[]},V3e="wrapper";function q3e(t){let{components:e,...n}=t;return(0,s.kt)(V3e,(0,p.Z)({},F3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}q3e.isMDXComponent=!0;const j3e={toc:[]},H3e="wrapper";function Y3e(t){let{components:e,...n}=t;return(0,s.kt)(H3e,(0,p.Z)({},j3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Y3e.isMDXComponent=!0;const Q3e={toc:[]},$3e="wrapper";function K3e(t){let{components:e,...n}=t;return(0,s.kt)($3e,(0,p.Z)({},Q3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}K3e.isMDXComponent=!0;const J3e={toc:[]},t1e="wrapper";function e1e(t){let{components:e,...n}=t;return(0,s.kt)(t1e,(0,p.Z)({},J3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}e1e.isMDXComponent=!0;const n1e={toc:[]},o1e="wrapper";function p1e(t){let{components:e,...n}=t;return(0,s.kt)(o1e,(0,p.Z)({},n1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}p1e.isMDXComponent=!0;const r1e={toc:[]},s1e="wrapper";function c1e(t){let{components:e,...n}=t;return(0,s.kt)(s1e,(0,p.Z)({},r1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}c1e.isMDXComponent=!0;const a1e={toc:[]},i1e="wrapper";function l1e(t){let{components:e,...n}=t;return(0,s.kt)(i1e,(0,p.Z)({},a1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}l1e.isMDXComponent=!0;const u1e={toc:[]},m1e="wrapper";function d1e(t){let{components:e,...n}=t;return(0,s.kt)(m1e,(0,p.Z)({},u1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}d1e.isMDXComponent=!0;const h1e={toc:[]},f1e="wrapper";function k1e(t){let{components:e,...n}=t;return(0,s.kt)(f1e,(0,p.Z)({},h1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}k1e.isMDXComponent=!0;const y1e={toc:[]},D1e="wrapper";function M1e(t){let{components:e,...n}=t;return(0,s.kt)(D1e,(0,p.Z)({},y1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}M1e.isMDXComponent=!0;const X1e={toc:[]},_1e="wrapper";function w1e(t){let{components:e,...n}=t;return(0,s.kt)(_1e,(0,p.Z)({},X1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}w1e.isMDXComponent=!0;const T1e={toc:[]},C1e="wrapper";function g1e(t){let{components:e,...n}=t;return(0,s.kt)(C1e,(0,p.Z)({},T1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}g1e.isMDXComponent=!0;const x1e={toc:[]},v1e="wrapper";function L1e(t){let{components:e,...n}=t;return(0,s.kt)(v1e,(0,p.Z)({},x1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}L1e.isMDXComponent=!0;const Z1e={toc:[]},b1e="wrapper";function N1e(t){let{components:e,...n}=t;return(0,s.kt)(b1e,(0,p.Z)({},Z1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}N1e.isMDXComponent=!0;const z1e={toc:[]},A1e="wrapper";function P1e(t){let{components:e,...n}=t;return(0,s.kt)(A1e,(0,p.Z)({},z1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}P1e.isMDXComponent=!0;const I1e={toc:[]},W1e="wrapper";function R1e(t){let{components:e,...n}=t;return(0,s.kt)(W1e,(0,p.Z)({},I1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}R1e.isMDXComponent=!0;const S1e={toc:[]},B1e="wrapper";function G1e(t){let{components:e,...n}=t;return(0,s.kt)(B1e,(0,p.Z)({},S1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}G1e.isMDXComponent=!0;const E1e={toc:[]},O1e="wrapper";function U1e(t){let{components:e,...n}=t;return(0,s.kt)(O1e,(0,p.Z)({},E1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}U1e.isMDXComponent=!0;const F1e={toc:[]},V1e="wrapper";function q1e(t){let{components:e,...n}=t;return(0,s.kt)(V1e,(0,p.Z)({},F1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}q1e.isMDXComponent=!0;const j1e={toc:[]},H1e="wrapper";function Y1e(t){let{components:e,...n}=t;return(0,s.kt)(H1e,(0,p.Z)({},j1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Y1e.isMDXComponent=!0;const Q1e={toc:[]},$1e="wrapper";function K1e(t){let{components:e,...n}=t;return(0,s.kt)($1e,(0,p.Z)({},Q1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}K1e.isMDXComponent=!0;const J1e={toc:[]},t8e="wrapper";function e8e(t){let{components:e,...n}=t;return(0,s.kt)(t8e,(0,p.Z)({},J1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}e8e.isMDXComponent=!0;const n8e={toc:[]},o8e="wrapper";function p8e(t){let{components:e,...n}=t;return(0,s.kt)(o8e,(0,p.Z)({},n8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}p8e.isMDXComponent=!0;const r8e={toc:[]},s8e="wrapper";function c8e(t){let{components:e,...n}=t;return(0,s.kt)(s8e,(0,p.Z)({},r8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}c8e.isMDXComponent=!0;const a8e={toc:[]},i8e="wrapper";function l8e(t){let{components:e,...n}=t;return(0,s.kt)(i8e,(0,p.Z)({},a8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}l8e.isMDXComponent=!0;const u8e={toc:[]},m8e="wrapper";function d8e(t){let{components:e,...n}=t;return(0,s.kt)(m8e,(0,p.Z)({},u8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}d8e.isMDXComponent=!0;const h8e={toc:[]},f8e="wrapper";function k8e(t){let{components:e,...n}=t;return(0,s.kt)(f8e,(0,p.Z)({},h8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}k8e.isMDXComponent=!0;const y8e={toc:[]},D8e="wrapper";function M8e(t){let{components:e,...n}=t;return(0,s.kt)(D8e,(0,p.Z)({},y8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}M8e.isMDXComponent=!0;const X8e={toc:[]},_8e="wrapper";function w8e(t){let{components:e,...n}=t;return(0,s.kt)(_8e,(0,p.Z)({},X8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}w8e.isMDXComponent=!0;const T8e={toc:[]},C8e="wrapper";function g8e(t){let{components:e,...n}=t;return(0,s.kt)(C8e,(0,p.Z)({},T8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}g8e.isMDXComponent=!0;const x8e={toc:[]},v8e="wrapper";function L8e(t){let{components:e,...n}=t;return(0,s.kt)(v8e,(0,p.Z)({},x8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}L8e.isMDXComponent=!0;const Z8e={toc:[]},b8e="wrapper";function N8e(t){let{components:e,...n}=t;return(0,s.kt)(b8e,(0,p.Z)({},Z8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}N8e.isMDXComponent=!0;const z8e={toc:[]},A8e="wrapper";function P8e(t){let{components:e,...n}=t;return(0,s.kt)(A8e,(0,p.Z)({},z8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}P8e.isMDXComponent=!0;const I8e={toc:[]},W8e="wrapper";function R8e(t){let{components:e,...n}=t;return(0,s.kt)(W8e,(0,p.Z)({},I8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}R8e.isMDXComponent=!0;const S8e={toc:[]},B8e="wrapper";function G8e(t){let{components:e,...n}=t;return(0,s.kt)(B8e,(0,p.Z)({},S8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}G8e.isMDXComponent=!0;const E8e={toc:[]},O8e="wrapper";function U8e(t){let{components:e,...n}=t;return(0,s.kt)(O8e,(0,p.Z)({},E8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}U8e.isMDXComponent=!0;const F8e={toc:[]},V8e="wrapper";function q8e(t){let{components:e,...n}=t;return(0,s.kt)(V8e,(0,p.Z)({},F8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}q8e.isMDXComponent=!0;const j8e={toc:[]},H8e="wrapper";function Y8e(t){let{components:e,...n}=t;return(0,s.kt)(H8e,(0,p.Z)({},j8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Y8e.isMDXComponent=!0;const Q8e={toc:[]},$8e="wrapper";function K8e(t){let{components:e,...n}=t;return(0,s.kt)($8e,(0,p.Z)({},Q8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}K8e.isMDXComponent=!0;const J8e={toc:[]},t2e="wrapper";function e2e(t){let{components:e,...n}=t;return(0,s.kt)(t2e,(0,p.Z)({},J8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}e2e.isMDXComponent=!0;const n2e={toc:[]},o2e="wrapper";function p2e(t){let{components:e,...n}=t;return(0,s.kt)(o2e,(0,p.Z)({},n2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}p2e.isMDXComponent=!0;const r2e={toc:[]},s2e="wrapper";function c2e(t){let{components:e,...n}=t;return(0,s.kt)(s2e,(0,p.Z)({},r2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}c2e.isMDXComponent=!0;const a2e={toc:[]},i2e="wrapper";function l2e(t){let{components:e,...n}=t;return(0,s.kt)(i2e,(0,p.Z)({},a2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}l2e.isMDXComponent=!0;const u2e={toc:[]},m2e="wrapper";function d2e(t){let{components:e,...n}=t;return(0,s.kt)(m2e,(0,p.Z)({},u2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}d2e.isMDXComponent=!0;const h2e={toc:[]},f2e="wrapper";function k2e(t){let{components:e,...n}=t;return(0,s.kt)(f2e,(0,p.Z)({},h2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}k2e.isMDXComponent=!0;const y2e={toc:[]},D2e="wrapper";function M2e(t){let{components:e,...n}=t;return(0,s.kt)(D2e,(0,p.Z)({},y2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}M2e.isMDXComponent=!0;const X2e={toc:[]},_2e="wrapper";function w2e(t){let{components:e,...n}=t;return(0,s.kt)(_2e,(0,p.Z)({},X2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}w2e.isMDXComponent=!0;const T2e={toc:[]},C2e="wrapper";function g2e(t){let{components:e,...n}=t;return(0,s.kt)(C2e,(0,p.Z)({},T2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}g2e.isMDXComponent=!0;const x2e={toc:[]},v2e="wrapper";function L2e(t){let{components:e,...n}=t;return(0,s.kt)(v2e,(0,p.Z)({},x2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}L2e.isMDXComponent=!0;const Z2e={toc:[]},b2e="wrapper";function N2e(t){let{components:e,...n}=t;return(0,s.kt)(b2e,(0,p.Z)({},Z2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}N2e.isMDXComponent=!0;const z2e={toc:[]},A2e="wrapper";function P2e(t){let{components:e,...n}=t;return(0,s.kt)(A2e,(0,p.Z)({},z2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}P2e.isMDXComponent=!0;const I2e={toc:[]},W2e="wrapper";function R2e(t){let{components:e,...n}=t;return(0,s.kt)(W2e,(0,p.Z)({},I2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}R2e.isMDXComponent=!0;const S2e={toc:[]},B2e="wrapper";function G2e(t){let{components:e,...n}=t;return(0,s.kt)(B2e,(0,p.Z)({},S2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}G2e.isMDXComponent=!0;const E2e={toc:[]},O2e="wrapper";function U2e(t){let{components:e,...n}=t;return(0,s.kt)(O2e,(0,p.Z)({},E2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}U2e.isMDXComponent=!0;const F2e={toc:[]},V2e="wrapper";function q2e(t){let{components:e,...n}=t;return(0,s.kt)(V2e,(0,p.Z)({},F2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}q2e.isMDXComponent=!0;const j2e={toc:[]},H2e="wrapper";function Y2e(t){let{components:e,...n}=t;return(0,s.kt)(H2e,(0,p.Z)({},j2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Y2e.isMDXComponent=!0;const Q2e={toc:[]},$2e="wrapper";function K2e(t){let{components:e,...n}=t;return(0,s.kt)($2e,(0,p.Z)({},Q2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}K2e.isMDXComponent=!0;const J2e={toc:[]},t4e="wrapper";function e4e(t){let{components:e,...n}=t;return(0,s.kt)(t4e,(0,p.Z)({},J2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}e4e.isMDXComponent=!0;const n4e={toc:[]},o4e="wrapper";function p4e(t){let{components:e,...n}=t;return(0,s.kt)(o4e,(0,p.Z)({},n4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}p4e.isMDXComponent=!0;const r4e={toc:[]},s4e="wrapper";function c4e(t){let{components:e,...n}=t;return(0,s.kt)(s4e,(0,p.Z)({},r4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}c4e.isMDXComponent=!0;const a4e={toc:[]},i4e="wrapper";function l4e(t){let{components:e,...n}=t;return(0,s.kt)(i4e,(0,p.Z)({},a4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}l4e.isMDXComponent=!0;const u4e={toc:[]},m4e="wrapper";function d4e(t){let{components:e,...n}=t;return(0,s.kt)(m4e,(0,p.Z)({},u4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}d4e.isMDXComponent=!0;const h4e={toc:[]},f4e="wrapper";function k4e(t){let{components:e,...n}=t;return(0,s.kt)(f4e,(0,p.Z)({},h4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}k4e.isMDXComponent=!0;const y4e={toc:[]},D4e="wrapper";function M4e(t){let{components:e,...n}=t;return(0,s.kt)(D4e,(0,p.Z)({},y4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}M4e.isMDXComponent=!0;const X4e={toc:[]},_4e="wrapper";function w4e(t){let{components:e,...n}=t;return(0,s.kt)(_4e,(0,p.Z)({},X4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}w4e.isMDXComponent=!0;const T4e={toc:[]},C4e="wrapper";function g4e(t){let{components:e,...n}=t;return(0,s.kt)(C4e,(0,p.Z)({},T4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}g4e.isMDXComponent=!0;const x4e={toc:[]},v4e="wrapper";function L4e(t){let{components:e,...n}=t;return(0,s.kt)(v4e,(0,p.Z)({},x4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}L4e.isMDXComponent=!0;const Z4e={toc:[]},b4e="wrapper";function N4e(t){let{components:e,...n}=t;return(0,s.kt)(b4e,(0,p.Z)({},Z4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}N4e.isMDXComponent=!0;const z4e={toc:[]},A4e="wrapper";function P4e(t){let{components:e,...n}=t;return(0,s.kt)(A4e,(0,p.Z)({},z4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}P4e.isMDXComponent=!0;const I4e={toc:[]},W4e="wrapper";function R4e(t){let{components:e,...n}=t;return(0,s.kt)(W4e,(0,p.Z)({},I4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}R4e.isMDXComponent=!0;const S4e={toc:[]},B4e="wrapper";function G4e(t){let{components:e,...n}=t;return(0,s.kt)(B4e,(0,p.Z)({},S4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}G4e.isMDXComponent=!0;const E4e={toc:[]},O4e="wrapper";function U4e(t){let{components:e,...n}=t;return(0,s.kt)(O4e,(0,p.Z)({},E4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}U4e.isMDXComponent=!0;const F4e={toc:[]},V4e="wrapper";function q4e(t){let{components:e,...n}=t;return(0,s.kt)(V4e,(0,p.Z)({},F4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}q4e.isMDXComponent=!0;const j4e={toc:[]},H4e="wrapper";function Y4e(t){let{components:e,...n}=t;return(0,s.kt)(H4e,(0,p.Z)({},j4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Y4e.isMDXComponent=!0;const Q4e={toc:[]},$4e="wrapper";function K4e(t){let{components:e,...n}=t;return(0,s.kt)($4e,(0,p.Z)({},Q4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}K4e.isMDXComponent=!0;const J4e={toc:[]},t6e="wrapper";function e6e(t){let{components:e,...n}=t;return(0,s.kt)(t6e,(0,p.Z)({},J4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}e6e.isMDXComponent=!0;const n6e={toc:[]},o6e="wrapper";function p6e(t){let{components:e,...n}=t;return(0,s.kt)(o6e,(0,p.Z)({},n6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}p6e.isMDXComponent=!0;const r6e={toc:[]},s6e="wrapper";function c6e(t){let{components:e,...n}=t;return(0,s.kt)(s6e,(0,p.Z)({},r6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}c6e.isMDXComponent=!0;const a6e={toc:[]},i6e="wrapper";function l6e(t){let{components:e,...n}=t;return(0,s.kt)(i6e,(0,p.Z)({},a6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}l6e.isMDXComponent=!0;const u6e={toc:[]},m6e="wrapper";function d6e(t){let{components:e,...n}=t;return(0,s.kt)(m6e,(0,p.Z)({},u6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}d6e.isMDXComponent=!0;const h6e={toc:[]},f6e="wrapper";function k6e(t){let{components:e,...n}=t;return(0,s.kt)(f6e,(0,p.Z)({},h6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}k6e.isMDXComponent=!0;const y6e={toc:[]},D6e="wrapper";function M6e(t){let{components:e,...n}=t;return(0,s.kt)(D6e,(0,p.Z)({},y6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}M6e.isMDXComponent=!0;const X6e={toc:[]},_6e="wrapper";function w6e(t){let{components:e,...n}=t;return(0,s.kt)(_6e,(0,p.Z)({},X6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}w6e.isMDXComponent=!0;const T6e={toc:[]},C6e="wrapper";function g6e(t){let{components:e,...n}=t;return(0,s.kt)(C6e,(0,p.Z)({},T6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}g6e.isMDXComponent=!0;const x6e={toc:[]},v6e="wrapper";function L6e(t){let{components:e,...n}=t;return(0,s.kt)(v6e,(0,p.Z)({},x6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}L6e.isMDXComponent=!0;const Z6e={toc:[]},b6e="wrapper";function N6e(t){let{components:e,...n}=t;return(0,s.kt)(b6e,(0,p.Z)({},Z6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}N6e.isMDXComponent=!0;const z6e={toc:[]},A6e="wrapper";function P6e(t){let{components:e,...n}=t;return(0,s.kt)(A6e,(0,p.Z)({},z6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}P6e.isMDXComponent=!0;const I6e={toc:[]},W6e="wrapper";function R6e(t){let{components:e,...n}=t;return(0,s.kt)(W6e,(0,p.Z)({},I6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}R6e.isMDXComponent=!0;const S6e={toc:[]},B6e="wrapper";function G6e(t){let{components:e,...n}=t;return(0,s.kt)(B6e,(0,p.Z)({},S6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}G6e.isMDXComponent=!0;const E6e={toc:[]},O6e="wrapper";function U6e(t){let{components:e,...n}=t;return(0,s.kt)(O6e,(0,p.Z)({},E6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}U6e.isMDXComponent=!0;const F6e={toc:[]},V6e="wrapper";function q6e(t){let{components:e,...n}=t;return(0,s.kt)(V6e,(0,p.Z)({},F6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}q6e.isMDXComponent=!0;const j6e={toc:[]},H6e="wrapper";function Y6e(t){let{components:e,...n}=t;return(0,s.kt)(H6e,(0,p.Z)({},j6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Y6e.isMDXComponent=!0;const Q6e={toc:[]},$6e="wrapper";function K6e(t){let{components:e,...n}=t;return(0,s.kt)($6e,(0,p.Z)({},Q6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}K6e.isMDXComponent=!0;const J6e={toc:[]},t5e="wrapper";function e5e(t){let{components:e,...n}=t;return(0,s.kt)(t5e,(0,p.Z)({},J6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}e5e.isMDXComponent=!0;const n5e={toc:[]},o5e="wrapper";function p5e(t){let{components:e,...n}=t;return(0,s.kt)(o5e,(0,p.Z)({},n5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}p5e.isMDXComponent=!0;const r5e={toc:[]},s5e="wrapper";function c5e(t){let{components:e,...n}=t;return(0,s.kt)(s5e,(0,p.Z)({},r5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}c5e.isMDXComponent=!0;const a5e={toc:[]},i5e="wrapper";function l5e(t){let{components:e,...n}=t;return(0,s.kt)(i5e,(0,p.Z)({},a5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}l5e.isMDXComponent=!0;const u5e={toc:[]},m5e="wrapper";function d5e(t){let{components:e,...n}=t;return(0,s.kt)(m5e,(0,p.Z)({},u5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render any polygonal shape defined by a set of\npoints."))}d5e.isMDXComponent=!0;const h5e={toc:[]},f5e="wrapper";function k5e(t){let{components:e,...n}=t;return(0,s.kt)(f5e,(0,p.Z)({},h5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple line\nimport {makeScene2D, Line} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [150, 50],\n        [0, -50],\n        [-150, 50],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={40}\n      startArrow\n    />,\n  );\n});\n\n// snippet Polygon\nimport {makeScene2D, Line} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [-200, 70],\n        [150, 70],\n        [100, -70],\n        [-100, -70],\n      ]}\n      fill={'lightseagreen'}\n      closed\n    />,\n  );\n});\n\n// snippet Using signals\nimport {makeScene2D, Line} from '@motion-canvas/2d';\nimport {createSignal} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const tip = createSignal(-150);\n  view.add(\n    <Line\n      points={[\n        [-150, 70],\n        [150, 70],\n        // this point is dynamically calculated based on the signal:\n        () => [tip(), -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      closed\n    />,\n  );\n\n  yield* tip(150, 1).back(1);\n});\n\n// snippet Tweening points\nimport {makeScene2D, Line} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const line = createRef<Line>();\n  view.add(\n    <Line\n      ref={line}\n      points={[\n        [-150, 70],\n        [150, 70],\n        [0, -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={20}\n      closed\n    />,\n  );\n\n  yield* line()\n    .points(\n      [\n        [-150, 0],\n        [0, 100],\n        [150, 0],\n        [150, -70],\n        [-150, -70],\n      ],\n      2,\n    )\n    .back(2);\n});\n")))}k5e.isMDXComponent=!0;const y5e={toc:[]},D5e="wrapper";function M5e(t){let{components:e,...n}=t;return(0,s.kt)(D5e,(0,p.Z)({},y5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing lines and polygons."))}M5e.isMDXComponent=!0;const X5e={toc:[]},_5e="wrapper";function w5e(t){let{components:e,...n}=t;return(0,s.kt)(_5e,(0,p.Z)({},X5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}w5e.isMDXComponent=!0;const T5e={toc:[]},C5e="wrapper";function g5e(t){let{components:e,...n}=t;return(0,s.kt)(C5e,(0,p.Z)({},T5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}g5e.isMDXComponent=!0;const x5e={toc:[]},v5e="wrapper";function L5e(t){let{components:e,...n}=t;return(0,s.kt)(v5e,(0,p.Z)({},x5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}L5e.isMDXComponent=!0;const Z5e={toc:[]},b5e="wrapper";function N5e(t){let{components:e,...n}=t;return(0,s.kt)(b5e,(0,p.Z)({},Z5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}N5e.isMDXComponent=!0;const z5e={toc:[]},A5e="wrapper";function P5e(t){let{components:e,...n}=t;return(0,s.kt)(A5e,(0,p.Z)({},z5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}P5e.isMDXComponent=!0;const I5e={toc:[]},W5e="wrapper";function R5e(t){let{components:e,...n}=t;return(0,s.kt)(W5e,(0,p.Z)({},I5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}R5e.isMDXComponent=!0;const S5e={toc:[]},B5e="wrapper";function G5e(t){let{components:e,...n}=t;return(0,s.kt)(B5e,(0,p.Z)({},S5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}G5e.isMDXComponent=!0;const E5e={toc:[]},O5e="wrapper";function U5e(t){let{components:e,...n}=t;return(0,s.kt)(O5e,(0,p.Z)({},E5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}U5e.isMDXComponent=!0;const F5e={toc:[]},V5e="wrapper";function q5e(t){let{components:e,...n}=t;return(0,s.kt)(V5e,(0,p.Z)({},F5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}q5e.isMDXComponent=!0;const j5e={toc:[]},H5e="wrapper";function Y5e(t){let{components:e,...n}=t;return(0,s.kt)(H5e,(0,p.Z)({},j5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Y5e.isMDXComponent=!0;const Q5e={toc:[]},$5e="wrapper";function K5e(t){let{components:e,...n}=t;return(0,s.kt)($5e,(0,p.Z)({},Q5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}K5e.isMDXComponent=!0;const J5e={toc:[]},t7e="wrapper";function e7e(t){let{components:e,...n}=t;return(0,s.kt)(t7e,(0,p.Z)({},J5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}e7e.isMDXComponent=!0;const n7e={toc:[]},o7e="wrapper";function p7e(t){let{components:e,...n}=t;return(0,s.kt)(o7e,(0,p.Z)({},n7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}p7e.isMDXComponent=!0;const r7e={toc:[]},s7e="wrapper";function c7e(t){let{components:e,...n}=t;return(0,s.kt)(s7e,(0,p.Z)({},r7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}c7e.isMDXComponent=!0;const a7e={toc:[]},i7e="wrapper";function l7e(t){let{components:e,...n}=t;return(0,s.kt)(i7e,(0,p.Z)({},a7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}l7e.isMDXComponent=!0;const u7e={toc:[]},m7e="wrapper";function d7e(t){let{components:e,...n}=t;return(0,s.kt)(m7e,(0,p.Z)({},u7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}d7e.isMDXComponent=!0;const h7e={toc:[]},f7e="wrapper";function k7e(t){let{components:e,...n}=t;return(0,s.kt)(f7e,(0,p.Z)({},h7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}k7e.isMDXComponent=!0;const y7e={toc:[]},D7e="wrapper";function M7e(t){let{components:e,...n}=t;return(0,s.kt)(D7e,(0,p.Z)({},y7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}M7e.isMDXComponent=!0;const X7e={toc:[]},_7e="wrapper";function w7e(t){let{components:e,...n}=t;return(0,s.kt)(_7e,(0,p.Z)({},X7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}w7e.isMDXComponent=!0;const T7e={toc:[]},C7e="wrapper";function g7e(t){let{components:e,...n}=t;return(0,s.kt)(C7e,(0,p.Z)({},T7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}g7e.isMDXComponent=!0;const x7e={toc:[]},v7e="wrapper";function L7e(t){let{components:e,...n}=t;return(0,s.kt)(v7e,(0,p.Z)({},x7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}L7e.isMDXComponent=!0;const Z7e={toc:[]},b7e="wrapper";function N7e(t){let{components:e,...n}=t;return(0,s.kt)(b7e,(0,p.Z)({},Z7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}N7e.isMDXComponent=!0;const z7e={toc:[]},A7e="wrapper";function P7e(t){let{components:e,...n}=t;return(0,s.kt)(A7e,(0,p.Z)({},z7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}P7e.isMDXComponent=!0;const I7e={toc:[]},W7e="wrapper";function R7e(t){let{components:e,...n}=t;return(0,s.kt)(W7e,(0,p.Z)({},I7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}R7e.isMDXComponent=!0;const S7e={toc:[]},B7e="wrapper";function G7e(t){let{components:e,...n}=t;return(0,s.kt)(B7e,(0,p.Z)({},S7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}G7e.isMDXComponent=!0;const E7e={toc:[]},O7e="wrapper";function U7e(t){let{components:e,...n}=t;return(0,s.kt)(O7e,(0,p.Z)({},E7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}U7e.isMDXComponent=!0;const F7e={toc:[]},V7e="wrapper";function q7e(t){let{components:e,...n}=t;return(0,s.kt)(V7e,(0,p.Z)({},F7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}q7e.isMDXComponent=!0;const j7e={toc:[]},H7e="wrapper";function Y7e(t){let{components:e,...n}=t;return(0,s.kt)(H7e,(0,p.Z)({},j7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Y7e.isMDXComponent=!0;const Q7e={toc:[]},$7e="wrapper";function K7e(t){let{components:e,...n}=t;return(0,s.kt)($7e,(0,p.Z)({},Q7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}K7e.isMDXComponent=!0;const J7e={toc:[]},t9e="wrapper";function e9e(t){let{components:e,...n}=t;return(0,s.kt)(t9e,(0,p.Z)({},J7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}e9e.isMDXComponent=!0;const n9e={toc:[]},o9e="wrapper";function p9e(t){let{components:e,...n}=t;return(0,s.kt)(o9e,(0,p.Z)({},n9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}p9e.isMDXComponent=!0;const r9e={toc:[]},s9e="wrapper";function c9e(t){let{components:e,...n}=t;return(0,s.kt)(s9e,(0,p.Z)({},r9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}c9e.isMDXComponent=!0;const a9e={toc:[]},i9e="wrapper";function l9e(t){let{components:e,...n}=t;return(0,s.kt)(i9e,(0,p.Z)({},a9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}l9e.isMDXComponent=!0;const u9e={toc:[]},m9e="wrapper";function d9e(t){let{components:e,...n}=t;return(0,s.kt)(m9e,(0,p.Z)({},u9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The points of the line."))}d9e.isMDXComponent=!0;const h9e={toc:[]},f9e="wrapper";function k9e(t){let{components:e,...n}=t;return(0,s.kt)(f9e,(0,p.Z)({},h9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}k9e.isMDXComponent=!0;const y9e={toc:[]},D9e="wrapper";function M9e(t){let{components:e,...n}=t;return(0,s.kt)(D9e,(0,p.Z)({},y9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}M9e.isMDXComponent=!0;const X9e={toc:[]},_9e="wrapper";function w9e(t){let{components:e,...n}=t;return(0,s.kt)(_9e,(0,p.Z)({},X9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the line's corners."))}w9e.isMDXComponent=!0;const T9e={toc:[]},C9e="wrapper";function g9e(t){let{components:e,...n}=t;return(0,s.kt)(C9e,(0,p.Z)({},T9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}g9e.isMDXComponent=!0;const x9e={toc:[]},v9e="wrapper";function L9e(t){let{components:e,...n}=t;return(0,s.kt)(v9e,(0,p.Z)({},x9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}L9e.isMDXComponent=!0;const Z9e={toc:[]},b9e="wrapper";function N9e(t){let{components:e,...n}=t;return(0,s.kt)(b9e,(0,p.Z)({},Z9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}N9e.isMDXComponent=!0;const z9e={toc:[]},A9e="wrapper";function P9e(t){let{components:e,...n}=t;return(0,s.kt)(A9e,(0,p.Z)({},z9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}P9e.isMDXComponent=!0;const I9e={toc:[]},W9e="wrapper";function R9e(t){let{components:e,...n}=t;return(0,s.kt)(W9e,(0,p.Z)({},I9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}R9e.isMDXComponent=!0;const S9e={toc:[]},B9e="wrapper";function G9e(t){let{components:e,...n}=t;return(0,s.kt)(B9e,(0,p.Z)({},S9e,n,{components:e,mdxType:"MDXLayout"}))}G9e.isMDXComponent=!0;const E9e={toc:[]},O9e="wrapper";function U9e(t){let{components:e,...n}=t;return(0,s.kt)(O9e,(0,p.Z)({},E9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}U9e.isMDXComponent=!0;const F9e={toc:[]},V9e="wrapper";function q9e(t){let{components:e,...n}=t;return(0,s.kt)(V9e,(0,p.Z)({},F9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}q9e.isMDXComponent=!0;const j9e={toc:[]},H9e="wrapper";function Y9e(t){let{components:e,...n}=t;return(0,s.kt)(H9e,(0,p.Z)({},j9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Y9e.isMDXComponent=!0;const Q9e={toc:[]},$9e="wrapper";function K9e(t){let{components:e,...n}=t;return(0,s.kt)($9e,(0,p.Z)({},Q9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}K9e.isMDXComponent=!0;const J9e={toc:[]},ttn="wrapper";function etn(t){let{components:e,...n}=t;return(0,s.kt)(ttn,(0,p.Z)({},J9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}etn.isMDXComponent=!0;const ntn={toc:[]},otn="wrapper";function ptn(t){let{components:e,...n}=t;return(0,s.kt)(otn,(0,p.Z)({},ntn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}ptn.isMDXComponent=!0;const rtn={toc:[]},stn="wrapper";function ctn(t){let{components:e,...n}=t;return(0,s.kt)(stn,(0,p.Z)({},rtn,n,{components:e,mdxType:"MDXLayout"}))}ctn.isMDXComponent=!0;const atn={toc:[]},itn="wrapper";function ltn(t){let{components:e,...n}=t;return(0,s.kt)(itn,(0,p.Z)({},atn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ltn.isMDXComponent=!0;const utn={toc:[]},mtn="wrapper";function dtn(t){let{components:e,...n}=t;return(0,s.kt)(mtn,(0,p.Z)({},utn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}dtn.isMDXComponent=!0;const htn={toc:[]},ftn="wrapper";function ktn(t){let{components:e,...n}=t;return(0,s.kt)(ftn,(0,p.Z)({},htn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ktn.isMDXComponent=!0;const ytn={toc:[]},Dtn="wrapper";function Mtn(t){let{components:e,...n}=t;return(0,s.kt)(Dtn,(0,p.Z)({},ytn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Mtn.isMDXComponent=!0;const Xtn={toc:[]},_tn="wrapper";function wtn(t){let{components:e,...n}=t;return(0,s.kt)(_tn,(0,p.Z)({},Xtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wtn.isMDXComponent=!0;const Ttn={toc:[]},Ctn="wrapper";function gtn(t){let{components:e,...n}=t;return(0,s.kt)(Ctn,(0,p.Z)({},Ttn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}gtn.isMDXComponent=!0;const xtn={toc:[]},vtn="wrapper";function Ltn(t){let{components:e,...n}=t;return(0,s.kt)(vtn,(0,p.Z)({},xtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ltn.isMDXComponent=!0;const Ztn={toc:[]},btn="wrapper";function Ntn(t){let{components:e,...n}=t;return(0,s.kt)(btn,(0,p.Z)({},Ztn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Ntn.isMDXComponent=!0;const ztn={toc:[]},Atn="wrapper";function Ptn(t){let{components:e,...n}=t;return(0,s.kt)(Atn,(0,p.Z)({},ztn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ptn.isMDXComponent=!0;const Itn={toc:[]},Wtn="wrapper";function Rtn(t){let{components:e,...n}=t;return(0,s.kt)(Wtn,(0,p.Z)({},Itn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Rtn.isMDXComponent=!0;const Stn={toc:[]},Btn="wrapper";function Gtn(t){let{components:e,...n}=t;return(0,s.kt)(Btn,(0,p.Z)({},Stn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Gtn.isMDXComponent=!0;const Etn={toc:[]},Otn="wrapper";function Utn(t){let{components:e,...n}=t;return(0,s.kt)(Otn,(0,p.Z)({},Etn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Utn.isMDXComponent=!0;const Ftn={toc:[]},Vtn="wrapper";function qtn(t){let{components:e,...n}=t;return(0,s.kt)(Vtn,(0,p.Z)({},Ftn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qtn.isMDXComponent=!0;const jtn={toc:[]},Htn="wrapper";function Ytn(t){let{components:e,...n}=t;return(0,s.kt)(Htn,(0,p.Z)({},jtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ytn.isMDXComponent=!0;const Qtn={toc:[]},$tn="wrapper";function Ktn(t){let{components:e,...n}=t;return(0,s.kt)($tn,(0,p.Z)({},Qtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]},ten="wrapper";function een(t){let{components:e,...n}=t;return(0,s.kt)(ten,(0,p.Z)({},Jtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}een.isMDXComponent=!0;const nen={toc:[]},oen="wrapper";function pen(t){let{components:e,...n}=t;return(0,s.kt)(oen,(0,p.Z)({},nen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pen.isMDXComponent=!0;const ren={toc:[]},sen="wrapper";function cen(t){let{components:e,...n}=t;return(0,s.kt)(sen,(0,p.Z)({},ren,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cen.isMDXComponent=!0;const aen={toc:[]},ien="wrapper";function len(t){let{components:e,...n}=t;return(0,s.kt)(ien,(0,p.Z)({},aen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}len.isMDXComponent=!0;const uen={toc:[]},men="wrapper";function den(t){let{components:e,...n}=t;return(0,s.kt)(men,(0,p.Z)({},uen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}den.isMDXComponent=!0;const hen={toc:[]},fen="wrapper";function ken(t){let{components:e,...n}=t;return(0,s.kt)(fen,(0,p.Z)({},hen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ken.isMDXComponent=!0;const yen={toc:[]},Den="wrapper";function Men(t){let{components:e,...n}=t;return(0,s.kt)(Den,(0,p.Z)({},yen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Men.isMDXComponent=!0;const Xen={toc:[]},_en="wrapper";function wen(t){let{components:e,...n}=t;return(0,s.kt)(_en,(0,p.Z)({},Xen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}wen.isMDXComponent=!0;const Ten={toc:[]},Cen="wrapper";function gen(t){let{components:e,...n}=t;return(0,s.kt)(Cen,(0,p.Z)({},Ten,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}gen.isMDXComponent=!0;const xen={toc:[]},ven="wrapper";function Len(t){let{components:e,...n}=t;return(0,s.kt)(ven,(0,p.Z)({},xen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Len.isMDXComponent=!0;const Zen={toc:[]},ben="wrapper";function Nen(t){let{components:e,...n}=t;return(0,s.kt)(ben,(0,p.Z)({},Zen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Nen.isMDXComponent=!0;const zen={toc:[]},Aen="wrapper";function Pen(t){let{components:e,...n}=t;return(0,s.kt)(Aen,(0,p.Z)({},zen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Pen.isMDXComponent=!0;const Ien={toc:[]},Wen="wrapper";function Ren(t){let{components:e,...n}=t;return(0,s.kt)(Wen,(0,p.Z)({},Ien,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Ren.isMDXComponent=!0;const Sen={toc:[]},Ben="wrapper";function Gen(t){let{components:e,...n}=t;return(0,s.kt)(Ben,(0,p.Z)({},Sen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}Gen.isMDXComponent=!0;const Een={toc:[]},Oen="wrapper";function Uen(t){let{components:e,...n}=t;return(0,s.kt)(Oen,(0,p.Z)({},Een,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}Uen.isMDXComponent=!0;const Fen={toc:[]},Ven="wrapper";function qen(t){let{components:e,...n}=t;return(0,s.kt)(Ven,(0,p.Z)({},Fen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}qen.isMDXComponent=!0;const jen={toc:[]},Hen="wrapper";function Yen(t){let{components:e,...n}=t;return(0,s.kt)(Hen,(0,p.Z)({},jen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Yen.isMDXComponent=!0;const Qen={toc:[]},$en="wrapper";function Ken(t){let{components:e,...n}=t;return(0,s.kt)($en,(0,p.Z)({},Qen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Ken.isMDXComponent=!0;const Jen={toc:[]},tnn="wrapper";function enn(t){let{components:e,...n}=t;return(0,s.kt)(tnn,(0,p.Z)({},Jen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}enn.isMDXComponent=!0;const nnn={toc:[]},onn="wrapper";function pnn(t){let{components:e,...n}=t;return(0,s.kt)(onn,(0,p.Z)({},nnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pnn.isMDXComponent=!0;const rnn={toc:[]},snn="wrapper";function cnn(t){let{components:e,...n}=t;return(0,s.kt)(snn,(0,p.Z)({},rnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}cnn.isMDXComponent=!0;const ann={toc:[]},inn="wrapper";function lnn(t){let{components:e,...n}=t;return(0,s.kt)(inn,(0,p.Z)({},ann,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lnn.isMDXComponent=!0;const unn={toc:[]},mnn="wrapper";function dnn(t){let{components:e,...n}=t;return(0,s.kt)(mnn,(0,p.Z)({},unn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}dnn.isMDXComponent=!0;const hnn={toc:[]},fnn="wrapper";function knn(t){let{components:e,...n}=t;return(0,s.kt)(fnn,(0,p.Z)({},hnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}knn.isMDXComponent=!0;const ynn={toc:[]},Dnn="wrapper";function Mnn(t){let{components:e,...n}=t;return(0,s.kt)(Dnn,(0,p.Z)({},ynn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Mnn.isMDXComponent=!0;const Xnn={toc:[]},_nn="wrapper";function wnn(t){let{components:e,...n}=t;return(0,s.kt)(_nn,(0,p.Z)({},Xnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wnn.isMDXComponent=!0;const Tnn={toc:[]},Cnn="wrapper";function gnn(t){let{components:e,...n}=t;return(0,s.kt)(Cnn,(0,p.Z)({},Tnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}gnn.isMDXComponent=!0;const xnn={toc:[]},vnn="wrapper";function Lnn(t){let{components:e,...n}=t;return(0,s.kt)(vnn,(0,p.Z)({},xnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Lnn.isMDXComponent=!0;const Znn={toc:[]},bnn="wrapper";function Nnn(t){let{components:e,...n}=t;return(0,s.kt)(bnn,(0,p.Z)({},Znn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Nnn.isMDXComponent=!0;const znn={toc:[]},Ann="wrapper";function Pnn(t){let{components:e,...n}=t;return(0,s.kt)(Ann,(0,p.Z)({},znn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Pnn.isMDXComponent=!0;const Inn={toc:[]},Wnn="wrapper";function Rnn(t){let{components:e,...n}=t;return(0,s.kt)(Wnn,(0,p.Z)({},Inn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Rnn.isMDXComponent=!0;const Snn={toc:[]},Bnn="wrapper";function Gnn(t){let{components:e,...n}=t;return(0,s.kt)(Bnn,(0,p.Z)({},Snn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Gnn.isMDXComponent=!0;const Enn={toc:[]},Onn="wrapper";function Unn(t){let{components:e,...n}=t;return(0,s.kt)(Onn,(0,p.Z)({},Enn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Unn.isMDXComponent=!0;const Fnn={toc:[]},Vnn="wrapper";function qnn(t){let{components:e,...n}=t;return(0,s.kt)(Vnn,(0,p.Z)({},Fnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qnn.isMDXComponent=!0;const jnn={toc:[]},Hnn="wrapper";function Ynn(t){let{components:e,...n}=t;return(0,s.kt)(Hnn,(0,p.Z)({},jnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Ynn.isMDXComponent=!0;const Qnn={toc:[]},$nn="wrapper";function Knn(t){let{components:e,...n}=t;return(0,s.kt)($nn,(0,p.Z)({},Qnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Knn.isMDXComponent=!0;const Jnn={toc:[]},ton="wrapper";function eon(t){let{components:e,...n}=t;return(0,s.kt)(ton,(0,p.Z)({},Jnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}eon.isMDXComponent=!0;const non={toc:[]},oon="wrapper";function pon(t){let{components:e,...n}=t;return(0,s.kt)(oon,(0,p.Z)({},non,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pon.isMDXComponent=!0;const ron={toc:[]},son="wrapper";function con(t){let{components:e,...n}=t;return(0,s.kt)(son,(0,p.Z)({},ron,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}con.isMDXComponent=!0;const aon={toc:[]},ion="wrapper";function lon(t){let{components:e,...n}=t;return(0,s.kt)(ion,(0,p.Z)({},aon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lon.isMDXComponent=!0;const uon={toc:[]},mon="wrapper";function don(t){let{components:e,...n}=t;return(0,s.kt)(mon,(0,p.Z)({},uon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}don.isMDXComponent=!0;const hon={toc:[]},fon="wrapper";function kon(t){let{components:e,...n}=t;return(0,s.kt)(fon,(0,p.Z)({},hon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}kon.isMDXComponent=!0;const yon={toc:[]},Don="wrapper";function Mon(t){let{components:e,...n}=t;return(0,s.kt)(Don,(0,p.Z)({},yon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mon.isMDXComponent=!0;const Xon={toc:[]},_on="wrapper";function won(t){let{components:e,...n}=t;return(0,s.kt)(_on,(0,p.Z)({},Xon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}won.isMDXComponent=!0;const Ton={toc:[]},Con="wrapper";function gon(t){let{components:e,...n}=t;return(0,s.kt)(Con,(0,p.Z)({},Ton,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gon.isMDXComponent=!0;const xon={toc:[]},von="wrapper";function Lon(t){let{components:e,...n}=t;return(0,s.kt)(von,(0,p.Z)({},xon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Lon.isMDXComponent=!0;const Zon={toc:[]},bon="wrapper";function Non(t){let{components:e,...n}=t;return(0,s.kt)(bon,(0,p.Z)({},Zon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Non.isMDXComponent=!0;const zon={toc:[]},Aon="wrapper";function Pon(t){let{components:e,...n}=t;return(0,s.kt)(Aon,(0,p.Z)({},zon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Pon.isMDXComponent=!0;const Ion={toc:[]},Won="wrapper";function Ron(t){let{components:e,...n}=t;return(0,s.kt)(Won,(0,p.Z)({},Ion,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ron.isMDXComponent=!0;const Son={toc:[]},Bon="wrapper";function Gon(t){let{components:e,...n}=t;return(0,s.kt)(Bon,(0,p.Z)({},Son,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Gon.isMDXComponent=!0;const Eon={toc:[]},Oon="wrapper";function Uon(t){let{components:e,...n}=t;return(0,s.kt)(Oon,(0,p.Z)({},Eon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Uon.isMDXComponent=!0;const Fon={toc:[]},Von="wrapper";function qon(t){let{components:e,...n}=t;return(0,s.kt)(Von,(0,p.Z)({},Fon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qon.isMDXComponent=!0;const jon={toc:[]},Hon="wrapper";function Yon(t){let{components:e,...n}=t;return(0,s.kt)(Hon,(0,p.Z)({},jon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Yon.isMDXComponent=!0;const Qon={toc:[]},$on="wrapper";function Kon(t){let{components:e,...n}=t;return(0,s.kt)($on,(0,p.Z)({},Qon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Kon.isMDXComponent=!0;const Jon={toc:[]},tpn="wrapper";function epn(t){let{components:e,...n}=t;return(0,s.kt)(tpn,(0,p.Z)({},Jon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}epn.isMDXComponent=!0;const npn={toc:[]},opn="wrapper";function ppn(t){let{components:e,...n}=t;return(0,s.kt)(opn,(0,p.Z)({},npn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ppn.isMDXComponent=!0;const rpn={toc:[]},spn="wrapper";function cpn(t){let{components:e,...n}=t;return(0,s.kt)(spn,(0,p.Z)({},rpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cpn.isMDXComponent=!0;const apn={toc:[]},ipn="wrapper";function lpn(t){let{components:e,...n}=t;return(0,s.kt)(ipn,(0,p.Z)({},apn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lpn.isMDXComponent=!0;const upn={toc:[]},mpn="wrapper";function dpn(t){let{components:e,...n}=t;return(0,s.kt)(mpn,(0,p.Z)({},upn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}dpn.isMDXComponent=!0;const hpn={toc:[]},fpn="wrapper";function kpn(t){let{components:e,...n}=t;return(0,s.kt)(fpn,(0,p.Z)({},hpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kpn.isMDXComponent=!0;const ypn={toc:[]},Dpn="wrapper";function Mpn(t){let{components:e,...n}=t;return(0,s.kt)(Dpn,(0,p.Z)({},ypn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Mpn.isMDXComponent=!0;const Xpn={toc:[]},_pn="wrapper";function wpn(t){let{components:e,...n}=t;return(0,s.kt)(_pn,(0,p.Z)({},Xpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wpn.isMDXComponent=!0;const Tpn={toc:[]},Cpn="wrapper";function gpn(t){let{components:e,...n}=t;return(0,s.kt)(Cpn,(0,p.Z)({},Tpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}gpn.isMDXComponent=!0;const xpn={toc:[]},vpn="wrapper";function Lpn(t){let{components:e,...n}=t;return(0,s.kt)(vpn,(0,p.Z)({},xpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lpn.isMDXComponent=!0;const Zpn={toc:[]},bpn="wrapper";function Npn(t){let{components:e,...n}=t;return(0,s.kt)(bpn,(0,p.Z)({},Zpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Npn.isMDXComponent=!0;const zpn={toc:[]},Apn="wrapper";function Ppn(t){let{components:e,...n}=t;return(0,s.kt)(Apn,(0,p.Z)({},zpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Ppn.isMDXComponent=!0;const Ipn={toc:[]},Wpn="wrapper";function Rpn(t){let{components:e,...n}=t;return(0,s.kt)(Wpn,(0,p.Z)({},Ipn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Rpn.isMDXComponent=!0;const Spn={toc:[]},Bpn="wrapper";function Gpn(t){let{components:e,...n}=t;return(0,s.kt)(Bpn,(0,p.Z)({},Spn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Gpn.isMDXComponent=!0;const Epn={toc:[]},Opn="wrapper";function Upn(t){let{components:e,...n}=t;return(0,s.kt)(Opn,(0,p.Z)({},Epn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Upn.isMDXComponent=!0;const Fpn={toc:[]},Vpn="wrapper";function qpn(t){let{components:e,...n}=t;return(0,s.kt)(Vpn,(0,p.Z)({},Fpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qpn.isMDXComponent=!0;const jpn={toc:[]},Hpn="wrapper";function Ypn(t){let{components:e,...n}=t;return(0,s.kt)(Hpn,(0,p.Z)({},jpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Ypn.isMDXComponent=!0;const Qpn={toc:[]},$pn="wrapper";function Kpn(t){let{components:e,...n}=t;return(0,s.kt)($pn,(0,p.Z)({},Qpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]},trn="wrapper";function ern(t){let{components:e,...n}=t;return(0,s.kt)(trn,(0,p.Z)({},Jpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}ern.isMDXComponent=!0;const nrn={toc:[]},orn="wrapper";function prn(t){let{components:e,...n}=t;return(0,s.kt)(orn,(0,p.Z)({},nrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}prn.isMDXComponent=!0;const rrn={toc:[]},srn="wrapper";function crn(t){let{components:e,...n}=t;return(0,s.kt)(srn,(0,p.Z)({},rrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}crn.isMDXComponent=!0;const arn={toc:[]},irn="wrapper";function lrn(t){let{components:e,...n}=t;return(0,s.kt)(irn,(0,p.Z)({},arn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lrn.isMDXComponent=!0;const urn={toc:[]},mrn="wrapper";function drn(t){let{components:e,...n}=t;return(0,s.kt)(mrn,(0,p.Z)({},urn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}drn.isMDXComponent=!0;const hrn={toc:[]},frn="wrapper";function krn(t){let{components:e,...n}=t;return(0,s.kt)(frn,(0,p.Z)({},hrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}krn.isMDXComponent=!0;const yrn={toc:[]},Drn="wrapper";function Mrn(t){let{components:e,...n}=t;return(0,s.kt)(Drn,(0,p.Z)({},yrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Mrn.isMDXComponent=!0;const Xrn={toc:[]},_rn="wrapper";function wrn(t){let{components:e,...n}=t;return(0,s.kt)(_rn,(0,p.Z)({},Xrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wrn.isMDXComponent=!0;const Trn={toc:[]},Crn="wrapper";function grn(t){let{components:e,...n}=t;return(0,s.kt)(Crn,(0,p.Z)({},Trn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}grn.isMDXComponent=!0;const xrn={toc:[]},vrn="wrapper";function Lrn(t){let{components:e,...n}=t;return(0,s.kt)(vrn,(0,p.Z)({},xrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Lrn.isMDXComponent=!0;const Zrn={toc:[]},brn="wrapper";function Nrn(t){let{components:e,...n}=t;return(0,s.kt)(brn,(0,p.Z)({},Zrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Nrn.isMDXComponent=!0;const zrn={toc:[]},Arn="wrapper";function Prn(t){let{components:e,...n}=t;return(0,s.kt)(Arn,(0,p.Z)({},zrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Prn.isMDXComponent=!0;const Irn={toc:[]},Wrn="wrapper";function Rrn(t){let{components:e,...n}=t;return(0,s.kt)(Wrn,(0,p.Z)({},Irn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Rrn.isMDXComponent=!0;const Srn={toc:[]},Brn="wrapper";function Grn(t){let{components:e,...n}=t;return(0,s.kt)(Brn,(0,p.Z)({},Srn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Grn.isMDXComponent=!0;const Ern={toc:[]},Orn="wrapper";function Urn(t){let{components:e,...n}=t;return(0,s.kt)(Orn,(0,p.Z)({},Ern,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Urn.isMDXComponent=!0;const Frn={toc:[]},Vrn="wrapper";function qrn(t){let{components:e,...n}=t;return(0,s.kt)(Vrn,(0,p.Z)({},Frn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qrn.isMDXComponent=!0;const jrn={toc:[]},Hrn="wrapper";function Yrn(t){let{components:e,...n}=t;return(0,s.kt)(Hrn,(0,p.Z)({},jrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Yrn.isMDXComponent=!0;const Qrn={toc:[]},$rn="wrapper";function Krn(t){let{components:e,...n}=t;return(0,s.kt)($rn,(0,p.Z)({},Qrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Krn.isMDXComponent=!0;const Jrn={toc:[]},tsn="wrapper";function esn(t){let{components:e,...n}=t;return(0,s.kt)(tsn,(0,p.Z)({},Jrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}esn.isMDXComponent=!0;const nsn={toc:[]},osn="wrapper";function psn(t){let{components:e,...n}=t;return(0,s.kt)(osn,(0,p.Z)({},nsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}psn.isMDXComponent=!0;const rsn={toc:[]},ssn="wrapper";function csn(t){let{components:e,...n}=t;return(0,s.kt)(ssn,(0,p.Z)({},rsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}csn.isMDXComponent=!0;const asn={toc:[]},isn="wrapper";function lsn(t){let{components:e,...n}=t;return(0,s.kt)(isn,(0,p.Z)({},asn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lsn.isMDXComponent=!0;const usn={toc:[]},msn="wrapper";function dsn(t){let{components:e,...n}=t;return(0,s.kt)(msn,(0,p.Z)({},usn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dsn.isMDXComponent=!0;const hsn={toc:[]},fsn="wrapper";function ksn(t){let{components:e,...n}=t;return(0,s.kt)(fsn,(0,p.Z)({},hsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}ksn.isMDXComponent=!0;const ysn={toc:[]},Dsn="wrapper";function Msn(t){let{components:e,...n}=t;return(0,s.kt)(Dsn,(0,p.Z)({},ysn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Msn.isMDXComponent=!0;const Xsn={toc:[]},_sn="wrapper";function wsn(t){let{components:e,...n}=t;return(0,s.kt)(_sn,(0,p.Z)({},Xsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wsn.isMDXComponent=!0;const Tsn={toc:[]},Csn="wrapper";function gsn(t){let{components:e,...n}=t;return(0,s.kt)(Csn,(0,p.Z)({},Tsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gsn.isMDXComponent=!0;const xsn={toc:[]},vsn="wrapper";function Lsn(t){let{components:e,...n}=t;return(0,s.kt)(vsn,(0,p.Z)({},xsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Lsn.isMDXComponent=!0;const Zsn={toc:[]},bsn="wrapper";function Nsn(t){let{components:e,...n}=t;return(0,s.kt)(bsn,(0,p.Z)({},Zsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Nsn.isMDXComponent=!0;const zsn={toc:[]},Asn="wrapper";function Psn(t){let{components:e,...n}=t;return(0,s.kt)(Asn,(0,p.Z)({},zsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Psn.isMDXComponent=!0;const Isn={toc:[]},Wsn="wrapper";function Rsn(t){let{components:e,...n}=t;return(0,s.kt)(Wsn,(0,p.Z)({},Isn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Rsn.isMDXComponent=!0;const Ssn={toc:[]},Bsn="wrapper";function Gsn(t){let{components:e,...n}=t;return(0,s.kt)(Bsn,(0,p.Z)({},Ssn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}Gsn.isMDXComponent=!0;const Esn={toc:[]},Osn="wrapper";function Usn(t){let{components:e,...n}=t;return(0,s.kt)(Osn,(0,p.Z)({},Esn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}Usn.isMDXComponent=!0;const Fsn={toc:[]},Vsn="wrapper";function qsn(t){let{components:e,...n}=t;return(0,s.kt)(Vsn,(0,p.Z)({},Fsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}qsn.isMDXComponent=!0;const jsn={toc:[]},Hsn="wrapper";function Ysn(t){let{components:e,...n}=t;return(0,s.kt)(Hsn,(0,p.Z)({},jsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Ysn.isMDXComponent=!0;const Qsn={toc:[]},$sn="wrapper";function Ksn(t){let{components:e,...n}=t;return(0,s.kt)($sn,(0,p.Z)({},Qsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Ksn.isMDXComponent=!0;const Jsn={toc:[]},tcn="wrapper";function ecn(t){let{components:e,...n}=t;return(0,s.kt)(tcn,(0,p.Z)({},Jsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}ecn.isMDXComponent=!0;const ncn={toc:[]},ocn="wrapper";function pcn(t){let{components:e,...n}=t;return(0,s.kt)(ocn,(0,p.Z)({},ncn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pcn.isMDXComponent=!0;const rcn={toc:[]},scn="wrapper";function ccn(t){let{components:e,...n}=t;return(0,s.kt)(scn,(0,p.Z)({},rcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}ccn.isMDXComponent=!0;const acn={toc:[]},icn="wrapper";function lcn(t){let{components:e,...n}=t;return(0,s.kt)(icn,(0,p.Z)({},acn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}lcn.isMDXComponent=!0;const ucn={toc:[]},mcn="wrapper";function dcn(t){let{components:e,...n}=t;return(0,s.kt)(mcn,(0,p.Z)({},ucn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dcn.isMDXComponent=!0;const hcn={toc:[]},fcn="wrapper";function kcn(t){let{components:e,...n}=t;return(0,s.kt)(fcn,(0,p.Z)({},hcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}kcn.isMDXComponent=!0;const ycn={toc:[]},Dcn="wrapper";function Mcn(t){let{components:e,...n}=t;return(0,s.kt)(Dcn,(0,p.Z)({},ycn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Mcn.isMDXComponent=!0;const Xcn={toc:[]},_cn="wrapper";function wcn(t){let{components:e,...n}=t;return(0,s.kt)(_cn,(0,p.Z)({},Xcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wcn.isMDXComponent=!0;const Tcn={toc:[]},Ccn="wrapper";function gcn(t){let{components:e,...n}=t;return(0,s.kt)(Ccn,(0,p.Z)({},Tcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}gcn.isMDXComponent=!0;const xcn={toc:[]},vcn="wrapper";function Lcn(t){let{components:e,...n}=t;return(0,s.kt)(vcn,(0,p.Z)({},xcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Lcn.isMDXComponent=!0;const Zcn={toc:[]},bcn="wrapper";function Ncn(t){let{components:e,...n}=t;return(0,s.kt)(bcn,(0,p.Z)({},Zcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Ncn.isMDXComponent=!0;const zcn={toc:[]},Acn="wrapper";function Pcn(t){let{components:e,...n}=t;return(0,s.kt)(Acn,(0,p.Z)({},zcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Pcn.isMDXComponent=!0;const Icn={toc:[]},Wcn="wrapper";function Rcn(t){let{components:e,...n}=t;return(0,s.kt)(Wcn,(0,p.Z)({},Icn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Rcn.isMDXComponent=!0;const Scn={toc:[]},Bcn="wrapper";function Gcn(t){let{components:e,...n}=t;return(0,s.kt)(Bcn,(0,p.Z)({},Scn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Gcn.isMDXComponent=!0;const Ecn={toc:[]},Ocn="wrapper";function Ucn(t){let{components:e,...n}=t;return(0,s.kt)(Ocn,(0,p.Z)({},Ecn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Ucn.isMDXComponent=!0;const Fcn={toc:[]},Vcn="wrapper";function qcn(t){let{components:e,...n}=t;return(0,s.kt)(Vcn,(0,p.Z)({},Fcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qcn.isMDXComponent=!0;const jcn={toc:[]},Hcn="wrapper";function Ycn(t){let{components:e,...n}=t;return(0,s.kt)(Hcn,(0,p.Z)({},jcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Ycn.isMDXComponent=!0;const Qcn={toc:[]},$cn="wrapper";function Kcn(t){let{components:e,...n}=t;return(0,s.kt)($cn,(0,p.Z)({},Qcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Kcn.isMDXComponent=!0;const Jcn={toc:[]},tan="wrapper";function ean(t){let{components:e,...n}=t;return(0,s.kt)(tan,(0,p.Z)({},Jcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}ean.isMDXComponent=!0;const nan={toc:[]},oan="wrapper";function pan(t){let{components:e,...n}=t;return(0,s.kt)(oan,(0,p.Z)({},nan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}pan.isMDXComponent=!0;const ran={toc:[]},san="wrapper";function can(t){let{components:e,...n}=t;return(0,s.kt)(san,(0,p.Z)({},ran,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}can.isMDXComponent=!0;const aan={toc:[]},ian="wrapper";function lan(t){let{components:e,...n}=t;return(0,s.kt)(ian,(0,p.Z)({},aan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}lan.isMDXComponent=!0;const uan={toc:[]},man="wrapper";function dan(t){let{components:e,...n}=t;return(0,s.kt)(man,(0,p.Z)({},uan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}dan.isMDXComponent=!0;const han={toc:[]},fan="wrapper";function kan(t){let{components:e,...n}=t;return(0,s.kt)(fan,(0,p.Z)({},han,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kan.isMDXComponent=!0;const yan={toc:[]},Dan="wrapper";function Man(t){let{components:e,...n}=t;return(0,s.kt)(Dan,(0,p.Z)({},yan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Man.isMDXComponent=!0;const Xan={toc:[]},_an="wrapper";function wan(t){let{components:e,...n}=t;return(0,s.kt)(_an,(0,p.Z)({},Xan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}wan.isMDXComponent=!0;const Tan={toc:[]},Can="wrapper";function gan(t){let{components:e,...n}=t;return(0,s.kt)(Can,(0,p.Z)({},Tan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gan.isMDXComponent=!0;const xan={toc:[]},van="wrapper";function Lan(t){let{components:e,...n}=t;return(0,s.kt)(van,(0,p.Z)({},xan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Lan.isMDXComponent=!0;const Zan={toc:[]},ban="wrapper";function Nan(t){let{components:e,...n}=t;return(0,s.kt)(ban,(0,p.Z)({},Zan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Nan.isMDXComponent=!0;const zan={toc:[]},Aan="wrapper";function Pan(t){let{components:e,...n}=t;return(0,s.kt)(Aan,(0,p.Z)({},zan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Pan.isMDXComponent=!0;const Ian={toc:[]},Wan="wrapper";function Ran(t){let{components:e,...n}=t;return(0,s.kt)(Wan,(0,p.Z)({},Ian,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Ran.isMDXComponent=!0;const San={toc:[]},Ban="wrapper";function Gan(t){let{components:e,...n}=t;return(0,s.kt)(Ban,(0,p.Z)({},San,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Gan.isMDXComponent=!0;const Ean={toc:[]},Oan="wrapper";function Uan(t){let{components:e,...n}=t;return(0,s.kt)(Oan,(0,p.Z)({},Ean,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Uan.isMDXComponent=!0;const Fan={toc:[]},Van="wrapper";function qan(t){let{components:e,...n}=t;return(0,s.kt)(Van,(0,p.Z)({},Fan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qan.isMDXComponent=!0;const jan={toc:[]},Han="wrapper";function Yan(t){let{components:e,...n}=t;return(0,s.kt)(Han,(0,p.Z)({},jan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Yan.isMDXComponent=!0;const Qan={toc:[]},$an="wrapper";function Kan(t){let{components:e,...n}=t;return(0,s.kt)($an,(0,p.Z)({},Qan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Kan.isMDXComponent=!0;const Jan={toc:[]},tin="wrapper";function ein(t){let{components:e,...n}=t;return(0,s.kt)(tin,(0,p.Z)({},Jan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ein.isMDXComponent=!0;const nin={toc:[]},oin="wrapper";function pin(t){let{components:e,...n}=t;return(0,s.kt)(oin,(0,p.Z)({},nin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pin.isMDXComponent=!0;const rin={toc:[]},sin="wrapper";function cin(t){let{components:e,...n}=t;return(0,s.kt)(sin,(0,p.Z)({},rin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cin.isMDXComponent=!0;const ain={toc:[]},iin="wrapper";function lin(t){let{components:e,...n}=t;return(0,s.kt)(iin,(0,p.Z)({},ain,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lin.isMDXComponent=!0;const uin={toc:[]},min="wrapper";function din(t){let{components:e,...n}=t;return(0,s.kt)(min,(0,p.Z)({},uin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}din.isMDXComponent=!0;const hin={toc:[]},fin="wrapper";function kin(t){let{components:e,...n}=t;return(0,s.kt)(fin,(0,p.Z)({},hin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}kin.isMDXComponent=!0;const yin={toc:[]},Din="wrapper";function Min(t){let{components:e,...n}=t;return(0,s.kt)(Din,(0,p.Z)({},yin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Min.isMDXComponent=!0;const Xin={toc:[]},_in="wrapper";function win(t){let{components:e,...n}=t;return(0,s.kt)(_in,(0,p.Z)({},Xin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}win.isMDXComponent=!0;const Tin={toc:[]},Cin="wrapper";function gin(t){let{components:e,...n}=t;return(0,s.kt)(Cin,(0,p.Z)({},Tin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}gin.isMDXComponent=!0;const xin={toc:[]},vin="wrapper";function Lin(t){let{components:e,...n}=t;return(0,s.kt)(vin,(0,p.Z)({},xin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Lin.isMDXComponent=!0;const Zin={toc:[]},bin="wrapper";function Nin(t){let{components:e,...n}=t;return(0,s.kt)(bin,(0,p.Z)({},Zin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Nin.isMDXComponent=!0;const zin={toc:[]},Ain="wrapper";function Pin(t){let{components:e,...n}=t;return(0,s.kt)(Ain,(0,p.Z)({},zin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Pin.isMDXComponent=!0;const Iin={toc:[]},Win="wrapper";function Rin(t){let{components:e,...n}=t;return(0,s.kt)(Win,(0,p.Z)({},Iin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Rin.isMDXComponent=!0;const Sin={toc:[]},Bin="wrapper";function Gin(t){let{components:e,...n}=t;return(0,s.kt)(Bin,(0,p.Z)({},Sin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Gin.isMDXComponent=!0;const Ein={toc:[]},Oin="wrapper";function Uin(t){let{components:e,...n}=t;return(0,s.kt)(Oin,(0,p.Z)({},Ein,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Uin.isMDXComponent=!0;const Fin={toc:[]},Vin="wrapper";function qin(t){let{components:e,...n}=t;return(0,s.kt)(Vin,(0,p.Z)({},Fin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qin.isMDXComponent=!0;const jin={toc:[]},Hin="wrapper";function Yin(t){let{components:e,...n}=t;return(0,s.kt)(Hin,(0,p.Z)({},jin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Yin.isMDXComponent=!0;const Qin={toc:[]},$in="wrapper";function Kin(t){let{components:e,...n}=t;return(0,s.kt)($in,(0,p.Z)({},Qin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kin.isMDXComponent=!0;const Jin={toc:[]},tln="wrapper";function eln(t){let{components:e,...n}=t;return(0,s.kt)(tln,(0,p.Z)({},Jin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}eln.isMDXComponent=!0;const nln={toc:[]},oln="wrapper";function pln(t){let{components:e,...n}=t;return(0,s.kt)(oln,(0,p.Z)({},nln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}pln.isMDXComponent=!0;const rln={toc:[]},sln="wrapper";function cln(t){let{components:e,...n}=t;return(0,s.kt)(sln,(0,p.Z)({},rln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cln.isMDXComponent=!0;const aln={toc:[]},iln="wrapper";function lln(t){let{components:e,...n}=t;return(0,s.kt)(iln,(0,p.Z)({},aln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}lln.isMDXComponent=!0;const uln={toc:[]},mln="wrapper";function dln(t){let{components:e,...n}=t;return(0,s.kt)(mln,(0,p.Z)({},uln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}dln.isMDXComponent=!0;const hln={toc:[]},fln="wrapper";function kln(t){let{components:e,...n}=t;return(0,s.kt)(fln,(0,p.Z)({},hln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kln.isMDXComponent=!0;const yln={toc:[]},Dln="wrapper";function Mln(t){let{components:e,...n}=t;return(0,s.kt)(Dln,(0,p.Z)({},yln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Mln.isMDXComponent=!0;const Xln={toc:[]},_ln="wrapper";function wln(t){let{components:e,...n}=t;return(0,s.kt)(_ln,(0,p.Z)({},Xln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wln.isMDXComponent=!0;const Tln={toc:[]},Cln="wrapper";function gln(t){let{components:e,...n}=t;return(0,s.kt)(Cln,(0,p.Z)({},Tln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}gln.isMDXComponent=!0;const xln={toc:[]},vln="wrapper";function Lln(t){let{components:e,...n}=t;return(0,s.kt)(vln,(0,p.Z)({},xln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Lln.isMDXComponent=!0;const Zln={toc:[]},bln="wrapper";function Nln(t){let{components:e,...n}=t;return(0,s.kt)(bln,(0,p.Z)({},Zln,n,{components:e,mdxType:"MDXLayout"}))}Nln.isMDXComponent=!0;const zln={toc:[]},Aln="wrapper";function Pln(t){let{components:e,...n}=t;return(0,s.kt)(Aln,(0,p.Z)({},zln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Pln.isMDXComponent=!0;const Iln={toc:[]},Wln="wrapper";function Rln(t){let{components:e,...n}=t;return(0,s.kt)(Wln,(0,p.Z)({},Iln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Rln.isMDXComponent=!0;const Sln={toc:[]},Bln="wrapper";function Gln(t){let{components:e,...n}=t;return(0,s.kt)(Bln,(0,p.Z)({},Sln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Gln.isMDXComponent=!0;const Eln={toc:[]},Oln="wrapper";function Uln(t){let{components:e,...n}=t;return(0,s.kt)(Oln,(0,p.Z)({},Eln,n,{components:e,mdxType:"MDXLayout"}))}Uln.isMDXComponent=!0;const Fln={toc:[]},Vln="wrapper";function qln(t){let{components:e,...n}=t;return(0,s.kt)(Vln,(0,p.Z)({},Fln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qln.isMDXComponent=!0;const jln={toc:[]},Hln="wrapper";function Yln(t){let{components:e,...n}=t;return(0,s.kt)(Hln,(0,p.Z)({},jln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Yln.isMDXComponent=!0;const Qln={toc:[]},$ln="wrapper";function Kln(t){let{components:e,...n}=t;return(0,s.kt)($ln,(0,p.Z)({},Qln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Kln.isMDXComponent=!0;const Jln={toc:[]},tun="wrapper";function eun(t){let{components:e,...n}=t;return(0,s.kt)(tun,(0,p.Z)({},Jln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eun.isMDXComponent=!0;const nun={toc:[]},oun="wrapper";function pun(t){let{components:e,...n}=t;return(0,s.kt)(oun,(0,p.Z)({},nun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pun.isMDXComponent=!0;const run={toc:[]},sun="wrapper";function cun(t){let{components:e,...n}=t;return(0,s.kt)(sun,(0,p.Z)({},run,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cun.isMDXComponent=!0;const aun={toc:[]},iun="wrapper";function lun(t){let{components:e,...n}=t;return(0,s.kt)(iun,(0,p.Z)({},aun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lun.isMDXComponent=!0;const uun={toc:[]},mun="wrapper";function dun(t){let{components:e,...n}=t;return(0,s.kt)(mun,(0,p.Z)({},uun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}dun.isMDXComponent=!0;const hun={toc:[]},fun="wrapper";function kun(t){let{components:e,...n}=t;return(0,s.kt)(fun,(0,p.Z)({},hun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kun.isMDXComponent=!0;const yun={toc:[]},Dun="wrapper";function Mun(t){let{components:e,...n}=t;return(0,s.kt)(Dun,(0,p.Z)({},yun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Mun.isMDXComponent=!0;const Xun={toc:[]},_un="wrapper";function wun(t){let{components:e,...n}=t;return(0,s.kt)(_un,(0,p.Z)({},Xun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wun.isMDXComponent=!0;const Tun={toc:[]},Cun="wrapper";function gun(t){let{components:e,...n}=t;return(0,s.kt)(Cun,(0,p.Z)({},Tun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gun.isMDXComponent=!0;const xun={toc:[]},vun="wrapper";function Lun(t){let{components:e,...n}=t;return(0,s.kt)(vun,(0,p.Z)({},xun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Lun.isMDXComponent=!0;const Zun={toc:[]},bun="wrapper";function Nun(t){let{components:e,...n}=t;return(0,s.kt)(bun,(0,p.Z)({},Zun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Nun.isMDXComponent=!0;const zun={toc:[]},Aun="wrapper";function Pun(t){let{components:e,...n}=t;return(0,s.kt)(Aun,(0,p.Z)({},zun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Pun.isMDXComponent=!0;const Iun={toc:[]},Wun="wrapper";function Run(t){let{components:e,...n}=t;return(0,s.kt)(Wun,(0,p.Z)({},Iun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Run.isMDXComponent=!0;const Sun={toc:[]},Bun="wrapper";function Gun(t){let{components:e,...n}=t;return(0,s.kt)(Bun,(0,p.Z)({},Sun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Gun.isMDXComponent=!0;const Eun={toc:[]},Oun="wrapper";function Uun(t){let{components:e,...n}=t;return(0,s.kt)(Oun,(0,p.Z)({},Eun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Uun.isMDXComponent=!0;const Fun={toc:[]},Vun="wrapper";function qun(t){let{components:e,...n}=t;return(0,s.kt)(Vun,(0,p.Z)({},Fun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}qun.isMDXComponent=!0;const jun={toc:[]},Hun="wrapper";function Yun(t){let{components:e,...n}=t;return(0,s.kt)(Hun,(0,p.Z)({},jun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Yun.isMDXComponent=!0;const Qun={toc:[]},$un="wrapper";function Kun(t){let{components:e,...n}=t;return(0,s.kt)($un,(0,p.Z)({},Qun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Kun.isMDXComponent=!0;const Jun={toc:[]},tmn="wrapper";function emn(t){let{components:e,...n}=t;return(0,s.kt)(tmn,(0,p.Z)({},Jun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}emn.isMDXComponent=!0;const nmn={toc:[]},omn="wrapper";function pmn(t){let{components:e,...n}=t;return(0,s.kt)(omn,(0,p.Z)({},nmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pmn.isMDXComponent=!0;const rmn={toc:[]},smn="wrapper";function cmn(t){let{components:e,...n}=t;return(0,s.kt)(smn,(0,p.Z)({},rmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}cmn.isMDXComponent=!0;const amn={toc:[]},imn="wrapper";function lmn(t){let{components:e,...n}=t;return(0,s.kt)(imn,(0,p.Z)({},amn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lmn.isMDXComponent=!0;const umn={toc:[]},mmn="wrapper";function dmn(t){let{components:e,...n}=t;return(0,s.kt)(mmn,(0,p.Z)({},umn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dmn.isMDXComponent=!0;const hmn={toc:[]},fmn="wrapper";function kmn(t){let{components:e,...n}=t;return(0,s.kt)(fmn,(0,p.Z)({},hmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kmn.isMDXComponent=!0;const ymn={toc:[]},Dmn="wrapper";function Mmn(t){let{components:e,...n}=t;return(0,s.kt)(Dmn,(0,p.Z)({},ymn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mmn.isMDXComponent=!0;const Xmn={toc:[]},_mn="wrapper";function wmn(t){let{components:e,...n}=t;return(0,s.kt)(_mn,(0,p.Z)({},Xmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wmn.isMDXComponent=!0;const Tmn={toc:[]},Cmn="wrapper";function gmn(t){let{components:e,...n}=t;return(0,s.kt)(Cmn,(0,p.Z)({},Tmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}gmn.isMDXComponent=!0;const xmn={toc:[]},vmn="wrapper";function Lmn(t){let{components:e,...n}=t;return(0,s.kt)(vmn,(0,p.Z)({},xmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lmn.isMDXComponent=!0;const Zmn={toc:[]},bmn="wrapper";function Nmn(t){let{components:e,...n}=t;return(0,s.kt)(bmn,(0,p.Z)({},Zmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Nmn.isMDXComponent=!0;const zmn={toc:[]},Amn="wrapper";function Pmn(t){let{components:e,...n}=t;return(0,s.kt)(Amn,(0,p.Z)({},zmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pmn.isMDXComponent=!0;const Imn={toc:[]},Wmn="wrapper";function Rmn(t){let{components:e,...n}=t;return(0,s.kt)(Wmn,(0,p.Z)({},Imn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Rmn.isMDXComponent=!0;const Smn={toc:[]},Bmn="wrapper";function Gmn(t){let{components:e,...n}=t;return(0,s.kt)(Bmn,(0,p.Z)({},Smn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gmn.isMDXComponent=!0;const Emn={toc:[]},Omn="wrapper";function Umn(t){let{components:e,...n}=t;return(0,s.kt)(Omn,(0,p.Z)({},Emn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Umn.isMDXComponent=!0;const Fmn={toc:[]},Vmn="wrapper";function qmn(t){let{components:e,...n}=t;return(0,s.kt)(Vmn,(0,p.Z)({},Fmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qmn.isMDXComponent=!0;const jmn={toc:[]},Hmn="wrapper";function Ymn(t){let{components:e,...n}=t;return(0,s.kt)(Hmn,(0,p.Z)({},jmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ymn.isMDXComponent=!0;const Qmn={toc:[]},$mn="wrapper";function Kmn(t){let{components:e,...n}=t;return(0,s.kt)($mn,(0,p.Z)({},Qmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kmn.isMDXComponent=!0;const Jmn={toc:[]},tdn="wrapper";function edn(t){let{components:e,...n}=t;return(0,s.kt)(tdn,(0,p.Z)({},Jmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}edn.isMDXComponent=!0;const ndn={toc:[]},odn="wrapper";function pdn(t){let{components:e,...n}=t;return(0,s.kt)(odn,(0,p.Z)({},ndn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pdn.isMDXComponent=!0;const rdn={toc:[]},sdn="wrapper";function cdn(t){let{components:e,...n}=t;return(0,s.kt)(sdn,(0,p.Z)({},rdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cdn.isMDXComponent=!0;const adn={toc:[]},idn="wrapper";function ldn(t){let{components:e,...n}=t;return(0,s.kt)(idn,(0,p.Z)({},adn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ldn.isMDXComponent=!0;const udn={toc:[]},mdn="wrapper";function ddn(t){let{components:e,...n}=t;return(0,s.kt)(mdn,(0,p.Z)({},udn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}ddn.isMDXComponent=!0;const hdn={toc:[]},fdn="wrapper";function kdn(t){let{components:e,...n}=t;return(0,s.kt)(fdn,(0,p.Z)({},hdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kdn.isMDXComponent=!0;const ydn={toc:[]},Ddn="wrapper";function Mdn(t){let{components:e,...n}=t;return(0,s.kt)(Ddn,(0,p.Z)({},ydn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mdn.isMDXComponent=!0;const Xdn={toc:[]},_dn="wrapper";function wdn(t){let{components:e,...n}=t;return(0,s.kt)(_dn,(0,p.Z)({},Xdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wdn.isMDXComponent=!0;const Tdn={toc:[]},Cdn="wrapper";function gdn(t){let{components:e,...n}=t;return(0,s.kt)(Cdn,(0,p.Z)({},Tdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}gdn.isMDXComponent=!0;const xdn={toc:[]},vdn="wrapper";function Ldn(t){let{components:e,...n}=t;return(0,s.kt)(vdn,(0,p.Z)({},xdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Ldn.isMDXComponent=!0;const Zdn={toc:[]},bdn="wrapper";function Ndn(t){let{components:e,...n}=t;return(0,s.kt)(bdn,(0,p.Z)({},Zdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ndn.isMDXComponent=!0;const zdn={toc:[]},Adn="wrapper";function Pdn(t){let{components:e,...n}=t;return(0,s.kt)(Adn,(0,p.Z)({},zdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Pdn.isMDXComponent=!0;const Idn={toc:[]},Wdn="wrapper";function Rdn(t){let{components:e,...n}=t;return(0,s.kt)(Wdn,(0,p.Z)({},Idn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Rdn.isMDXComponent=!0;const Sdn={toc:[]},Bdn="wrapper";function Gdn(t){let{components:e,...n}=t;return(0,s.kt)(Bdn,(0,p.Z)({},Sdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Gdn.isMDXComponent=!0;const Edn={toc:[]},Odn="wrapper";function Udn(t){let{components:e,...n}=t;return(0,s.kt)(Odn,(0,p.Z)({},Edn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Udn.isMDXComponent=!0;const Fdn={toc:[]},Vdn="wrapper";function qdn(t){let{components:e,...n}=t;return(0,s.kt)(Vdn,(0,p.Z)({},Fdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qdn.isMDXComponent=!0;const jdn={toc:[]},Hdn="wrapper";function Ydn(t){let{components:e,...n}=t;return(0,s.kt)(Hdn,(0,p.Z)({},jdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Ydn.isMDXComponent=!0;const Qdn={toc:[]},$dn="wrapper";function Kdn(t){let{components:e,...n}=t;return(0,s.kt)($dn,(0,p.Z)({},Qdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Kdn.isMDXComponent=!0;const Jdn={toc:[]},thn="wrapper";function ehn(t){let{components:e,...n}=t;return(0,s.kt)(thn,(0,p.Z)({},Jdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}ehn.isMDXComponent=!0;const nhn={toc:[]},ohn="wrapper";function phn(t){let{components:e,...n}=t;return(0,s.kt)(ohn,(0,p.Z)({},nhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}phn.isMDXComponent=!0;const rhn={toc:[]},shn="wrapper";function chn(t){let{components:e,...n}=t;return(0,s.kt)(shn,(0,p.Z)({},rhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}chn.isMDXComponent=!0;const ahn={toc:[]},ihn="wrapper";function lhn(t){let{components:e,...n}=t;return(0,s.kt)(ihn,(0,p.Z)({},ahn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}lhn.isMDXComponent=!0;const uhn={toc:[]},mhn="wrapper";function dhn(t){let{components:e,...n}=t;return(0,s.kt)(mhn,(0,p.Z)({},uhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}dhn.isMDXComponent=!0;const hhn={toc:[]},fhn="wrapper";function khn(t){let{components:e,...n}=t;return(0,s.kt)(fhn,(0,p.Z)({},hhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}khn.isMDXComponent=!0;const yhn={toc:[]},Dhn="wrapper";function Mhn(t){let{components:e,...n}=t;return(0,s.kt)(Dhn,(0,p.Z)({},yhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Mhn.isMDXComponent=!0;const Xhn={toc:[]},_hn="wrapper";function whn(t){let{components:e,...n}=t;return(0,s.kt)(_hn,(0,p.Z)({},Xhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}whn.isMDXComponent=!0;const Thn={toc:[]},Chn="wrapper";function ghn(t){let{components:e,...n}=t;return(0,s.kt)(Chn,(0,p.Z)({},Thn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}ghn.isMDXComponent=!0;const xhn={toc:[]},vhn="wrapper";function Lhn(t){let{components:e,...n}=t;return(0,s.kt)(vhn,(0,p.Z)({},xhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Lhn.isMDXComponent=!0;const Zhn={toc:[]},bhn="wrapper";function Nhn(t){let{components:e,...n}=t;return(0,s.kt)(bhn,(0,p.Z)({},Zhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nhn.isMDXComponent=!0;const zhn={toc:[]},Ahn="wrapper";function Phn(t){let{components:e,...n}=t;return(0,s.kt)(Ahn,(0,p.Z)({},zhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Phn.isMDXComponent=!0;const Ihn={toc:[]},Whn="wrapper";function Rhn(t){let{components:e,...n}=t;return(0,s.kt)(Whn,(0,p.Z)({},Ihn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Rhn.isMDXComponent=!0;const Shn={toc:[]},Bhn="wrapper";function Ghn(t){let{components:e,...n}=t;return(0,s.kt)(Bhn,(0,p.Z)({},Shn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Ghn.isMDXComponent=!0;const Ehn={toc:[]},Ohn="wrapper";function Uhn(t){let{components:e,...n}=t;return(0,s.kt)(Ohn,(0,p.Z)({},Ehn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Uhn.isMDXComponent=!0;const Fhn={toc:[]},Vhn="wrapper";function qhn(t){let{components:e,...n}=t;return(0,s.kt)(Vhn,(0,p.Z)({},Fhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qhn.isMDXComponent=!0;const jhn={toc:[]},Hhn="wrapper";function Yhn(t){let{components:e,...n}=t;return(0,s.kt)(Hhn,(0,p.Z)({},jhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Yhn.isMDXComponent=!0;const Qhn={toc:[]},$hn="wrapper";function Khn(t){let{components:e,...n}=t;return(0,s.kt)($hn,(0,p.Z)({},Qhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Khn.isMDXComponent=!0;const Jhn={toc:[]},tfn="wrapper";function efn(t){let{components:e,...n}=t;return(0,s.kt)(tfn,(0,p.Z)({},Jhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}efn.isMDXComponent=!0;const nfn={toc:[]},ofn="wrapper";function pfn(t){let{components:e,...n}=t;return(0,s.kt)(ofn,(0,p.Z)({},nfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}pfn.isMDXComponent=!0;const rfn={toc:[]},sfn="wrapper";function cfn(t){let{components:e,...n}=t;return(0,s.kt)(sfn,(0,p.Z)({},rfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}cfn.isMDXComponent=!0;const afn={toc:[]},ifn="wrapper";function lfn(t){let{components:e,...n}=t;return(0,s.kt)(ifn,(0,p.Z)({},afn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lfn.isMDXComponent=!0;const ufn={toc:[]},mfn="wrapper";function dfn(t){let{components:e,...n}=t;return(0,s.kt)(mfn,(0,p.Z)({},ufn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}dfn.isMDXComponent=!0;const hfn={toc:[]},ffn="wrapper";function kfn(t){let{components:e,...n}=t;return(0,s.kt)(ffn,(0,p.Z)({},hfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}kfn.isMDXComponent=!0;const yfn={toc:[]},Dfn="wrapper";function Mfn(t){let{components:e,...n}=t;return(0,s.kt)(Dfn,(0,p.Z)({},yfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Mfn.isMDXComponent=!0;const Xfn={toc:[]},_fn="wrapper";function wfn(t){let{components:e,...n}=t;return(0,s.kt)(_fn,(0,p.Z)({},Xfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wfn.isMDXComponent=!0;const Tfn={toc:[]},Cfn="wrapper";function gfn(t){let{components:e,...n}=t;return(0,s.kt)(Cfn,(0,p.Z)({},Tfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}gfn.isMDXComponent=!0;const xfn={toc:[]},vfn="wrapper";function Lfn(t){let{components:e,...n}=t;return(0,s.kt)(vfn,(0,p.Z)({},xfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Lfn.isMDXComponent=!0;const Zfn={toc:[]},bfn="wrapper";function Nfn(t){let{components:e,...n}=t;return(0,s.kt)(bfn,(0,p.Z)({},Zfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Nfn.isMDXComponent=!0;const zfn={toc:[]},Afn="wrapper";function Pfn(t){let{components:e,...n}=t;return(0,s.kt)(Afn,(0,p.Z)({},zfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Pfn.isMDXComponent=!0;const Ifn={toc:[]},Wfn="wrapper";function Rfn(t){let{components:e,...n}=t;return(0,s.kt)(Wfn,(0,p.Z)({},Ifn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}Rfn.isMDXComponent=!0;const Sfn={toc:[]},Bfn="wrapper";function Gfn(t){let{components:e,...n}=t;return(0,s.kt)(Bfn,(0,p.Z)({},Sfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}Gfn.isMDXComponent=!0;const Efn={toc:[]},Ofn="wrapper";function Ufn(t){let{components:e,...n}=t;return(0,s.kt)(Ofn,(0,p.Z)({},Efn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Ufn.isMDXComponent=!0;const Ffn={toc:[]},Vfn="wrapper";function qfn(t){let{components:e,...n}=t;return(0,s.kt)(Vfn,(0,p.Z)({},Ffn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}qfn.isMDXComponent=!0;const jfn={toc:[]},Hfn="wrapper";function Yfn(t){let{components:e,...n}=t;return(0,s.kt)(Hfn,(0,p.Z)({},jfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Yfn.isMDXComponent=!0;const Qfn={toc:[]},$fn="wrapper";function Kfn(t){let{components:e,...n}=t;return(0,s.kt)($fn,(0,p.Z)({},Qfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]},tkn="wrapper";function ekn(t){let{components:e,...n}=t;return(0,s.kt)(tkn,(0,p.Z)({},Jfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ekn.isMDXComponent=!0;const nkn={toc:[]},okn="wrapper";function pkn(t){let{components:e,...n}=t;return(0,s.kt)(okn,(0,p.Z)({},nkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pkn.isMDXComponent=!0;const rkn={toc:[]},skn="wrapper";function ckn(t){let{components:e,...n}=t;return(0,s.kt)(skn,(0,p.Z)({},rkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ckn.isMDXComponent=!0;const akn={toc:[]},ikn="wrapper";function lkn(t){let{components:e,...n}=t;return(0,s.kt)(ikn,(0,p.Z)({},akn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lkn.isMDXComponent=!0;const ukn={toc:[]},mkn="wrapper";function dkn(t){let{components:e,...n}=t;return(0,s.kt)(mkn,(0,p.Z)({},ukn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dkn.isMDXComponent=!0;const hkn={toc:[]},fkn="wrapper";function kkn(t){let{components:e,...n}=t;return(0,s.kt)(fkn,(0,p.Z)({},hkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kkn.isMDXComponent=!0;const ykn={toc:[]},Dkn="wrapper";function Mkn(t){let{components:e,...n}=t;return(0,s.kt)(Dkn,(0,p.Z)({},ykn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Mkn.isMDXComponent=!0;const Xkn={toc:[]},_kn="wrapper";function wkn(t){let{components:e,...n}=t;return(0,s.kt)(_kn,(0,p.Z)({},Xkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wkn.isMDXComponent=!0;const Tkn={toc:[]},Ckn="wrapper";function gkn(t){let{components:e,...n}=t;return(0,s.kt)(Ckn,(0,p.Z)({},Tkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gkn.isMDXComponent=!0;const xkn={toc:[]},vkn="wrapper";function Lkn(t){let{components:e,...n}=t;return(0,s.kt)(vkn,(0,p.Z)({},xkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lkn.isMDXComponent=!0;const Zkn={toc:[]},bkn="wrapper";function Nkn(t){let{components:e,...n}=t;return(0,s.kt)(bkn,(0,p.Z)({},Zkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Nkn.isMDXComponent=!0;const zkn={toc:[]},Akn="wrapper";function Pkn(t){let{components:e,...n}=t;return(0,s.kt)(Akn,(0,p.Z)({},zkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Pkn.isMDXComponent=!0;const Ikn={toc:[]},Wkn="wrapper";function Rkn(t){let{components:e,...n}=t;return(0,s.kt)(Wkn,(0,p.Z)({},Ikn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Rkn.isMDXComponent=!0;const Skn={toc:[]},Bkn="wrapper";function Gkn(t){let{components:e,...n}=t;return(0,s.kt)(Bkn,(0,p.Z)({},Skn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Gkn.isMDXComponent=!0;const Ekn={toc:[]},Okn="wrapper";function Ukn(t){let{components:e,...n}=t;return(0,s.kt)(Okn,(0,p.Z)({},Ekn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Ukn.isMDXComponent=!0;const Fkn={toc:[]},Vkn="wrapper";function qkn(t){let{components:e,...n}=t;return(0,s.kt)(Vkn,(0,p.Z)({},Fkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qkn.isMDXComponent=!0;const jkn={toc:[]},Hkn="wrapper";function Ykn(t){let{components:e,...n}=t;return(0,s.kt)(Hkn,(0,p.Z)({},jkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ykn.isMDXComponent=!0;const Qkn={toc:[]},$kn="wrapper";function Kkn(t){let{components:e,...n}=t;return(0,s.kt)($kn,(0,p.Z)({},Qkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]},tyn="wrapper";function eyn(t){let{components:e,...n}=t;return(0,s.kt)(tyn,(0,p.Z)({},Jkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}eyn.isMDXComponent=!0;const nyn={toc:[]},oyn="wrapper";function pyn(t){let{components:e,...n}=t;return(0,s.kt)(oyn,(0,p.Z)({},nyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}pyn.isMDXComponent=!0;const ryn={toc:[]},syn="wrapper";function cyn(t){let{components:e,...n}=t;return(0,s.kt)(syn,(0,p.Z)({},ryn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cyn.isMDXComponent=!0;const ayn={toc:[]},iyn="wrapper";function lyn(t){let{components:e,...n}=t;return(0,s.kt)(iyn,(0,p.Z)({},ayn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lyn.isMDXComponent=!0;const uyn={toc:[]},myn="wrapper";function dyn(t){let{components:e,...n}=t;return(0,s.kt)(myn,(0,p.Z)({},uyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}dyn.isMDXComponent=!0;const hyn={toc:[]},fyn="wrapper";function kyn(t){let{components:e,...n}=t;return(0,s.kt)(fyn,(0,p.Z)({},hyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}kyn.isMDXComponent=!0;const yyn={toc:[]},Dyn="wrapper";function Myn(t){let{components:e,...n}=t;return(0,s.kt)(Dyn,(0,p.Z)({},yyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Myn.isMDXComponent=!0;const Xyn={toc:[]},_yn="wrapper";function wyn(t){let{components:e,...n}=t;return(0,s.kt)(_yn,(0,p.Z)({},Xyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wyn.isMDXComponent=!0;const Tyn={toc:[]},Cyn="wrapper";function gyn(t){let{components:e,...n}=t;return(0,s.kt)(Cyn,(0,p.Z)({},Tyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gyn.isMDXComponent=!0;const xyn={toc:[]},vyn="wrapper";function Lyn(t){let{components:e,...n}=t;return(0,s.kt)(vyn,(0,p.Z)({},xyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Lyn.isMDXComponent=!0;const Zyn={toc:[]},byn="wrapper";function Nyn(t){let{components:e,...n}=t;return(0,s.kt)(byn,(0,p.Z)({},Zyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Nyn.isMDXComponent=!0;const zyn={toc:[]},Ayn="wrapper";function Pyn(t){let{components:e,...n}=t;return(0,s.kt)(Ayn,(0,p.Z)({},zyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Pyn.isMDXComponent=!0;const Iyn={toc:[]},Wyn="wrapper";function Ryn(t){let{components:e,...n}=t;return(0,s.kt)(Wyn,(0,p.Z)({},Iyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ryn.isMDXComponent=!0;const Syn={toc:[]},Byn="wrapper";function Gyn(t){let{components:e,...n}=t;return(0,s.kt)(Byn,(0,p.Z)({},Syn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Gyn.isMDXComponent=!0;const Eyn={toc:[]},Oyn="wrapper";function Uyn(t){let{components:e,...n}=t;return(0,s.kt)(Oyn,(0,p.Z)({},Eyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Uyn.isMDXComponent=!0;const Fyn={toc:[]},Vyn="wrapper";function qyn(t){let{components:e,...n}=t;return(0,s.kt)(Vyn,(0,p.Z)({},Fyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qyn.isMDXComponent=!0;const jyn={toc:[]},Hyn="wrapper";function Yyn(t){let{components:e,...n}=t;return(0,s.kt)(Hyn,(0,p.Z)({},jyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Yyn.isMDXComponent=!0;const Qyn={toc:[]},$yn="wrapper";function Kyn(t){let{components:e,...n}=t;return(0,s.kt)($yn,(0,p.Z)({},Qyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Kyn.isMDXComponent=!0;const Jyn={toc:[]},tDn="wrapper";function eDn(t){let{components:e,...n}=t;return(0,s.kt)(tDn,(0,p.Z)({},Jyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eDn.isMDXComponent=!0;const nDn={toc:[]},oDn="wrapper";function pDn(t){let{components:e,...n}=t;return(0,s.kt)(oDn,(0,p.Z)({},nDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pDn.isMDXComponent=!0;const rDn={toc:[]},sDn="wrapper";function cDn(t){let{components:e,...n}=t;return(0,s.kt)(sDn,(0,p.Z)({},rDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cDn.isMDXComponent=!0;const aDn={toc:[]},iDn="wrapper";function lDn(t){let{components:e,...n}=t;return(0,s.kt)(iDn,(0,p.Z)({},aDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lDn.isMDXComponent=!0;const uDn={toc:[]},mDn="wrapper";function dDn(t){let{components:e,...n}=t;return(0,s.kt)(mDn,(0,p.Z)({},uDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dDn.isMDXComponent=!0;const hDn={toc:[]},fDn="wrapper";function kDn(t){let{components:e,...n}=t;return(0,s.kt)(fDn,(0,p.Z)({},hDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kDn.isMDXComponent=!0;const yDn={toc:[]},DDn="wrapper";function MDn(t){let{components:e,...n}=t;return(0,s.kt)(DDn,(0,p.Z)({},yDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}MDn.isMDXComponent=!0;const XDn={toc:[]},_Dn="wrapper";function wDn(t){let{components:e,...n}=t;return(0,s.kt)(_Dn,(0,p.Z)({},XDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wDn.isMDXComponent=!0;const TDn={toc:[]},CDn="wrapper";function gDn(t){let{components:e,...n}=t;return(0,s.kt)(CDn,(0,p.Z)({},TDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}gDn.isMDXComponent=!0;const xDn={toc:[]},vDn="wrapper";function LDn(t){let{components:e,...n}=t;return(0,s.kt)(vDn,(0,p.Z)({},xDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}LDn.isMDXComponent=!0;const ZDn={toc:[]},bDn="wrapper";function NDn(t){let{components:e,...n}=t;return(0,s.kt)(bDn,(0,p.Z)({},ZDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}NDn.isMDXComponent=!0;const zDn={toc:[]},ADn="wrapper";function PDn(t){let{components:e,...n}=t;return(0,s.kt)(ADn,(0,p.Z)({},zDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}PDn.isMDXComponent=!0;const IDn={toc:[]},WDn="wrapper";function RDn(t){let{components:e,...n}=t;return(0,s.kt)(WDn,(0,p.Z)({},IDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}RDn.isMDXComponent=!0;const SDn={toc:[]},BDn="wrapper";function GDn(t){let{components:e,...n}=t;return(0,s.kt)(BDn,(0,p.Z)({},SDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}GDn.isMDXComponent=!0;const EDn={toc:[]},ODn="wrapper";function UDn(t){let{components:e,...n}=t;return(0,s.kt)(ODn,(0,p.Z)({},EDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}UDn.isMDXComponent=!0;const FDn={toc:[]},VDn="wrapper";function qDn(t){let{components:e,...n}=t;return(0,s.kt)(VDn,(0,p.Z)({},FDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qDn.isMDXComponent=!0;const jDn={toc:[]},HDn="wrapper";function YDn(t){let{components:e,...n}=t;return(0,s.kt)(HDn,(0,p.Z)({},jDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}YDn.isMDXComponent=!0;const QDn={toc:[]},$Dn="wrapper";function KDn(t){let{components:e,...n}=t;return(0,s.kt)($Dn,(0,p.Z)({},QDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}KDn.isMDXComponent=!0;const JDn={toc:[]},tMn="wrapper";function eMn(t){let{components:e,...n}=t;return(0,s.kt)(tMn,(0,p.Z)({},JDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eMn.isMDXComponent=!0;const nMn={toc:[]},oMn="wrapper";function pMn(t){let{components:e,...n}=t;return(0,s.kt)(oMn,(0,p.Z)({},nMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pMn.isMDXComponent=!0;const rMn={toc:[]},sMn="wrapper";function cMn(t){let{components:e,...n}=t;return(0,s.kt)(sMn,(0,p.Z)({},rMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cMn.isMDXComponent=!0;const aMn={toc:[]},iMn="wrapper";function lMn(t){let{components:e,...n}=t;return(0,s.kt)(iMn,(0,p.Z)({},aMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lMn.isMDXComponent=!0;const uMn={toc:[]},mMn="wrapper";function dMn(t){let{components:e,...n}=t;return(0,s.kt)(mMn,(0,p.Z)({},uMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dMn.isMDXComponent=!0;const hMn={toc:[]},fMn="wrapper";function kMn(t){let{components:e,...n}=t;return(0,s.kt)(fMn,(0,p.Z)({},hMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kMn.isMDXComponent=!0;const yMn={toc:[]},DMn="wrapper";function MMn(t){let{components:e,...n}=t;return(0,s.kt)(DMn,(0,p.Z)({},yMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MMn.isMDXComponent=!0;const XMn={toc:[]},_Mn="wrapper";function wMn(t){let{components:e,...n}=t;return(0,s.kt)(_Mn,(0,p.Z)({},XMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wMn.isMDXComponent=!0;const TMn={toc:[]},CMn="wrapper";function gMn(t){let{components:e,...n}=t;return(0,s.kt)(CMn,(0,p.Z)({},TMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}gMn.isMDXComponent=!0;const xMn={toc:[]},vMn="wrapper";function LMn(t){let{components:e,...n}=t;return(0,s.kt)(vMn,(0,p.Z)({},xMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}LMn.isMDXComponent=!0;const ZMn={toc:[]},bMn="wrapper";function NMn(t){let{components:e,...n}=t;return(0,s.kt)(bMn,(0,p.Z)({},ZMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}NMn.isMDXComponent=!0;const zMn={toc:[]},AMn="wrapper";function PMn(t){let{components:e,...n}=t;return(0,s.kt)(AMn,(0,p.Z)({},zMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}PMn.isMDXComponent=!0;const IMn={toc:[]},WMn="wrapper";function RMn(t){let{components:e,...n}=t;return(0,s.kt)(WMn,(0,p.Z)({},IMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}RMn.isMDXComponent=!0;const SMn={toc:[]},BMn="wrapper";function GMn(t){let{components:e,...n}=t;return(0,s.kt)(BMn,(0,p.Z)({},SMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}GMn.isMDXComponent=!0;const EMn={toc:[]},OMn="wrapper";function UMn(t){let{components:e,...n}=t;return(0,s.kt)(OMn,(0,p.Z)({},EMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}UMn.isMDXComponent=!0;const FMn={toc:[]},VMn="wrapper";function qMn(t){let{components:e,...n}=t;return(0,s.kt)(VMn,(0,p.Z)({},FMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}qMn.isMDXComponent=!0;const jMn={toc:[]},HMn="wrapper";function YMn(t){let{components:e,...n}=t;return(0,s.kt)(HMn,(0,p.Z)({},jMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}YMn.isMDXComponent=!0;const QMn={toc:[]},$Mn="wrapper";function KMn(t){let{components:e,...n}=t;return(0,s.kt)($Mn,(0,p.Z)({},QMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}KMn.isMDXComponent=!0;const JMn={toc:[]},tXn="wrapper";function eXn(t){let{components:e,...n}=t;return(0,s.kt)(tXn,(0,p.Z)({},JMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eXn.isMDXComponent=!0;const nXn={toc:[]},oXn="wrapper";function pXn(t){let{components:e,...n}=t;return(0,s.kt)(oXn,(0,p.Z)({},nXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}pXn.isMDXComponent=!0;const rXn={toc:[]},sXn="wrapper";function cXn(t){let{components:e,...n}=t;return(0,s.kt)(sXn,(0,p.Z)({},rXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}cXn.isMDXComponent=!0;const aXn={toc:[]},iXn="wrapper";function lXn(t){let{components:e,...n}=t;return(0,s.kt)(iXn,(0,p.Z)({},aXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lXn.isMDXComponent=!0;const uXn={toc:[]},mXn="wrapper";function dXn(t){let{components:e,...n}=t;return(0,s.kt)(mXn,(0,p.Z)({},uXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dXn.isMDXComponent=!0;const hXn={toc:[]},fXn="wrapper";function kXn(t){let{components:e,...n}=t;return(0,s.kt)(fXn,(0,p.Z)({},hXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kXn.isMDXComponent=!0;const yXn={toc:[]},DXn="wrapper";function MXn(t){let{components:e,...n}=t;return(0,s.kt)(DXn,(0,p.Z)({},yXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}MXn.isMDXComponent=!0;const XXn={toc:[]},_Xn="wrapper";function wXn(t){let{components:e,...n}=t;return(0,s.kt)(_Xn,(0,p.Z)({},XXn,n,{components:e,mdxType:"MDXLayout"}))}wXn.isMDXComponent=!0;const TXn={toc:[]},CXn="wrapper";function gXn(t){let{components:e,...n}=t;return(0,s.kt)(CXn,(0,p.Z)({},TXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gXn.isMDXComponent=!0;const xXn={toc:[]},vXn="wrapper";function LXn(t){let{components:e,...n}=t;return(0,s.kt)(vXn,(0,p.Z)({},xXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}LXn.isMDXComponent=!0;const ZXn={toc:[]},bXn="wrapper";function NXn(t){let{components:e,...n}=t;return(0,s.kt)(bXn,(0,p.Z)({},ZXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}NXn.isMDXComponent=!0;const zXn={toc:[]},AXn="wrapper";function PXn(t){let{components:e,...n}=t;return(0,s.kt)(AXn,(0,p.Z)({},zXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}PXn.isMDXComponent=!0;const IXn={toc:[]},WXn="wrapper";function RXn(t){let{components:e,...n}=t;return(0,s.kt)(WXn,(0,p.Z)({},IXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}RXn.isMDXComponent=!0;const SXn={toc:[]},BXn="wrapper";function GXn(t){let{components:e,...n}=t;return(0,s.kt)(BXn,(0,p.Z)({},SXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}GXn.isMDXComponent=!0;const EXn={toc:[]},OXn="wrapper";function UXn(t){let{components:e,...n}=t;return(0,s.kt)(OXn,(0,p.Z)({},EXn,n,{components:e,mdxType:"MDXLayout"}))}UXn.isMDXComponent=!0;const FXn={toc:[]},VXn="wrapper";function qXn(t){let{components:e,...n}=t;return(0,s.kt)(VXn,(0,p.Z)({},FXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qXn.isMDXComponent=!0;const jXn={toc:[]},HXn="wrapper";function YXn(t){let{components:e,...n}=t;return(0,s.kt)(HXn,(0,p.Z)({},jXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}YXn.isMDXComponent=!0;const QXn={toc:[]},$Xn="wrapper";function KXn(t){let{components:e,...n}=t;return(0,s.kt)($Xn,(0,p.Z)({},QXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}KXn.isMDXComponent=!0;const JXn={toc:[]},t_n="wrapper";function e_n(t){let{components:e,...n}=t;return(0,s.kt)(t_n,(0,p.Z)({},JXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}e_n.isMDXComponent=!0;const n_n={toc:[]},o_n="wrapper";function p_n(t){let{components:e,...n}=t;return(0,s.kt)(o_n,(0,p.Z)({},n_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}p_n.isMDXComponent=!0;const r_n={toc:[]},s_n="wrapper";function c_n(t){let{components:e,...n}=t;return(0,s.kt)(s_n,(0,p.Z)({},r_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}c_n.isMDXComponent=!0;const a_n={toc:[]},i_n="wrapper";function l_n(t){let{components:e,...n}=t;return(0,s.kt)(i_n,(0,p.Z)({},a_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}l_n.isMDXComponent=!0;const u_n={toc:[]},m_n="wrapper";function d_n(t){let{components:e,...n}=t;return(0,s.kt)(m_n,(0,p.Z)({},u_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}d_n.isMDXComponent=!0;const h_n={toc:[]},f_n="wrapper";function k_n(t){let{components:e,...n}=t;return(0,s.kt)(f_n,(0,p.Z)({},h_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}k_n.isMDXComponent=!0;const y_n={toc:[]},D_n="wrapper";function M_n(t){let{components:e,...n}=t;return(0,s.kt)(D_n,(0,p.Z)({},y_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}M_n.isMDXComponent=!0;const X_n={toc:[]},__n="wrapper";function w_n(t){let{components:e,...n}=t;return(0,s.kt)(__n,(0,p.Z)({},X_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}w_n.isMDXComponent=!0;const T_n={toc:[]},C_n="wrapper";function g_n(t){let{components:e,...n}=t;return(0,s.kt)(C_n,(0,p.Z)({},T_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}g_n.isMDXComponent=!0;const x_n={toc:[]},v_n="wrapper";function L_n(t){let{components:e,...n}=t;return(0,s.kt)(v_n,(0,p.Z)({},x_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}L_n.isMDXComponent=!0;const Z_n={toc:[]},b_n="wrapper";function N_n(t){let{components:e,...n}=t;return(0,s.kt)(b_n,(0,p.Z)({},Z_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}N_n.isMDXComponent=!0;const z_n={toc:[]},A_n="wrapper";function P_n(t){let{components:e,...n}=t;return(0,s.kt)(A_n,(0,p.Z)({},z_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}P_n.isMDXComponent=!0;const I_n={toc:[]},W_n="wrapper";function R_n(t){let{components:e,...n}=t;return(0,s.kt)(W_n,(0,p.Z)({},I_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}R_n.isMDXComponent=!0;const S_n={toc:[]},B_n="wrapper";function G_n(t){let{components:e,...n}=t;return(0,s.kt)(B_n,(0,p.Z)({},S_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}G_n.isMDXComponent=!0;const E_n={toc:[]},O_n="wrapper";function U_n(t){let{components:e,...n}=t;return(0,s.kt)(O_n,(0,p.Z)({},E_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}U_n.isMDXComponent=!0;const F_n={toc:[]},V_n="wrapper";function q_n(t){let{components:e,...n}=t;return(0,s.kt)(V_n,(0,p.Z)({},F_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}q_n.isMDXComponent=!0;const j_n={toc:[]},H_n="wrapper";function Y_n(t){let{components:e,...n}=t;return(0,s.kt)(H_n,(0,p.Z)({},j_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Y_n.isMDXComponent=!0;const Q_n={toc:[]},$_n="wrapper";function K_n(t){let{components:e,...n}=t;return(0,s.kt)($_n,(0,p.Z)({},Q_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}K_n.isMDXComponent=!0;const J_n={toc:[]},twn="wrapper";function ewn(t){let{components:e,...n}=t;return(0,s.kt)(twn,(0,p.Z)({},J_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}ewn.isMDXComponent=!0;const nwn={toc:[]},own="wrapper";function pwn(t){let{components:e,...n}=t;return(0,s.kt)(own,(0,p.Z)({},nwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}pwn.isMDXComponent=!0;const rwn={toc:[]},swn="wrapper";function cwn(t){let{components:e,...n}=t;return(0,s.kt)(swn,(0,p.Z)({},rwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}cwn.isMDXComponent=!0;const awn={toc:[]},iwn="wrapper";function lwn(t){let{components:e,...n}=t;return(0,s.kt)(iwn,(0,p.Z)({},awn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}lwn.isMDXComponent=!0;const uwn={toc:[]},mwn="wrapper";function dwn(t){let{components:e,...n}=t;return(0,s.kt)(mwn,(0,p.Z)({},uwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}dwn.isMDXComponent=!0;const hwn={toc:[]},fwn="wrapper";function kwn(t){let{components:e,...n}=t;return(0,s.kt)(fwn,(0,p.Z)({},hwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kwn.isMDXComponent=!0;const ywn={toc:[]},Dwn="wrapper";function Mwn(t){let{components:e,...n}=t;return(0,s.kt)(Dwn,(0,p.Z)({},ywn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Mwn.isMDXComponent=!0;const Xwn={toc:[]},_wn="wrapper";function wwn(t){let{components:e,...n}=t;return(0,s.kt)(_wn,(0,p.Z)({},Xwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}wwn.isMDXComponent=!0;const Twn={toc:[]},Cwn="wrapper";function gwn(t){let{components:e,...n}=t;return(0,s.kt)(Cwn,(0,p.Z)({},Twn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}gwn.isMDXComponent=!0;const xwn={toc:[]},vwn="wrapper";function Lwn(t){let{components:e,...n}=t;return(0,s.kt)(vwn,(0,p.Z)({},xwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Lwn.isMDXComponent=!0;const Zwn={toc:[]},bwn="wrapper";function Nwn(t){let{components:e,...n}=t;return(0,s.kt)(bwn,(0,p.Z)({},Zwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Nwn.isMDXComponent=!0;const zwn={toc:[]},Awn="wrapper";function Pwn(t){let{components:e,...n}=t;return(0,s.kt)(Awn,(0,p.Z)({},zwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Pwn.isMDXComponent=!0;const Iwn={toc:[]},Wwn="wrapper";function Rwn(t){let{components:e,...n}=t;return(0,s.kt)(Wwn,(0,p.Z)({},Iwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Rwn.isMDXComponent=!0;const Swn={toc:[]},Bwn="wrapper";function Gwn(t){let{components:e,...n}=t;return(0,s.kt)(Bwn,(0,p.Z)({},Swn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Gwn.isMDXComponent=!0;const Ewn={toc:[]},Own="wrapper";function Uwn(t){let{components:e,...n}=t;return(0,s.kt)(Own,(0,p.Z)({},Ewn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Uwn.isMDXComponent=!0;const Fwn={toc:[]},Vwn="wrapper";function qwn(t){let{components:e,...n}=t;return(0,s.kt)(Vwn,(0,p.Z)({},Fwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}qwn.isMDXComponent=!0;const jwn={toc:[]},Hwn="wrapper";function Ywn(t){let{components:e,...n}=t;return(0,s.kt)(Hwn,(0,p.Z)({},jwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Ywn.isMDXComponent=!0;const Qwn={toc:[]},$wn="wrapper";function Kwn(t){let{components:e,...n}=t;return(0,s.kt)($wn,(0,p.Z)({},Qwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]},tTn="wrapper";function eTn(t){let{components:e,...n}=t;return(0,s.kt)(tTn,(0,p.Z)({},Jwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}eTn.isMDXComponent=!0;const nTn={toc:[]},oTn="wrapper";function pTn(t){let{components:e,...n}=t;return(0,s.kt)(oTn,(0,p.Z)({},nTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pTn.isMDXComponent=!0;const rTn={toc:[]},sTn="wrapper";function cTn(t){let{components:e,...n}=t;return(0,s.kt)(sTn,(0,p.Z)({},rTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}cTn.isMDXComponent=!0;const aTn={toc:[]},iTn="wrapper";function lTn(t){let{components:e,...n}=t;return(0,s.kt)(iTn,(0,p.Z)({},aTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lTn.isMDXComponent=!0;const uTn={toc:[]},mTn="wrapper";function dTn(t){let{components:e,...n}=t;return(0,s.kt)(mTn,(0,p.Z)({},uTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}dTn.isMDXComponent=!0;const hTn={toc:[]},fTn="wrapper";function kTn(t){let{components:e,...n}=t;return(0,s.kt)(fTn,(0,p.Z)({},hTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}kTn.isMDXComponent=!0;const yTn={toc:[]},DTn="wrapper";function MTn(t){let{components:e,...n}=t;return(0,s.kt)(DTn,(0,p.Z)({},yTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}MTn.isMDXComponent=!0;const XTn={toc:[]},_Tn="wrapper";function wTn(t){let{components:e,...n}=t;return(0,s.kt)(_Tn,(0,p.Z)({},XTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}wTn.isMDXComponent=!0;const TTn={toc:[]},CTn="wrapper";function gTn(t){let{components:e,...n}=t;return(0,s.kt)(CTn,(0,p.Z)({},TTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gTn.isMDXComponent=!0;const xTn={toc:[]},vTn="wrapper";function LTn(t){let{components:e,...n}=t;return(0,s.kt)(vTn,(0,p.Z)({},xTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}LTn.isMDXComponent=!0;const ZTn={toc:[]},bTn="wrapper";function NTn(t){let{components:e,...n}=t;return(0,s.kt)(bTn,(0,p.Z)({},ZTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}NTn.isMDXComponent=!0;const zTn={toc:[]},ATn="wrapper";function PTn(t){let{components:e,...n}=t;return(0,s.kt)(ATn,(0,p.Z)({},zTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}PTn.isMDXComponent=!0;const ITn={toc:[]},WTn="wrapper";function RTn(t){let{components:e,...n}=t;return(0,s.kt)(WTn,(0,p.Z)({},ITn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}RTn.isMDXComponent=!0;const STn={toc:[]},BTn="wrapper";function GTn(t){let{components:e,...n}=t;return(0,s.kt)(BTn,(0,p.Z)({},STn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}GTn.isMDXComponent=!0;const ETn={toc:[]},OTn="wrapper";function UTn(t){let{components:e,...n}=t;return(0,s.kt)(OTn,(0,p.Z)({},ETn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}UTn.isMDXComponent=!0;const FTn={toc:[]},VTn="wrapper";function qTn(t){let{components:e,...n}=t;return(0,s.kt)(VTn,(0,p.Z)({},FTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}qTn.isMDXComponent=!0;const jTn={toc:[]},HTn="wrapper";function YTn(t){let{components:e,...n}=t;return(0,s.kt)(HTn,(0,p.Z)({},jTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}YTn.isMDXComponent=!0;const QTn={toc:[]},$Tn="wrapper";function KTn(t){let{components:e,...n}=t;return(0,s.kt)($Tn,(0,p.Z)({},QTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}KTn.isMDXComponent=!0;const JTn={toc:[]},tCn="wrapper";function eCn(t){let{components:e,...n}=t;return(0,s.kt)(tCn,(0,p.Z)({},JTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eCn.isMDXComponent=!0;const nCn={toc:[]},oCn="wrapper";function pCn(t){let{components:e,...n}=t;return(0,s.kt)(oCn,(0,p.Z)({},nCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}pCn.isMDXComponent=!0;const rCn={toc:[]},sCn="wrapper";function cCn(t){let{components:e,...n}=t;return(0,s.kt)(sCn,(0,p.Z)({},rCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cCn.isMDXComponent=!0;const aCn={toc:[]},iCn="wrapper";function lCn(t){let{components:e,...n}=t;return(0,s.kt)(iCn,(0,p.Z)({},aCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lCn.isMDXComponent=!0;const uCn={toc:[]},mCn="wrapper";function dCn(t){let{components:e,...n}=t;return(0,s.kt)(mCn,(0,p.Z)({},uCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dCn.isMDXComponent=!0;const hCn={toc:[]},fCn="wrapper";function kCn(t){let{components:e,...n}=t;return(0,s.kt)(fCn,(0,p.Z)({},hCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}kCn.isMDXComponent=!0;const yCn={toc:[]},DCn="wrapper";function MCn(t){let{components:e,...n}=t;return(0,s.kt)(DCn,(0,p.Z)({},yCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MCn.isMDXComponent=!0;const XCn={toc:[]},_Cn="wrapper";function wCn(t){let{components:e,...n}=t;return(0,s.kt)(_Cn,(0,p.Z)({},XCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wCn.isMDXComponent=!0;const TCn={toc:[]},CCn="wrapper";function gCn(t){let{components:e,...n}=t;return(0,s.kt)(CCn,(0,p.Z)({},TCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gCn.isMDXComponent=!0;const xCn={toc:[]},vCn="wrapper";function LCn(t){let{components:e,...n}=t;return(0,s.kt)(vCn,(0,p.Z)({},xCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}LCn.isMDXComponent=!0;const ZCn={toc:[]},bCn="wrapper";function NCn(t){let{components:e,...n}=t;return(0,s.kt)(bCn,(0,p.Z)({},ZCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NCn.isMDXComponent=!0;const zCn={toc:[]},ACn="wrapper";function PCn(t){let{components:e,...n}=t;return(0,s.kt)(ACn,(0,p.Z)({},zCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}PCn.isMDXComponent=!0;const ICn={toc:[]},WCn="wrapper";function RCn(t){let{components:e,...n}=t;return(0,s.kt)(WCn,(0,p.Z)({},ICn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}RCn.isMDXComponent=!0;const SCn={toc:[]},BCn="wrapper";function GCn(t){let{components:e,...n}=t;return(0,s.kt)(BCn,(0,p.Z)({},SCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}GCn.isMDXComponent=!0;const ECn={toc:[]},OCn="wrapper";function UCn(t){let{components:e,...n}=t;return(0,s.kt)(OCn,(0,p.Z)({},ECn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}UCn.isMDXComponent=!0;const FCn={toc:[]},VCn="wrapper";function qCn(t){let{components:e,...n}=t;return(0,s.kt)(VCn,(0,p.Z)({},FCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qCn.isMDXComponent=!0;const jCn={toc:[]},HCn="wrapper";function YCn(t){let{components:e,...n}=t;return(0,s.kt)(HCn,(0,p.Z)({},jCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}YCn.isMDXComponent=!0;const QCn={toc:[]},$Cn="wrapper";function KCn(t){let{components:e,...n}=t;return(0,s.kt)($Cn,(0,p.Z)({},QCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}KCn.isMDXComponent=!0;const JCn={toc:[]},tgn="wrapper";function egn(t){let{components:e,...n}=t;return(0,s.kt)(tgn,(0,p.Z)({},JCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}egn.isMDXComponent=!0;const ngn={toc:[]},ogn="wrapper";function pgn(t){let{components:e,...n}=t;return(0,s.kt)(ogn,(0,p.Z)({},ngn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}pgn.isMDXComponent=!0;const rgn={toc:[]},sgn="wrapper";function cgn(t){let{components:e,...n}=t;return(0,s.kt)(sgn,(0,p.Z)({},rgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}cgn.isMDXComponent=!0;const agn={toc:[]},ign="wrapper";function lgn(t){let{components:e,...n}=t;return(0,s.kt)(ign,(0,p.Z)({},agn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lgn.isMDXComponent=!0;const ugn={toc:[]},mgn="wrapper";function dgn(t){let{components:e,...n}=t;return(0,s.kt)(mgn,(0,p.Z)({},ugn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dgn.isMDXComponent=!0;const hgn={toc:[]},fgn="wrapper";function kgn(t){let{components:e,...n}=t;return(0,s.kt)(fgn,(0,p.Z)({},hgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}kgn.isMDXComponent=!0;const ygn={toc:[]},Dgn="wrapper";function Mgn(t){let{components:e,...n}=t;return(0,s.kt)(Dgn,(0,p.Z)({},ygn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Mgn.isMDXComponent=!0;const Xgn={toc:[]},_gn="wrapper";function wgn(t){let{components:e,...n}=t;return(0,s.kt)(_gn,(0,p.Z)({},Xgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}wgn.isMDXComponent=!0;const Tgn={toc:[]},Cgn="wrapper";function ggn(t){let{components:e,...n}=t;return(0,s.kt)(Cgn,(0,p.Z)({},Tgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}ggn.isMDXComponent=!0;const xgn={toc:[]},vgn="wrapper";function Lgn(t){let{components:e,...n}=t;return(0,s.kt)(vgn,(0,p.Z)({},xgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Lgn.isMDXComponent=!0;const Zgn={toc:[]},bgn="wrapper";function Ngn(t){let{components:e,...n}=t;return(0,s.kt)(bgn,(0,p.Z)({},Zgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Ngn.isMDXComponent=!0;const zgn={toc:[]},Agn="wrapper";function Pgn(t){let{components:e,...n}=t;return(0,s.kt)(Agn,(0,p.Z)({},zgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Pgn.isMDXComponent=!0;const Ign={toc:[]},Wgn="wrapper";function Rgn(t){let{components:e,...n}=t;return(0,s.kt)(Wgn,(0,p.Z)({},Ign,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Rgn.isMDXComponent=!0;const Sgn={toc:[]},Bgn="wrapper";function Ggn(t){let{components:e,...n}=t;return(0,s.kt)(Bgn,(0,p.Z)({},Sgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Ggn.isMDXComponent=!0;const Egn={toc:[]},Ogn="wrapper";function Ugn(t){let{components:e,...n}=t;return(0,s.kt)(Ogn,(0,p.Z)({},Egn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Ugn.isMDXComponent=!0;const Fgn={toc:[]},Vgn="wrapper";function qgn(t){let{components:e,...n}=t;return(0,s.kt)(Vgn,(0,p.Z)({},Fgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}qgn.isMDXComponent=!0;const jgn={toc:[]},Hgn="wrapper";function Ygn(t){let{components:e,...n}=t;return(0,s.kt)(Hgn,(0,p.Z)({},jgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ygn.isMDXComponent=!0;const Qgn={toc:[]},$gn="wrapper";function Kgn(t){let{components:e,...n}=t;return(0,s.kt)($gn,(0,p.Z)({},Qgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Kgn.isMDXComponent=!0;const Jgn={toc:[]},txn="wrapper";function exn(t){let{components:e,...n}=t;return(0,s.kt)(txn,(0,p.Z)({},Jgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}exn.isMDXComponent=!0;const nxn={toc:[]},oxn="wrapper";function pxn(t){let{components:e,...n}=t;return(0,s.kt)(oxn,(0,p.Z)({},nxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pxn.isMDXComponent=!0;const rxn={toc:[]},sxn="wrapper";function cxn(t){let{components:e,...n}=t;return(0,s.kt)(sxn,(0,p.Z)({},rxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cxn.isMDXComponent=!0;const axn={toc:[]},ixn="wrapper";function lxn(t){let{components:e,...n}=t;return(0,s.kt)(ixn,(0,p.Z)({},axn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lxn.isMDXComponent=!0;const uxn={toc:[]},mxn="wrapper";function dxn(t){let{components:e,...n}=t;return(0,s.kt)(mxn,(0,p.Z)({},uxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}dxn.isMDXComponent=!0;const hxn={toc:[]},fxn="wrapper";function kxn(t){let{components:e,...n}=t;return(0,s.kt)(fxn,(0,p.Z)({},hxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kxn.isMDXComponent=!0;const yxn={toc:[]},Dxn="wrapper";function Mxn(t){let{components:e,...n}=t;return(0,s.kt)(Dxn,(0,p.Z)({},yxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Mxn.isMDXComponent=!0;const Xxn={toc:[]},_xn="wrapper";function wxn(t){let{components:e,...n}=t;return(0,s.kt)(_xn,(0,p.Z)({},Xxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wxn.isMDXComponent=!0;const Txn={toc:[]},Cxn="wrapper";function gxn(t){let{components:e,...n}=t;return(0,s.kt)(Cxn,(0,p.Z)({},Txn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gxn.isMDXComponent=!0;const xxn={toc:[]},vxn="wrapper";function Lxn(t){let{components:e,...n}=t;return(0,s.kt)(vxn,(0,p.Z)({},xxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Lxn.isMDXComponent=!0;const Zxn={toc:[]},bxn="wrapper";function Nxn(t){let{components:e,...n}=t;return(0,s.kt)(bxn,(0,p.Z)({},Zxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Nxn.isMDXComponent=!0;const zxn={toc:[]},Axn="wrapper";function Pxn(t){let{components:e,...n}=t;return(0,s.kt)(Axn,(0,p.Z)({},zxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Pxn.isMDXComponent=!0;const Ixn={toc:[]},Wxn="wrapper";function Rxn(t){let{components:e,...n}=t;return(0,s.kt)(Wxn,(0,p.Z)({},Ixn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Rxn.isMDXComponent=!0;const Sxn={toc:[]},Bxn="wrapper";function Gxn(t){let{components:e,...n}=t;return(0,s.kt)(Bxn,(0,p.Z)({},Sxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Gxn.isMDXComponent=!0;const Exn={toc:[]},Oxn="wrapper";function Uxn(t){let{components:e,...n}=t;return(0,s.kt)(Oxn,(0,p.Z)({},Exn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Uxn.isMDXComponent=!0;const Fxn={toc:[]},Vxn="wrapper";function qxn(t){let{components:e,...n}=t;return(0,s.kt)(Vxn,(0,p.Z)({},Fxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}qxn.isMDXComponent=!0;const jxn={toc:[]},Hxn="wrapper";function Yxn(t){let{components:e,...n}=t;return(0,s.kt)(Hxn,(0,p.Z)({},jxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Yxn.isMDXComponent=!0;const Qxn={toc:[]},$xn="wrapper";function Kxn(t){let{components:e,...n}=t;return(0,s.kt)($xn,(0,p.Z)({},Qxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Kxn.isMDXComponent=!0;const Jxn={toc:[]},tvn="wrapper";function evn(t){let{components:e,...n}=t;return(0,s.kt)(tvn,(0,p.Z)({},Jxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}evn.isMDXComponent=!0;const nvn={toc:[]},ovn="wrapper";function pvn(t){let{components:e,...n}=t;return(0,s.kt)(ovn,(0,p.Z)({},nvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}pvn.isMDXComponent=!0;const rvn={toc:[]},svn="wrapper";function cvn(t){let{components:e,...n}=t;return(0,s.kt)(svn,(0,p.Z)({},rvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}cvn.isMDXComponent=!0;const avn={toc:[]},ivn="wrapper";function lvn(t){let{components:e,...n}=t;return(0,s.kt)(ivn,(0,p.Z)({},avn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}lvn.isMDXComponent=!0;const uvn={toc:[]},mvn="wrapper";function dvn(t){let{components:e,...n}=t;return(0,s.kt)(mvn,(0,p.Z)({},uvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}dvn.isMDXComponent=!0;const hvn={toc:[]},fvn="wrapper";function kvn(t){let{components:e,...n}=t;return(0,s.kt)(fvn,(0,p.Z)({},hvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}kvn.isMDXComponent=!0;const yvn={toc:[]},Dvn="wrapper";function Mvn(t){let{components:e,...n}=t;return(0,s.kt)(Dvn,(0,p.Z)({},yvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Mvn.isMDXComponent=!0;const Xvn={toc:[]},_vn="wrapper";function wvn(t){let{components:e,...n}=t;return(0,s.kt)(_vn,(0,p.Z)({},Xvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}wvn.isMDXComponent=!0;const Tvn={toc:[]},Cvn="wrapper";function gvn(t){let{components:e,...n}=t;return(0,s.kt)(Cvn,(0,p.Z)({},Tvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}gvn.isMDXComponent=!0;const xvn={toc:[]},vvn="wrapper";function Lvn(t){let{components:e,...n}=t;return(0,s.kt)(vvn,(0,p.Z)({},xvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Lvn.isMDXComponent=!0;const Zvn={toc:[]},bvn="wrapper";function Nvn(t){let{components:e,...n}=t;return(0,s.kt)(bvn,(0,p.Z)({},Zvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Nvn.isMDXComponent=!0;const zvn={toc:[]},Avn="wrapper";function Pvn(t){let{components:e,...n}=t;return(0,s.kt)(Avn,(0,p.Z)({},zvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Pvn.isMDXComponent=!0;const Ivn={toc:[]},Wvn="wrapper";function Rvn(t){let{components:e,...n}=t;return(0,s.kt)(Wvn,(0,p.Z)({},Ivn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}Rvn.isMDXComponent=!0;const Svn={toc:[]},Bvn="wrapper";function Gvn(t){let{components:e,...n}=t;return(0,s.kt)(Bvn,(0,p.Z)({},Svn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Gvn.isMDXComponent=!0;const Evn={toc:[]},Ovn="wrapper";function Uvn(t){let{components:e,...n}=t;return(0,s.kt)(Ovn,(0,p.Z)({},Evn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Uvn.isMDXComponent=!0;const Fvn={toc:[]},Vvn="wrapper";function qvn(t){let{components:e,...n}=t;return(0,s.kt)(Vvn,(0,p.Z)({},Fvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}qvn.isMDXComponent=!0;const jvn={toc:[]},Hvn="wrapper";function Yvn(t){let{components:e,...n}=t;return(0,s.kt)(Hvn,(0,p.Z)({},jvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Yvn.isMDXComponent=!0;const Qvn={toc:[]},$vn="wrapper";function Kvn(t){let{components:e,...n}=t;return(0,s.kt)($vn,(0,p.Z)({},Qvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Kvn.isMDXComponent=!0;const Jvn={toc:[]},tLn="wrapper";function eLn(t){let{components:e,...n}=t;return(0,s.kt)(tLn,(0,p.Z)({},Jvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eLn.isMDXComponent=!0;const nLn={toc:[]},oLn="wrapper";function pLn(t){let{components:e,...n}=t;return(0,s.kt)(oLn,(0,p.Z)({},nLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pLn.isMDXComponent=!0;const rLn={toc:[]},sLn="wrapper";function cLn(t){let{components:e,...n}=t;return(0,s.kt)(sLn,(0,p.Z)({},rLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}cLn.isMDXComponent=!0;const aLn={toc:[]},iLn="wrapper";function lLn(t){let{components:e,...n}=t;return(0,s.kt)(iLn,(0,p.Z)({},aLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}lLn.isMDXComponent=!0;const uLn={toc:[]},mLn="wrapper";function dLn(t){let{components:e,...n}=t;return(0,s.kt)(mLn,(0,p.Z)({},uLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}dLn.isMDXComponent=!0;const hLn={toc:[]},fLn="wrapper";function kLn(t){let{components:e,...n}=t;return(0,s.kt)(fLn,(0,p.Z)({},hLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kLn.isMDXComponent=!0;const yLn={toc:[]},DLn="wrapper";function MLn(t){let{components:e,...n}=t;return(0,s.kt)(DLn,(0,p.Z)({},yLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}MLn.isMDXComponent=!0;const XLn={toc:[]},_Ln="wrapper";function wLn(t){let{components:e,...n}=t;return(0,s.kt)(_Ln,(0,p.Z)({},XLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wLn.isMDXComponent=!0;const TLn={toc:[]},CLn="wrapper";function gLn(t){let{components:e,...n}=t;return(0,s.kt)(CLn,(0,p.Z)({},TLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}gLn.isMDXComponent=!0;const xLn={toc:[]},vLn="wrapper";function LLn(t){let{components:e,...n}=t;return(0,s.kt)(vLn,(0,p.Z)({},xLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LLn.isMDXComponent=!0;const ZLn={toc:[]},bLn="wrapper";function NLn(t){let{components:e,...n}=t;return(0,s.kt)(bLn,(0,p.Z)({},ZLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NLn.isMDXComponent=!0;const zLn={toc:[]},ALn="wrapper";function PLn(t){let{components:e,...n}=t;return(0,s.kt)(ALn,(0,p.Z)({},zLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}PLn.isMDXComponent=!0;const ILn={toc:[]},WLn="wrapper";function RLn(t){let{components:e,...n}=t;return(0,s.kt)(WLn,(0,p.Z)({},ILn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}RLn.isMDXComponent=!0;const SLn={toc:[]},BLn="wrapper";function GLn(t){let{components:e,...n}=t;return(0,s.kt)(BLn,(0,p.Z)({},SLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}GLn.isMDXComponent=!0;const ELn={toc:[]},OLn="wrapper";function ULn(t){let{components:e,...n}=t;return(0,s.kt)(OLn,(0,p.Z)({},ELn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ULn.isMDXComponent=!0;const FLn={toc:[]},VLn="wrapper";function qLn(t){let{components:e,...n}=t;return(0,s.kt)(VLn,(0,p.Z)({},FLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qLn.isMDXComponent=!0;const jLn={toc:[]},HLn="wrapper";function YLn(t){let{components:e,...n}=t;return(0,s.kt)(HLn,(0,p.Z)({},jLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}YLn.isMDXComponent=!0;const QLn={toc:[]},$Ln="wrapper";function KLn(t){let{components:e,...n}=t;return(0,s.kt)($Ln,(0,p.Z)({},QLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}KLn.isMDXComponent=!0;const JLn={toc:[]},tZn="wrapper";function eZn(t){let{components:e,...n}=t;return(0,s.kt)(tZn,(0,p.Z)({},JLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}eZn.isMDXComponent=!0;const nZn={toc:[]},oZn="wrapper";function pZn(t){let{components:e,...n}=t;return(0,s.kt)(oZn,(0,p.Z)({},nZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pZn.isMDXComponent=!0;const rZn={toc:[]},sZn="wrapper";function cZn(t){let{components:e,...n}=t;return(0,s.kt)(sZn,(0,p.Z)({},rZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cZn.isMDXComponent=!0;const aZn={toc:[]},iZn="wrapper";function lZn(t){let{components:e,...n}=t;return(0,s.kt)(iZn,(0,p.Z)({},aZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lZn.isMDXComponent=!0;const uZn={toc:[]},mZn="wrapper";function dZn(t){let{components:e,...n}=t;return(0,s.kt)(mZn,(0,p.Z)({},uZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dZn.isMDXComponent=!0;const hZn={toc:[]},fZn="wrapper";function kZn(t){let{components:e,...n}=t;return(0,s.kt)(fZn,(0,p.Z)({},hZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kZn.isMDXComponent=!0;const yZn={toc:[]},DZn="wrapper";function MZn(t){let{components:e,...n}=t;return(0,s.kt)(DZn,(0,p.Z)({},yZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}MZn.isMDXComponent=!0;const XZn={toc:[]},_Zn="wrapper";function wZn(t){let{components:e,...n}=t;return(0,s.kt)(_Zn,(0,p.Z)({},XZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wZn.isMDXComponent=!0;const TZn={toc:[]},CZn="wrapper";function gZn(t){let{components:e,...n}=t;return(0,s.kt)(CZn,(0,p.Z)({},TZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}gZn.isMDXComponent=!0;const xZn={toc:[]},vZn="wrapper";function LZn(t){let{components:e,...n}=t;return(0,s.kt)(vZn,(0,p.Z)({},xZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LZn.isMDXComponent=!0;const ZZn={toc:[]},bZn="wrapper";function NZn(t){let{components:e,...n}=t;return(0,s.kt)(bZn,(0,p.Z)({},ZZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NZn.isMDXComponent=!0;const zZn={toc:[]},AZn="wrapper";function PZn(t){let{components:e,...n}=t;return(0,s.kt)(AZn,(0,p.Z)({},zZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}PZn.isMDXComponent=!0;const IZn={toc:[]},WZn="wrapper";function RZn(t){let{components:e,...n}=t;return(0,s.kt)(WZn,(0,p.Z)({},IZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}RZn.isMDXComponent=!0;const SZn={toc:[]},BZn="wrapper";function GZn(t){let{components:e,...n}=t;return(0,s.kt)(BZn,(0,p.Z)({},SZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}GZn.isMDXComponent=!0;const EZn={toc:[]},OZn="wrapper";function UZn(t){let{components:e,...n}=t;return(0,s.kt)(OZn,(0,p.Z)({},EZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}UZn.isMDXComponent=!0;const FZn={toc:[]},VZn="wrapper";function qZn(t){let{components:e,...n}=t;return(0,s.kt)(VZn,(0,p.Z)({},FZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qZn.isMDXComponent=!0;const jZn={toc:[]},HZn="wrapper";function YZn(t){let{components:e,...n}=t;return(0,s.kt)(HZn,(0,p.Z)({},jZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}YZn.isMDXComponent=!0;const QZn={toc:[]},$Zn="wrapper";function KZn(t){let{components:e,...n}=t;return(0,s.kt)($Zn,(0,p.Z)({},QZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}KZn.isMDXComponent=!0;const JZn={toc:[]},tbn="wrapper";function ebn(t){let{components:e,...n}=t;return(0,s.kt)(tbn,(0,p.Z)({},JZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ebn.isMDXComponent=!0;const nbn={toc:[]},obn="wrapper";function pbn(t){let{components:e,...n}=t;return(0,s.kt)(obn,(0,p.Z)({},nbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pbn.isMDXComponent=!0;const rbn={toc:[]},sbn="wrapper";function cbn(t){let{components:e,...n}=t;return(0,s.kt)(sbn,(0,p.Z)({},rbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cbn.isMDXComponent=!0;const abn={toc:[]},ibn="wrapper";function lbn(t){let{components:e,...n}=t;return(0,s.kt)(ibn,(0,p.Z)({},abn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lbn.isMDXComponent=!0;const ubn={toc:[]},mbn="wrapper";function dbn(t){let{components:e,...n}=t;return(0,s.kt)(mbn,(0,p.Z)({},ubn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dbn.isMDXComponent=!0;const hbn={toc:[]},fbn="wrapper";function kbn(t){let{components:e,...n}=t;return(0,s.kt)(fbn,(0,p.Z)({},hbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kbn.isMDXComponent=!0;const ybn={toc:[]},Dbn="wrapper";function Mbn(t){let{components:e,...n}=t;return(0,s.kt)(Dbn,(0,p.Z)({},ybn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Mbn.isMDXComponent=!0;const Xbn={toc:[]},_bn="wrapper";function wbn(t){let{components:e,...n}=t;return(0,s.kt)(_bn,(0,p.Z)({},Xbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}wbn.isMDXComponent=!0;const Tbn={toc:[]},Cbn="wrapper";function gbn(t){let{components:e,...n}=t;return(0,s.kt)(Cbn,(0,p.Z)({},Tbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      radius={30}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}gbn.isMDXComponent=!0;const xbn={toc:[]},vbn="wrapper";function Lbn(t){let{components:e,...n}=t;return(0,s.kt)(vbn,(0,p.Z)({},xbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}Lbn.isMDXComponent=!0;const Zbn={toc:[]},bbn="wrapper";function Nbn(t){let{components:e,...n}=t;return(0,s.kt)(bbn,(0,p.Z)({},Zbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nbn.isMDXComponent=!0;const zbn={toc:[]},Abn="wrapper";function Pbn(t){let{components:e,...n}=t;return(0,s.kt)(Abn,(0,p.Z)({},zbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Pbn.isMDXComponent=!0;const Ibn={toc:[]},Wbn="wrapper";function Rbn(t){let{components:e,...n}=t;return(0,s.kt)(Wbn,(0,p.Z)({},Ibn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Rbn.isMDXComponent=!0;const Sbn={toc:[]},Bbn="wrapper";function Gbn(t){let{components:e,...n}=t;return(0,s.kt)(Bbn,(0,p.Z)({},Sbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Gbn.isMDXComponent=!0;const Ebn={toc:[]},Obn="wrapper";function Ubn(t){let{components:e,...n}=t;return(0,s.kt)(Obn,(0,p.Z)({},Ebn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ubn.isMDXComponent=!0;const Fbn={toc:[]},Vbn="wrapper";function qbn(t){let{components:e,...n}=t;return(0,s.kt)(Vbn,(0,p.Z)({},Fbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qbn.isMDXComponent=!0;const jbn={toc:[]},Hbn="wrapper";function Ybn(t){let{components:e,...n}=t;return(0,s.kt)(Hbn,(0,p.Z)({},jbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ybn.isMDXComponent=!0;const Qbn={toc:[]},$bn="wrapper";function Kbn(t){let{components:e,...n}=t;return(0,s.kt)($bn,(0,p.Z)({},Qbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Kbn.isMDXComponent=!0;const Jbn={toc:[]},tNn="wrapper";function eNn(t){let{components:e,...n}=t;return(0,s.kt)(tNn,(0,p.Z)({},Jbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}eNn.isMDXComponent=!0;const nNn={toc:[]},oNn="wrapper";function pNn(t){let{components:e,...n}=t;return(0,s.kt)(oNn,(0,p.Z)({},nNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pNn.isMDXComponent=!0;const rNn={toc:[]},sNn="wrapper";function cNn(t){let{components:e,...n}=t;return(0,s.kt)(sNn,(0,p.Z)({},rNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cNn.isMDXComponent=!0;const aNn={toc:[]},iNn="wrapper";function lNn(t){let{components:e,...n}=t;return(0,s.kt)(iNn,(0,p.Z)({},aNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lNn.isMDXComponent=!0;const uNn={toc:[]},mNn="wrapper";function dNn(t){let{components:e,...n}=t;return(0,s.kt)(mNn,(0,p.Z)({},uNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}dNn.isMDXComponent=!0;const hNn={toc:[]},fNn="wrapper";function kNn(t){let{components:e,...n}=t;return(0,s.kt)(fNn,(0,p.Z)({},hNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kNn.isMDXComponent=!0;const yNn={toc:[]},DNn="wrapper";function MNn(t){let{components:e,...n}=t;return(0,s.kt)(DNn,(0,p.Z)({},yNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}MNn.isMDXComponent=!0;const XNn={toc:[]},_Nn="wrapper";function wNn(t){let{components:e,...n}=t;return(0,s.kt)(_Nn,(0,p.Z)({},XNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wNn.isMDXComponent=!0;const TNn={toc:[]},CNn="wrapper";function gNn(t){let{components:e,...n}=t;return(0,s.kt)(CNn,(0,p.Z)({},TNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}gNn.isMDXComponent=!0;const xNn={toc:[]},vNn="wrapper";function LNn(t){let{components:e,...n}=t;return(0,s.kt)(vNn,(0,p.Z)({},xNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}LNn.isMDXComponent=!0;const ZNn={toc:[]},bNn="wrapper";function NNn(t){let{components:e,...n}=t;return(0,s.kt)(bNn,(0,p.Z)({},ZNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}NNn.isMDXComponent=!0;const zNn={toc:[]},ANn="wrapper";function PNn(t){let{components:e,...n}=t;return(0,s.kt)(ANn,(0,p.Z)({},zNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}PNn.isMDXComponent=!0;const INn={toc:[]},WNn="wrapper";function RNn(t){let{components:e,...n}=t;return(0,s.kt)(WNn,(0,p.Z)({},INn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}RNn.isMDXComponent=!0;const SNn={toc:[]},BNn="wrapper";function GNn(t){let{components:e,...n}=t;return(0,s.kt)(BNn,(0,p.Z)({},SNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}GNn.isMDXComponent=!0;const ENn={toc:[]},ONn="wrapper";function UNn(t){let{components:e,...n}=t;return(0,s.kt)(ONn,(0,p.Z)({},ENn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}UNn.isMDXComponent=!0;const FNn={toc:[]},VNn="wrapper";function qNn(t){let{components:e,...n}=t;return(0,s.kt)(VNn,(0,p.Z)({},FNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qNn.isMDXComponent=!0;const jNn={toc:[]},HNn="wrapper";function YNn(t){let{components:e,...n}=t;return(0,s.kt)(HNn,(0,p.Z)({},jNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}YNn.isMDXComponent=!0;const QNn={toc:[]},$Nn="wrapper";function KNn(t){let{components:e,...n}=t;return(0,s.kt)($Nn,(0,p.Z)({},QNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}KNn.isMDXComponent=!0;const JNn={toc:[]},tzn="wrapper";function ezn(t){let{components:e,...n}=t;return(0,s.kt)(tzn,(0,p.Z)({},JNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}ezn.isMDXComponent=!0;const nzn={toc:[]},ozn="wrapper";function pzn(t){let{components:e,...n}=t;return(0,s.kt)(ozn,(0,p.Z)({},nzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}pzn.isMDXComponent=!0;const rzn={toc:[]},szn="wrapper";function czn(t){let{components:e,...n}=t;return(0,s.kt)(szn,(0,p.Z)({},rzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}czn.isMDXComponent=!0;const azn={toc:[]},izn="wrapper";function lzn(t){let{components:e,...n}=t;return(0,s.kt)(izn,(0,p.Z)({},azn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}lzn.isMDXComponent=!0;const uzn={toc:[]},mzn="wrapper";function dzn(t){let{components:e,...n}=t;return(0,s.kt)(mzn,(0,p.Z)({},uzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}dzn.isMDXComponent=!0;const hzn={toc:[]},fzn="wrapper";function kzn(t){let{components:e,...n}=t;return(0,s.kt)(fzn,(0,p.Z)({},hzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}kzn.isMDXComponent=!0;const yzn={toc:[]},Dzn="wrapper";function Mzn(t){let{components:e,...n}=t;return(0,s.kt)(Dzn,(0,p.Z)({},yzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Mzn.isMDXComponent=!0;const Xzn={toc:[]},_zn="wrapper";function wzn(t){let{components:e,...n}=t;return(0,s.kt)(_zn,(0,p.Z)({},Xzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wzn.isMDXComponent=!0;const Tzn={toc:[]},Czn="wrapper";function gzn(t){let{components:e,...n}=t;return(0,s.kt)(Czn,(0,p.Z)({},Tzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  radius={30}\n  size={320}\n  sides={3}\n  stroke={'#fff'}\n  lineWidth={8}\n/>\n")))}gzn.isMDXComponent=!0;const xzn={toc:[]},vzn="wrapper";function Lzn(t){let{components:e,...n}=t;return(0,s.kt)(vzn,(0,p.Z)({},xzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the polygon's corners."))}Lzn.isMDXComponent=!0;const Zzn={toc:[]},bzn="wrapper";function Nzn(t){let{components:e,...n}=t;return(0,s.kt)(bzn,(0,p.Z)({},Zzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Nzn.isMDXComponent=!0;const zzn={toc:[]},Azn="wrapper";function Pzn(t){let{components:e,...n}=t;return(0,s.kt)(Azn,(0,p.Z)({},zzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Pzn.isMDXComponent=!0;const Izn={toc:[]},Wzn="wrapper";function Rzn(t){let{components:e,...n}=t;return(0,s.kt)(Wzn,(0,p.Z)({},Izn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Rzn.isMDXComponent=!0;const Szn={toc:[]},Bzn="wrapper";function Gzn(t){let{components:e,...n}=t;return(0,s.kt)(Bzn,(0,p.Z)({},Szn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Gzn.isMDXComponent=!0;const Ezn={toc:[]},Ozn="wrapper";function Uzn(t){let{components:e,...n}=t;return(0,s.kt)(Ozn,(0,p.Z)({},Ezn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Uzn.isMDXComponent=!0;const Fzn={toc:[]},Vzn="wrapper";function qzn(t){let{components:e,...n}=t;return(0,s.kt)(Vzn,(0,p.Z)({},Fzn,n,{components:e,mdxType:"MDXLayout"}))}qzn.isMDXComponent=!0;const jzn={toc:[]},Hzn="wrapper";function Yzn(t){let{components:e,...n}=t;return(0,s.kt)(Hzn,(0,p.Z)({},jzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}Yzn.isMDXComponent=!0;const Qzn={toc:[]},$zn="wrapper";function Kzn(t){let{components:e,...n}=t;return(0,s.kt)($zn,(0,p.Z)({},Qzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}Kzn.isMDXComponent=!0;const Jzn={toc:[]},tAn="wrapper";function eAn(t){let{components:e,...n}=t;return(0,s.kt)(tAn,(0,p.Z)({},Jzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of sides of the polygon."))}eAn.isMDXComponent=!0;const nAn={toc:[]},oAn="wrapper";function pAn(t){let{components:e,...n}=t;return(0,s.kt)(oAn,(0,p.Z)({},nAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}pAn.isMDXComponent=!0;const rAn={toc:[]},sAn="wrapper";function cAn(t){let{components:e,...n}=t;return(0,s.kt)(sAn,(0,p.Z)({},rAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}cAn.isMDXComponent=!0;const aAn={toc:[]},iAn="wrapper";function lAn(t){let{components:e,...n}=t;return(0,s.kt)(iAn,(0,p.Z)({},aAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}lAn.isMDXComponent=!0;const uAn={toc:[]},mAn="wrapper";function dAn(t){let{components:e,...n}=t;return(0,s.kt)(mAn,(0,p.Z)({},uAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}dAn.isMDXComponent=!0;const hAn={toc:[]},fAn="wrapper";function kAn(t){let{components:e,...n}=t;return(0,s.kt)(fAn,(0,p.Z)({},hAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}kAn.isMDXComponent=!0;const yAn={toc:[]},DAn="wrapper";function MAn(t){let{components:e,...n}=t;return(0,s.kt)(DAn,(0,p.Z)({},yAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}MAn.isMDXComponent=!0;const XAn={toc:[]},_An="wrapper";function wAn(t){let{components:e,...n}=t;return(0,s.kt)(_An,(0,p.Z)({},XAn,n,{components:e,mdxType:"MDXLayout"}))}wAn.isMDXComponent=!0;const TAn={toc:[]},CAn="wrapper";function gAn(t){let{components:e,...n}=t;return(0,s.kt)(CAn,(0,p.Z)({},TAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}gAn.isMDXComponent=!0;const xAn={toc:[]},vAn="wrapper";function LAn(t){let{components:e,...n}=t;return(0,s.kt)(vAn,(0,p.Z)({},xAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}LAn.isMDXComponent=!0;const ZAn={toc:[]},bAn="wrapper";function NAn(t){let{components:e,...n}=t;return(0,s.kt)(bAn,(0,p.Z)({},ZAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NAn.isMDXComponent=!0;const zAn={toc:[]},AAn="wrapper";function PAn(t){let{components:e,...n}=t;return(0,s.kt)(AAn,(0,p.Z)({},zAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}PAn.isMDXComponent=!0;const IAn={toc:[]},WAn="wrapper";function RAn(t){let{components:e,...n}=t;return(0,s.kt)(WAn,(0,p.Z)({},IAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}RAn.isMDXComponent=!0;const SAn={toc:[]},BAn="wrapper";function GAn(t){let{components:e,...n}=t;return(0,s.kt)(BAn,(0,p.Z)({},SAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}GAn.isMDXComponent=!0;const EAn={toc:[]},OAn="wrapper";function UAn(t){let{components:e,...n}=t;return(0,s.kt)(OAn,(0,p.Z)({},EAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}UAn.isMDXComponent=!0;const FAn={toc:[]},VAn="wrapper";function qAn(t){let{components:e,...n}=t;return(0,s.kt)(VAn,(0,p.Z)({},FAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}qAn.isMDXComponent=!0;const jAn={toc:[]},HAn="wrapper";function YAn(t){let{components:e,...n}=t;return(0,s.kt)(HAn,(0,p.Z)({},jAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}YAn.isMDXComponent=!0;const QAn={toc:[]},$An="wrapper";function KAn(t){let{components:e,...n}=t;return(0,s.kt)($An,(0,p.Z)({},QAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}KAn.isMDXComponent=!0;const JAn={toc:[]},tPn="wrapper";function ePn(t){let{components:e,...n}=t;return(0,s.kt)(tPn,(0,p.Z)({},JAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ePn.isMDXComponent=!0;const nPn={toc:[]},oPn="wrapper";function pPn(t){let{components:e,...n}=t;return(0,s.kt)(oPn,(0,p.Z)({},nPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pPn.isMDXComponent=!0;const rPn={toc:[]},sPn="wrapper";function cPn(t){let{components:e,...n}=t;return(0,s.kt)(sPn,(0,p.Z)({},rPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}cPn.isMDXComponent=!0;const aPn={toc:[]},iPn="wrapper";function lPn(t){let{components:e,...n}=t;return(0,s.kt)(iPn,(0,p.Z)({},aPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lPn.isMDXComponent=!0;const uPn={toc:[]},mPn="wrapper";function dPn(t){let{components:e,...n}=t;return(0,s.kt)(mPn,(0,p.Z)({},uPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}dPn.isMDXComponent=!0;const hPn={toc:[]},fPn="wrapper";function kPn(t){let{components:e,...n}=t;return(0,s.kt)(fPn,(0,p.Z)({},hPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}kPn.isMDXComponent=!0;const yPn={toc:[]},DPn="wrapper";function MPn(t){let{components:e,...n}=t;return(0,s.kt)(DPn,(0,p.Z)({},yPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}MPn.isMDXComponent=!0;const XPn={toc:[]},_Pn="wrapper";function wPn(t){let{components:e,...n}=t;return(0,s.kt)(_Pn,(0,p.Z)({},XPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}wPn.isMDXComponent=!0;const TPn={toc:[]},CPn="wrapper";function gPn(t){let{components:e,...n}=t;return(0,s.kt)(CPn,(0,p.Z)({},TPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}gPn.isMDXComponent=!0;const xPn={toc:[]},vPn="wrapper";function LPn(t){let{components:e,...n}=t;return(0,s.kt)(vPn,(0,p.Z)({},xPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}LPn.isMDXComponent=!0;const ZPn={toc:[]},bPn="wrapper";function NPn(t){let{components:e,...n}=t;return(0,s.kt)(bPn,(0,p.Z)({},ZPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}NPn.isMDXComponent=!0;const zPn={toc:[]},APn="wrapper";function PPn(t){let{components:e,...n}=t;return(0,s.kt)(APn,(0,p.Z)({},zPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}PPn.isMDXComponent=!0;const IPn={toc:[]},WPn="wrapper";function RPn(t){let{components:e,...n}=t;return(0,s.kt)(WPn,(0,p.Z)({},IPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}RPn.isMDXComponent=!0;const SPn={toc:[]},BPn="wrapper";function GPn(t){let{components:e,...n}=t;return(0,s.kt)(BPn,(0,p.Z)({},SPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}GPn.isMDXComponent=!0;const EPn={toc:[]},OPn="wrapper";function UPn(t){let{components:e,...n}=t;return(0,s.kt)(OPn,(0,p.Z)({},EPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}UPn.isMDXComponent=!0;const FPn={toc:[]},VPn="wrapper";function qPn(t){let{components:e,...n}=t;return(0,s.kt)(VPn,(0,p.Z)({},FPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}qPn.isMDXComponent=!0;const jPn={toc:[]},HPn="wrapper";function YPn(t){let{components:e,...n}=t;return(0,s.kt)(HPn,(0,p.Z)({},jPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}YPn.isMDXComponent=!0;const QPn={toc:[]},$Pn="wrapper";function KPn(t){let{components:e,...n}=t;return(0,s.kt)($Pn,(0,p.Z)({},QPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}KPn.isMDXComponent=!0;const JPn={toc:[]},tIn="wrapper";function eIn(t){let{components:e,...n}=t;return(0,s.kt)(tIn,(0,p.Z)({},JPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}eIn.isMDXComponent=!0;const nIn={toc:[]},oIn="wrapper";function pIn(t){let{components:e,...n}=t;return(0,s.kt)(oIn,(0,p.Z)({},nIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}pIn.isMDXComponent=!0;const rIn={toc:[]},sIn="wrapper";function cIn(t){let{components:e,...n}=t;return(0,s.kt)(sIn,(0,p.Z)({},rIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}cIn.isMDXComponent=!0;const aIn={toc:[]},iIn="wrapper";function lIn(t){let{components:e,...n}=t;return(0,s.kt)(iIn,(0,p.Z)({},aIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}lIn.isMDXComponent=!0;const uIn={toc:[]},mIn="wrapper";function dIn(t){let{components:e,...n}=t;return(0,s.kt)(mIn,(0,p.Z)({},uIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}dIn.isMDXComponent=!0;const hIn={toc:[]},fIn="wrapper";function kIn(t){let{components:e,...n}=t;return(0,s.kt)(fIn,(0,p.Z)({},hIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kIn.isMDXComponent=!0;const yIn={toc:[]},DIn="wrapper";function MIn(t){let{components:e,...n}=t;return(0,s.kt)(DIn,(0,p.Z)({},yIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MIn.isMDXComponent=!0;const XIn={toc:[]},_In="wrapper";function wIn(t){let{components:e,...n}=t;return(0,s.kt)(_In,(0,p.Z)({},XIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}wIn.isMDXComponent=!0;const TIn={toc:[]},CIn="wrapper";function gIn(t){let{components:e,...n}=t;return(0,s.kt)(CIn,(0,p.Z)({},TIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}gIn.isMDXComponent=!0;const xIn={toc:[]},vIn="wrapper";function LIn(t){let{components:e,...n}=t;return(0,s.kt)(vIn,(0,p.Z)({},xIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}LIn.isMDXComponent=!0;const ZIn={toc:[]},bIn="wrapper";function NIn(t){let{components:e,...n}=t;return(0,s.kt)(bIn,(0,p.Z)({},ZIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}NIn.isMDXComponent=!0;const zIn={toc:[]},AIn="wrapper";function PIn(t){let{components:e,...n}=t;return(0,s.kt)(AIn,(0,p.Z)({},zIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}PIn.isMDXComponent=!0;const IIn={toc:[]},WIn="wrapper";function RIn(t){let{components:e,...n}=t;return(0,s.kt)(WIn,(0,p.Z)({},IIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}RIn.isMDXComponent=!0;const SIn={toc:[]},BIn="wrapper";function GIn(t){let{components:e,...n}=t;return(0,s.kt)(BIn,(0,p.Z)({},SIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}GIn.isMDXComponent=!0;const EIn={toc:[]},OIn="wrapper";function UIn(t){let{components:e,...n}=t;return(0,s.kt)(OIn,(0,p.Z)({},EIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}UIn.isMDXComponent=!0;const FIn={toc:[]},VIn="wrapper";function qIn(t){let{components:e,...n}=t;return(0,s.kt)(VIn,(0,p.Z)({},FIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}qIn.isMDXComponent=!0;const jIn={toc:[]},HIn="wrapper";function YIn(t){let{components:e,...n}=t;return(0,s.kt)(HIn,(0,p.Z)({},jIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}YIn.isMDXComponent=!0;const QIn={toc:[]},$In="wrapper";function KIn(t){let{components:e,...n}=t;return(0,s.kt)($In,(0,p.Z)({},QIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}KIn.isMDXComponent=!0;const JIn={toc:[]},tWn="wrapper";function eWn(t){let{components:e,...n}=t;return(0,s.kt)(tWn,(0,p.Z)({},JIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}eWn.isMDXComponent=!0;const nWn={toc:[]},oWn="wrapper";function pWn(t){let{components:e,...n}=t;return(0,s.kt)(oWn,(0,p.Z)({},nWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pWn.isMDXComponent=!0;const rWn={toc:[]},sWn="wrapper";function cWn(t){let{components:e,...n}=t;return(0,s.kt)(sWn,(0,p.Z)({},rWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}cWn.isMDXComponent=!0;const aWn={toc:[]},iWn="wrapper";function lWn(t){let{components:e,...n}=t;return(0,s.kt)(iWn,(0,p.Z)({},aWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lWn.isMDXComponent=!0;const uWn={toc:[]},mWn="wrapper";function dWn(t){let{components:e,...n}=t;return(0,s.kt)(mWn,(0,p.Z)({},uWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dWn.isMDXComponent=!0;const hWn={toc:[]},fWn="wrapper";function kWn(t){let{components:e,...n}=t;return(0,s.kt)(fWn,(0,p.Z)({},hWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kWn.isMDXComponent=!0;const yWn={toc:[]},DWn="wrapper";function MWn(t){let{components:e,...n}=t;return(0,s.kt)(DWn,(0,p.Z)({},yWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}MWn.isMDXComponent=!0;const XWn={toc:[]},_Wn="wrapper";function wWn(t){let{components:e,...n}=t;return(0,s.kt)(_Wn,(0,p.Z)({},XWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wWn.isMDXComponent=!0;const TWn={toc:[]},CWn="wrapper";function gWn(t){let{components:e,...n}=t;return(0,s.kt)(CWn,(0,p.Z)({},TWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}gWn.isMDXComponent=!0;const xWn={toc:[]},vWn="wrapper";function LWn(t){let{components:e,...n}=t;return(0,s.kt)(vWn,(0,p.Z)({},xWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LWn.isMDXComponent=!0;const ZWn={toc:[]},bWn="wrapper";function NWn(t){let{components:e,...n}=t;return(0,s.kt)(bWn,(0,p.Z)({},ZWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}NWn.isMDXComponent=!0;const zWn={toc:[]},AWn="wrapper";function PWn(t){let{components:e,...n}=t;return(0,s.kt)(AWn,(0,p.Z)({},zWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PWn.isMDXComponent=!0;const IWn={toc:[]},WWn="wrapper";function RWn(t){let{components:e,...n}=t;return(0,s.kt)(WWn,(0,p.Z)({},IWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}RWn.isMDXComponent=!0;const SWn={toc:[]},BWn="wrapper";function GWn(t){let{components:e,...n}=t;return(0,s.kt)(BWn,(0,p.Z)({},SWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}GWn.isMDXComponent=!0;const EWn={toc:[]},OWn="wrapper";function UWn(t){let{components:e,...n}=t;return(0,s.kt)(OWn,(0,p.Z)({},EWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}UWn.isMDXComponent=!0;const FWn={toc:[]},VWn="wrapper";function qWn(t){let{components:e,...n}=t;return(0,s.kt)(VWn,(0,p.Z)({},FWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qWn.isMDXComponent=!0;const jWn={toc:[]},HWn="wrapper";function YWn(t){let{components:e,...n}=t;return(0,s.kt)(HWn,(0,p.Z)({},jWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}YWn.isMDXComponent=!0;const QWn={toc:[]},$Wn="wrapper";function KWn(t){let{components:e,...n}=t;return(0,s.kt)($Wn,(0,p.Z)({},QWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}KWn.isMDXComponent=!0;const JWn={toc:[]},tRn="wrapper";function eRn(t){let{components:e,...n}=t;return(0,s.kt)(tRn,(0,p.Z)({},JWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}eRn.isMDXComponent=!0;const nRn={toc:[]},oRn="wrapper";function pRn(t){let{components:e,...n}=t;return(0,s.kt)(oRn,(0,p.Z)({},nRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pRn.isMDXComponent=!0;const rRn={toc:[]},sRn="wrapper";function cRn(t){let{components:e,...n}=t;return(0,s.kt)(sRn,(0,p.Z)({},rRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cRn.isMDXComponent=!0;const aRn={toc:[]},iRn="wrapper";function lRn(t){let{components:e,...n}=t;return(0,s.kt)(iRn,(0,p.Z)({},aRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lRn.isMDXComponent=!0;const uRn={toc:[]},mRn="wrapper";function dRn(t){let{components:e,...n}=t;return(0,s.kt)(mRn,(0,p.Z)({},uRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dRn.isMDXComponent=!0;const hRn={toc:[]},fRn="wrapper";function kRn(t){let{components:e,...n}=t;return(0,s.kt)(fRn,(0,p.Z)({},hRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kRn.isMDXComponent=!0;const yRn={toc:[]},DRn="wrapper";function MRn(t){let{components:e,...n}=t;return(0,s.kt)(DRn,(0,p.Z)({},yRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}MRn.isMDXComponent=!0;const XRn={toc:[]},_Rn="wrapper";function wRn(t){let{components:e,...n}=t;return(0,s.kt)(_Rn,(0,p.Z)({},XRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wRn.isMDXComponent=!0;const TRn={toc:[]},CRn="wrapper";function gRn(t){let{components:e,...n}=t;return(0,s.kt)(CRn,(0,p.Z)({},TRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}gRn.isMDXComponent=!0;const xRn={toc:[]},vRn="wrapper";function LRn(t){let{components:e,...n}=t;return(0,s.kt)(vRn,(0,p.Z)({},xRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}LRn.isMDXComponent=!0;const ZRn={toc:[]},bRn="wrapper";function NRn(t){let{components:e,...n}=t;return(0,s.kt)(bRn,(0,p.Z)({},ZRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}NRn.isMDXComponent=!0;const zRn={toc:[]},ARn="wrapper";function PRn(t){let{components:e,...n}=t;return(0,s.kt)(ARn,(0,p.Z)({},zRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}PRn.isMDXComponent=!0;const IRn={toc:[]},WRn="wrapper";function RRn(t){let{components:e,...n}=t;return(0,s.kt)(WRn,(0,p.Z)({},IRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}RRn.isMDXComponent=!0;const SRn={toc:[]},BRn="wrapper";function GRn(t){let{components:e,...n}=t;return(0,s.kt)(BRn,(0,p.Z)({},SRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}GRn.isMDXComponent=!0;const ERn={toc:[]},ORn="wrapper";function URn(t){let{components:e,...n}=t;return(0,s.kt)(ORn,(0,p.Z)({},ERn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}URn.isMDXComponent=!0;const FRn={toc:[]},VRn="wrapper";function qRn(t){let{components:e,...n}=t;return(0,s.kt)(VRn,(0,p.Z)({},FRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qRn.isMDXComponent=!0;const jRn={toc:[]},HRn="wrapper";function YRn(t){let{components:e,...n}=t;return(0,s.kt)(HRn,(0,p.Z)({},jRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}YRn.isMDXComponent=!0;const QRn={toc:[]},$Rn="wrapper";function KRn(t){let{components:e,...n}=t;return(0,s.kt)($Rn,(0,p.Z)({},QRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}KRn.isMDXComponent=!0;const JRn={toc:[]},tSn="wrapper";function eSn(t){let{components:e,...n}=t;return(0,s.kt)(tSn,(0,p.Z)({},JRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}eSn.isMDXComponent=!0;const nSn={toc:[]},oSn="wrapper";function pSn(t){let{components:e,...n}=t;return(0,s.kt)(oSn,(0,p.Z)({},nSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pSn.isMDXComponent=!0;const rSn={toc:[]},sSn="wrapper";function cSn(t){let{components:e,...n}=t;return(0,s.kt)(sSn,(0,p.Z)({},rSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cSn.isMDXComponent=!0;const aSn={toc:[]},iSn="wrapper";function lSn(t){let{components:e,...n}=t;return(0,s.kt)(iSn,(0,p.Z)({},aSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lSn.isMDXComponent=!0;const uSn={toc:[]},mSn="wrapper";function dSn(t){let{components:e,...n}=t;return(0,s.kt)(mSn,(0,p.Z)({},uSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dSn.isMDXComponent=!0;const hSn={toc:[]},fSn="wrapper";function kSn(t){let{components:e,...n}=t;return(0,s.kt)(fSn,(0,p.Z)({},hSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}kSn.isMDXComponent=!0;const ySn={toc:[]},DSn="wrapper";function MSn(t){let{components:e,...n}=t;return(0,s.kt)(DSn,(0,p.Z)({},ySn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}MSn.isMDXComponent=!0;const XSn={toc:[]},_Sn="wrapper";function wSn(t){let{components:e,...n}=t;return(0,s.kt)(_Sn,(0,p.Z)({},XSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wSn.isMDXComponent=!0;const TSn={toc:[]},CSn="wrapper";function gSn(t){let{components:e,...n}=t;return(0,s.kt)(CSn,(0,p.Z)({},TSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}gSn.isMDXComponent=!0;const xSn={toc:[]},vSn="wrapper";function LSn(t){let{components:e,...n}=t;return(0,s.kt)(vSn,(0,p.Z)({},xSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}LSn.isMDXComponent=!0;const ZSn={toc:[]},bSn="wrapper";function NSn(t){let{components:e,...n}=t;return(0,s.kt)(bSn,(0,p.Z)({},ZSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}NSn.isMDXComponent=!0;const zSn={toc:[]},ASn="wrapper";function PSn(t){let{components:e,...n}=t;return(0,s.kt)(ASn,(0,p.Z)({},zSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}PSn.isMDXComponent=!0;const ISn={toc:[]},WSn="wrapper";function RSn(t){let{components:e,...n}=t;return(0,s.kt)(WSn,(0,p.Z)({},ISn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}RSn.isMDXComponent=!0;const SSn={toc:[]},BSn="wrapper";function GSn(t){let{components:e,...n}=t;return(0,s.kt)(BSn,(0,p.Z)({},SSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}GSn.isMDXComponent=!0;const ESn={toc:[]},OSn="wrapper";function USn(t){let{components:e,...n}=t;return(0,s.kt)(OSn,(0,p.Z)({},ESn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}USn.isMDXComponent=!0;const FSn={toc:[]},VSn="wrapper";function qSn(t){let{components:e,...n}=t;return(0,s.kt)(VSn,(0,p.Z)({},FSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}qSn.isMDXComponent=!0;const jSn={toc:[]},HSn="wrapper";function YSn(t){let{components:e,...n}=t;return(0,s.kt)(HSn,(0,p.Z)({},jSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}YSn.isMDXComponent=!0;const QSn={toc:[]},$Sn="wrapper";function KSn(t){let{components:e,...n}=t;return(0,s.kt)($Sn,(0,p.Z)({},QSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}KSn.isMDXComponent=!0;const JSn={toc:[]},tBn="wrapper";function eBn(t){let{components:e,...n}=t;return(0,s.kt)(tBn,(0,p.Z)({},JSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}eBn.isMDXComponent=!0;const nBn={toc:[]},oBn="wrapper";function pBn(t){let{components:e,...n}=t;return(0,s.kt)(oBn,(0,p.Z)({},nBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pBn.isMDXComponent=!0;const rBn={toc:[]},sBn="wrapper";function cBn(t){let{components:e,...n}=t;return(0,s.kt)(sBn,(0,p.Z)({},rBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cBn.isMDXComponent=!0;const aBn={toc:[]},iBn="wrapper";function lBn(t){let{components:e,...n}=t;return(0,s.kt)(iBn,(0,p.Z)({},aBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}lBn.isMDXComponent=!0;const uBn={toc:[]},mBn="wrapper";function dBn(t){let{components:e,...n}=t;return(0,s.kt)(mBn,(0,p.Z)({},uBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dBn.isMDXComponent=!0;const hBn={toc:[]},fBn="wrapper";function kBn(t){let{components:e,...n}=t;return(0,s.kt)(fBn,(0,p.Z)({},hBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}kBn.isMDXComponent=!0;const yBn={toc:[]},DBn="wrapper";function MBn(t){let{components:e,...n}=t;return(0,s.kt)(DBn,(0,p.Z)({},yBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}MBn.isMDXComponent=!0;const XBn={toc:[]},_Bn="wrapper";function wBn(t){let{components:e,...n}=t;return(0,s.kt)(_Bn,(0,p.Z)({},XBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wBn.isMDXComponent=!0;const TBn={toc:[]},CBn="wrapper";function gBn(t){let{components:e,...n}=t;return(0,s.kt)(CBn,(0,p.Z)({},TBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}gBn.isMDXComponent=!0;const xBn={toc:[]},vBn="wrapper";function LBn(t){let{components:e,...n}=t;return(0,s.kt)(vBn,(0,p.Z)({},xBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}LBn.isMDXComponent=!0;const ZBn={toc:[]},bBn="wrapper";function NBn(t){let{components:e,...n}=t;return(0,s.kt)(bBn,(0,p.Z)({},ZBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}NBn.isMDXComponent=!0;const zBn={toc:[]},ABn="wrapper";function PBn(t){let{components:e,...n}=t;return(0,s.kt)(ABn,(0,p.Z)({},zBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}PBn.isMDXComponent=!0;const IBn={toc:[]},WBn="wrapper";function RBn(t){let{components:e,...n}=t;return(0,s.kt)(WBn,(0,p.Z)({},IBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}RBn.isMDXComponent=!0;const SBn={toc:[]},BBn="wrapper";function GBn(t){let{components:e,...n}=t;return(0,s.kt)(BBn,(0,p.Z)({},SBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}GBn.isMDXComponent=!0;const EBn={toc:[]},OBn="wrapper";function UBn(t){let{components:e,...n}=t;return(0,s.kt)(OBn,(0,p.Z)({},EBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}UBn.isMDXComponent=!0;const FBn={toc:[]},VBn="wrapper";function qBn(t){let{components:e,...n}=t;return(0,s.kt)(VBn,(0,p.Z)({},FBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}qBn.isMDXComponent=!0;const jBn={toc:[]},HBn="wrapper";function YBn(t){let{components:e,...n}=t;return(0,s.kt)(HBn,(0,p.Z)({},jBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}YBn.isMDXComponent=!0;const QBn={toc:[]},$Bn="wrapper";function KBn(t){let{components:e,...n}=t;return(0,s.kt)($Bn,(0,p.Z)({},QBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}KBn.isMDXComponent=!0;const JBn={toc:[]},tGn="wrapper";function eGn(t){let{components:e,...n}=t;return(0,s.kt)(tGn,(0,p.Z)({},JBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}eGn.isMDXComponent=!0;const nGn={toc:[]},oGn="wrapper";function pGn(t){let{components:e,...n}=t;return(0,s.kt)(oGn,(0,p.Z)({},nGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}pGn.isMDXComponent=!0;const rGn={toc:[]},sGn="wrapper";function cGn(t){let{components:e,...n}=t;return(0,s.kt)(sGn,(0,p.Z)({},rGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}cGn.isMDXComponent=!0;const aGn={toc:[]},iGn="wrapper";function lGn(t){let{components:e,...n}=t;return(0,s.kt)(iGn,(0,p.Z)({},aGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}lGn.isMDXComponent=!0;const uGn={toc:[]},mGn="wrapper";function dGn(t){let{components:e,...n}=t;return(0,s.kt)(mGn,(0,p.Z)({},uGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}dGn.isMDXComponent=!0;const hGn={toc:[]},fGn="wrapper";function kGn(t){let{components:e,...n}=t;return(0,s.kt)(fGn,(0,p.Z)({},hGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}kGn.isMDXComponent=!0;const yGn={toc:[]},DGn="wrapper";function MGn(t){let{components:e,...n}=t;return(0,s.kt)(DGn,(0,p.Z)({},yGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}MGn.isMDXComponent=!0;const XGn={toc:[]},_Gn="wrapper";function wGn(t){let{components:e,...n}=t;return(0,s.kt)(_Gn,(0,p.Z)({},XGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}wGn.isMDXComponent=!0;const TGn={toc:[]},CGn="wrapper";function gGn(t){let{components:e,...n}=t;return(0,s.kt)(CGn,(0,p.Z)({},TGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}gGn.isMDXComponent=!0;const xGn={toc:[]},vGn="wrapper";function LGn(t){let{components:e,...n}=t;return(0,s.kt)(vGn,(0,p.Z)({},xGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}LGn.isMDXComponent=!0;const ZGn={toc:[]},bGn="wrapper";function NGn(t){let{components:e,...n}=t;return(0,s.kt)(bGn,(0,p.Z)({},ZGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}NGn.isMDXComponent=!0;const zGn={toc:[]},AGn="wrapper";function PGn(t){let{components:e,...n}=t;return(0,s.kt)(AGn,(0,p.Z)({},zGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}PGn.isMDXComponent=!0;const IGn={toc:[]},WGn="wrapper";function RGn(t){let{components:e,...n}=t;return(0,s.kt)(WGn,(0,p.Z)({},IGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}RGn.isMDXComponent=!0;const SGn={toc:[]},BGn="wrapper";function GGn(t){let{components:e,...n}=t;return(0,s.kt)(BGn,(0,p.Z)({},SGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}GGn.isMDXComponent=!0;const EGn={toc:[]},OGn="wrapper";function UGn(t){let{components:e,...n}=t;return(0,s.kt)(OGn,(0,p.Z)({},EGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}UGn.isMDXComponent=!0;const FGn={toc:[]},VGn="wrapper";function qGn(t){let{components:e,...n}=t;return(0,s.kt)(VGn,(0,p.Z)({},FGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}qGn.isMDXComponent=!0;const jGn={toc:[]},HGn="wrapper";function YGn(t){let{components:e,...n}=t;return(0,s.kt)(HGn,(0,p.Z)({},jGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YGn.isMDXComponent=!0;const QGn={toc:[]},$Gn="wrapper";function KGn(t){let{components:e,...n}=t;return(0,s.kt)($Gn,(0,p.Z)({},QGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}KGn.isMDXComponent=!0;const JGn={toc:[]},tEn="wrapper";function eEn(t){let{components:e,...n}=t;return(0,s.kt)(tEn,(0,p.Z)({},JGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}eEn.isMDXComponent=!0;const nEn={toc:[]},oEn="wrapper";function pEn(t){let{components:e,...n}=t;return(0,s.kt)(oEn,(0,p.Z)({},nEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}pEn.isMDXComponent=!0;const rEn={toc:[]},sEn="wrapper";function cEn(t){let{components:e,...n}=t;return(0,s.kt)(sEn,(0,p.Z)({},rEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}cEn.isMDXComponent=!0;const aEn={toc:[]},iEn="wrapper";function lEn(t){let{components:e,...n}=t;return(0,s.kt)(iEn,(0,p.Z)({},aEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}lEn.isMDXComponent=!0;const uEn={toc:[]},mEn="wrapper";function dEn(t){let{components:e,...n}=t;return(0,s.kt)(mEn,(0,p.Z)({},uEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}dEn.isMDXComponent=!0;const hEn={toc:[]},fEn="wrapper";function kEn(t){let{components:e,...n}=t;return(0,s.kt)(fEn,(0,p.Z)({},hEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}kEn.isMDXComponent=!0;const yEn={toc:[]},DEn="wrapper";function MEn(t){let{components:e,...n}=t;return(0,s.kt)(DEn,(0,p.Z)({},yEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}MEn.isMDXComponent=!0;const XEn={toc:[]},_En="wrapper";function wEn(t){let{components:e,...n}=t;return(0,s.kt)(_En,(0,p.Z)({},XEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wEn.isMDXComponent=!0;const TEn={toc:[]},CEn="wrapper";function gEn(t){let{components:e,...n}=t;return(0,s.kt)(CEn,(0,p.Z)({},TEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}gEn.isMDXComponent=!0;const xEn={toc:[]},vEn="wrapper";function LEn(t){let{components:e,...n}=t;return(0,s.kt)(vEn,(0,p.Z)({},xEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}LEn.isMDXComponent=!0;const ZEn={toc:[]},bEn="wrapper";function NEn(t){let{components:e,...n}=t;return(0,s.kt)(bEn,(0,p.Z)({},ZEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}NEn.isMDXComponent=!0;const zEn={toc:[]},AEn="wrapper";function PEn(t){let{components:e,...n}=t;return(0,s.kt)(AEn,(0,p.Z)({},zEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}PEn.isMDXComponent=!0;const IEn={toc:[]},WEn="wrapper";function REn(t){let{components:e,...n}=t;return(0,s.kt)(WEn,(0,p.Z)({},IEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}REn.isMDXComponent=!0;const SEn={toc:[]},BEn="wrapper";function GEn(t){let{components:e,...n}=t;return(0,s.kt)(BEn,(0,p.Z)({},SEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}GEn.isMDXComponent=!0;const EEn={toc:[]},OEn="wrapper";function UEn(t){let{components:e,...n}=t;return(0,s.kt)(OEn,(0,p.Z)({},EEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}UEn.isMDXComponent=!0;const FEn={toc:[]},VEn="wrapper";function qEn(t){let{components:e,...n}=t;return(0,s.kt)(VEn,(0,p.Z)({},FEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qEn.isMDXComponent=!0;const jEn={toc:[]},HEn="wrapper";function YEn(t){let{components:e,...n}=t;return(0,s.kt)(HEn,(0,p.Z)({},jEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}YEn.isMDXComponent=!0;const QEn={toc:[]},$En="wrapper";function KEn(t){let{components:e,...n}=t;return(0,s.kt)($En,(0,p.Z)({},QEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}KEn.isMDXComponent=!0;const JEn={toc:[]},tOn="wrapper";function eOn(t){let{components:e,...n}=t;return(0,s.kt)(tOn,(0,p.Z)({},JEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}eOn.isMDXComponent=!0;const nOn={toc:[]},oOn="wrapper";function pOn(t){let{components:e,...n}=t;return(0,s.kt)(oOn,(0,p.Z)({},nOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}pOn.isMDXComponent=!0;const rOn={toc:[]},sOn="wrapper";function cOn(t){let{components:e,...n}=t;return(0,s.kt)(sOn,(0,p.Z)({},rOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}cOn.isMDXComponent=!0;const aOn={toc:[]},iOn="wrapper";function lOn(t){let{components:e,...n}=t;return(0,s.kt)(iOn,(0,p.Z)({},aOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}lOn.isMDXComponent=!0;const uOn={toc:[]},mOn="wrapper";function dOn(t){let{components:e,...n}=t;return(0,s.kt)(mOn,(0,p.Z)({},uOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}dOn.isMDXComponent=!0;const hOn={toc:[]},fOn="wrapper";function kOn(t){let{components:e,...n}=t;return(0,s.kt)(fOn,(0,p.Z)({},hOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}kOn.isMDXComponent=!0;const yOn={toc:[]},DOn="wrapper";function MOn(t){let{components:e,...n}=t;return(0,s.kt)(DOn,(0,p.Z)({},yOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}MOn.isMDXComponent=!0;const XOn={toc:[]},_On="wrapper";function wOn(t){let{components:e,...n}=t;return(0,s.kt)(_On,(0,p.Z)({},XOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wOn.isMDXComponent=!0;const TOn={toc:[]},COn="wrapper";function gOn(t){let{components:e,...n}=t;return(0,s.kt)(COn,(0,p.Z)({},TOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}gOn.isMDXComponent=!0;const xOn={toc:[]},vOn="wrapper";function LOn(t){let{components:e,...n}=t;return(0,s.kt)(vOn,(0,p.Z)({},xOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}LOn.isMDXComponent=!0;const ZOn={toc:[]},bOn="wrapper";function NOn(t){let{components:e,...n}=t;return(0,s.kt)(bOn,(0,p.Z)({},ZOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}NOn.isMDXComponent=!0;const zOn={toc:[]},AOn="wrapper";function POn(t){let{components:e,...n}=t;return(0,s.kt)(AOn,(0,p.Z)({},zOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}POn.isMDXComponent=!0;const IOn={toc:[]},WOn="wrapper";function ROn(t){let{components:e,...n}=t;return(0,s.kt)(WOn,(0,p.Z)({},IOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ROn.isMDXComponent=!0;const SOn={toc:[]},BOn="wrapper";function GOn(t){let{components:e,...n}=t;return(0,s.kt)(BOn,(0,p.Z)({},SOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}GOn.isMDXComponent=!0;const EOn={toc:[]},OOn="wrapper";function UOn(t){let{components:e,...n}=t;return(0,s.kt)(OOn,(0,p.Z)({},EOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}UOn.isMDXComponent=!0;const FOn={toc:[]},VOn="wrapper";function qOn(t){let{components:e,...n}=t;return(0,s.kt)(VOn,(0,p.Z)({},FOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}qOn.isMDXComponent=!0;const jOn={toc:[]},HOn="wrapper";function YOn(t){let{components:e,...n}=t;return(0,s.kt)(HOn,(0,p.Z)({},jOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}YOn.isMDXComponent=!0;const QOn={toc:[]},$On="wrapper";function KOn(t){let{components:e,...n}=t;return(0,s.kt)($On,(0,p.Z)({},QOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}KOn.isMDXComponent=!0;const JOn={toc:[]},tUn="wrapper";function eUn(t){let{components:e,...n}=t;return(0,s.kt)(tUn,(0,p.Z)({},JOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}eUn.isMDXComponent=!0;const nUn={toc:[]},oUn="wrapper";function pUn(t){let{components:e,...n}=t;return(0,s.kt)(oUn,(0,p.Z)({},nUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}pUn.isMDXComponent=!0;const rUn={toc:[]},sUn="wrapper";function cUn(t){let{components:e,...n}=t;return(0,s.kt)(sUn,(0,p.Z)({},rUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}cUn.isMDXComponent=!0;const aUn={toc:[]},iUn="wrapper";function lUn(t){let{components:e,...n}=t;return(0,s.kt)(iUn,(0,p.Z)({},aUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}lUn.isMDXComponent=!0;const uUn={toc:[]},mUn="wrapper";function dUn(t){let{components:e,...n}=t;return(0,s.kt)(mUn,(0,p.Z)({},uUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}dUn.isMDXComponent=!0;const hUn={toc:[]},fUn="wrapper";function kUn(t){let{components:e,...n}=t;return(0,s.kt)(fUn,(0,p.Z)({},hUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}kUn.isMDXComponent=!0;const yUn={toc:[]},DUn="wrapper";function MUn(t){let{components:e,...n}=t;return(0,s.kt)(DUn,(0,p.Z)({},yUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}MUn.isMDXComponent=!0;const XUn={toc:[]},_Un="wrapper";function wUn(t){let{components:e,...n}=t;return(0,s.kt)(_Un,(0,p.Z)({},XUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}wUn.isMDXComponent=!0;const TUn={toc:[]},CUn="wrapper";function gUn(t){let{components:e,...n}=t;return(0,s.kt)(CUn,(0,p.Z)({},TUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}gUn.isMDXComponent=!0;const xUn={toc:[]},vUn="wrapper";function LUn(t){let{components:e,...n}=t;return(0,s.kt)(vUn,(0,p.Z)({},xUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}LUn.isMDXComponent=!0;const ZUn={toc:[]},bUn="wrapper";function NUn(t){let{components:e,...n}=t;return(0,s.kt)(bUn,(0,p.Z)({},ZUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}NUn.isMDXComponent=!0;const zUn={toc:[]},AUn="wrapper";function PUn(t){let{components:e,...n}=t;return(0,s.kt)(AUn,(0,p.Z)({},zUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}PUn.isMDXComponent=!0;const IUn={toc:[]},WUn="wrapper";function RUn(t){let{components:e,...n}=t;return(0,s.kt)(WUn,(0,p.Z)({},IUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}RUn.isMDXComponent=!0;const SUn={toc:[]},BUn="wrapper";function GUn(t){let{components:e,...n}=t;return(0,s.kt)(BUn,(0,p.Z)({},SUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}GUn.isMDXComponent=!0;const EUn={toc:[]},OUn="wrapper";function UUn(t){let{components:e,...n}=t;return(0,s.kt)(OUn,(0,p.Z)({},EUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}UUn.isMDXComponent=!0;const FUn={toc:[]},VUn="wrapper";function qUn(t){let{components:e,...n}=t;return(0,s.kt)(VUn,(0,p.Z)({},FUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qUn.isMDXComponent=!0;const jUn={toc:[]},HUn="wrapper";function YUn(t){let{components:e,...n}=t;return(0,s.kt)(HUn,(0,p.Z)({},jUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}YUn.isMDXComponent=!0;const QUn={toc:[]},$Un="wrapper";function KUn(t){let{components:e,...n}=t;return(0,s.kt)($Un,(0,p.Z)({},QUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}KUn.isMDXComponent=!0;const JUn={toc:[]},tFn="wrapper";function eFn(t){let{components:e,...n}=t;return(0,s.kt)(tFn,(0,p.Z)({},JUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}eFn.isMDXComponent=!0;const nFn={toc:[]},oFn="wrapper";function pFn(t){let{components:e,...n}=t;return(0,s.kt)(oFn,(0,p.Z)({},nFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pFn.isMDXComponent=!0;const rFn={toc:[]},sFn="wrapper";function cFn(t){let{components:e,...n}=t;return(0,s.kt)(sFn,(0,p.Z)({},rFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}cFn.isMDXComponent=!0;const aFn={toc:[]},iFn="wrapper";function lFn(t){let{components:e,...n}=t;return(0,s.kt)(iFn,(0,p.Z)({},aFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}lFn.isMDXComponent=!0;const uFn={toc:[]},mFn="wrapper";function dFn(t){let{components:e,...n}=t;return(0,s.kt)(mFn,(0,p.Z)({},uFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}dFn.isMDXComponent=!0;const hFn={toc:[]},fFn="wrapper";function kFn(t){let{components:e,...n}=t;return(0,s.kt)(fFn,(0,p.Z)({},hFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}kFn.isMDXComponent=!0;const yFn={toc:[]},DFn="wrapper";function MFn(t){let{components:e,...n}=t;return(0,s.kt)(DFn,(0,p.Z)({},yFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}MFn.isMDXComponent=!0;const XFn={toc:[]},_Fn="wrapper";function wFn(t){let{components:e,...n}=t;return(0,s.kt)(_Fn,(0,p.Z)({},XFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}wFn.isMDXComponent=!0;const TFn={toc:[]},CFn="wrapper";function gFn(t){let{components:e,...n}=t;return(0,s.kt)(CFn,(0,p.Z)({},TFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}gFn.isMDXComponent=!0;const xFn={toc:[]},vFn="wrapper";function LFn(t){let{components:e,...n}=t;return(0,s.kt)(vFn,(0,p.Z)({},xFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}LFn.isMDXComponent=!0;const ZFn={toc:[]},bFn="wrapper";function NFn(t){let{components:e,...n}=t;return(0,s.kt)(bFn,(0,p.Z)({},ZFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}NFn.isMDXComponent=!0;const zFn={toc:[]},AFn="wrapper";function PFn(t){let{components:e,...n}=t;return(0,s.kt)(AFn,(0,p.Z)({},zFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}PFn.isMDXComponent=!0;const IFn={toc:[]},WFn="wrapper";function RFn(t){let{components:e,...n}=t;return(0,s.kt)(WFn,(0,p.Z)({},IFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}RFn.isMDXComponent=!0;const SFn={toc:[]},BFn="wrapper";function GFn(t){let{components:e,...n}=t;return(0,s.kt)(BFn,(0,p.Z)({},SFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}GFn.isMDXComponent=!0;const EFn={toc:[]},OFn="wrapper";function UFn(t){let{components:e,...n}=t;return(0,s.kt)(OFn,(0,p.Z)({},EFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}UFn.isMDXComponent=!0;const FFn={toc:[]},VFn="wrapper";function qFn(t){let{components:e,...n}=t;return(0,s.kt)(VFn,(0,p.Z)({},FFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}qFn.isMDXComponent=!0;const jFn={toc:[]},HFn="wrapper";function YFn(t){let{components:e,...n}=t;return(0,s.kt)(HFn,(0,p.Z)({},jFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}YFn.isMDXComponent=!0;const QFn={toc:[]},$Fn="wrapper";function KFn(t){let{components:e,...n}=t;return(0,s.kt)($Fn,(0,p.Z)({},QFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}KFn.isMDXComponent=!0;const JFn={toc:[]},tVn="wrapper";function eVn(t){let{components:e,...n}=t;return(0,s.kt)(tVn,(0,p.Z)({},JFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}eVn.isMDXComponent=!0;const nVn={toc:[]},oVn="wrapper";function pVn(t){let{components:e,...n}=t;return(0,s.kt)(oVn,(0,p.Z)({},nVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pVn.isMDXComponent=!0;const rVn={toc:[]},sVn="wrapper";function cVn(t){let{components:e,...n}=t;return(0,s.kt)(sVn,(0,p.Z)({},rVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}cVn.isMDXComponent=!0;const aVn={toc:[]},iVn="wrapper";function lVn(t){let{components:e,...n}=t;return(0,s.kt)(iVn,(0,p.Z)({},aVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lVn.isMDXComponent=!0;const uVn={toc:[]},mVn="wrapper";function dVn(t){let{components:e,...n}=t;return(0,s.kt)(mVn,(0,p.Z)({},uVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}dVn.isMDXComponent=!0;const hVn={toc:[]},fVn="wrapper";function kVn(t){let{components:e,...n}=t;return(0,s.kt)(fVn,(0,p.Z)({},hVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kVn.isMDXComponent=!0;const yVn={toc:[]},DVn="wrapper";function MVn(t){let{components:e,...n}=t;return(0,s.kt)(DVn,(0,p.Z)({},yVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}MVn.isMDXComponent=!0;const XVn={toc:[]},_Vn="wrapper";function wVn(t){let{components:e,...n}=t;return(0,s.kt)(_Vn,(0,p.Z)({},XVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wVn.isMDXComponent=!0;const TVn={toc:[]},CVn="wrapper";function gVn(t){let{components:e,...n}=t;return(0,s.kt)(CVn,(0,p.Z)({},TVn,n,{components:e,mdxType:"MDXLayout"}))}gVn.isMDXComponent=!0;const xVn={toc:[]},vVn="wrapper";function LVn(t){let{components:e,...n}=t;return(0,s.kt)(vVn,(0,p.Z)({},xVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}LVn.isMDXComponent=!0;const ZVn={toc:[]},bVn="wrapper";function NVn(t){let{components:e,...n}=t;return(0,s.kt)(bVn,(0,p.Z)({},ZVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}NVn.isMDXComponent=!0;const zVn={toc:[]},AVn="wrapper";function PVn(t){let{components:e,...n}=t;return(0,s.kt)(AVn,(0,p.Z)({},zVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}PVn.isMDXComponent=!0;const IVn={toc:[]},WVn="wrapper";function RVn(t){let{components:e,...n}=t;return(0,s.kt)(WVn,(0,p.Z)({},IVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}RVn.isMDXComponent=!0;const SVn={toc:[]},BVn="wrapper";function GVn(t){let{components:e,...n}=t;return(0,s.kt)(BVn,(0,p.Z)({},SVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}GVn.isMDXComponent=!0;const EVn={toc:[]},OVn="wrapper";function UVn(t){let{components:e,...n}=t;return(0,s.kt)(OVn,(0,p.Z)({},EVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}UVn.isMDXComponent=!0;const FVn={toc:[]},VVn="wrapper";function qVn(t){let{components:e,...n}=t;return(0,s.kt)(VVn,(0,p.Z)({},FVn,n,{components:e,mdxType:"MDXLayout"}))}qVn.isMDXComponent=!0;const jVn={toc:[]},HVn="wrapper";function YVn(t){let{components:e,...n}=t;return(0,s.kt)(HVn,(0,p.Z)({},jVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}YVn.isMDXComponent=!0;const QVn={toc:[]},$Vn="wrapper";function KVn(t){let{components:e,...n}=t;return(0,s.kt)($Vn,(0,p.Z)({},QVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}KVn.isMDXComponent=!0;const JVn={toc:[]},tqn="wrapper";function eqn(t){let{components:e,...n}=t;return(0,s.kt)(tqn,(0,p.Z)({},JVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}eqn.isMDXComponent=!0;const nqn={toc:[]},oqn="wrapper";function pqn(t){let{components:e,...n}=t;return(0,s.kt)(oqn,(0,p.Z)({},nqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}pqn.isMDXComponent=!0;const rqn={toc:[]},sqn="wrapper";function cqn(t){let{components:e,...n}=t;return(0,s.kt)(sqn,(0,p.Z)({},rqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}cqn.isMDXComponent=!0;const aqn={toc:[]},iqn="wrapper";function lqn(t){let{components:e,...n}=t;return(0,s.kt)(iqn,(0,p.Z)({},aqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}lqn.isMDXComponent=!0;const uqn={toc:[]},mqn="wrapper";function dqn(t){let{components:e,...n}=t;return(0,s.kt)(mqn,(0,p.Z)({},uqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}dqn.isMDXComponent=!0;const hqn={toc:[]},fqn="wrapper";function kqn(t){let{components:e,...n}=t;return(0,s.kt)(fqn,(0,p.Z)({},hqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kqn.isMDXComponent=!0;const yqn={toc:[]},Dqn="wrapper";function Mqn(t){let{components:e,...n}=t;return(0,s.kt)(Dqn,(0,p.Z)({},yqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Mqn.isMDXComponent=!0;const Xqn={toc:[]},_qn="wrapper";function wqn(t){let{components:e,...n}=t;return(0,s.kt)(_qn,(0,p.Z)({},Xqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wqn.isMDXComponent=!0;const Tqn={toc:[]},Cqn="wrapper";function gqn(t){let{components:e,...n}=t;return(0,s.kt)(Cqn,(0,p.Z)({},Tqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}gqn.isMDXComponent=!0;const xqn={toc:[]},vqn="wrapper";function Lqn(t){let{components:e,...n}=t;return(0,s.kt)(vqn,(0,p.Z)({},xqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Lqn.isMDXComponent=!0;const Zqn={toc:[]},bqn="wrapper";function Nqn(t){let{components:e,...n}=t;return(0,s.kt)(bqn,(0,p.Z)({},Zqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Nqn.isMDXComponent=!0;const zqn={toc:[]},Aqn="wrapper";function Pqn(t){let{components:e,...n}=t;return(0,s.kt)(Aqn,(0,p.Z)({},zqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Pqn.isMDXComponent=!0;const Iqn={toc:[]},Wqn="wrapper";function Rqn(t){let{components:e,...n}=t;return(0,s.kt)(Wqn,(0,p.Z)({},Iqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Rqn.isMDXComponent=!0;const Sqn={toc:[]},Bqn="wrapper";function Gqn(t){let{components:e,...n}=t;return(0,s.kt)(Bqn,(0,p.Z)({},Sqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Gqn.isMDXComponent=!0;const Eqn={toc:[]},Oqn="wrapper";function Uqn(t){let{components:e,...n}=t;return(0,s.kt)(Oqn,(0,p.Z)({},Eqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Uqn.isMDXComponent=!0;const Fqn={toc:[]},Vqn="wrapper";function qqn(t){let{components:e,...n}=t;return(0,s.kt)(Vqn,(0,p.Z)({},Fqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}qqn.isMDXComponent=!0;const jqn={toc:[]},Hqn="wrapper";function Yqn(t){let{components:e,...n}=t;return(0,s.kt)(Hqn,(0,p.Z)({},jqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Yqn.isMDXComponent=!0;const Qqn={toc:[]},$qn="wrapper";function Kqn(t){let{components:e,...n}=t;return(0,s.kt)($qn,(0,p.Z)({},Qqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Kqn.isMDXComponent=!0;const Jqn={toc:[]},tjn="wrapper";function ejn(t){let{components:e,...n}=t;return(0,s.kt)(tjn,(0,p.Z)({},Jqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ejn.isMDXComponent=!0;const njn={toc:[]},ojn="wrapper";function pjn(t){let{components:e,...n}=t;return(0,s.kt)(ojn,(0,p.Z)({},njn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}pjn.isMDXComponent=!0;const rjn={toc:[]},sjn="wrapper";function cjn(t){let{components:e,...n}=t;return(0,s.kt)(sjn,(0,p.Z)({},rjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}cjn.isMDXComponent=!0;const ajn={toc:[]},ijn="wrapper";function ljn(t){let{components:e,...n}=t;return(0,s.kt)(ijn,(0,p.Z)({},ajn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}ljn.isMDXComponent=!0;const ujn={toc:[]},mjn="wrapper";function djn(t){let{components:e,...n}=t;return(0,s.kt)(mjn,(0,p.Z)({},ujn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}djn.isMDXComponent=!0;const hjn={toc:[]},fjn="wrapper";function kjn(t){let{components:e,...n}=t;return(0,s.kt)(fjn,(0,p.Z)({},hjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}kjn.isMDXComponent=!0;const yjn={toc:[]},Djn="wrapper";function Mjn(t){let{components:e,...n}=t;return(0,s.kt)(Djn,(0,p.Z)({},yjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Mjn.isMDXComponent=!0;const Xjn={toc:[]},_jn="wrapper";function wjn(t){let{components:e,...n}=t;return(0,s.kt)(_jn,(0,p.Z)({},Xjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}wjn.isMDXComponent=!0;const Tjn={toc:[]},Cjn="wrapper";function gjn(t){let{components:e,...n}=t;return(0,s.kt)(Cjn,(0,p.Z)({},Tjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}gjn.isMDXComponent=!0;const xjn={toc:[]},vjn="wrapper";function Ljn(t){let{components:e,...n}=t;return(0,s.kt)(vjn,(0,p.Z)({},xjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}Ljn.isMDXComponent=!0;const Zjn={toc:[]},bjn="wrapper";function Njn(t){let{components:e,...n}=t;return(0,s.kt)(bjn,(0,p.Z)({},Zjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Njn.isMDXComponent=!0;const zjn={toc:[]},Ajn="wrapper";function Pjn(t){let{components:e,...n}=t;return(0,s.kt)(Ajn,(0,p.Z)({},zjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Pjn.isMDXComponent=!0;const Ijn={toc:[]},Wjn="wrapper";function Rjn(t){let{components:e,...n}=t;return(0,s.kt)(Wjn,(0,p.Z)({},Ijn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Rjn.isMDXComponent=!0;const Sjn={toc:[]},Bjn="wrapper";function Gjn(t){let{components:e,...n}=t;return(0,s.kt)(Bjn,(0,p.Z)({},Sjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Gjn.isMDXComponent=!0;const Ejn={toc:[]},Ojn="wrapper";function Ujn(t){let{components:e,...n}=t;return(0,s.kt)(Ojn,(0,p.Z)({},Ejn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ujn.isMDXComponent=!0;const Fjn={toc:[]},Vjn="wrapper";function qjn(t){let{components:e,...n}=t;return(0,s.kt)(Vjn,(0,p.Z)({},Fjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}qjn.isMDXComponent=!0;const jjn={toc:[]},Hjn="wrapper";function Yjn(t){let{components:e,...n}=t;return(0,s.kt)(Hjn,(0,p.Z)({},jjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Yjn.isMDXComponent=!0;const Qjn={toc:[]},$jn="wrapper";function Kjn(t){let{components:e,...n}=t;return(0,s.kt)($jn,(0,p.Z)({},Qjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Kjn.isMDXComponent=!0;const Jjn={toc:[]},tHn="wrapper";function eHn(t){let{components:e,...n}=t;return(0,s.kt)(tHn,(0,p.Z)({},Jjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}eHn.isMDXComponent=!0;const nHn={toc:[]},oHn="wrapper";function pHn(t){let{components:e,...n}=t;return(0,s.kt)(oHn,(0,p.Z)({},nHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}pHn.isMDXComponent=!0;const rHn={toc:[]},sHn="wrapper";function cHn(t){let{components:e,...n}=t;return(0,s.kt)(sHn,(0,p.Z)({},rHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}cHn.isMDXComponent=!0;const aHn={toc:[]},iHn="wrapper";function lHn(t){let{components:e,...n}=t;return(0,s.kt)(iHn,(0,p.Z)({},aHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}lHn.isMDXComponent=!0;const uHn={toc:[]},mHn="wrapper";function dHn(t){let{components:e,...n}=t;return(0,s.kt)(mHn,(0,p.Z)({},uHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dHn.isMDXComponent=!0;const hHn={toc:[]},fHn="wrapper";function kHn(t){let{components:e,...n}=t;return(0,s.kt)(fHn,(0,p.Z)({},hHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}kHn.isMDXComponent=!0;const yHn={toc:[]},DHn="wrapper";function MHn(t){let{components:e,...n}=t;return(0,s.kt)(DHn,(0,p.Z)({},yHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}MHn.isMDXComponent=!0;const XHn={toc:[]},_Hn="wrapper";function wHn(t){let{components:e,...n}=t;return(0,s.kt)(_Hn,(0,p.Z)({},XHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}wHn.isMDXComponent=!0;const THn={toc:[]},CHn="wrapper";function gHn(t){let{components:e,...n}=t;return(0,s.kt)(CHn,(0,p.Z)({},THn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}gHn.isMDXComponent=!0;const xHn={toc:[]},vHn="wrapper";function LHn(t){let{components:e,...n}=t;return(0,s.kt)(vHn,(0,p.Z)({},xHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}LHn.isMDXComponent=!0;const ZHn={toc:[]},bHn="wrapper";function NHn(t){let{components:e,...n}=t;return(0,s.kt)(bHn,(0,p.Z)({},ZHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}NHn.isMDXComponent=!0;const zHn={toc:[]},AHn="wrapper";function PHn(t){let{components:e,...n}=t;return(0,s.kt)(AHn,(0,p.Z)({},zHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PHn.isMDXComponent=!0;const IHn={toc:[]},WHn="wrapper";function RHn(t){let{components:e,...n}=t;return(0,s.kt)(WHn,(0,p.Z)({},IHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}RHn.isMDXComponent=!0;const SHn={toc:[]},BHn="wrapper";function GHn(t){let{components:e,...n}=t;return(0,s.kt)(BHn,(0,p.Z)({},SHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}GHn.isMDXComponent=!0;const EHn={toc:[]},OHn="wrapper";function UHn(t){let{components:e,...n}=t;return(0,s.kt)(OHn,(0,p.Z)({},EHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}UHn.isMDXComponent=!0;const FHn={toc:[]},VHn="wrapper";function qHn(t){let{components:e,...n}=t;return(0,s.kt)(VHn,(0,p.Z)({},FHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}qHn.isMDXComponent=!0;const jHn={toc:[]},HHn="wrapper";function YHn(t){let{components:e,...n}=t;return(0,s.kt)(HHn,(0,p.Z)({},jHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}YHn.isMDXComponent=!0;const QHn={toc:[]},$Hn="wrapper";function KHn(t){let{components:e,...n}=t;return(0,s.kt)($Hn,(0,p.Z)({},QHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}KHn.isMDXComponent=!0;const JHn={toc:[]},tYn="wrapper";function eYn(t){let{components:e,...n}=t;return(0,s.kt)(tYn,(0,p.Z)({},JHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}eYn.isMDXComponent=!0;const nYn={toc:[]},oYn="wrapper";function pYn(t){let{components:e,...n}=t;return(0,s.kt)(oYn,(0,p.Z)({},nYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pYn.isMDXComponent=!0;const rYn={toc:[]},sYn="wrapper";function cYn(t){let{components:e,...n}=t;return(0,s.kt)(sYn,(0,p.Z)({},rYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cYn.isMDXComponent=!0;const aYn={toc:[]},iYn="wrapper";function lYn(t){let{components:e,...n}=t;return(0,s.kt)(iYn,(0,p.Z)({},aYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lYn.isMDXComponent=!0;const uYn={toc:[]},mYn="wrapper";function dYn(t){let{components:e,...n}=t;return(0,s.kt)(mYn,(0,p.Z)({},uYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}dYn.isMDXComponent=!0;const hYn={toc:[]},fYn="wrapper";function kYn(t){let{components:e,...n}=t;return(0,s.kt)(fYn,(0,p.Z)({},hYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kYn.isMDXComponent=!0;const yYn={toc:[]},DYn="wrapper";function MYn(t){let{components:e,...n}=t;return(0,s.kt)(DYn,(0,p.Z)({},yYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}MYn.isMDXComponent=!0;const XYn={toc:[]},_Yn="wrapper";function wYn(t){let{components:e,...n}=t;return(0,s.kt)(_Yn,(0,p.Z)({},XYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wYn.isMDXComponent=!0;const TYn={toc:[]},CYn="wrapper";function gYn(t){let{components:e,...n}=t;return(0,s.kt)(CYn,(0,p.Z)({},TYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}gYn.isMDXComponent=!0;const xYn={toc:[]},vYn="wrapper";function LYn(t){let{components:e,...n}=t;return(0,s.kt)(vYn,(0,p.Z)({},xYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LYn.isMDXComponent=!0;const ZYn={toc:[]},bYn="wrapper";function NYn(t){let{components:e,...n}=t;return(0,s.kt)(bYn,(0,p.Z)({},ZYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}NYn.isMDXComponent=!0;const zYn={toc:[]},AYn="wrapper";function PYn(t){let{components:e,...n}=t;return(0,s.kt)(AYn,(0,p.Z)({},zYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PYn.isMDXComponent=!0;const IYn={toc:[]},WYn="wrapper";function RYn(t){let{components:e,...n}=t;return(0,s.kt)(WYn,(0,p.Z)({},IYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}RYn.isMDXComponent=!0;const SYn={toc:[]},BYn="wrapper";function GYn(t){let{components:e,...n}=t;return(0,s.kt)(BYn,(0,p.Z)({},SYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}GYn.isMDXComponent=!0;const EYn={toc:[]},OYn="wrapper";function UYn(t){let{components:e,...n}=t;return(0,s.kt)(OYn,(0,p.Z)({},EYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}UYn.isMDXComponent=!0;const FYn={toc:[]},VYn="wrapper";function qYn(t){let{components:e,...n}=t;return(0,s.kt)(VYn,(0,p.Z)({},FYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qYn.isMDXComponent=!0;const jYn={toc:[]},HYn="wrapper";function YYn(t){let{components:e,...n}=t;return(0,s.kt)(HYn,(0,p.Z)({},jYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}YYn.isMDXComponent=!0;const QYn={toc:[]},$Yn="wrapper";function KYn(t){let{components:e,...n}=t;return(0,s.kt)($Yn,(0,p.Z)({},QYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}KYn.isMDXComponent=!0;const JYn={toc:[]},tQn="wrapper";function eQn(t){let{components:e,...n}=t;return(0,s.kt)(tQn,(0,p.Z)({},JYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}eQn.isMDXComponent=!0;const nQn={toc:[]},oQn="wrapper";function pQn(t){let{components:e,...n}=t;return(0,s.kt)(oQn,(0,p.Z)({},nQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}pQn.isMDXComponent=!0;const rQn={toc:[]},sQn="wrapper";function cQn(t){let{components:e,...n}=t;return(0,s.kt)(sQn,(0,p.Z)({},rQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}cQn.isMDXComponent=!0;const aQn={toc:[]},iQn="wrapper";function lQn(t){let{components:e,...n}=t;return(0,s.kt)(iQn,(0,p.Z)({},aQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}lQn.isMDXComponent=!0;const uQn={toc:[]},mQn="wrapper";function dQn(t){let{components:e,...n}=t;return(0,s.kt)(mQn,(0,p.Z)({},uQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dQn.isMDXComponent=!0;const hQn={toc:[]},fQn="wrapper";function kQn(t){let{components:e,...n}=t;return(0,s.kt)(fQn,(0,p.Z)({},hQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}kQn.isMDXComponent=!0;const yQn={toc:[]},DQn="wrapper";function MQn(t){let{components:e,...n}=t;return(0,s.kt)(DQn,(0,p.Z)({},yQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}MQn.isMDXComponent=!0;const XQn={toc:[]},_Qn="wrapper";function wQn(t){let{components:e,...n}=t;return(0,s.kt)(_Qn,(0,p.Z)({},XQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wQn.isMDXComponent=!0;const TQn={toc:[]},CQn="wrapper";function gQn(t){let{components:e,...n}=t;return(0,s.kt)(CQn,(0,p.Z)({},TQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}gQn.isMDXComponent=!0;const xQn={toc:[]},vQn="wrapper";function LQn(t){let{components:e,...n}=t;return(0,s.kt)(vQn,(0,p.Z)({},xQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}LQn.isMDXComponent=!0;const ZQn={toc:[]},bQn="wrapper";function NQn(t){let{components:e,...n}=t;return(0,s.kt)(bQn,(0,p.Z)({},ZQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}NQn.isMDXComponent=!0;const zQn={toc:[]},AQn="wrapper";function PQn(t){let{components:e,...n}=t;return(0,s.kt)(AQn,(0,p.Z)({},zQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}PQn.isMDXComponent=!0;const IQn={toc:[]},WQn="wrapper";function RQn(t){let{components:e,...n}=t;return(0,s.kt)(WQn,(0,p.Z)({},IQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}RQn.isMDXComponent=!0;const SQn={toc:[]},BQn="wrapper";function GQn(t){let{components:e,...n}=t;return(0,s.kt)(BQn,(0,p.Z)({},SQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}GQn.isMDXComponent=!0;const EQn={toc:[]},OQn="wrapper";function UQn(t){let{components:e,...n}=t;return(0,s.kt)(OQn,(0,p.Z)({},EQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}UQn.isMDXComponent=!0;const FQn={toc:[]},VQn="wrapper";function qQn(t){let{components:e,...n}=t;return(0,s.kt)(VQn,(0,p.Z)({},FQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}qQn.isMDXComponent=!0;const jQn={toc:[]},HQn="wrapper";function YQn(t){let{components:e,...n}=t;return(0,s.kt)(HQn,(0,p.Z)({},jQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}YQn.isMDXComponent=!0;const QQn={toc:[]},$Qn="wrapper";function KQn(t){let{components:e,...n}=t;return(0,s.kt)($Qn,(0,p.Z)({},QQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}KQn.isMDXComponent=!0;const JQn={toc:[]},t$n="wrapper";function e$n(t){let{components:e,...n}=t;return(0,s.kt)(t$n,(0,p.Z)({},JQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}e$n.isMDXComponent=!0;const n$n={toc:[]},o$n="wrapper";function p$n(t){let{components:e,...n}=t;return(0,s.kt)(o$n,(0,p.Z)({},n$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}p$n.isMDXComponent=!0;const r$n={toc:[]},s$n="wrapper";function c$n(t){let{components:e,...n}=t;return(0,s.kt)(s$n,(0,p.Z)({},r$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}c$n.isMDXComponent=!0;const a$n={toc:[]},i$n="wrapper";function l$n(t){let{components:e,...n}=t;return(0,s.kt)(i$n,(0,p.Z)({},a$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}l$n.isMDXComponent=!0;const u$n={toc:[]},m$n="wrapper";function d$n(t){let{components:e,...n}=t;return(0,s.kt)(m$n,(0,p.Z)({},u$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}d$n.isMDXComponent=!0;const h$n={toc:[]},f$n="wrapper";function k$n(t){let{components:e,...n}=t;return(0,s.kt)(f$n,(0,p.Z)({},h$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}k$n.isMDXComponent=!0;const y$n={toc:[]},D$n="wrapper";function M$n(t){let{components:e,...n}=t;return(0,s.kt)(D$n,(0,p.Z)({},y$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}M$n.isMDXComponent=!0;const X$n={toc:[]},_$n="wrapper";function w$n(t){let{components:e,...n}=t;return(0,s.kt)(_$n,(0,p.Z)({},X$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}w$n.isMDXComponent=!0;const T$n={toc:[]},C$n="wrapper";function g$n(t){let{components:e,...n}=t;return(0,s.kt)(C$n,(0,p.Z)({},T$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}g$n.isMDXComponent=!0;const x$n={toc:[]},v$n="wrapper";function L$n(t){let{components:e,...n}=t;return(0,s.kt)(v$n,(0,p.Z)({},x$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}L$n.isMDXComponent=!0;const Z$n={toc:[]},b$n="wrapper";function N$n(t){let{components:e,...n}=t;return(0,s.kt)(b$n,(0,p.Z)({},Z$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}N$n.isMDXComponent=!0;const z$n={toc:[]},A$n="wrapper";function P$n(t){let{components:e,...n}=t;return(0,s.kt)(A$n,(0,p.Z)({},z$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}P$n.isMDXComponent=!0;const I$n={toc:[]},W$n="wrapper";function R$n(t){let{components:e,...n}=t;return(0,s.kt)(W$n,(0,p.Z)({},I$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}R$n.isMDXComponent=!0;const S$n={toc:[]},B$n="wrapper";function G$n(t){let{components:e,...n}=t;return(0,s.kt)(B$n,(0,p.Z)({},S$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}G$n.isMDXComponent=!0;const E$n={toc:[]},O$n="wrapper";function U$n(t){let{components:e,...n}=t;return(0,s.kt)(O$n,(0,p.Z)({},E$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}U$n.isMDXComponent=!0;const F$n={toc:[]},V$n="wrapper";function q$n(t){let{components:e,...n}=t;return(0,s.kt)(V$n,(0,p.Z)({},F$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}q$n.isMDXComponent=!0;const j$n={toc:[]},H$n="wrapper";function Y$n(t){let{components:e,...n}=t;return(0,s.kt)(H$n,(0,p.Z)({},j$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Y$n.isMDXComponent=!0;const Q$n={toc:[]},$$n="wrapper";function K$n(t){let{components:e,...n}=t;return(0,s.kt)($$n,(0,p.Z)({},Q$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}K$n.isMDXComponent=!0;const J$n={toc:[]},tKn="wrapper";function eKn(t){let{components:e,...n}=t;return(0,s.kt)(tKn,(0,p.Z)({},J$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}eKn.isMDXComponent=!0;const nKn={toc:[]},oKn="wrapper";function pKn(t){let{components:e,...n}=t;return(0,s.kt)(oKn,(0,p.Z)({},nKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}pKn.isMDXComponent=!0;const rKn={toc:[]},sKn="wrapper";function cKn(t){let{components:e,...n}=t;return(0,s.kt)(sKn,(0,p.Z)({},rKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}cKn.isMDXComponent=!0;const aKn={toc:[]},iKn="wrapper";function lKn(t){let{components:e,...n}=t;return(0,s.kt)(iKn,(0,p.Z)({},aKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lKn.isMDXComponent=!0;const uKn={toc:[]},mKn="wrapper";function dKn(t){let{components:e,...n}=t;return(0,s.kt)(mKn,(0,p.Z)({},uKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}dKn.isMDXComponent=!0;const hKn={toc:[]},fKn="wrapper";function kKn(t){let{components:e,...n}=t;return(0,s.kt)(fKn,(0,p.Z)({},hKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kKn.isMDXComponent=!0;const yKn={toc:[]},DKn="wrapper";function MKn(t){let{components:e,...n}=t;return(0,s.kt)(DKn,(0,p.Z)({},yKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}MKn.isMDXComponent=!0;const XKn={toc:[]},_Kn="wrapper";function wKn(t){let{components:e,...n}=t;return(0,s.kt)(_Kn,(0,p.Z)({},XKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}wKn.isMDXComponent=!0;const TKn={toc:[]},CKn="wrapper";function gKn(t){let{components:e,...n}=t;return(0,s.kt)(CKn,(0,p.Z)({},TKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}gKn.isMDXComponent=!0;const xKn={toc:[]},vKn="wrapper";function LKn(t){let{components:e,...n}=t;return(0,s.kt)(vKn,(0,p.Z)({},xKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}LKn.isMDXComponent=!0;const ZKn={toc:[]},bKn="wrapper";function NKn(t){let{components:e,...n}=t;return(0,s.kt)(bKn,(0,p.Z)({},ZKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}NKn.isMDXComponent=!0;const zKn={toc:[]},AKn="wrapper";function PKn(t){let{components:e,...n}=t;return(0,s.kt)(AKn,(0,p.Z)({},zKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}PKn.isMDXComponent=!0;const IKn={toc:[]},WKn="wrapper";function RKn(t){let{components:e,...n}=t;return(0,s.kt)(WKn,(0,p.Z)({},IKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}RKn.isMDXComponent=!0;const SKn={toc:[]},BKn="wrapper";function GKn(t){let{components:e,...n}=t;return(0,s.kt)(BKn,(0,p.Z)({},SKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}GKn.isMDXComponent=!0;const EKn={toc:[]},OKn="wrapper";function UKn(t){let{components:e,...n}=t;return(0,s.kt)(OKn,(0,p.Z)({},EKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}UKn.isMDXComponent=!0;const FKn={toc:[]},VKn="wrapper";function qKn(t){let{components:e,...n}=t;return(0,s.kt)(VKn,(0,p.Z)({},FKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}qKn.isMDXComponent=!0;const jKn={toc:[]},HKn="wrapper";function YKn(t){let{components:e,...n}=t;return(0,s.kt)(HKn,(0,p.Z)({},jKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}YKn.isMDXComponent=!0;const QKn={toc:[]},$Kn="wrapper";function KKn(t){let{components:e,...n}=t;return(0,s.kt)($Kn,(0,p.Z)({},QKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}KKn.isMDXComponent=!0;const JKn={toc:[]},tJn="wrapper";function eJn(t){let{components:e,...n}=t;return(0,s.kt)(tJn,(0,p.Z)({},JKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}eJn.isMDXComponent=!0;const nJn={toc:[]},oJn="wrapper";function pJn(t){let{components:e,...n}=t;return(0,s.kt)(oJn,(0,p.Z)({},nJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pJn.isMDXComponent=!0;const rJn={toc:[]},sJn="wrapper";function cJn(t){let{components:e,...n}=t;return(0,s.kt)(sJn,(0,p.Z)({},rJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}cJn.isMDXComponent=!0;const aJn={toc:[]},iJn="wrapper";function lJn(t){let{components:e,...n}=t;return(0,s.kt)(iJn,(0,p.Z)({},aJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}lJn.isMDXComponent=!0;const uJn={toc:[]},mJn="wrapper";function dJn(t){let{components:e,...n}=t;return(0,s.kt)(mJn,(0,p.Z)({},uJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}dJn.isMDXComponent=!0;const hJn={toc:[]},fJn="wrapper";function kJn(t){let{components:e,...n}=t;return(0,s.kt)(fJn,(0,p.Z)({},hJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}kJn.isMDXComponent=!0;const yJn={toc:[]},DJn="wrapper";function MJn(t){let{components:e,...n}=t;return(0,s.kt)(DJn,(0,p.Z)({},yJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}MJn.isMDXComponent=!0;const XJn={toc:[]},_Jn="wrapper";function wJn(t){let{components:e,...n}=t;return(0,s.kt)(_Jn,(0,p.Z)({},XJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wJn.isMDXComponent=!0;const TJn={toc:[]},CJn="wrapper";function gJn(t){let{components:e,...n}=t;return(0,s.kt)(CJn,(0,p.Z)({},TJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gJn.isMDXComponent=!0;const xJn={toc:[]},vJn="wrapper";function LJn(t){let{components:e,...n}=t;return(0,s.kt)(vJn,(0,p.Z)({},xJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}LJn.isMDXComponent=!0;const ZJn={toc:[]},bJn="wrapper";function NJn(t){let{components:e,...n}=t;return(0,s.kt)(bJn,(0,p.Z)({},ZJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}NJn.isMDXComponent=!0;const zJn={toc:[]},AJn="wrapper";function PJn(t){let{components:e,...n}=t;return(0,s.kt)(AJn,(0,p.Z)({},zJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}PJn.isMDXComponent=!0;const IJn={toc:[]},WJn="wrapper";function RJn(t){let{components:e,...n}=t;return(0,s.kt)(WJn,(0,p.Z)({},IJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}RJn.isMDXComponent=!0;const SJn={toc:[]},BJn="wrapper";function GJn(t){let{components:e,...n}=t;return(0,s.kt)(BJn,(0,p.Z)({},SJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}GJn.isMDXComponent=!0;const EJn={toc:[]},OJn="wrapper";function UJn(t){let{components:e,...n}=t;return(0,s.kt)(OJn,(0,p.Z)({},EJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}UJn.isMDXComponent=!0;const FJn={toc:[]},VJn="wrapper";function qJn(t){let{components:e,...n}=t;return(0,s.kt)(VJn,(0,p.Z)({},FJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qJn.isMDXComponent=!0;const jJn={toc:[]},HJn="wrapper";function YJn(t){let{components:e,...n}=t;return(0,s.kt)(HJn,(0,p.Z)({},jJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}YJn.isMDXComponent=!0;const QJn={toc:[]},$Jn="wrapper";function KJn(t){let{components:e,...n}=t;return(0,s.kt)($Jn,(0,p.Z)({},QJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}KJn.isMDXComponent=!0;const JJn={toc:[]},t0n="wrapper";function e0n(t){let{components:e,...n}=t;return(0,s.kt)(t0n,(0,p.Z)({},JJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}e0n.isMDXComponent=!0;const n0n={toc:[]},o0n="wrapper";function p0n(t){let{components:e,...n}=t;return(0,s.kt)(o0n,(0,p.Z)({},n0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}p0n.isMDXComponent=!0;const r0n={toc:[]},s0n="wrapper";function c0n(t){let{components:e,...n}=t;return(0,s.kt)(s0n,(0,p.Z)({},r0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}c0n.isMDXComponent=!0;const a0n={toc:[]},i0n="wrapper";function l0n(t){let{components:e,...n}=t;return(0,s.kt)(i0n,(0,p.Z)({},a0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}l0n.isMDXComponent=!0;const u0n={toc:[]},m0n="wrapper";function d0n(t){let{components:e,...n}=t;return(0,s.kt)(m0n,(0,p.Z)({},u0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}d0n.isMDXComponent=!0;const h0n={toc:[]},f0n="wrapper";function k0n(t){let{components:e,...n}=t;return(0,s.kt)(f0n,(0,p.Z)({},h0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}k0n.isMDXComponent=!0;const y0n={toc:[]},D0n="wrapper";function M0n(t){let{components:e,...n}=t;return(0,s.kt)(D0n,(0,p.Z)({},y0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}M0n.isMDXComponent=!0;const X0n={toc:[]},_0n="wrapper";function w0n(t){let{components:e,...n}=t;return(0,s.kt)(_0n,(0,p.Z)({},X0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}w0n.isMDXComponent=!0;const T0n={toc:[]},C0n="wrapper";function g0n(t){let{components:e,...n}=t;return(0,s.kt)(C0n,(0,p.Z)({},T0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}g0n.isMDXComponent=!0;const x0n={toc:[]},v0n="wrapper";function L0n(t){let{components:e,...n}=t;return(0,s.kt)(v0n,(0,p.Z)({},x0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}L0n.isMDXComponent=!0;const Z0n={toc:[]},b0n="wrapper";function N0n(t){let{components:e,...n}=t;return(0,s.kt)(b0n,(0,p.Z)({},Z0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}N0n.isMDXComponent=!0;const z0n={toc:[]},A0n="wrapper";function P0n(t){let{components:e,...n}=t;return(0,s.kt)(A0n,(0,p.Z)({},z0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}P0n.isMDXComponent=!0;const I0n={toc:[]},W0n="wrapper";function R0n(t){let{components:e,...n}=t;return(0,s.kt)(W0n,(0,p.Z)({},I0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}R0n.isMDXComponent=!0;const S0n={toc:[]},B0n="wrapper";function G0n(t){let{components:e,...n}=t;return(0,s.kt)(B0n,(0,p.Z)({},S0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}G0n.isMDXComponent=!0;const E0n={toc:[]},O0n="wrapper";function U0n(t){let{components:e,...n}=t;return(0,s.kt)(O0n,(0,p.Z)({},E0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}U0n.isMDXComponent=!0;const F0n={toc:[]},V0n="wrapper";function q0n(t){let{components:e,...n}=t;return(0,s.kt)(V0n,(0,p.Z)({},F0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}q0n.isMDXComponent=!0;const j0n={toc:[]},H0n="wrapper";function Y0n(t){let{components:e,...n}=t;return(0,s.kt)(H0n,(0,p.Z)({},j0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Y0n.isMDXComponent=!0;const Q0n={toc:[]},$0n="wrapper";function K0n(t){let{components:e,...n}=t;return(0,s.kt)($0n,(0,p.Z)({},Q0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}K0n.isMDXComponent=!0;const J0n={toc:[]},t3n="wrapper";function e3n(t){let{components:e,...n}=t;return(0,s.kt)(t3n,(0,p.Z)({},J0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}e3n.isMDXComponent=!0;const n3n={toc:[]},o3n="wrapper";function p3n(t){let{components:e,...n}=t;return(0,s.kt)(o3n,(0,p.Z)({},n3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}p3n.isMDXComponent=!0;const r3n={toc:[]},s3n="wrapper";function c3n(t){let{components:e,...n}=t;return(0,s.kt)(s3n,(0,p.Z)({},r3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}c3n.isMDXComponent=!0;const a3n={toc:[]},i3n="wrapper";function l3n(t){let{components:e,...n}=t;return(0,s.kt)(i3n,(0,p.Z)({},a3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}l3n.isMDXComponent=!0;const u3n={toc:[]},m3n="wrapper";function d3n(t){let{components:e,...n}=t;return(0,s.kt)(m3n,(0,p.Z)({},u3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}d3n.isMDXComponent=!0;const h3n={toc:[]},f3n="wrapper";function k3n(t){let{components:e,...n}=t;return(0,s.kt)(f3n,(0,p.Z)({},h3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}k3n.isMDXComponent=!0;const y3n={toc:[]},D3n="wrapper";function M3n(t){let{components:e,...n}=t;return(0,s.kt)(D3n,(0,p.Z)({},y3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}M3n.isMDXComponent=!0;const X3n={toc:[]},_3n="wrapper";function w3n(t){let{components:e,...n}=t;return(0,s.kt)(_3n,(0,p.Z)({},X3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}w3n.isMDXComponent=!0;const T3n={toc:[]},C3n="wrapper";function g3n(t){let{components:e,...n}=t;return(0,s.kt)(C3n,(0,p.Z)({},T3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}g3n.isMDXComponent=!0;const x3n={toc:[]},v3n="wrapper";function L3n(t){let{components:e,...n}=t;return(0,s.kt)(v3n,(0,p.Z)({},x3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}L3n.isMDXComponent=!0;const Z3n={toc:[]},b3n="wrapper";function N3n(t){let{components:e,...n}=t;return(0,s.kt)(b3n,(0,p.Z)({},Z3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}N3n.isMDXComponent=!0;const z3n={toc:[]},A3n="wrapper";function P3n(t){let{components:e,...n}=t;return(0,s.kt)(A3n,(0,p.Z)({},z3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}P3n.isMDXComponent=!0;const I3n={toc:[]},W3n="wrapper";function R3n(t){let{components:e,...n}=t;return(0,s.kt)(W3n,(0,p.Z)({},I3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}R3n.isMDXComponent=!0;const S3n={toc:[]},B3n="wrapper";function G3n(t){let{components:e,...n}=t;return(0,s.kt)(B3n,(0,p.Z)({},S3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}G3n.isMDXComponent=!0;const E3n={toc:[]},O3n="wrapper";function U3n(t){let{components:e,...n}=t;return(0,s.kt)(O3n,(0,p.Z)({},E3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}U3n.isMDXComponent=!0;const F3n={toc:[]},V3n="wrapper";function q3n(t){let{components:e,...n}=t;return(0,s.kt)(V3n,(0,p.Z)({},F3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}q3n.isMDXComponent=!0;const j3n={toc:[]},H3n="wrapper";function Y3n(t){let{components:e,...n}=t;return(0,s.kt)(H3n,(0,p.Z)({},j3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Y3n.isMDXComponent=!0;const Q3n={toc:[]},$3n="wrapper";function K3n(t){let{components:e,...n}=t;return(0,s.kt)($3n,(0,p.Z)({},Q3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}K3n.isMDXComponent=!0;const J3n={toc:[]},t1n="wrapper";function e1n(t){let{components:e,...n}=t;return(0,s.kt)(t1n,(0,p.Z)({},J3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}e1n.isMDXComponent=!0;const n1n={toc:[]},o1n="wrapper";function p1n(t){let{components:e,...n}=t;return(0,s.kt)(o1n,(0,p.Z)({},n1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}p1n.isMDXComponent=!0;const r1n={toc:[]},s1n="wrapper";function c1n(t){let{components:e,...n}=t;return(0,s.kt)(s1n,(0,p.Z)({},r1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}c1n.isMDXComponent=!0;const a1n={toc:[]},i1n="wrapper";function l1n(t){let{components:e,...n}=t;return(0,s.kt)(i1n,(0,p.Z)({},a1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}l1n.isMDXComponent=!0;const u1n={toc:[]},m1n="wrapper";function d1n(t){let{components:e,...n}=t;return(0,s.kt)(m1n,(0,p.Z)({},u1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}d1n.isMDXComponent=!0;const h1n={toc:[]},f1n="wrapper";function k1n(t){let{components:e,...n}=t;return(0,s.kt)(f1n,(0,p.Z)({},h1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}k1n.isMDXComponent=!0;const y1n={toc:[]},D1n="wrapper";function M1n(t){let{components:e,...n}=t;return(0,s.kt)(D1n,(0,p.Z)({},y1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}M1n.isMDXComponent=!0;const X1n={toc:[]},_1n="wrapper";function w1n(t){let{components:e,...n}=t;return(0,s.kt)(_1n,(0,p.Z)({},X1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}w1n.isMDXComponent=!0;const T1n={toc:[]},C1n="wrapper";function g1n(t){let{components:e,...n}=t;return(0,s.kt)(C1n,(0,p.Z)({},T1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}g1n.isMDXComponent=!0;const x1n={toc:[]},v1n="wrapper";function L1n(t){let{components:e,...n}=t;return(0,s.kt)(v1n,(0,p.Z)({},x1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}L1n.isMDXComponent=!0;const Z1n={toc:[]},b1n="wrapper";function N1n(t){let{components:e,...n}=t;return(0,s.kt)(b1n,(0,p.Z)({},Z1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}N1n.isMDXComponent=!0;const z1n={toc:[]},A1n="wrapper";function P1n(t){let{components:e,...n}=t;return(0,s.kt)(A1n,(0,p.Z)({},z1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}P1n.isMDXComponent=!0;const I1n={toc:[]},W1n="wrapper";function R1n(t){let{components:e,...n}=t;return(0,s.kt)(W1n,(0,p.Z)({},I1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}R1n.isMDXComponent=!0;const S1n={toc:[]},B1n="wrapper";function G1n(t){let{components:e,...n}=t;return(0,s.kt)(B1n,(0,p.Z)({},S1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}G1n.isMDXComponent=!0;const E1n={toc:[]},O1n="wrapper";function U1n(t){let{components:e,...n}=t;return(0,s.kt)(O1n,(0,p.Z)({},E1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}U1n.isMDXComponent=!0;const F1n={toc:[]},V1n="wrapper";function q1n(t){let{components:e,...n}=t;return(0,s.kt)(V1n,(0,p.Z)({},F1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}q1n.isMDXComponent=!0;const j1n={toc:[]},H1n="wrapper";function Y1n(t){let{components:e,...n}=t;return(0,s.kt)(H1n,(0,p.Z)({},j1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}Y1n.isMDXComponent=!0;const Q1n={toc:[]},$1n="wrapper";function K1n(t){let{components:e,...n}=t;return(0,s.kt)($1n,(0,p.Z)({},Q1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}K1n.isMDXComponent=!0;const J1n={toc:[]},t8n="wrapper";function e8n(t){let{components:e,...n}=t;return(0,s.kt)(t8n,(0,p.Z)({},J1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}e8n.isMDXComponent=!0;const n8n={toc:[]},o8n="wrapper";function p8n(t){let{components:e,...n}=t;return(0,s.kt)(o8n,(0,p.Z)({},n8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}p8n.isMDXComponent=!0;const r8n={toc:[]},s8n="wrapper";function c8n(t){let{components:e,...n}=t;return(0,s.kt)(s8n,(0,p.Z)({},r8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}c8n.isMDXComponent=!0;const a8n={toc:[]},i8n="wrapper";function l8n(t){let{components:e,...n}=t;return(0,s.kt)(i8n,(0,p.Z)({},a8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}l8n.isMDXComponent=!0;const u8n={toc:[]},m8n="wrapper";function d8n(t){let{components:e,...n}=t;return(0,s.kt)(m8n,(0,p.Z)({},u8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}d8n.isMDXComponent=!0;const h8n={toc:[]},f8n="wrapper";function k8n(t){let{components:e,...n}=t;return(0,s.kt)(f8n,(0,p.Z)({},h8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}k8n.isMDXComponent=!0;const y8n={toc:[]},D8n="wrapper";function M8n(t){let{components:e,...n}=t;return(0,s.kt)(D8n,(0,p.Z)({},y8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}M8n.isMDXComponent=!0;const X8n={toc:[]},_8n="wrapper";function w8n(t){let{components:e,...n}=t;return(0,s.kt)(_8n,(0,p.Z)({},X8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}w8n.isMDXComponent=!0;const T8n={toc:[]},C8n="wrapper";function g8n(t){let{components:e,...n}=t;return(0,s.kt)(C8n,(0,p.Z)({},T8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}g8n.isMDXComponent=!0;const x8n={toc:[]},v8n="wrapper";function L8n(t){let{components:e,...n}=t;return(0,s.kt)(v8n,(0,p.Z)({},x8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}L8n.isMDXComponent=!0;const Z8n={toc:[]},b8n="wrapper";function N8n(t){let{components:e,...n}=t;return(0,s.kt)(b8n,(0,p.Z)({},Z8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}N8n.isMDXComponent=!0;const z8n={toc:[]},A8n="wrapper";function P8n(t){let{components:e,...n}=t;return(0,s.kt)(A8n,(0,p.Z)({},z8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}P8n.isMDXComponent=!0;const I8n={toc:[]},W8n="wrapper";function R8n(t){let{components:e,...n}=t;return(0,s.kt)(W8n,(0,p.Z)({},I8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}R8n.isMDXComponent=!0;const S8n={toc:[]},B8n="wrapper";function G8n(t){let{components:e,...n}=t;return(0,s.kt)(B8n,(0,p.Z)({},S8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}G8n.isMDXComponent=!0;const E8n={toc:[]},O8n="wrapper";function U8n(t){let{components:e,...n}=t;return(0,s.kt)(O8n,(0,p.Z)({},E8n,n,{components:e,mdxType:"MDXLayout"}))}U8n.isMDXComponent=!0;const F8n={toc:[]},V8n="wrapper";function q8n(t){let{components:e,...n}=t;return(0,s.kt)(V8n,(0,p.Z)({},F8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}q8n.isMDXComponent=!0;const j8n={toc:[]},H8n="wrapper";function Y8n(t){let{components:e,...n}=t;return(0,s.kt)(H8n,(0,p.Z)({},j8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Y8n.isMDXComponent=!0;const Q8n={toc:[]},$8n="wrapper";function K8n(t){let{components:e,...n}=t;return(0,s.kt)($8n,(0,p.Z)({},Q8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}K8n.isMDXComponent=!0;const J8n={toc:[]},t2n="wrapper";function e2n(t){let{components:e,...n}=t;return(0,s.kt)(t2n,(0,p.Z)({},J8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}e2n.isMDXComponent=!0;const n2n={toc:[]},o2n="wrapper";function p2n(t){let{components:e,...n}=t;return(0,s.kt)(o2n,(0,p.Z)({},n2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}p2n.isMDXComponent=!0;const r2n={toc:[]},s2n="wrapper";function c2n(t){let{components:e,...n}=t;return(0,s.kt)(s2n,(0,p.Z)({},r2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}c2n.isMDXComponent=!0;const a2n={toc:[]},i2n="wrapper";function l2n(t){let{components:e,...n}=t;return(0,s.kt)(i2n,(0,p.Z)({},a2n,n,{components:e,mdxType:"MDXLayout"}))}l2n.isMDXComponent=!0;const u2n={toc:[]},m2n="wrapper";function d2n(t){let{components:e,...n}=t;return(0,s.kt)(m2n,(0,p.Z)({},u2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}d2n.isMDXComponent=!0;const h2n={toc:[]},f2n="wrapper";function k2n(t){let{components:e,...n}=t;return(0,s.kt)(f2n,(0,p.Z)({},h2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}k2n.isMDXComponent=!0;const y2n={toc:[]},D2n="wrapper";function M2n(t){let{components:e,...n}=t;return(0,s.kt)(D2n,(0,p.Z)({},y2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}M2n.isMDXComponent=!0;const X2n={toc:[]},_2n="wrapper";function w2n(t){let{components:e,...n}=t;return(0,s.kt)(_2n,(0,p.Z)({},X2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}w2n.isMDXComponent=!0;const T2n={toc:[]},C2n="wrapper";function g2n(t){let{components:e,...n}=t;return(0,s.kt)(C2n,(0,p.Z)({},T2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}g2n.isMDXComponent=!0;const x2n={toc:[]},v2n="wrapper";function L2n(t){let{components:e,...n}=t;return(0,s.kt)(v2n,(0,p.Z)({},x2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}L2n.isMDXComponent=!0;const Z2n={toc:[]},b2n="wrapper";function N2n(t){let{components:e,...n}=t;return(0,s.kt)(b2n,(0,p.Z)({},Z2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}N2n.isMDXComponent=!0;const z2n={toc:[]},A2n="wrapper";function P2n(t){let{components:e,...n}=t;return(0,s.kt)(A2n,(0,p.Z)({},z2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}P2n.isMDXComponent=!0;const I2n={toc:[]},W2n="wrapper";function R2n(t){let{components:e,...n}=t;return(0,s.kt)(W2n,(0,p.Z)({},I2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}R2n.isMDXComponent=!0;const S2n={toc:[]},B2n="wrapper";function G2n(t){let{components:e,...n}=t;return(0,s.kt)(B2n,(0,p.Z)({},S2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}G2n.isMDXComponent=!0;const E2n={toc:[]},O2n="wrapper";function U2n(t){let{components:e,...n}=t;return(0,s.kt)(O2n,(0,p.Z)({},E2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}U2n.isMDXComponent=!0;const F2n={toc:[]},V2n="wrapper";function q2n(t){let{components:e,...n}=t;return(0,s.kt)(V2n,(0,p.Z)({},F2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}q2n.isMDXComponent=!0;const j2n={toc:[]},H2n="wrapper";function Y2n(t){let{components:e,...n}=t;return(0,s.kt)(H2n,(0,p.Z)({},j2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Y2n.isMDXComponent=!0;const Q2n={toc:[]},$2n="wrapper";function K2n(t){let{components:e,...n}=t;return(0,s.kt)($2n,(0,p.Z)({},Q2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}K2n.isMDXComponent=!0;const J2n={toc:[]},t4n="wrapper";function e4n(t){let{components:e,...n}=t;return(0,s.kt)(t4n,(0,p.Z)({},J2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}e4n.isMDXComponent=!0;const n4n={toc:[]},o4n="wrapper";function p4n(t){let{components:e,...n}=t;return(0,s.kt)(o4n,(0,p.Z)({},n4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}p4n.isMDXComponent=!0;const r4n={toc:[]},s4n="wrapper";function c4n(t){let{components:e,...n}=t;return(0,s.kt)(s4n,(0,p.Z)({},r4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}c4n.isMDXComponent=!0;const a4n={toc:[]},i4n="wrapper";function l4n(t){let{components:e,...n}=t;return(0,s.kt)(i4n,(0,p.Z)({},a4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}l4n.isMDXComponent=!0;const u4n={toc:[]},m4n="wrapper";function d4n(t){let{components:e,...n}=t;return(0,s.kt)(m4n,(0,p.Z)({},u4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}d4n.isMDXComponent=!0;const h4n={toc:[]},f4n="wrapper";function k4n(t){let{components:e,...n}=t;return(0,s.kt)(f4n,(0,p.Z)({},h4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}k4n.isMDXComponent=!0;const y4n={toc:[]},D4n="wrapper";function M4n(t){let{components:e,...n}=t;return(0,s.kt)(D4n,(0,p.Z)({},y4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}M4n.isMDXComponent=!0;const X4n={toc:[]},_4n="wrapper";function w4n(t){let{components:e,...n}=t;return(0,s.kt)(_4n,(0,p.Z)({},X4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}w4n.isMDXComponent=!0;const T4n={toc:[]},C4n="wrapper";function g4n(t){let{components:e,...n}=t;return(0,s.kt)(C4n,(0,p.Z)({},T4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}g4n.isMDXComponent=!0;const x4n={toc:[]},v4n="wrapper";function L4n(t){let{components:e,...n}=t;return(0,s.kt)(v4n,(0,p.Z)({},x4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}L4n.isMDXComponent=!0;const Z4n={toc:[]},b4n="wrapper";function N4n(t){let{components:e,...n}=t;return(0,s.kt)(b4n,(0,p.Z)({},Z4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}N4n.isMDXComponent=!0;const z4n={toc:[]},A4n="wrapper";function P4n(t){let{components:e,...n}=t;return(0,s.kt)(A4n,(0,p.Z)({},z4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}P4n.isMDXComponent=!0;const I4n={toc:[]},W4n="wrapper";function R4n(t){let{components:e,...n}=t;return(0,s.kt)(W4n,(0,p.Z)({},I4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}R4n.isMDXComponent=!0;const S4n={toc:[]},B4n="wrapper";function G4n(t){let{components:e,...n}=t;return(0,s.kt)(B4n,(0,p.Z)({},S4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}G4n.isMDXComponent=!0;const E4n={toc:[]},O4n="wrapper";function U4n(t){let{components:e,...n}=t;return(0,s.kt)(O4n,(0,p.Z)({},E4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}U4n.isMDXComponent=!0;const F4n={toc:[]},V4n="wrapper";function q4n(t){let{components:e,...n}=t;return(0,s.kt)(V4n,(0,p.Z)({},F4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}q4n.isMDXComponent=!0;const j4n={toc:[]},H4n="wrapper";function Y4n(t){let{components:e,...n}=t;return(0,s.kt)(H4n,(0,p.Z)({},j4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}Y4n.isMDXComponent=!0;const Q4n={toc:[]},$4n="wrapper";function K4n(t){let{components:e,...n}=t;return(0,s.kt)($4n,(0,p.Z)({},Q4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}K4n.isMDXComponent=!0;const J4n={toc:[]},t6n="wrapper";function e6n(t){let{components:e,...n}=t;return(0,s.kt)(t6n,(0,p.Z)({},J4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}e6n.isMDXComponent=!0;const n6n={toc:[]},o6n="wrapper";function p6n(t){let{components:e,...n}=t;return(0,s.kt)(o6n,(0,p.Z)({},n6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}p6n.isMDXComponent=!0;const r6n={toc:[]},s6n="wrapper";function c6n(t){let{components:e,...n}=t;return(0,s.kt)(s6n,(0,p.Z)({},r6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}c6n.isMDXComponent=!0;const a6n={toc:[]},i6n="wrapper";function l6n(t){let{components:e,...n}=t;return(0,s.kt)(i6n,(0,p.Z)({},a6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}l6n.isMDXComponent=!0;const u6n={toc:[]},m6n="wrapper";function d6n(t){let{components:e,...n}=t;return(0,s.kt)(m6n,(0,p.Z)({},u6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}d6n.isMDXComponent=!0;const h6n={toc:[]},f6n="wrapper";function k6n(t){let{components:e,...n}=t;return(0,s.kt)(f6n,(0,p.Z)({},h6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}k6n.isMDXComponent=!0;const y6n={toc:[]},D6n="wrapper";function M6n(t){let{components:e,...n}=t;return(0,s.kt)(D6n,(0,p.Z)({},y6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}M6n.isMDXComponent=!0;const X6n={toc:[]},_6n="wrapper";function w6n(t){let{components:e,...n}=t;return(0,s.kt)(_6n,(0,p.Z)({},X6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}w6n.isMDXComponent=!0;const T6n={toc:[]},C6n="wrapper";function g6n(t){let{components:e,...n}=t;return(0,s.kt)(C6n,(0,p.Z)({},T6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}g6n.isMDXComponent=!0;const x6n={toc:[]},v6n="wrapper";function L6n(t){let{components:e,...n}=t;return(0,s.kt)(v6n,(0,p.Z)({},x6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}L6n.isMDXComponent=!0;const Z6n={toc:[]},b6n="wrapper";function N6n(t){let{components:e,...n}=t;return(0,s.kt)(b6n,(0,p.Z)({},Z6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}N6n.isMDXComponent=!0;const z6n={toc:[]},A6n="wrapper";function P6n(t){let{components:e,...n}=t;return(0,s.kt)(A6n,(0,p.Z)({},z6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}P6n.isMDXComponent=!0;const I6n={toc:[]},W6n="wrapper";function R6n(t){let{components:e,...n}=t;return(0,s.kt)(W6n,(0,p.Z)({},I6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}R6n.isMDXComponent=!0;const S6n={toc:[]},B6n="wrapper";function G6n(t){let{components:e,...n}=t;return(0,s.kt)(B6n,(0,p.Z)({},S6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}G6n.isMDXComponent=!0;const E6n={toc:[]},O6n="wrapper";function U6n(t){let{components:e,...n}=t;return(0,s.kt)(O6n,(0,p.Z)({},E6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}U6n.isMDXComponent=!0;const F6n={toc:[]},V6n="wrapper";function q6n(t){let{components:e,...n}=t;return(0,s.kt)(V6n,(0,p.Z)({},F6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}q6n.isMDXComponent=!0;const j6n={toc:[]},H6n="wrapper";function Y6n(t){let{components:e,...n}=t;return(0,s.kt)(H6n,(0,p.Z)({},j6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Y6n.isMDXComponent=!0;const Q6n={toc:[]},$6n="wrapper";function K6n(t){let{components:e,...n}=t;return(0,s.kt)($6n,(0,p.Z)({},Q6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}K6n.isMDXComponent=!0;const J6n={toc:[]},t5n="wrapper";function e5n(t){let{components:e,...n}=t;return(0,s.kt)(t5n,(0,p.Z)({},J6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}e5n.isMDXComponent=!0;const n5n={toc:[]},o5n="wrapper";function p5n(t){let{components:e,...n}=t;return(0,s.kt)(o5n,(0,p.Z)({},n5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}p5n.isMDXComponent=!0;const r5n={toc:[]},s5n="wrapper";function c5n(t){let{components:e,...n}=t;return(0,s.kt)(s5n,(0,p.Z)({},r5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}c5n.isMDXComponent=!0;const a5n={toc:[]},i5n="wrapper";function l5n(t){let{components:e,...n}=t;return(0,s.kt)(i5n,(0,p.Z)({},a5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}l5n.isMDXComponent=!0;const u5n={toc:[]},m5n="wrapper";function d5n(t){let{components:e,...n}=t;return(0,s.kt)(m5n,(0,p.Z)({},u5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}d5n.isMDXComponent=!0;const h5n={toc:[]},f5n="wrapper";function k5n(t){let{components:e,...n}=t;return(0,s.kt)(f5n,(0,p.Z)({},h5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}k5n.isMDXComponent=!0;const y5n={toc:[]},D5n="wrapper";function M5n(t){let{components:e,...n}=t;return(0,s.kt)(D5n,(0,p.Z)({},y5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}M5n.isMDXComponent=!0;const X5n={toc:[]},_5n="wrapper";function w5n(t){let{components:e,...n}=t;return(0,s.kt)(_5n,(0,p.Z)({},X5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}w5n.isMDXComponent=!0;const T5n={toc:[]},C5n="wrapper";function g5n(t){let{components:e,...n}=t;return(0,s.kt)(C5n,(0,p.Z)({},T5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}g5n.isMDXComponent=!0;const x5n={toc:[]},v5n="wrapper";function L5n(t){let{components:e,...n}=t;return(0,s.kt)(v5n,(0,p.Z)({},x5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}L5n.isMDXComponent=!0;const Z5n={toc:[]},b5n="wrapper";function N5n(t){let{components:e,...n}=t;return(0,s.kt)(b5n,(0,p.Z)({},Z5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N5n.isMDXComponent=!0;const z5n={toc:[]},A5n="wrapper";function P5n(t){let{components:e,...n}=t;return(0,s.kt)(A5n,(0,p.Z)({},z5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}P5n.isMDXComponent=!0;const I5n={toc:[]},W5n="wrapper";function R5n(t){let{components:e,...n}=t;return(0,s.kt)(W5n,(0,p.Z)({},I5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}R5n.isMDXComponent=!0;const S5n={toc:[]},B5n="wrapper";function G5n(t){let{components:e,...n}=t;return(0,s.kt)(B5n,(0,p.Z)({},S5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}G5n.isMDXComponent=!0;const E5n={toc:[]},O5n="wrapper";function U5n(t){let{components:e,...n}=t;return(0,s.kt)(O5n,(0,p.Z)({},E5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}U5n.isMDXComponent=!0;const F5n={toc:[]},V5n="wrapper";function q5n(t){let{components:e,...n}=t;return(0,s.kt)(V5n,(0,p.Z)({},F5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}q5n.isMDXComponent=!0;const j5n={toc:[]},H5n="wrapper";function Y5n(t){let{components:e,...n}=t;return(0,s.kt)(H5n,(0,p.Z)({},j5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Y5n.isMDXComponent=!0;const Q5n={toc:[]},$5n="wrapper";function K5n(t){let{components:e,...n}=t;return(0,s.kt)($5n,(0,p.Z)({},Q5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}K5n.isMDXComponent=!0;const J5n={toc:[]},t7n="wrapper";function e7n(t){let{components:e,...n}=t;return(0,s.kt)(t7n,(0,p.Z)({},J5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}e7n.isMDXComponent=!0;const n7n={toc:[]},o7n="wrapper";function p7n(t){let{components:e,...n}=t;return(0,s.kt)(o7n,(0,p.Z)({},n7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}p7n.isMDXComponent=!0;const r7n={toc:[]},s7n="wrapper";function c7n(t){let{components:e,...n}=t;return(0,s.kt)(s7n,(0,p.Z)({},r7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}c7n.isMDXComponent=!0;const a7n={toc:[]},i7n="wrapper";function l7n(t){let{components:e,...n}=t;return(0,s.kt)(i7n,(0,p.Z)({},a7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}l7n.isMDXComponent=!0;const u7n={toc:[]},m7n="wrapper";function d7n(t){let{components:e,...n}=t;return(0,s.kt)(m7n,(0,p.Z)({},u7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}d7n.isMDXComponent=!0;const h7n={toc:[]},f7n="wrapper";function k7n(t){let{components:e,...n}=t;return(0,s.kt)(f7n,(0,p.Z)({},h7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}k7n.isMDXComponent=!0;const y7n={toc:[]},D7n="wrapper";function M7n(t){let{components:e,...n}=t;return(0,s.kt)(D7n,(0,p.Z)({},y7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}M7n.isMDXComponent=!0;const X7n={toc:[]},_7n="wrapper";function w7n(t){let{components:e,...n}=t;return(0,s.kt)(_7n,(0,p.Z)({},X7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}w7n.isMDXComponent=!0;const T7n={toc:[]},C7n="wrapper";function g7n(t){let{components:e,...n}=t;return(0,s.kt)(C7n,(0,p.Z)({},T7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}g7n.isMDXComponent=!0;const x7n={toc:[]},v7n="wrapper";function L7n(t){let{components:e,...n}=t;return(0,s.kt)(v7n,(0,p.Z)({},x7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}L7n.isMDXComponent=!0;const Z7n={toc:[]},b7n="wrapper";function N7n(t){let{components:e,...n}=t;return(0,s.kt)(b7n,(0,p.Z)({},Z7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}N7n.isMDXComponent=!0;const z7n={toc:[]},A7n="wrapper";function P7n(t){let{components:e,...n}=t;return(0,s.kt)(A7n,(0,p.Z)({},z7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}P7n.isMDXComponent=!0;const I7n={toc:[]},W7n="wrapper";function R7n(t){let{components:e,...n}=t;return(0,s.kt)(W7n,(0,p.Z)({},I7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}R7n.isMDXComponent=!0;const S7n={toc:[]},B7n="wrapper";function G7n(t){let{components:e,...n}=t;return(0,s.kt)(B7n,(0,p.Z)({},S7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}G7n.isMDXComponent=!0;const E7n={toc:[]},O7n="wrapper";function U7n(t){let{components:e,...n}=t;return(0,s.kt)(O7n,(0,p.Z)({},E7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}U7n.isMDXComponent=!0;const F7n={toc:[]},V7n="wrapper";function q7n(t){let{components:e,...n}=t;return(0,s.kt)(V7n,(0,p.Z)({},F7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}q7n.isMDXComponent=!0;const j7n={toc:[]},H7n="wrapper";function Y7n(t){let{components:e,...n}=t;return(0,s.kt)(H7n,(0,p.Z)({},j7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Y7n.isMDXComponent=!0;const Q7n={toc:[]},$7n="wrapper";function K7n(t){let{components:e,...n}=t;return(0,s.kt)($7n,(0,p.Z)({},Q7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}K7n.isMDXComponent=!0;const J7n={toc:[]},t9n="wrapper";function e9n(t){let{components:e,...n}=t;return(0,s.kt)(t9n,(0,p.Z)({},J7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}e9n.isMDXComponent=!0;const n9n={toc:[]},o9n="wrapper";function p9n(t){let{components:e,...n}=t;return(0,s.kt)(o9n,(0,p.Z)({},n9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}p9n.isMDXComponent=!0;const r9n={toc:[]},s9n="wrapper";function c9n(t){let{components:e,...n}=t;return(0,s.kt)(s9n,(0,p.Z)({},r9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}c9n.isMDXComponent=!0;const a9n={toc:[]},i9n="wrapper";function l9n(t){let{components:e,...n}=t;return(0,s.kt)(i9n,(0,p.Z)({},a9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}l9n.isMDXComponent=!0;const u9n={toc:[]},m9n="wrapper";function d9n(t){let{components:e,...n}=t;return(0,s.kt)(m9n,(0,p.Z)({},u9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}d9n.isMDXComponent=!0;const h9n={toc:[]},f9n="wrapper";function k9n(t){let{components:e,...n}=t;return(0,s.kt)(f9n,(0,p.Z)({},h9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}k9n.isMDXComponent=!0;const y9n={toc:[]},D9n="wrapper";function M9n(t){let{components:e,...n}=t;return(0,s.kt)(D9n,(0,p.Z)({},y9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}M9n.isMDXComponent=!0;const X9n={toc:[]},_9n="wrapper";function w9n(t){let{components:e,...n}=t;return(0,s.kt)(_9n,(0,p.Z)({},X9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}w9n.isMDXComponent=!0;const T9n={toc:[]},C9n="wrapper";function g9n(t){let{components:e,...n}=t;return(0,s.kt)(C9n,(0,p.Z)({},T9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}g9n.isMDXComponent=!0;const x9n={toc:[]},v9n="wrapper";function L9n(t){let{components:e,...n}=t;return(0,s.kt)(v9n,(0,p.Z)({},x9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}L9n.isMDXComponent=!0;const Z9n={toc:[]},b9n="wrapper";function N9n(t){let{components:e,...n}=t;return(0,s.kt)(b9n,(0,p.Z)({},Z9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}N9n.isMDXComponent=!0;const z9n={toc:[]},A9n="wrapper";function P9n(t){let{components:e,...n}=t;return(0,s.kt)(A9n,(0,p.Z)({},z9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}P9n.isMDXComponent=!0;const I9n={toc:[]},W9n="wrapper";function R9n(t){let{components:e,...n}=t;return(0,s.kt)(W9n,(0,p.Z)({},I9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}R9n.isMDXComponent=!0;const S9n={toc:[]},B9n="wrapper";function G9n(t){let{components:e,...n}=t;return(0,s.kt)(B9n,(0,p.Z)({},S9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}G9n.isMDXComponent=!0;const E9n={toc:[]},O9n="wrapper";function U9n(t){let{components:e,...n}=t;return(0,s.kt)(O9n,(0,p.Z)({},E9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}U9n.isMDXComponent=!0;const F9n={toc:[]},V9n="wrapper";function q9n(t){let{components:e,...n}=t;return(0,s.kt)(V9n,(0,p.Z)({},F9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}q9n.isMDXComponent=!0;const j9n={toc:[]},H9n="wrapper";function Y9n(t){let{components:e,...n}=t;return(0,s.kt)(H9n,(0,p.Z)({},j9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Y9n.isMDXComponent=!0;const Q9n={toc:[]},$9n="wrapper";function K9n(t){let{components:e,...n}=t;return(0,s.kt)($9n,(0,p.Z)({},Q9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}K9n.isMDXComponent=!0;const J9n={toc:[]},tto="wrapper";function eto(t){let{components:e,...n}=t;return(0,s.kt)(tto,(0,p.Z)({},J9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}eto.isMDXComponent=!0;const nto={toc:[]},oto="wrapper";function pto(t){let{components:e,...n}=t;return(0,s.kt)(oto,(0,p.Z)({},nto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pto.isMDXComponent=!0;const rto={toc:[]},sto="wrapper";function cto(t){let{components:e,...n}=t;return(0,s.kt)(sto,(0,p.Z)({},rto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}cto.isMDXComponent=!0;const ato={toc:[]},ito="wrapper";function lto(t){let{components:e,...n}=t;return(0,s.kt)(ito,(0,p.Z)({},ato,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}lto.isMDXComponent=!0;const uto={toc:[]},mto="wrapper";function dto(t){let{components:e,...n}=t;return(0,s.kt)(mto,(0,p.Z)({},uto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}dto.isMDXComponent=!0;const hto={toc:[]},fto="wrapper";function kto(t){let{components:e,...n}=t;return(0,s.kt)(fto,(0,p.Z)({},hto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}kto.isMDXComponent=!0;const yto={toc:[]},Dto="wrapper";function Mto(t){let{components:e,...n}=t;return(0,s.kt)(Dto,(0,p.Z)({},yto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Mto.isMDXComponent=!0;const Xto={toc:[]},_to="wrapper";function wto(t){let{components:e,...n}=t;return(0,s.kt)(_to,(0,p.Z)({},Xto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}wto.isMDXComponent=!0;const Tto={toc:[]},Cto="wrapper";function gto(t){let{components:e,...n}=t;return(0,s.kt)(Cto,(0,p.Z)({},Tto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gto.isMDXComponent=!0;const xto={toc:[]},vto="wrapper";function Lto(t){let{components:e,...n}=t;return(0,s.kt)(vto,(0,p.Z)({},xto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Lto.isMDXComponent=!0;const Zto={toc:[]},bto="wrapper";function Nto(t){let{components:e,...n}=t;return(0,s.kt)(bto,(0,p.Z)({},Zto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Nto.isMDXComponent=!0;const zto={toc:[]},Ato="wrapper";function Pto(t){let{components:e,...n}=t;return(0,s.kt)(Ato,(0,p.Z)({},zto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Pto.isMDXComponent=!0;const Ito={toc:[]},Wto="wrapper";function Rto(t){let{components:e,...n}=t;return(0,s.kt)(Wto,(0,p.Z)({},Ito,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Rto.isMDXComponent=!0;const Sto={toc:[]},Bto="wrapper";function Gto(t){let{components:e,...n}=t;return(0,s.kt)(Bto,(0,p.Z)({},Sto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Gto.isMDXComponent=!0;const Eto={toc:[]},Oto="wrapper";function Uto(t){let{components:e,...n}=t;return(0,s.kt)(Oto,(0,p.Z)({},Eto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Uto.isMDXComponent=!0;const Fto={toc:[]},Vto="wrapper";function qto(t){let{components:e,...n}=t;return(0,s.kt)(Vto,(0,p.Z)({},Fto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}qto.isMDXComponent=!0;const jto={toc:[]},Hto="wrapper";function Yto(t){let{components:e,...n}=t;return(0,s.kt)(Hto,(0,p.Z)({},jto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}Yto.isMDXComponent=!0;const Qto={toc:[]},$to="wrapper";function Kto(t){let{components:e,...n}=t;return(0,s.kt)($to,(0,p.Z)({},Qto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Kto.isMDXComponent=!0;const Jto={toc:[]},teo="wrapper";function eeo(t){let{components:e,...n}=t;return(0,s.kt)(teo,(0,p.Z)({},Jto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}eeo.isMDXComponent=!0;const neo={toc:[]},oeo="wrapper";function peo(t){let{components:e,...n}=t;return(0,s.kt)(oeo,(0,p.Z)({},neo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}peo.isMDXComponent=!0;const reo={toc:[]},seo="wrapper";function ceo(t){let{components:e,...n}=t;return(0,s.kt)(seo,(0,p.Z)({},reo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}ceo.isMDXComponent=!0;const aeo={toc:[]},ieo="wrapper";function leo(t){let{components:e,...n}=t;return(0,s.kt)(ieo,(0,p.Z)({},aeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}leo.isMDXComponent=!0;const ueo={toc:[]},meo="wrapper";function deo(t){let{components:e,...n}=t;return(0,s.kt)(meo,(0,p.Z)({},ueo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}deo.isMDXComponent=!0;const heo={toc:[]},feo="wrapper";function keo(t){let{components:e,...n}=t;return(0,s.kt)(feo,(0,p.Z)({},heo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}keo.isMDXComponent=!0;const yeo={toc:[]},Deo="wrapper";function Meo(t){let{components:e,...n}=t;return(0,s.kt)(Deo,(0,p.Z)({},yeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Meo.isMDXComponent=!0;const Xeo={toc:[]},_eo="wrapper";function weo(t){let{components:e,...n}=t;return(0,s.kt)(_eo,(0,p.Z)({},Xeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}weo.isMDXComponent=!0;const Teo={toc:[]},Ceo="wrapper";function geo(t){let{components:e,...n}=t;return(0,s.kt)(Ceo,(0,p.Z)({},Teo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}geo.isMDXComponent=!0;const xeo={toc:[]},veo="wrapper";function Leo(t){let{components:e,...n}=t;return(0,s.kt)(veo,(0,p.Z)({},xeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Leo.isMDXComponent=!0;const Zeo={toc:[]},beo="wrapper";function Neo(t){let{components:e,...n}=t;return(0,s.kt)(beo,(0,p.Z)({},Zeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Neo.isMDXComponent=!0;const zeo={toc:[]},Aeo="wrapper";function Peo(t){let{components:e,...n}=t;return(0,s.kt)(Aeo,(0,p.Z)({},zeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Peo.isMDXComponent=!0;const Ieo={toc:[]},Weo="wrapper";function Reo(t){let{components:e,...n}=t;return(0,s.kt)(Weo,(0,p.Z)({},Ieo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Reo.isMDXComponent=!0;const Seo={toc:[]},Beo="wrapper";function Geo(t){let{components:e,...n}=t;return(0,s.kt)(Beo,(0,p.Z)({},Seo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Geo.isMDXComponent=!0;const Eeo={toc:[]},Oeo="wrapper";function Ueo(t){let{components:e,...n}=t;return(0,s.kt)(Oeo,(0,p.Z)({},Eeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Ueo.isMDXComponent=!0;const Feo={toc:[]},Veo="wrapper";function qeo(t){let{components:e,...n}=t;return(0,s.kt)(Veo,(0,p.Z)({},Feo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}qeo.isMDXComponent=!0;const jeo={toc:[]},Heo="wrapper";function Yeo(t){let{components:e,...n}=t;return(0,s.kt)(Heo,(0,p.Z)({},jeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Yeo.isMDXComponent=!0;const Qeo={toc:[]},$eo="wrapper";function Keo(t){let{components:e,...n}=t;return(0,s.kt)($eo,(0,p.Z)({},Qeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Keo.isMDXComponent=!0;const Jeo={toc:[]},tno="wrapper";function eno(t){let{components:e,...n}=t;return(0,s.kt)(tno,(0,p.Z)({},Jeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eno.isMDXComponent=!0;const nno={toc:[]},ono="wrapper";function pno(t){let{components:e,...n}=t;return(0,s.kt)(ono,(0,p.Z)({},nno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pno.isMDXComponent=!0;const rno={toc:[]},sno="wrapper";function cno(t){let{components:e,...n}=t;return(0,s.kt)(sno,(0,p.Z)({},rno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}cno.isMDXComponent=!0;const ano={toc:[]},ino="wrapper";function lno(t){let{components:e,...n}=t;return(0,s.kt)(ino,(0,p.Z)({},ano,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}lno.isMDXComponent=!0;const uno={toc:[]},mno="wrapper";function dno(t){let{components:e,...n}=t;return(0,s.kt)(mno,(0,p.Z)({},uno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}dno.isMDXComponent=!0;const hno={toc:[]},fno="wrapper";function kno(t){let{components:e,...n}=t;return(0,s.kt)(fno,(0,p.Z)({},hno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}kno.isMDXComponent=!0;const yno={toc:[]},Dno="wrapper";function Mno(t){let{components:e,...n}=t;return(0,s.kt)(Dno,(0,p.Z)({},yno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Mno.isMDXComponent=!0;const Xno={toc:[]},_no="wrapper";function wno(t){let{components:e,...n}=t;return(0,s.kt)(_no,(0,p.Z)({},Xno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wno.isMDXComponent=!0;const Tno={toc:[]},Cno="wrapper";function gno(t){let{components:e,...n}=t;return(0,s.kt)(Cno,(0,p.Z)({},Tno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}gno.isMDXComponent=!0;const xno={toc:[]},vno="wrapper";function Lno(t){let{components:e,...n}=t;return(0,s.kt)(vno,(0,p.Z)({},xno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Lno.isMDXComponent=!0;const Zno={toc:[]},bno="wrapper";function Nno(t){let{components:e,...n}=t;return(0,s.kt)(bno,(0,p.Z)({},Zno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Nno.isMDXComponent=!0;const zno={toc:[]},Ano="wrapper";function Pno(t){let{components:e,...n}=t;return(0,s.kt)(Ano,(0,p.Z)({},zno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Pno.isMDXComponent=!0;const Ino={toc:[]},Wno="wrapper";function Rno(t){let{components:e,...n}=t;return(0,s.kt)(Wno,(0,p.Z)({},Ino,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Rno.isMDXComponent=!0;const Sno={toc:[]},Bno="wrapper";function Gno(t){let{components:e,...n}=t;return(0,s.kt)(Bno,(0,p.Z)({},Sno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Gno.isMDXComponent=!0;const Eno={toc:[]},Ono="wrapper";function Uno(t){let{components:e,...n}=t;return(0,s.kt)(Ono,(0,p.Z)({},Eno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Uno.isMDXComponent=!0;const Fno={toc:[]},Vno="wrapper";function qno(t){let{components:e,...n}=t;return(0,s.kt)(Vno,(0,p.Z)({},Fno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}qno.isMDXComponent=!0;const jno={toc:[]},Hno="wrapper";function Yno(t){let{components:e,...n}=t;return(0,s.kt)(Hno,(0,p.Z)({},jno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Yno.isMDXComponent=!0;const Qno={toc:[]},$no="wrapper";function Kno(t){let{components:e,...n}=t;return(0,s.kt)($no,(0,p.Z)({},Qno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Kno.isMDXComponent=!0;const Jno={toc:[]},too="wrapper";function eoo(t){let{components:e,...n}=t;return(0,s.kt)(too,(0,p.Z)({},Jno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}eoo.isMDXComponent=!0;const noo={toc:[]},ooo="wrapper";function poo(t){let{components:e,...n}=t;return(0,s.kt)(ooo,(0,p.Z)({},noo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}poo.isMDXComponent=!0;const roo={toc:[]},soo="wrapper";function coo(t){let{components:e,...n}=t;return(0,s.kt)(soo,(0,p.Z)({},roo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}coo.isMDXComponent=!0;const aoo={toc:[]},ioo="wrapper";function loo(t){let{components:e,...n}=t;return(0,s.kt)(ioo,(0,p.Z)({},aoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}loo.isMDXComponent=!0;const uoo={toc:[]},moo="wrapper";function doo(t){let{components:e,...n}=t;return(0,s.kt)(moo,(0,p.Z)({},uoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}doo.isMDXComponent=!0;const hoo={toc:[]},foo="wrapper";function koo(t){let{components:e,...n}=t;return(0,s.kt)(foo,(0,p.Z)({},hoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}koo.isMDXComponent=!0;const yoo={toc:[]},Doo="wrapper";function Moo(t){let{components:e,...n}=t;return(0,s.kt)(Doo,(0,p.Z)({},yoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Moo.isMDXComponent=!0;const Xoo={toc:[]},_oo="wrapper";function woo(t){let{components:e,...n}=t;return(0,s.kt)(_oo,(0,p.Z)({},Xoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}woo.isMDXComponent=!0;const Too={toc:[]},Coo="wrapper";function goo(t){let{components:e,...n}=t;return(0,s.kt)(Coo,(0,p.Z)({},Too,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}goo.isMDXComponent=!0;const xoo={toc:[]},voo="wrapper";function Loo(t){let{components:e,...n}=t;return(0,s.kt)(voo,(0,p.Z)({},xoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Loo.isMDXComponent=!0;const Zoo={toc:[]},boo="wrapper";function Noo(t){let{components:e,...n}=t;return(0,s.kt)(boo,(0,p.Z)({},Zoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Noo.isMDXComponent=!0;const zoo={toc:[]},Aoo="wrapper";function Poo(t){let{components:e,...n}=t;return(0,s.kt)(Aoo,(0,p.Z)({},zoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Poo.isMDXComponent=!0;const Ioo={toc:[]},Woo="wrapper";function Roo(t){let{components:e,...n}=t;return(0,s.kt)(Woo,(0,p.Z)({},Ioo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Roo.isMDXComponent=!0;const Soo={toc:[]},Boo="wrapper";function Goo(t){let{components:e,...n}=t;return(0,s.kt)(Boo,(0,p.Z)({},Soo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Goo.isMDXComponent=!0;const Eoo={toc:[]},Ooo="wrapper";function Uoo(t){let{components:e,...n}=t;return(0,s.kt)(Ooo,(0,p.Z)({},Eoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Uoo.isMDXComponent=!0;const Foo={toc:[]},Voo="wrapper";function qoo(t){let{components:e,...n}=t;return(0,s.kt)(Voo,(0,p.Z)({},Foo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}qoo.isMDXComponent=!0;const joo={toc:[]},Hoo="wrapper";function Yoo(t){let{components:e,...n}=t;return(0,s.kt)(Hoo,(0,p.Z)({},joo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Yoo.isMDXComponent=!0;const Qoo={toc:[]},$oo="wrapper";function Koo(t){let{components:e,...n}=t;return(0,s.kt)($oo,(0,p.Z)({},Qoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Koo.isMDXComponent=!0;const Joo={toc:[]},tpo="wrapper";function epo(t){let{components:e,...n}=t;return(0,s.kt)(tpo,(0,p.Z)({},Joo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}epo.isMDXComponent=!0;const npo={toc:[]},opo="wrapper";function ppo(t){let{components:e,...n}=t;return(0,s.kt)(opo,(0,p.Z)({},npo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ppo.isMDXComponent=!0;const rpo={toc:[]},spo="wrapper";function cpo(t){let{components:e,...n}=t;return(0,s.kt)(spo,(0,p.Z)({},rpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}cpo.isMDXComponent=!0;const apo={toc:[]},ipo="wrapper";function lpo(t){let{components:e,...n}=t;return(0,s.kt)(ipo,(0,p.Z)({},apo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lpo.isMDXComponent=!0;const upo={toc:[]},mpo="wrapper";function dpo(t){let{components:e,...n}=t;return(0,s.kt)(mpo,(0,p.Z)({},upo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}dpo.isMDXComponent=!0;const hpo={toc:[]},fpo="wrapper";function kpo(t){let{components:e,...n}=t;return(0,s.kt)(fpo,(0,p.Z)({},hpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}kpo.isMDXComponent=!0;const ypo={toc:[]},Dpo="wrapper";function Mpo(t){let{components:e,...n}=t;return(0,s.kt)(Dpo,(0,p.Z)({},ypo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Mpo.isMDXComponent=!0;const Xpo={toc:[]},_po="wrapper";function wpo(t){let{components:e,...n}=t;return(0,s.kt)(_po,(0,p.Z)({},Xpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wpo.isMDXComponent=!0;const Tpo={toc:[]},Cpo="wrapper";function gpo(t){let{components:e,...n}=t;return(0,s.kt)(Cpo,(0,p.Z)({},Tpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}gpo.isMDXComponent=!0;const xpo={toc:[]},vpo="wrapper";function Lpo(t){let{components:e,...n}=t;return(0,s.kt)(vpo,(0,p.Z)({},xpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Lpo.isMDXComponent=!0;const Zpo={toc:[]},bpo="wrapper";function Npo(t){let{components:e,...n}=t;return(0,s.kt)(bpo,(0,p.Z)({},Zpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Npo.isMDXComponent=!0;const zpo={toc:[]},Apo="wrapper";function Ppo(t){let{components:e,...n}=t;return(0,s.kt)(Apo,(0,p.Z)({},zpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Ppo.isMDXComponent=!0;const Ipo={toc:[]},Wpo="wrapper";function Rpo(t){let{components:e,...n}=t;return(0,s.kt)(Wpo,(0,p.Z)({},Ipo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Rpo.isMDXComponent=!0;const Spo={toc:[]},Bpo="wrapper";function Gpo(t){let{components:e,...n}=t;return(0,s.kt)(Bpo,(0,p.Z)({},Spo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Gpo.isMDXComponent=!0;const Epo={toc:[]},Opo="wrapper";function Upo(t){let{components:e,...n}=t;return(0,s.kt)(Opo,(0,p.Z)({},Epo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Upo.isMDXComponent=!0;const Fpo={toc:[]},Vpo="wrapper";function qpo(t){let{components:e,...n}=t;return(0,s.kt)(Vpo,(0,p.Z)({},Fpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}qpo.isMDXComponent=!0;const jpo={toc:[]},Hpo="wrapper";function Ypo(t){let{components:e,...n}=t;return(0,s.kt)(Hpo,(0,p.Z)({},jpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Ypo.isMDXComponent=!0;const Qpo={toc:[]},$po="wrapper";function Kpo(t){let{components:e,...n}=t;return(0,s.kt)($po,(0,p.Z)({},Qpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Kpo.isMDXComponent=!0;const Jpo={toc:[]},tro="wrapper";function ero(t){let{components:e,...n}=t;return(0,s.kt)(tro,(0,p.Z)({},Jpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ero.isMDXComponent=!0;const nro={toc:[]},oro="wrapper";function pro(t){let{components:e,...n}=t;return(0,s.kt)(oro,(0,p.Z)({},nro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}pro.isMDXComponent=!0;const rro={toc:[]},sro="wrapper";function cro(t){let{components:e,...n}=t;return(0,s.kt)(sro,(0,p.Z)({},rro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cro.isMDXComponent=!0;const aro={toc:[]},iro="wrapper";function lro(t){let{components:e,...n}=t;return(0,s.kt)(iro,(0,p.Z)({},aro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}lro.isMDXComponent=!0;const uro={toc:[]},mro="wrapper";function dro(t){let{components:e,...n}=t;return(0,s.kt)(mro,(0,p.Z)({},uro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}dro.isMDXComponent=!0;const hro={toc:[]},fro="wrapper";function kro(t){let{components:e,...n}=t;return(0,s.kt)(fro,(0,p.Z)({},hro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}kro.isMDXComponent=!0;const yro={toc:[]},Dro="wrapper";function Mro(t){let{components:e,...n}=t;return(0,s.kt)(Dro,(0,p.Z)({},yro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Mro.isMDXComponent=!0;const Xro={toc:[]},_ro="wrapper";function wro(t){let{components:e,...n}=t;return(0,s.kt)(_ro,(0,p.Z)({},Xro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wro.isMDXComponent=!0;const Tro={toc:[]},Cro="wrapper";function gro(t){let{components:e,...n}=t;return(0,s.kt)(Cro,(0,p.Z)({},Tro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}gro.isMDXComponent=!0;const xro={toc:[]},vro="wrapper";function Lro(t){let{components:e,...n}=t;return(0,s.kt)(vro,(0,p.Z)({},xro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Lro.isMDXComponent=!0;const Zro={toc:[]},bro="wrapper";function Nro(t){let{components:e,...n}=t;return(0,s.kt)(bro,(0,p.Z)({},Zro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Nro.isMDXComponent=!0;const zro={toc:[]},Aro="wrapper";function Pro(t){let{components:e,...n}=t;return(0,s.kt)(Aro,(0,p.Z)({},zro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Pro.isMDXComponent=!0;const Iro={toc:[]},Wro="wrapper";function Rro(t){let{components:e,...n}=t;return(0,s.kt)(Wro,(0,p.Z)({},Iro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Rro.isMDXComponent=!0;const Sro={toc:[]},Bro="wrapper";function Gro(t){let{components:e,...n}=t;return(0,s.kt)(Bro,(0,p.Z)({},Sro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Gro.isMDXComponent=!0;const Ero={toc:[]},Oro="wrapper";function Uro(t){let{components:e,...n}=t;return(0,s.kt)(Oro,(0,p.Z)({},Ero,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Uro.isMDXComponent=!0;const Fro={toc:[]},Vro="wrapper";function qro(t){let{components:e,...n}=t;return(0,s.kt)(Vro,(0,p.Z)({},Fro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}qro.isMDXComponent=!0;const jro={toc:[]},Hro="wrapper";function Yro(t){let{components:e,...n}=t;return(0,s.kt)(Hro,(0,p.Z)({},jro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Yro.isMDXComponent=!0;const Qro={toc:[]},$ro="wrapper";function Kro(t){let{components:e,...n}=t;return(0,s.kt)($ro,(0,p.Z)({},Qro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Kro.isMDXComponent=!0;const Jro={toc:[]},tso="wrapper";function eso(t){let{components:e,...n}=t;return(0,s.kt)(tso,(0,p.Z)({},Jro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}eso.isMDXComponent=!0;const nso={toc:[]},oso="wrapper";function pso(t){let{components:e,...n}=t;return(0,s.kt)(oso,(0,p.Z)({},nso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}pso.isMDXComponent=!0;const rso={toc:[]},sso="wrapper";function cso(t){let{components:e,...n}=t;return(0,s.kt)(sso,(0,p.Z)({},rso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}cso.isMDXComponent=!0;const aso={toc:[]},iso="wrapper";function lso(t){let{components:e,...n}=t;return(0,s.kt)(iso,(0,p.Z)({},aso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lso.isMDXComponent=!0;const uso={toc:[]},mso="wrapper";function dso(t){let{components:e,...n}=t;return(0,s.kt)(mso,(0,p.Z)({},uso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dso.isMDXComponent=!0;const hso={toc:[]},fso="wrapper";function kso(t){let{components:e,...n}=t;return(0,s.kt)(fso,(0,p.Z)({},hso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kso.isMDXComponent=!0;const yso={toc:[]},Dso="wrapper";function Mso(t){let{components:e,...n}=t;return(0,s.kt)(Dso,(0,p.Z)({},yso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Mso.isMDXComponent=!0;const Xso={toc:[]},_so="wrapper";function wso(t){let{components:e,...n}=t;return(0,s.kt)(_so,(0,p.Z)({},Xso,n,{components:e,mdxType:"MDXLayout"}))}wso.isMDXComponent=!0;const Tso={toc:[]},Cso="wrapper";function gso(t){let{components:e,...n}=t;return(0,s.kt)(Cso,(0,p.Z)({},Tso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gso.isMDXComponent=!0;const xso={toc:[]},vso="wrapper";function Lso(t){let{components:e,...n}=t;return(0,s.kt)(vso,(0,p.Z)({},xso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Lso.isMDXComponent=!0;const Zso={toc:[]},bso="wrapper";function Nso(t){let{components:e,...n}=t;return(0,s.kt)(bso,(0,p.Z)({},Zso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Nso.isMDXComponent=!0;const zso={toc:[]},Aso="wrapper";function Pso(t){let{components:e,...n}=t;return(0,s.kt)(Aso,(0,p.Z)({},zso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Pso.isMDXComponent=!0;const Iso={toc:[]},Wso="wrapper";function Rso(t){let{components:e,...n}=t;return(0,s.kt)(Wso,(0,p.Z)({},Iso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Rso.isMDXComponent=!0;const Sso={toc:[]},Bso="wrapper";function Gso(t){let{components:e,...n}=t;return(0,s.kt)(Bso,(0,p.Z)({},Sso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Gso.isMDXComponent=!0;const Eso={toc:[]},Oso="wrapper";function Uso(t){let{components:e,...n}=t;return(0,s.kt)(Oso,(0,p.Z)({},Eso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Uso.isMDXComponent=!0;const Fso={toc:[]},Vso="wrapper";function qso(t){let{components:e,...n}=t;return(0,s.kt)(Vso,(0,p.Z)({},Fso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}qso.isMDXComponent=!0;const jso={toc:[]},Hso="wrapper";function Yso(t){let{components:e,...n}=t;return(0,s.kt)(Hso,(0,p.Z)({},jso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Yso.isMDXComponent=!0;const Qso={toc:[]},$so="wrapper";function Kso(t){let{components:e,...n}=t;return(0,s.kt)($so,(0,p.Z)({},Qso,n,{components:e,mdxType:"MDXLayout"}))}Kso.isMDXComponent=!0;const Jso={toc:[]},tco="wrapper";function eco(t){let{components:e,...n}=t;return(0,s.kt)(tco,(0,p.Z)({},Jso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}eco.isMDXComponent=!0;const nco={toc:[]},oco="wrapper";function pco(t){let{components:e,...n}=t;return(0,s.kt)(oco,(0,p.Z)({},nco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pco.isMDXComponent=!0;const rco={toc:[]},sco="wrapper";function cco(t){let{components:e,...n}=t;return(0,s.kt)(sco,(0,p.Z)({},rco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cco.isMDXComponent=!0;const aco={toc:[]},ico="wrapper";function lco(t){let{components:e,...n}=t;return(0,s.kt)(ico,(0,p.Z)({},aco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}lco.isMDXComponent=!0;const uco={toc:[]},mco="wrapper";function dco(t){let{components:e,...n}=t;return(0,s.kt)(mco,(0,p.Z)({},uco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}dco.isMDXComponent=!0;const hco={toc:[]},fco="wrapper";function kco(t){let{components:e,...n}=t;return(0,s.kt)(fco,(0,p.Z)({},hco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}kco.isMDXComponent=!0;const yco={toc:[]},Dco="wrapper";function Mco(t){let{components:e,...n}=t;return(0,s.kt)(Dco,(0,p.Z)({},yco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Mco.isMDXComponent=!0;const Xco={toc:[]},_co="wrapper";function wco(t){let{components:e,...n}=t;return(0,s.kt)(_co,(0,p.Z)({},Xco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wco.isMDXComponent=!0;const Tco={toc:[]},Cco="wrapper";function gco(t){let{components:e,...n}=t;return(0,s.kt)(Cco,(0,p.Z)({},Tco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}gco.isMDXComponent=!0;const xco={toc:[]},vco="wrapper";function Lco(t){let{components:e,...n}=t;return(0,s.kt)(vco,(0,p.Z)({},xco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lco.isMDXComponent=!0;const Zco={toc:[]},bco="wrapper";function Nco(t){let{components:e,...n}=t;return(0,s.kt)(bco,(0,p.Z)({},Zco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Nco.isMDXComponent=!0;const zco={toc:[]},Aco="wrapper";function Pco(t){let{components:e,...n}=t;return(0,s.kt)(Aco,(0,p.Z)({},zco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Pco.isMDXComponent=!0;const Ico={toc:[]},Wco="wrapper";function Rco(t){let{components:e,...n}=t;return(0,s.kt)(Wco,(0,p.Z)({},Ico,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Rco.isMDXComponent=!0;const Sco={toc:[]},Bco="wrapper";function Gco(t){let{components:e,...n}=t;return(0,s.kt)(Bco,(0,p.Z)({},Sco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Gco.isMDXComponent=!0;const Eco={toc:[]},Oco="wrapper";function Uco(t){let{components:e,...n}=t;return(0,s.kt)(Oco,(0,p.Z)({},Eco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Uco.isMDXComponent=!0;const Fco={toc:[]},Vco="wrapper";function qco(t){let{components:e,...n}=t;return(0,s.kt)(Vco,(0,p.Z)({},Fco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}qco.isMDXComponent=!0;const jco={toc:[]},Hco="wrapper";function Yco(t){let{components:e,...n}=t;return(0,s.kt)(Hco,(0,p.Z)({},jco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Yco.isMDXComponent=!0;const Qco={toc:[]},$co="wrapper";function Kco(t){let{components:e,...n}=t;return(0,s.kt)($co,(0,p.Z)({},Qco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Kco.isMDXComponent=!0;const Jco={toc:[]},tao="wrapper";function eao(t){let{components:e,...n}=t;return(0,s.kt)(tao,(0,p.Z)({},Jco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}eao.isMDXComponent=!0;const nao={toc:[]},oao="wrapper";function pao(t){let{components:e,...n}=t;return(0,s.kt)(oao,(0,p.Z)({},nao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}pao.isMDXComponent=!0;const rao={toc:[]},sao="wrapper";function cao(t){let{components:e,...n}=t;return(0,s.kt)(sao,(0,p.Z)({},rao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cao.isMDXComponent=!0;const aao={toc:[]},iao="wrapper";function lao(t){let{components:e,...n}=t;return(0,s.kt)(iao,(0,p.Z)({},aao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lao.isMDXComponent=!0;const uao={toc:[]},mao="wrapper";function dao(t){let{components:e,...n}=t;return(0,s.kt)(mao,(0,p.Z)({},uao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}dao.isMDXComponent=!0;const hao={toc:[]},fao="wrapper";function kao(t){let{components:e,...n}=t;return(0,s.kt)(fao,(0,p.Z)({},hao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}kao.isMDXComponent=!0;const yao={toc:[]},Dao="wrapper";function Mao(t){let{components:e,...n}=t;return(0,s.kt)(Dao,(0,p.Z)({},yao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Mao.isMDXComponent=!0;const Xao={toc:[]},_ao="wrapper";function wao(t){let{components:e,...n}=t;return(0,s.kt)(_ao,(0,p.Z)({},Xao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}wao.isMDXComponent=!0;const Tao={toc:[]},Cao="wrapper";function gao(t){let{components:e,...n}=t;return(0,s.kt)(Cao,(0,p.Z)({},Tao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}gao.isMDXComponent=!0;const xao={toc:[]},vao="wrapper";function Lao(t){let{components:e,...n}=t;return(0,s.kt)(vao,(0,p.Z)({},xao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Lao.isMDXComponent=!0;const Zao={toc:[]},bao="wrapper";function Nao(t){let{components:e,...n}=t;return(0,s.kt)(bao,(0,p.Z)({},Zao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}Nao.isMDXComponent=!0;const zao={toc:[]},Aao="wrapper";function Pao(t){let{components:e,...n}=t;return(0,s.kt)(Aao,(0,p.Z)({},zao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}Pao.isMDXComponent=!0;const Iao={toc:[]},Wao="wrapper";function Rao(t){let{components:e,...n}=t;return(0,s.kt)(Wao,(0,p.Z)({},Iao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Rao.isMDXComponent=!0;const Sao={toc:[]},Bao="wrapper";function Gao(t){let{components:e,...n}=t;return(0,s.kt)(Bao,(0,p.Z)({},Sao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Gao.isMDXComponent=!0;const Eao={toc:[]},Oao="wrapper";function Uao(t){let{components:e,...n}=t;return(0,s.kt)(Oao,(0,p.Z)({},Eao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Uao.isMDXComponent=!0;const Fao={toc:[]},Vao="wrapper";function qao(t){let{components:e,...n}=t;return(0,s.kt)(Vao,(0,p.Z)({},Fao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qao.isMDXComponent=!0;const jao={toc:[]},Hao="wrapper";function Yao(t){let{components:e,...n}=t;return(0,s.kt)(Hao,(0,p.Z)({},jao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Yao.isMDXComponent=!0;const Qao={toc:[]},$ao="wrapper";function Kao(t){let{components:e,...n}=t;return(0,s.kt)($ao,(0,p.Z)({},Qao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Kao.isMDXComponent=!0;const Jao={toc:[]},tio="wrapper";function eio(t){let{components:e,...n}=t;return(0,s.kt)(tio,(0,p.Z)({},Jao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}eio.isMDXComponent=!0;const nio={toc:[]},oio="wrapper";function pio(t){let{components:e,...n}=t;return(0,s.kt)(oio,(0,p.Z)({},nio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}pio.isMDXComponent=!0;const rio={toc:[]},sio="wrapper";function cio(t){let{components:e,...n}=t;return(0,s.kt)(sio,(0,p.Z)({},rio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}cio.isMDXComponent=!0;const aio={toc:[]},iio="wrapper";function lio(t){let{components:e,...n}=t;return(0,s.kt)(iio,(0,p.Z)({},aio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}lio.isMDXComponent=!0;const uio={toc:[]},mio="wrapper";function dio(t){let{components:e,...n}=t;return(0,s.kt)(mio,(0,p.Z)({},uio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}dio.isMDXComponent=!0;const hio={toc:[]},fio="wrapper";function kio(t){let{components:e,...n}=t;return(0,s.kt)(fio,(0,p.Z)({},hio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}kio.isMDXComponent=!0;const yio={toc:[]},Dio="wrapper";function Mio(t){let{components:e,...n}=t;return(0,s.kt)(Dio,(0,p.Z)({},yio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Mio.isMDXComponent=!0;const Xio={toc:[]},_io="wrapper";function wio(t){let{components:e,...n}=t;return(0,s.kt)(_io,(0,p.Z)({},Xio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}wio.isMDXComponent=!0;const Tio={toc:[]},Cio="wrapper";function gio(t){let{components:e,...n}=t;return(0,s.kt)(Cio,(0,p.Z)({},Tio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}gio.isMDXComponent=!0;const xio={toc:[]},vio="wrapper";function Lio(t){let{components:e,...n}=t;return(0,s.kt)(vio,(0,p.Z)({},xio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Lio.isMDXComponent=!0;const Zio={toc:[]},bio="wrapper";function Nio(t){let{components:e,...n}=t;return(0,s.kt)(bio,(0,p.Z)({},Zio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Nio.isMDXComponent=!0;const zio={toc:[]},Aio="wrapper";function Pio(t){let{components:e,...n}=t;return(0,s.kt)(Aio,(0,p.Z)({},zio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Pio.isMDXComponent=!0;const Iio={toc:[]},Wio="wrapper";function Rio(t){let{components:e,...n}=t;return(0,s.kt)(Wio,(0,p.Z)({},Iio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Rio.isMDXComponent=!0;const Sio={toc:[]},Bio="wrapper";function Gio(t){let{components:e,...n}=t;return(0,s.kt)(Bio,(0,p.Z)({},Sio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Gio.isMDXComponent=!0;const Eio={toc:[]},Oio="wrapper";function Uio(t){let{components:e,...n}=t;return(0,s.kt)(Oio,(0,p.Z)({},Eio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Uio.isMDXComponent=!0;const Fio={toc:[]},Vio="wrapper";function qio(t){let{components:e,...n}=t;return(0,s.kt)(Vio,(0,p.Z)({},Fio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}qio.isMDXComponent=!0;const jio={toc:[]},Hio="wrapper";function Yio(t){let{components:e,...n}=t;return(0,s.kt)(Hio,(0,p.Z)({},jio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Yio.isMDXComponent=!0;const Qio={toc:[]},$io="wrapper";function Kio(t){let{components:e,...n}=t;return(0,s.kt)($io,(0,p.Z)({},Qio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Kio.isMDXComponent=!0;const Jio={toc:[]},tlo="wrapper";function elo(t){let{components:e,...n}=t;return(0,s.kt)(tlo,(0,p.Z)({},Jio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}elo.isMDXComponent=!0;const nlo={toc:[]},olo="wrapper";function plo(t){let{components:e,...n}=t;return(0,s.kt)(olo,(0,p.Z)({},nlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}plo.isMDXComponent=!0;const rlo={toc:[]},slo="wrapper";function clo(t){let{components:e,...n}=t;return(0,s.kt)(slo,(0,p.Z)({},rlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}clo.isMDXComponent=!0;const alo={toc:[]},ilo="wrapper";function llo(t){let{components:e,...n}=t;return(0,s.kt)(ilo,(0,p.Z)({},alo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}llo.isMDXComponent=!0;const ulo={toc:[]},mlo="wrapper";function dlo(t){let{components:e,...n}=t;return(0,s.kt)(mlo,(0,p.Z)({},ulo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}dlo.isMDXComponent=!0;const hlo={toc:[]},flo="wrapper";function klo(t){let{components:e,...n}=t;return(0,s.kt)(flo,(0,p.Z)({},hlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}klo.isMDXComponent=!0;const ylo={toc:[]},Dlo="wrapper";function Mlo(t){let{components:e,...n}=t;return(0,s.kt)(Dlo,(0,p.Z)({},ylo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Mlo.isMDXComponent=!0;const Xlo={toc:[]},_lo="wrapper";function wlo(t){let{components:e,...n}=t;return(0,s.kt)(_lo,(0,p.Z)({},Xlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wlo.isMDXComponent=!0;const Tlo={toc:[]},Clo="wrapper";function glo(t){let{components:e,...n}=t;return(0,s.kt)(Clo,(0,p.Z)({},Tlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}glo.isMDXComponent=!0;const xlo={toc:[]},vlo="wrapper";function Llo(t){let{components:e,...n}=t;return(0,s.kt)(vlo,(0,p.Z)({},xlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Llo.isMDXComponent=!0;const Zlo={toc:[]},blo="wrapper";function Nlo(t){let{components:e,...n}=t;return(0,s.kt)(blo,(0,p.Z)({},Zlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Nlo.isMDXComponent=!0;const zlo={toc:[]},Alo="wrapper";function Plo(t){let{components:e,...n}=t;return(0,s.kt)(Alo,(0,p.Z)({},zlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Plo.isMDXComponent=!0;const Ilo={toc:[]},Wlo="wrapper";function Rlo(t){let{components:e,...n}=t;return(0,s.kt)(Wlo,(0,p.Z)({},Ilo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Rlo.isMDXComponent=!0;const Slo={toc:[]},Blo="wrapper";function Glo(t){let{components:e,...n}=t;return(0,s.kt)(Blo,(0,p.Z)({},Slo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Glo.isMDXComponent=!0;const Elo={toc:[]},Olo="wrapper";function Ulo(t){let{components:e,...n}=t;return(0,s.kt)(Olo,(0,p.Z)({},Elo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Ulo.isMDXComponent=!0;const Flo={toc:[]},Vlo="wrapper";function qlo(t){let{components:e,...n}=t;return(0,s.kt)(Vlo,(0,p.Z)({},Flo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qlo.isMDXComponent=!0;const jlo={toc:[]},Hlo="wrapper";function Ylo(t){let{components:e,...n}=t;return(0,s.kt)(Hlo,(0,p.Z)({},jlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Ylo.isMDXComponent=!0;const Qlo={toc:[]},$lo="wrapper";function Klo(t){let{components:e,...n}=t;return(0,s.kt)($lo,(0,p.Z)({},Qlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Klo.isMDXComponent=!0;const Jlo={toc:[]},tuo="wrapper";function euo(t){let{components:e,...n}=t;return(0,s.kt)(tuo,(0,p.Z)({},Jlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}euo.isMDXComponent=!0;const nuo={toc:[]},ouo="wrapper";function puo(t){let{components:e,...n}=t;return(0,s.kt)(ouo,(0,p.Z)({},nuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}puo.isMDXComponent=!0;const ruo={toc:[]},suo="wrapper";function cuo(t){let{components:e,...n}=t;return(0,s.kt)(suo,(0,p.Z)({},ruo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}cuo.isMDXComponent=!0;const auo={toc:[]},iuo="wrapper";function luo(t){let{components:e,...n}=t;return(0,s.kt)(iuo,(0,p.Z)({},auo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}luo.isMDXComponent=!0;const uuo={toc:[]},muo="wrapper";function duo(t){let{components:e,...n}=t;return(0,s.kt)(muo,(0,p.Z)({},uuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}duo.isMDXComponent=!0;const huo={toc:[]},fuo="wrapper";function kuo(t){let{components:e,...n}=t;return(0,s.kt)(fuo,(0,p.Z)({},huo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}kuo.isMDXComponent=!0;const yuo={toc:[]},Duo="wrapper";function Muo(t){let{components:e,...n}=t;return(0,s.kt)(Duo,(0,p.Z)({},yuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Muo.isMDXComponent=!0;const Xuo={toc:[]},_uo="wrapper";function wuo(t){let{components:e,...n}=t;return(0,s.kt)(_uo,(0,p.Z)({},Xuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wuo.isMDXComponent=!0;const Tuo={toc:[]},Cuo="wrapper";function guo(t){let{components:e,...n}=t;return(0,s.kt)(Cuo,(0,p.Z)({},Tuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}guo.isMDXComponent=!0;const xuo={toc:[]},vuo="wrapper";function Luo(t){let{components:e,...n}=t;return(0,s.kt)(vuo,(0,p.Z)({},xuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Luo.isMDXComponent=!0;const Zuo={toc:[]},buo="wrapper";function Nuo(t){let{components:e,...n}=t;return(0,s.kt)(buo,(0,p.Z)({},Zuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Nuo.isMDXComponent=!0;const zuo={toc:[]},Auo="wrapper";function Puo(t){let{components:e,...n}=t;return(0,s.kt)(Auo,(0,p.Z)({},zuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Puo.isMDXComponent=!0;const Iuo={toc:[]},Wuo="wrapper";function Ruo(t){let{components:e,...n}=t;return(0,s.kt)(Wuo,(0,p.Z)({},Iuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Ruo.isMDXComponent=!0;const Suo={toc:[]},Buo="wrapper";function Guo(t){let{components:e,...n}=t;return(0,s.kt)(Buo,(0,p.Z)({},Suo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Guo.isMDXComponent=!0;const Euo={toc:[]},Ouo="wrapper";function Uuo(t){let{components:e,...n}=t;return(0,s.kt)(Ouo,(0,p.Z)({},Euo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Uuo.isMDXComponent=!0;const Fuo={toc:[]},Vuo="wrapper";function quo(t){let{components:e,...n}=t;return(0,s.kt)(Vuo,(0,p.Z)({},Fuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}quo.isMDXComponent=!0;const juo={toc:[]},Huo="wrapper";function Yuo(t){let{components:e,...n}=t;return(0,s.kt)(Huo,(0,p.Z)({},juo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Yuo.isMDXComponent=!0;const Quo={toc:[]},$uo="wrapper";function Kuo(t){let{components:e,...n}=t;return(0,s.kt)($uo,(0,p.Z)({},Quo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Kuo.isMDXComponent=!0;const Juo={toc:[]},tmo="wrapper";function emo(t){let{components:e,...n}=t;return(0,s.kt)(tmo,(0,p.Z)({},Juo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}emo.isMDXComponent=!0;const nmo={toc:[]},omo="wrapper";function pmo(t){let{components:e,...n}=t;return(0,s.kt)(omo,(0,p.Z)({},nmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}pmo.isMDXComponent=!0;const rmo={toc:[]},smo="wrapper";function cmo(t){let{components:e,...n}=t;return(0,s.kt)(smo,(0,p.Z)({},rmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}cmo.isMDXComponent=!0;const amo={toc:[]},imo="wrapper";function lmo(t){let{components:e,...n}=t;return(0,s.kt)(imo,(0,p.Z)({},amo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lmo.isMDXComponent=!0;const umo={toc:[]},mmo="wrapper";function dmo(t){let{components:e,...n}=t;return(0,s.kt)(mmo,(0,p.Z)({},umo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}dmo.isMDXComponent=!0;const hmo={toc:[]},fmo="wrapper";function kmo(t){let{components:e,...n}=t;return(0,s.kt)(fmo,(0,p.Z)({},hmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}kmo.isMDXComponent=!0;const ymo={toc:[]},Dmo="wrapper";function Mmo(t){let{components:e,...n}=t;return(0,s.kt)(Dmo,(0,p.Z)({},ymo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mmo.isMDXComponent=!0;const Xmo={toc:[]},_mo="wrapper";function wmo(t){let{components:e,...n}=t;return(0,s.kt)(_mo,(0,p.Z)({},Xmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wmo.isMDXComponent=!0;const Tmo={toc:[]},Cmo="wrapper";function gmo(t){let{components:e,...n}=t;return(0,s.kt)(Cmo,(0,p.Z)({},Tmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}gmo.isMDXComponent=!0;const xmo={toc:[]},vmo="wrapper";function Lmo(t){let{components:e,...n}=t;return(0,s.kt)(vmo,(0,p.Z)({},xmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Lmo.isMDXComponent=!0;const Zmo={toc:[]},bmo="wrapper";function Nmo(t){let{components:e,...n}=t;return(0,s.kt)(bmo,(0,p.Z)({},Zmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Nmo.isMDXComponent=!0;const zmo={toc:[]},Amo="wrapper";function Pmo(t){let{components:e,...n}=t;return(0,s.kt)(Amo,(0,p.Z)({},zmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Pmo.isMDXComponent=!0;const Imo={toc:[]},Wmo="wrapper";function Rmo(t){let{components:e,...n}=t;return(0,s.kt)(Wmo,(0,p.Z)({},Imo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Rmo.isMDXComponent=!0;const Smo={toc:[]},Bmo="wrapper";function Gmo(t){let{components:e,...n}=t;return(0,s.kt)(Bmo,(0,p.Z)({},Smo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Gmo.isMDXComponent=!0;const Emo={toc:[]},Omo="wrapper";function Umo(t){let{components:e,...n}=t;return(0,s.kt)(Omo,(0,p.Z)({},Emo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Umo.isMDXComponent=!0;const Fmo={toc:[]},Vmo="wrapper";function qmo(t){let{components:e,...n}=t;return(0,s.kt)(Vmo,(0,p.Z)({},Fmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}qmo.isMDXComponent=!0;const jmo={toc:[]},Hmo="wrapper";function Ymo(t){let{components:e,...n}=t;return(0,s.kt)(Hmo,(0,p.Z)({},jmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Ymo.isMDXComponent=!0;const Qmo={toc:[]},$mo="wrapper";function Kmo(t){let{components:e,...n}=t;return(0,s.kt)($mo,(0,p.Z)({},Qmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Kmo.isMDXComponent=!0;const Jmo={toc:[]},tdo="wrapper";function edo(t){let{components:e,...n}=t;return(0,s.kt)(tdo,(0,p.Z)({},Jmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}edo.isMDXComponent=!0;const ndo={toc:[]},odo="wrapper";function pdo(t){let{components:e,...n}=t;return(0,s.kt)(odo,(0,p.Z)({},ndo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pdo.isMDXComponent=!0;const rdo={toc:[]},sdo="wrapper";function cdo(t){let{components:e,...n}=t;return(0,s.kt)(sdo,(0,p.Z)({},rdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}cdo.isMDXComponent=!0;const ado={toc:[]},ido="wrapper";function ldo(t){let{components:e,...n}=t;return(0,s.kt)(ido,(0,p.Z)({},ado,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ldo.isMDXComponent=!0;const udo={toc:[]},mdo="wrapper";function ddo(t){let{components:e,...n}=t;return(0,s.kt)(mdo,(0,p.Z)({},udo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}ddo.isMDXComponent=!0;const hdo={toc:[]},fdo="wrapper";function kdo(t){let{components:e,...n}=t;return(0,s.kt)(fdo,(0,p.Z)({},hdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kdo.isMDXComponent=!0;const ydo={toc:[]},Ddo="wrapper";function Mdo(t){let{components:e,...n}=t;return(0,s.kt)(Ddo,(0,p.Z)({},ydo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Mdo.isMDXComponent=!0;const Xdo={toc:[]},_do="wrapper";function wdo(t){let{components:e,...n}=t;return(0,s.kt)(_do,(0,p.Z)({},Xdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wdo.isMDXComponent=!0;const Tdo={toc:[]},Cdo="wrapper";function gdo(t){let{components:e,...n}=t;return(0,s.kt)(Cdo,(0,p.Z)({},Tdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}gdo.isMDXComponent=!0;const xdo={toc:[]},vdo="wrapper";function Ldo(t){let{components:e,...n}=t;return(0,s.kt)(vdo,(0,p.Z)({},xdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Ldo.isMDXComponent=!0;const Zdo={toc:[]},bdo="wrapper";function Ndo(t){let{components:e,...n}=t;return(0,s.kt)(bdo,(0,p.Z)({},Zdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}Ndo.isMDXComponent=!0;const zdo={toc:[]},Ado="wrapper";function Pdo(t){let{components:e,...n}=t;return(0,s.kt)(Ado,(0,p.Z)({},zdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}Pdo.isMDXComponent=!0;const Ido={toc:[]},Wdo="wrapper";function Rdo(t){let{components:e,...n}=t;return(0,s.kt)(Wdo,(0,p.Z)({},Ido,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Rdo.isMDXComponent=!0;const Sdo={toc:[]},Bdo="wrapper";function Gdo(t){let{components:e,...n}=t;return(0,s.kt)(Bdo,(0,p.Z)({},Sdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Gdo.isMDXComponent=!0;const Edo={toc:[]},Odo="wrapper";function Udo(t){let{components:e,...n}=t;return(0,s.kt)(Odo,(0,p.Z)({},Edo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Udo.isMDXComponent=!0;const Fdo={toc:[]},Vdo="wrapper";function qdo(t){let{components:e,...n}=t;return(0,s.kt)(Vdo,(0,p.Z)({},Fdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}qdo.isMDXComponent=!0;const jdo={toc:[]},Hdo="wrapper";function Ydo(t){let{components:e,...n}=t;return(0,s.kt)(Hdo,(0,p.Z)({},jdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Ydo.isMDXComponent=!0;const Qdo={toc:[]},$do="wrapper";function Kdo(t){let{components:e,...n}=t;return(0,s.kt)($do,(0,p.Z)({},Qdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Kdo.isMDXComponent=!0;const Jdo={toc:[]},tho="wrapper";function eho(t){let{components:e,...n}=t;return(0,s.kt)(tho,(0,p.Z)({},Jdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}eho.isMDXComponent=!0;const nho={toc:[]},oho="wrapper";function pho(t){let{components:e,...n}=t;return(0,s.kt)(oho,(0,p.Z)({},nho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}pho.isMDXComponent=!0;const rho={toc:[]},sho="wrapper";function cho(t){let{components:e,...n}=t;return(0,s.kt)(sho,(0,p.Z)({},rho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}cho.isMDXComponent=!0;const aho={toc:[]},iho="wrapper";function lho(t){let{components:e,...n}=t;return(0,s.kt)(iho,(0,p.Z)({},aho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lho.isMDXComponent=!0;const uho={toc:[]},mho="wrapper";function dho(t){let{components:e,...n}=t;return(0,s.kt)(mho,(0,p.Z)({},uho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}dho.isMDXComponent=!0;const hho={toc:[]},fho="wrapper";function kho(t){let{components:e,...n}=t;return(0,s.kt)(fho,(0,p.Z)({},hho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}kho.isMDXComponent=!0;const yho={toc:[]},Dho="wrapper";function Mho(t){let{components:e,...n}=t;return(0,s.kt)(Dho,(0,p.Z)({},yho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Mho.isMDXComponent=!0;const Xho={toc:[]},_ho="wrapper";function who(t){let{components:e,...n}=t;return(0,s.kt)(_ho,(0,p.Z)({},Xho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}who.isMDXComponent=!0;const Tho={toc:[]},Cho="wrapper";function gho(t){let{components:e,...n}=t;return(0,s.kt)(Cho,(0,p.Z)({},Tho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}gho.isMDXComponent=!0;const xho={toc:[]},vho="wrapper";function Lho(t){let{components:e,...n}=t;return(0,s.kt)(vho,(0,p.Z)({},xho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Lho.isMDXComponent=!0;const Zho={toc:[]},bho="wrapper";function Nho(t){let{components:e,...n}=t;return(0,s.kt)(bho,(0,p.Z)({},Zho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Nho.isMDXComponent=!0;const zho={toc:[]},Aho="wrapper";function Pho(t){let{components:e,...n}=t;return(0,s.kt)(Aho,(0,p.Z)({},zho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Pho.isMDXComponent=!0;const Iho={toc:[]},Who="wrapper";function Rho(t){let{components:e,...n}=t;return(0,s.kt)(Who,(0,p.Z)({},Iho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Rho.isMDXComponent=!0;const Sho={toc:[]},Bho="wrapper";function Gho(t){let{components:e,...n}=t;return(0,s.kt)(Bho,(0,p.Z)({},Sho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Gho.isMDXComponent=!0;const Eho={toc:[]},Oho="wrapper";function Uho(t){let{components:e,...n}=t;return(0,s.kt)(Oho,(0,p.Z)({},Eho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Uho.isMDXComponent=!0;const Fho={toc:[]},Vho="wrapper";function qho(t){let{components:e,...n}=t;return(0,s.kt)(Vho,(0,p.Z)({},Fho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}qho.isMDXComponent=!0;const jho={toc:[]},Hho="wrapper";function Yho(t){let{components:e,...n}=t;return(0,s.kt)(Hho,(0,p.Z)({},jho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Yho.isMDXComponent=!0;const Qho={toc:[]},$ho="wrapper";function Kho(t){let{components:e,...n}=t;return(0,s.kt)($ho,(0,p.Z)({},Qho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Kho.isMDXComponent=!0;const Jho={toc:[]},tfo="wrapper";function efo(t){let{components:e,...n}=t;return(0,s.kt)(tfo,(0,p.Z)({},Jho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}efo.isMDXComponent=!0;const nfo={toc:[]},ofo="wrapper";function pfo(t){let{components:e,...n}=t;return(0,s.kt)(ofo,(0,p.Z)({},nfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}pfo.isMDXComponent=!0;const rfo={toc:[]},sfo="wrapper";function cfo(t){let{components:e,...n}=t;return(0,s.kt)(sfo,(0,p.Z)({},rfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}cfo.isMDXComponent=!0;const afo={toc:[]},ifo="wrapper";function lfo(t){let{components:e,...n}=t;return(0,s.kt)(ifo,(0,p.Z)({},afo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}lfo.isMDXComponent=!0;const ufo={toc:[]},mfo="wrapper";function dfo(t){let{components:e,...n}=t;return(0,s.kt)(mfo,(0,p.Z)({},ufo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}dfo.isMDXComponent=!0;const hfo={toc:[]},ffo="wrapper";function kfo(t){let{components:e,...n}=t;return(0,s.kt)(ffo,(0,p.Z)({},hfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kfo.isMDXComponent=!0;const yfo={toc:[]},Dfo="wrapper";function Mfo(t){let{components:e,...n}=t;return(0,s.kt)(Dfo,(0,p.Z)({},yfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Mfo.isMDXComponent=!0;const Xfo={toc:[]},_fo="wrapper";function wfo(t){let{components:e,...n}=t;return(0,s.kt)(_fo,(0,p.Z)({},Xfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}wfo.isMDXComponent=!0;const Tfo={toc:[]},Cfo="wrapper";function gfo(t){let{components:e,...n}=t;return(0,s.kt)(Cfo,(0,p.Z)({},Tfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}gfo.isMDXComponent=!0;const xfo={toc:[]},vfo="wrapper";function Lfo(t){let{components:e,...n}=t;return(0,s.kt)(vfo,(0,p.Z)({},xfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Lfo.isMDXComponent=!0;const Zfo={toc:[]},bfo="wrapper";function Nfo(t){let{components:e,...n}=t;return(0,s.kt)(bfo,(0,p.Z)({},Zfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Nfo.isMDXComponent=!0;const zfo={toc:[]},Afo="wrapper";function Pfo(t){let{components:e,...n}=t;return(0,s.kt)(Afo,(0,p.Z)({},zfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Pfo.isMDXComponent=!0;const Ifo={toc:[]},Wfo="wrapper";function Rfo(t){let{components:e,...n}=t;return(0,s.kt)(Wfo,(0,p.Z)({},Ifo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Rfo.isMDXComponent=!0;const Sfo={toc:[]},Bfo="wrapper";function Gfo(t){let{components:e,...n}=t;return(0,s.kt)(Bfo,(0,p.Z)({},Sfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Gfo.isMDXComponent=!0;const Efo={toc:[]},Ofo="wrapper";function Ufo(t){let{components:e,...n}=t;return(0,s.kt)(Ofo,(0,p.Z)({},Efo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Ufo.isMDXComponent=!0;const Ffo={toc:[]},Vfo="wrapper";function qfo(t){let{components:e,...n}=t;return(0,s.kt)(Vfo,(0,p.Z)({},Ffo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}qfo.isMDXComponent=!0;const jfo={toc:[]},Hfo="wrapper";function Yfo(t){let{components:e,...n}=t;return(0,s.kt)(Hfo,(0,p.Z)({},jfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Yfo.isMDXComponent=!0;const Qfo={toc:[]},$fo="wrapper";function Kfo(t){let{components:e,...n}=t;return(0,s.kt)($fo,(0,p.Z)({},Qfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Kfo.isMDXComponent=!0;const Jfo={toc:[]},tko="wrapper";function eko(t){let{components:e,...n}=t;return(0,s.kt)(tko,(0,p.Z)({},Jfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}eko.isMDXComponent=!0;const nko={toc:[]},oko="wrapper";function pko(t){let{components:e,...n}=t;return(0,s.kt)(oko,(0,p.Z)({},nko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pko.isMDXComponent=!0;const rko={toc:[]},sko="wrapper";function cko(t){let{components:e,...n}=t;return(0,s.kt)(sko,(0,p.Z)({},rko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}cko.isMDXComponent=!0;const ako={toc:[]},iko="wrapper";function lko(t){let{components:e,...n}=t;return(0,s.kt)(iko,(0,p.Z)({},ako,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}lko.isMDXComponent=!0;const uko={toc:[]},mko="wrapper";function dko(t){let{components:e,...n}=t;return(0,s.kt)(mko,(0,p.Z)({},uko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}dko.isMDXComponent=!0;const hko={toc:[]},fko="wrapper";function kko(t){let{components:e,...n}=t;return(0,s.kt)(fko,(0,p.Z)({},hko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kko.isMDXComponent=!0;const yko={toc:[]},Dko="wrapper";function Mko(t){let{components:e,...n}=t;return(0,s.kt)(Dko,(0,p.Z)({},yko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Mko.isMDXComponent=!0;const Xko={toc:[]},_ko="wrapper";function wko(t){let{components:e,...n}=t;return(0,s.kt)(_ko,(0,p.Z)({},Xko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}wko.isMDXComponent=!0;const Tko={toc:[]},Cko="wrapper";function gko(t){let{components:e,...n}=t;return(0,s.kt)(Cko,(0,p.Z)({},Tko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}gko.isMDXComponent=!0;const xko={toc:[]},vko="wrapper";function Lko(t){let{components:e,...n}=t;return(0,s.kt)(vko,(0,p.Z)({},xko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Lko.isMDXComponent=!0;const Zko={toc:[]},bko="wrapper";function Nko(t){let{components:e,...n}=t;return(0,s.kt)(bko,(0,p.Z)({},Zko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you're not interested in animating SVG, you can use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,s.kt)("inlineCode",{parentName:"a"},"Img"))," instead."))}Nko.isMDXComponent=!0;const zko={toc:[]},Ako="wrapper";function Pko(t){let{components:e,...n}=t;return(0,s.kt)(Ako,(0,p.Z)({},zko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A Node for drawing and animating SVG images."))}Pko.isMDXComponent=!0;const Iko={toc:[]},Wko="wrapper";function Rko(t){let{components:e,...n}=t;return(0,s.kt)(Wko,(0,p.Z)({},Iko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Rko.isMDXComponent=!0;const Sko={toc:[]},Bko="wrapper";function Gko(t){let{components:e,...n}=t;return(0,s.kt)(Bko,(0,p.Z)({},Sko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Gko.isMDXComponent=!0;const Eko={toc:[]},Oko="wrapper";function Uko(t){let{components:e,...n}=t;return(0,s.kt)(Oko,(0,p.Z)({},Eko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Uko.isMDXComponent=!0;const Fko={toc:[]},Vko="wrapper";function qko(t){let{components:e,...n}=t;return(0,s.kt)(Vko,(0,p.Z)({},Fko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}qko.isMDXComponent=!0;const jko={toc:[]},Hko="wrapper";function Yko(t){let{components:e,...n}=t;return(0,s.kt)(Hko,(0,p.Z)({},jko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Yko.isMDXComponent=!0;const Qko={toc:[]},$ko="wrapper";function Kko(t){let{components:e,...n}=t;return(0,s.kt)($ko,(0,p.Z)({},Qko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Kko.isMDXComponent=!0;const Jko={toc:[]},tyo="wrapper";function eyo(t){let{components:e,...n}=t;return(0,s.kt)(tyo,(0,p.Z)({},Jko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}eyo.isMDXComponent=!0;const nyo={toc:[]},oyo="wrapper";function pyo(t){let{components:e,...n}=t;return(0,s.kt)(oyo,(0,p.Z)({},nyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pyo.isMDXComponent=!0;const ryo={toc:[]},syo="wrapper";function cyo(t){let{components:e,...n}=t;return(0,s.kt)(syo,(0,p.Z)({},ryo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cyo.isMDXComponent=!0;const ayo={toc:[]},iyo="wrapper";function lyo(t){let{components:e,...n}=t;return(0,s.kt)(iyo,(0,p.Z)({},ayo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lyo.isMDXComponent=!0;const uyo={toc:[]},myo="wrapper";function dyo(t){let{components:e,...n}=t;return(0,s.kt)(myo,(0,p.Z)({},uyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}dyo.isMDXComponent=!0;const hyo={toc:[]},fyo="wrapper";function kyo(t){let{components:e,...n}=t;return(0,s.kt)(fyo,(0,p.Z)({},hyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kyo.isMDXComponent=!0;const yyo={toc:[]},Dyo="wrapper";function Myo(t){let{components:e,...n}=t;return(0,s.kt)(Dyo,(0,p.Z)({},yyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Myo.isMDXComponent=!0;const Xyo={toc:[]},_yo="wrapper";function wyo(t){let{components:e,...n}=t;return(0,s.kt)(_yo,(0,p.Z)({},Xyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wyo.isMDXComponent=!0;const Tyo={toc:[]},Cyo="wrapper";function gyo(t){let{components:e,...n}=t;return(0,s.kt)(Cyo,(0,p.Z)({},Tyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}gyo.isMDXComponent=!0;const xyo={toc:[]},vyo="wrapper";function Lyo(t){let{components:e,...n}=t;return(0,s.kt)(vyo,(0,p.Z)({},xyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Lyo.isMDXComponent=!0;const Zyo={toc:[]},byo="wrapper";function Nyo(t){let{components:e,...n}=t;return(0,s.kt)(byo,(0,p.Z)({},Zyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Nyo.isMDXComponent=!0;const zyo={toc:[]},Ayo="wrapper";function Pyo(t){let{components:e,...n}=t;return(0,s.kt)(Ayo,(0,p.Z)({},zyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Pyo.isMDXComponent=!0;const Iyo={toc:[]},Wyo="wrapper";function Ryo(t){let{components:e,...n}=t;return(0,s.kt)(Wyo,(0,p.Z)({},Iyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ryo.isMDXComponent=!0;const Syo={toc:[]},Byo="wrapper";function Gyo(t){let{components:e,...n}=t;return(0,s.kt)(Byo,(0,p.Z)({},Syo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Gyo.isMDXComponent=!0;const Eyo={toc:[]},Oyo="wrapper";function Uyo(t){let{components:e,...n}=t;return(0,s.kt)(Oyo,(0,p.Z)({},Eyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Uyo.isMDXComponent=!0;const Fyo={toc:[]},Vyo="wrapper";function qyo(t){let{components:e,...n}=t;return(0,s.kt)(Vyo,(0,p.Z)({},Fyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}qyo.isMDXComponent=!0;const jyo={toc:[]},Hyo="wrapper";function Yyo(t){let{components:e,...n}=t;return(0,s.kt)(Hyo,(0,p.Z)({},jyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Yyo.isMDXComponent=!0;const Qyo={toc:[]},$yo="wrapper";function Kyo(t){let{components:e,...n}=t;return(0,s.kt)($yo,(0,p.Z)({},Qyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Kyo.isMDXComponent=!0;const Jyo={toc:[]},tDo="wrapper";function eDo(t){let{components:e,...n}=t;return(0,s.kt)(tDo,(0,p.Z)({},Jyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eDo.isMDXComponent=!0;const nDo={toc:[]},oDo="wrapper";function pDo(t){let{components:e,...n}=t;return(0,s.kt)(oDo,(0,p.Z)({},nDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pDo.isMDXComponent=!0;const rDo={toc:[]},sDo="wrapper";function cDo(t){let{components:e,...n}=t;return(0,s.kt)(sDo,(0,p.Z)({},rDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cDo.isMDXComponent=!0;const aDo={toc:[]},iDo="wrapper";function lDo(t){let{components:e,...n}=t;return(0,s.kt)(iDo,(0,p.Z)({},aDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lDo.isMDXComponent=!0;const uDo={toc:[]},mDo="wrapper";function dDo(t){let{components:e,...n}=t;return(0,s.kt)(mDo,(0,p.Z)({},uDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}dDo.isMDXComponent=!0;const hDo={toc:[]},fDo="wrapper";function kDo(t){let{components:e,...n}=t;return(0,s.kt)(fDo,(0,p.Z)({},hDo,n,{components:e,mdxType:"MDXLayout"}))}kDo.isMDXComponent=!0;const yDo={toc:[]},DDo="wrapper";function MDo(t){let{components:e,...n}=t;return(0,s.kt)(DDo,(0,p.Z)({},yDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}MDo.isMDXComponent=!0;const XDo={toc:[]},_Do="wrapper";function wDo(t){let{components:e,...n}=t;return(0,s.kt)(_Do,(0,p.Z)({},XDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wDo.isMDXComponent=!0;const TDo={toc:[]},CDo="wrapper";function gDo(t){let{components:e,...n}=t;return(0,s.kt)(CDo,(0,p.Z)({},TDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}gDo.isMDXComponent=!0;const xDo={toc:[]},vDo="wrapper";function LDo(t){let{components:e,...n}=t;return(0,s.kt)(vDo,(0,p.Z)({},xDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}LDo.isMDXComponent=!0;const ZDo={toc:[]},bDo="wrapper";function NDo(t){let{components:e,...n}=t;return(0,s.kt)(bDo,(0,p.Z)({},ZDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}NDo.isMDXComponent=!0;const zDo={toc:[]},ADo="wrapper";function PDo(t){let{components:e,...n}=t;return(0,s.kt)(ADo,(0,p.Z)({},zDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}PDo.isMDXComponent=!0;const IDo={toc:[]},WDo="wrapper";function RDo(t){let{components:e,...n}=t;return(0,s.kt)(WDo,(0,p.Z)({},IDo,n,{components:e,mdxType:"MDXLayout"}))}RDo.isMDXComponent=!0;const SDo={toc:[]},BDo="wrapper";function GDo(t){let{components:e,...n}=t;return(0,s.kt)(BDo,(0,p.Z)({},SDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"SVG string to be rendered"))}GDo.isMDXComponent=!0;const EDo={toc:[]},ODo="wrapper";function UDo(t){let{components:e,...n}=t;return(0,s.kt)(ODo,(0,p.Z)({},EDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}UDo.isMDXComponent=!0;const FDo={toc:[]},VDo="wrapper";function qDo(t){let{components:e,...n}=t;return(0,s.kt)(VDo,(0,p.Z)({},FDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}qDo.isMDXComponent=!0;const jDo={toc:[]},HDo="wrapper";function YDo(t){let{components:e,...n}=t;return(0,s.kt)(HDo,(0,p.Z)({},jDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}YDo.isMDXComponent=!0;const QDo={toc:[]},$Do="wrapper";function KDo(t){let{components:e,...n}=t;return(0,s.kt)($Do,(0,p.Z)({},QDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}KDo.isMDXComponent=!0;const JDo={toc:[]},tMo="wrapper";function eMo(t){let{components:e,...n}=t;return(0,s.kt)(tMo,(0,p.Z)({},JDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}eMo.isMDXComponent=!0;const nMo={toc:[]},oMo="wrapper";function pMo(t){let{components:e,...n}=t;return(0,s.kt)(oMo,(0,p.Z)({},nMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pMo.isMDXComponent=!0;const rMo={toc:[]},sMo="wrapper";function cMo(t){let{components:e,...n}=t;return(0,s.kt)(sMo,(0,p.Z)({},rMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Child to wrap all SVG node"))}cMo.isMDXComponent=!0;const aMo={toc:[]},iMo="wrapper";function lMo(t){let{components:e,...n}=t;return(0,s.kt)(iMo,(0,p.Z)({},aMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}lMo.isMDXComponent=!0;const uMo={toc:[]},mMo="wrapper";function dMo(t){let{components:e,...n}=t;return(0,s.kt)(mMo,(0,p.Z)({},uMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}dMo.isMDXComponent=!0;const hMo={toc:[]},fMo="wrapper";function kMo(t){let{components:e,...n}=t;return(0,s.kt)(fMo,(0,p.Z)({},hMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}kMo.isMDXComponent=!0;const yMo={toc:[]},DMo="wrapper";function MMo(t){let{components:e,...n}=t;return(0,s.kt)(DMo,(0,p.Z)({},yMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}MMo.isMDXComponent=!0;const XMo={toc:[]},_Mo="wrapper";function wMo(t){let{components:e,...n}=t;return(0,s.kt)(_Mo,(0,p.Z)({},XMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wMo.isMDXComponent=!0;const TMo={toc:[]},CMo="wrapper";function gMo(t){let{components:e,...n}=t;return(0,s.kt)(CMo,(0,p.Z)({},TMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}gMo.isMDXComponent=!0;const xMo={toc:[]},vMo="wrapper";function LMo(t){let{components:e,...n}=t;return(0,s.kt)(vMo,(0,p.Z)({},xMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}LMo.isMDXComponent=!0;const ZMo={toc:[]},bMo="wrapper";function NMo(t){let{components:e,...n}=t;return(0,s.kt)(bMo,(0,p.Z)({},ZMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}NMo.isMDXComponent=!0;const zMo={toc:[]},AMo="wrapper";function PMo(t){let{components:e,...n}=t;return(0,s.kt)(AMo,(0,p.Z)({},zMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}PMo.isMDXComponent=!0;const IMo={toc:[]},WMo="wrapper";function RMo(t){let{components:e,...n}=t;return(0,s.kt)(WMo,(0,p.Z)({},IMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}RMo.isMDXComponent=!0;const SMo={toc:[]},BMo="wrapper";function GMo(t){let{components:e,...n}=t;return(0,s.kt)(BMo,(0,p.Z)({},SMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}GMo.isMDXComponent=!0;const EMo={toc:[]},OMo="wrapper";function UMo(t){let{components:e,...n}=t;return(0,s.kt)(OMo,(0,p.Z)({},EMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to convert."))}UMo.isMDXComponent=!0;const FMo={toc:[]},VMo="wrapper";function qMo(t){let{components:e,...n}=t;return(0,s.kt)(VMo,(0,p.Z)({},FMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShape"),"."))}qMo.isMDXComponent=!0;const jMo={toc:[]},HMo="wrapper";function YMo(t){let{components:e,...n}=t;return(0,s.kt)(HMo,(0,p.Z)({},jMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to convert."))}YMo.isMDXComponent=!0;const QMo={toc:[]},$Mo="wrapper";function KMo(t){let{components:e,...n}=t;return(0,s.kt)($Mo,(0,p.Z)({},QMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}KMo.isMDXComponent=!0;const JMo={toc:[]},tXo="wrapper";function eXo(t){let{components:e,...n}=t;return(0,s.kt)(tXo,(0,p.Z)({},JMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}eXo.isMDXComponent=!0;const nXo={toc:[]},oXo="wrapper";function pXo(t){let{components:e,...n}=t;return(0,s.kt)(oXo,(0,p.Z)({},nXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}pXo.isMDXComponent=!0;const rXo={toc:[]},sXo="wrapper";function cXo(t){let{components:e,...n}=t;return(0,s.kt)(sXo,(0,p.Z)({},rXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}cXo.isMDXComponent=!0;const aXo={toc:[]},iXo="wrapper";function lXo(t){let{components:e,...n}=t;return(0,s.kt)(iXo,(0,p.Z)({},aXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}lXo.isMDXComponent=!0;const uXo={toc:[]},mXo="wrapper";function dXo(t){let{components:e,...n}=t;return(0,s.kt)(mXo,(0,p.Z)({},uXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}dXo.isMDXComponent=!0;const hXo={toc:[]},fXo="wrapper";function kXo(t){let{components:e,...n}=t;return(0,s.kt)(fXo,(0,p.Z)({},hXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}kXo.isMDXComponent=!0;const yXo={toc:[]},DXo="wrapper";function MXo(t){let{components:e,...n}=t;return(0,s.kt)(DXo,(0,p.Z)({},yXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}MXo.isMDXComponent=!0;const XXo={toc:[]},_Xo="wrapper";function wXo(t){let{components:e,...n}=t;return(0,s.kt)(_Xo,(0,p.Z)({},XXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wXo.isMDXComponent=!0;const TXo={toc:[]},CXo="wrapper";function gXo(t){let{components:e,...n}=t;return(0,s.kt)(CXo,(0,p.Z)({},TXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}gXo.isMDXComponent=!0;const xXo={toc:[]},vXo="wrapper";function LXo(t){let{components:e,...n}=t;return(0,s.kt)(vXo,(0,p.Z)({},xXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}LXo.isMDXComponent=!0;const ZXo={toc:[]},bXo="wrapper";function NXo(t){let{components:e,...n}=t;return(0,s.kt)(bXo,(0,p.Z)({},ZXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}NXo.isMDXComponent=!0;const zXo={toc:[]},AXo="wrapper";function PXo(t){let{components:e,...n}=t;return(0,s.kt)(AXo,(0,p.Z)({},zXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}PXo.isMDXComponent=!0;const IXo={toc:[]},WXo="wrapper";function RXo(t){let{components:e,...n}=t;return(0,s.kt)(WXo,(0,p.Z)({},IXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}RXo.isMDXComponent=!0;const SXo={toc:[]},BXo="wrapper";function GXo(t){let{components:e,...n}=t;return(0,s.kt)(BXo,(0,p.Z)({},SXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}GXo.isMDXComponent=!0;const EXo={toc:[]},OXo="wrapper";function UXo(t){let{components:e,...n}=t;return(0,s.kt)(OXo,(0,p.Z)({},EXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}UXo.isMDXComponent=!0;const FXo={toc:[]},VXo="wrapper";function qXo(t){let{components:e,...n}=t;return(0,s.kt)(VXo,(0,p.Z)({},FXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qXo.isMDXComponent=!0;const jXo={toc:[]},HXo="wrapper";function YXo(t){let{components:e,...n}=t;return(0,s.kt)(HXo,(0,p.Z)({},jXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}YXo.isMDXComponent=!0;const QXo={toc:[]},$Xo="wrapper";function KXo(t){let{components:e,...n}=t;return(0,s.kt)($Xo,(0,p.Z)({},QXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}KXo.isMDXComponent=!0;const JXo={toc:[]},t_o="wrapper";function e_o(t){let{components:e,...n}=t;return(0,s.kt)(t_o,(0,p.Z)({},JXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}e_o.isMDXComponent=!0;const n_o={toc:[]},o_o="wrapper";function p_o(t){let{components:e,...n}=t;return(0,s.kt)(o_o,(0,p.Z)({},n_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}p_o.isMDXComponent=!0;const r_o={toc:[]},s_o="wrapper";function c_o(t){let{components:e,...n}=t;return(0,s.kt)(s_o,(0,p.Z)({},r_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}c_o.isMDXComponent=!0;const a_o={toc:[]},i_o="wrapper";function l_o(t){let{components:e,...n}=t;return(0,s.kt)(i_o,(0,p.Z)({},a_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}l_o.isMDXComponent=!0;const u_o={toc:[]},m_o="wrapper";function d_o(t){let{components:e,...n}=t;return(0,s.kt)(m_o,(0,p.Z)({},u_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}d_o.isMDXComponent=!0;const h_o={toc:[]},f_o="wrapper";function k_o(t){let{components:e,...n}=t;return(0,s.kt)(f_o,(0,p.Z)({},h_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}k_o.isMDXComponent=!0;const y_o={toc:[]},D_o="wrapper";function M_o(t){let{components:e,...n}=t;return(0,s.kt)(D_o,(0,p.Z)({},y_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}M_o.isMDXComponent=!0;const X_o={toc:[]},__o="wrapper";function w_o(t){let{components:e,...n}=t;return(0,s.kt)(__o,(0,p.Z)({},X_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}w_o.isMDXComponent=!0;const T_o={toc:[]},C_o="wrapper";function g_o(t){let{components:e,...n}=t;return(0,s.kt)(C_o,(0,p.Z)({},T_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}g_o.isMDXComponent=!0;const x_o={toc:[]},v_o="wrapper";function L_o(t){let{components:e,...n}=t;return(0,s.kt)(v_o,(0,p.Z)({},x_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}L_o.isMDXComponent=!0;const Z_o={toc:[]},b_o="wrapper";function N_o(t){let{components:e,...n}=t;return(0,s.kt)(b_o,(0,p.Z)({},Z_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}N_o.isMDXComponent=!0;const z_o={toc:[]},A_o="wrapper";function P_o(t){let{components:e,...n}=t;return(0,s.kt)(A_o,(0,p.Z)({},z_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}P_o.isMDXComponent=!0;const I_o={toc:[]},W_o="wrapper";function R_o(t){let{components:e,...n}=t;return(0,s.kt)(W_o,(0,p.Z)({},I_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}R_o.isMDXComponent=!0;const S_o={toc:[]},B_o="wrapper";function G_o(t){let{components:e,...n}=t;return(0,s.kt)(B_o,(0,p.Z)({},S_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}G_o.isMDXComponent=!0;const E_o={toc:[]},O_o="wrapper";function U_o(t){let{components:e,...n}=t;return(0,s.kt)(O_o,(0,p.Z)({},E_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}U_o.isMDXComponent=!0;const F_o={toc:[]},V_o="wrapper";function q_o(t){let{components:e,...n}=t;return(0,s.kt)(V_o,(0,p.Z)({},F_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}q_o.isMDXComponent=!0;const j_o={toc:[]},H_o="wrapper";function Y_o(t){let{components:e,...n}=t;return(0,s.kt)(H_o,(0,p.Z)({},j_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Y_o.isMDXComponent=!0;const Q_o={toc:[]},$_o="wrapper";function K_o(t){let{components:e,...n}=t;return(0,s.kt)($_o,(0,p.Z)({},Q_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}K_o.isMDXComponent=!0;const J_o={toc:[]},two="wrapper";function ewo(t){let{components:e,...n}=t;return(0,s.kt)(two,(0,p.Z)({},J_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}ewo.isMDXComponent=!0;const nwo={toc:[]},owo="wrapper";function pwo(t){let{components:e,...n}=t;return(0,s.kt)(owo,(0,p.Z)({},nwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pwo.isMDXComponent=!0;const rwo={toc:[]},swo="wrapper";function cwo(t){let{components:e,...n}=t;return(0,s.kt)(swo,(0,p.Z)({},rwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}cwo.isMDXComponent=!0;const awo={toc:[]},iwo="wrapper";function lwo(t){let{components:e,...n}=t;return(0,s.kt)(iwo,(0,p.Z)({},awo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lwo.isMDXComponent=!0;const uwo={toc:[]},mwo="wrapper";function dwo(t){let{components:e,...n}=t;return(0,s.kt)(mwo,(0,p.Z)({},uwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a tweening list to tween between two SVG nodes."))}dwo.isMDXComponent=!0;const hwo={toc:[]},fwo="wrapper";function kwo(t){let{components:e,...n}=t;return(0,s.kt)(fwo,(0,p.Z)({},hwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial node,"))}kwo.isMDXComponent=!0;const ywo={toc:[]},Dwo="wrapper";function Mwo(t){let{components:e,...n}=t;return(0,s.kt)(Dwo,(0,p.Z)({},ywo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The final node."))}Mwo.isMDXComponent=!0;const Xwo={toc:[]},_wo="wrapper";function wwo(t){let{components:e,...n}=t;return(0,s.kt)(_wo,(0,p.Z)({},Xwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}wwo.isMDXComponent=!0;const Two={toc:[]},Cwo="wrapper";function gwo(t){let{components:e,...n}=t;return(0,s.kt)(Cwo,(0,p.Z)({},Two,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function."))}gwo.isMDXComponent=!0;const xwo={toc:[]},vwo="wrapper";function Lwo(t){let{components:e,...n}=t;return(0,s.kt)(vwo,(0,p.Z)({},xwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Lwo.isMDXComponent=!0;const Zwo={toc:[]},bwo="wrapper";function Nwo(t){let{components:e,...n}=t;return(0,s.kt)(bwo,(0,p.Z)({},Zwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Nwo.isMDXComponent=!0;const zwo={toc:[]},Awo="wrapper";function Pwo(t){let{components:e,...n}=t;return(0,s.kt)(Awo,(0,p.Z)({},zwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get all SVG nodes with the given id."))}Pwo.isMDXComponent=!0;const Iwo={toc:[]},Wwo="wrapper";function Rwo(t){let{components:e,...n}=t;return(0,s.kt)(Wwo,(0,p.Z)({},Iwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An id to query."))}Rwo.isMDXComponent=!0;const Swo={toc:[]},Bwo="wrapper";function Gwo(t){let{components:e,...n}=t;return(0,s.kt)(Bwo,(0,p.Z)({},Swo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Gwo.isMDXComponent=!0;const Ewo={toc:[]},Owo="wrapper";function Uwo(t){let{components:e,...n}=t;return(0,s.kt)(Owo,(0,p.Z)({},Ewo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Uwo.isMDXComponent=!0;const Fwo={toc:[]},Vwo="wrapper";function qwo(t){let{components:e,...n}=t;return(0,s.kt)(Vwo,(0,p.Z)({},Fwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}qwo.isMDXComponent=!0;const jwo={toc:[]},Hwo="wrapper";function Ywo(t){let{components:e,...n}=t;return(0,s.kt)(Hwo,(0,p.Z)({},jwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Ywo.isMDXComponent=!0;const Qwo={toc:[]},$wo="wrapper";function Kwo(t){let{components:e,...n}=t;return(0,s.kt)($wo,(0,p.Z)({},Qwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Kwo.isMDXComponent=!0;const Jwo={toc:[]},tTo="wrapper";function eTo(t){let{components:e,...n}=t;return(0,s.kt)(tTo,(0,p.Z)({},Jwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}eTo.isMDXComponent=!0;const nTo={toc:[]},oTo="wrapper";function pTo(t){let{components:e,...n}=t;return(0,s.kt)(oTo,(0,p.Z)({},nTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}pTo.isMDXComponent=!0;const rTo={toc:[]},sTo="wrapper";function cTo(t){let{components:e,...n}=t;return(0,s.kt)(sTo,(0,p.Z)({},rTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}cTo.isMDXComponent=!0;const aTo={toc:[]},iTo="wrapper";function lTo(t){let{components:e,...n}=t;return(0,s.kt)(iTo,(0,p.Z)({},aTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}lTo.isMDXComponent=!0;const uTo={toc:[]},mTo="wrapper";function dTo(t){let{components:e,...n}=t;return(0,s.kt)(mTo,(0,p.Z)({},uTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}dTo.isMDXComponent=!0;const hTo={toc:[]},fTo="wrapper";function kTo(t){let{components:e,...n}=t;return(0,s.kt)(fTo,(0,p.Z)({},hTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}kTo.isMDXComponent=!0;const yTo={toc:[]},DTo="wrapper";function MTo(t){let{components:e,...n}=t;return(0,s.kt)(DTo,(0,p.Z)({},yTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}MTo.isMDXComponent=!0;const XTo={toc:[]},_To="wrapper";function wTo(t){let{components:e,...n}=t;return(0,s.kt)(_To,(0,p.Z)({},XTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wTo.isMDXComponent=!0;const TTo={toc:[]},CTo="wrapper";function gTo(t){let{components:e,...n}=t;return(0,s.kt)(CTo,(0,p.Z)({},TTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}gTo.isMDXComponent=!0;const xTo={toc:[]},vTo="wrapper";function LTo(t){let{components:e,...n}=t;return(0,s.kt)(vTo,(0,p.Z)({},xTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}LTo.isMDXComponent=!0;const ZTo={toc:[]},bTo="wrapper";function NTo(t){let{components:e,...n}=t;return(0,s.kt)(bTo,(0,p.Z)({},ZTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}NTo.isMDXComponent=!0;const zTo={toc:[]},ATo="wrapper";function PTo(t){let{components:e,...n}=t;return(0,s.kt)(ATo,(0,p.Z)({},zTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}PTo.isMDXComponent=!0;const ITo={toc:[]},WTo="wrapper";function RTo(t){let{components:e,...n}=t;return(0,s.kt)(WTo,(0,p.Z)({},ITo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}RTo.isMDXComponent=!0;const STo={toc:[]},BTo="wrapper";function GTo(t){let{components:e,...n}=t;return(0,s.kt)(BTo,(0,p.Z)({},STo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}GTo.isMDXComponent=!0;const ETo={toc:[]},OTo="wrapper";function UTo(t){let{components:e,...n}=t;return(0,s.kt)(OTo,(0,p.Z)({},ETo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}UTo.isMDXComponent=!0;const FTo={toc:[]},VTo="wrapper";function qTo(t){let{components:e,...n}=t;return(0,s.kt)(VTo,(0,p.Z)({},FTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}qTo.isMDXComponent=!0;const jTo={toc:[]},HTo="wrapper";function YTo(t){let{components:e,...n}=t;return(0,s.kt)(HTo,(0,p.Z)({},jTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}YTo.isMDXComponent=!0;const QTo={toc:[]},$To="wrapper";function KTo(t){let{components:e,...n}=t;return(0,s.kt)($To,(0,p.Z)({},QTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}KTo.isMDXComponent=!0;const JTo={toc:[]},tCo="wrapper";function eCo(t){let{components:e,...n}=t;return(0,s.kt)(tCo,(0,p.Z)({},JTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}eCo.isMDXComponent=!0;const nCo={toc:[]},oCo="wrapper";function pCo(t){let{components:e,...n}=t;return(0,s.kt)(oCo,(0,p.Z)({},nCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pCo.isMDXComponent=!0;const rCo={toc:[]},sCo="wrapper";function cCo(t){let{components:e,...n}=t;return(0,s.kt)(sCo,(0,p.Z)({},rCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}cCo.isMDXComponent=!0;const aCo={toc:[]},iCo="wrapper";function lCo(t){let{components:e,...n}=t;return(0,s.kt)(iCo,(0,p.Z)({},aCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lCo.isMDXComponent=!0;const uCo={toc:[]},mCo="wrapper";function dCo(t){let{components:e,...n}=t;return(0,s.kt)(mCo,(0,p.Z)({},uCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}dCo.isMDXComponent=!0;const hCo={toc:[]},fCo="wrapper";function kCo(t){let{components:e,...n}=t;return(0,s.kt)(fCo,(0,p.Z)({},hCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kCo.isMDXComponent=!0;const yCo={toc:[]},DCo="wrapper";function MCo(t){let{components:e,...n}=t;return(0,s.kt)(DCo,(0,p.Z)({},yCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}MCo.isMDXComponent=!0;const XCo={toc:[]},_Co="wrapper";function wCo(t){let{components:e,...n}=t;return(0,s.kt)(_Co,(0,p.Z)({},XCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wCo.isMDXComponent=!0;const TCo={toc:[]},CCo="wrapper";function gCo(t){let{components:e,...n}=t;return(0,s.kt)(CCo,(0,p.Z)({},TCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}gCo.isMDXComponent=!0;const xCo={toc:[]},vCo="wrapper";function LCo(t){let{components:e,...n}=t;return(0,s.kt)(vCo,(0,p.Z)({},xCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}LCo.isMDXComponent=!0;const ZCo={toc:[]},bCo="wrapper";function NCo(t){let{components:e,...n}=t;return(0,s.kt)(bCo,(0,p.Z)({},ZCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}NCo.isMDXComponent=!0;const zCo={toc:[]},ACo="wrapper";function PCo(t){let{components:e,...n}=t;return(0,s.kt)(ACo,(0,p.Z)({},zCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}PCo.isMDXComponent=!0;const ICo={toc:[]},WCo="wrapper";function RCo(t){let{components:e,...n}=t;return(0,s.kt)(WCo,(0,p.Z)({},ICo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}RCo.isMDXComponent=!0;const SCo={toc:[]},BCo="wrapper";function GCo(t){let{components:e,...n}=t;return(0,s.kt)(BCo,(0,p.Z)({},SCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}GCo.isMDXComponent=!0;const ECo={toc:[]},OCo="wrapper";function UCo(t){let{components:e,...n}=t;return(0,s.kt)(OCo,(0,p.Z)({},ECo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}UCo.isMDXComponent=!0;const FCo={toc:[]},VCo="wrapper";function qCo(t){let{components:e,...n}=t;return(0,s.kt)(VCo,(0,p.Z)({},FCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}qCo.isMDXComponent=!0;const jCo={toc:[]},HCo="wrapper";function YCo(t){let{components:e,...n}=t;return(0,s.kt)(HCo,(0,p.Z)({},jCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}YCo.isMDXComponent=!0;const QCo={toc:[]},$Co="wrapper";function KCo(t){let{components:e,...n}=t;return(0,s.kt)($Co,(0,p.Z)({},QCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}KCo.isMDXComponent=!0;const JCo={toc:[]},tgo="wrapper";function ego(t){let{components:e,...n}=t;return(0,s.kt)(tgo,(0,p.Z)({},JCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}ego.isMDXComponent=!0;const ngo={toc:[]},ogo="wrapper";function pgo(t){let{components:e,...n}=t;return(0,s.kt)(ogo,(0,p.Z)({},ngo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}pgo.isMDXComponent=!0;const rgo={toc:[]},sgo="wrapper";function cgo(t){let{components:e,...n}=t;return(0,s.kt)(sgo,(0,p.Z)({},rgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}cgo.isMDXComponent=!0;const ago={toc:[]},igo="wrapper";function lgo(t){let{components:e,...n}=t;return(0,s.kt)(igo,(0,p.Z)({},ago,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}lgo.isMDXComponent=!0;const ugo={toc:[]},mgo="wrapper";function dgo(t){let{components:e,...n}=t;return(0,s.kt)(mgo,(0,p.Z)({},ugo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}dgo.isMDXComponent=!0;const hgo={toc:[]},fgo="wrapper";function kgo(t){let{components:e,...n}=t;return(0,s.kt)(fgo,(0,p.Z)({},hgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert an SVG string to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}kgo.isMDXComponent=!0;const ygo={toc:[]},Dgo="wrapper";function Mgo(t){let{components:e,...n}=t;return(0,s.kt)(Dgo,(0,p.Z)({},ygo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An SVG string to be parsed."))}Mgo.isMDXComponent=!0;const Xgo={toc:[]},_go="wrapper";function wgo(t){let{components:e,...n}=t;return(0,s.kt)(_go,(0,p.Z)({},Xgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}wgo.isMDXComponent=!0;const Tgo={toc:[]},Cgo="wrapper";function ggo(t){let{components:e,...n}=t;return(0,s.kt)(Cgo,(0,p.Z)({},Tgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}ggo.isMDXComponent=!0;const xgo={toc:[]},vgo="wrapper";function Lgo(t){let{components:e,...n}=t;return(0,s.kt)(vgo,(0,p.Z)({},xgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Lgo.isMDXComponent=!0;const Zgo={toc:[]},bgo="wrapper";function Ngo(t){let{components:e,...n}=t;return(0,s.kt)(bgo,(0,p.Z)({},Zgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Ngo.isMDXComponent=!0;const zgo={toc:[]},Ago="wrapper";function Pgo(t){let{components:e,...n}=t;return(0,s.kt)(Ago,(0,p.Z)({},zgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pgo.isMDXComponent=!0;const Igo={toc:[]},Wgo="wrapper";function Rgo(t){let{components:e,...n}=t;return(0,s.kt)(Wgo,(0,p.Z)({},Igo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Rgo.isMDXComponent=!0;const Sgo={toc:[]},Bgo="wrapper";function Ggo(t){let{components:e,...n}=t;return(0,s.kt)(Bgo,(0,p.Z)({},Sgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Ggo.isMDXComponent=!0;const Ego={toc:[]},Ogo="wrapper";function Ugo(t){let{components:e,...n}=t;return(0,s.kt)(Ogo,(0,p.Z)({},Ego,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Ugo.isMDXComponent=!0;const Fgo={toc:[]},Vgo="wrapper";function qgo(t){let{components:e,...n}=t;return(0,s.kt)(Vgo,(0,p.Z)({},Fgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}qgo.isMDXComponent=!0;const jgo={toc:[]},Hgo="wrapper";function Ygo(t){let{components:e,...n}=t;return(0,s.kt)(Hgo,(0,p.Z)({},jgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Ygo.isMDXComponent=!0;const Qgo={toc:[]},$go="wrapper";function Kgo(t){let{components:e,...n}=t;return(0,s.kt)($go,(0,p.Z)({},Qgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Kgo.isMDXComponent=!0;const Jgo={toc:[]},txo="wrapper";function exo(t){let{components:e,...n}=t;return(0,s.kt)(txo,(0,p.Z)({},Jgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}exo.isMDXComponent=!0;const nxo={toc:[]},oxo="wrapper";function pxo(t){let{components:e,...n}=t;return(0,s.kt)(oxo,(0,p.Z)({},nxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}pxo.isMDXComponent=!0;const rxo={toc:[]},sxo="wrapper";function cxo(t){let{components:e,...n}=t;return(0,s.kt)(sxo,(0,p.Z)({},rxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}cxo.isMDXComponent=!0;const axo={toc:[]},ixo="wrapper";function lxo(t){let{components:e,...n}=t;return(0,s.kt)(ixo,(0,p.Z)({},axo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}lxo.isMDXComponent=!0;const uxo={toc:[]},mxo="wrapper";function dxo(t){let{components:e,...n}=t;return(0,s.kt)(mxo,(0,p.Z)({},uxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}dxo.isMDXComponent=!0;const hxo={toc:[]},fxo="wrapper";function kxo(t){let{components:e,...n}=t;return(0,s.kt)(fxo,(0,p.Z)({},hxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kxo.isMDXComponent=!0;const yxo={toc:[]},Dxo="wrapper";function Mxo(t){let{components:e,...n}=t;return(0,s.kt)(Dxo,(0,p.Z)({},yxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Mxo.isMDXComponent=!0;const Xxo={toc:[]},_xo="wrapper";function wxo(t){let{components:e,...n}=t;return(0,s.kt)(_xo,(0,p.Z)({},Xxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}wxo.isMDXComponent=!0;const Txo={toc:[]},Cxo="wrapper";function gxo(t){let{components:e,...n}=t;return(0,s.kt)(Cxo,(0,p.Z)({},Txo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gxo.isMDXComponent=!0;const xxo={toc:[]},vxo="wrapper";function Lxo(t){let{components:e,...n}=t;return(0,s.kt)(vxo,(0,p.Z)({},xxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Lxo.isMDXComponent=!0;const Zxo={toc:[]},bxo="wrapper";function Nxo(t){let{components:e,...n}=t;return(0,s.kt)(bxo,(0,p.Z)({},Zxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Nxo.isMDXComponent=!0;const zxo={toc:[]},Axo="wrapper";function Pxo(t){let{components:e,...n}=t;return(0,s.kt)(Axo,(0,p.Z)({},zxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Pxo.isMDXComponent=!0;const Ixo={toc:[]},Wxo="wrapper";function Rxo(t){let{components:e,...n}=t;return(0,s.kt)(Wxo,(0,p.Z)({},Ixo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Rxo.isMDXComponent=!0;const Sxo={toc:[]},Bxo="wrapper";function Gxo(t){let{components:e,...n}=t;return(0,s.kt)(Bxo,(0,p.Z)({},Sxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Gxo.isMDXComponent=!0;const Exo={toc:[]},Oxo="wrapper";function Uxo(t){let{components:e,...n}=t;return(0,s.kt)(Oxo,(0,p.Z)({},Exo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Uxo.isMDXComponent=!0;const Fxo={toc:[]},Vxo="wrapper";function qxo(t){let{components:e,...n}=t;return(0,s.kt)(Vxo,(0,p.Z)({},Fxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}qxo.isMDXComponent=!0;const jxo={toc:[]},Hxo="wrapper";function Yxo(t){let{components:e,...n}=t;return(0,s.kt)(Hxo,(0,p.Z)({},jxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Yxo.isMDXComponent=!0;const Qxo={toc:[]},$xo="wrapper";function Kxo(t){let{components:e,...n}=t;return(0,s.kt)($xo,(0,p.Z)({},Qxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Kxo.isMDXComponent=!0;const Jxo={toc:[]},tvo="wrapper";function evo(t){let{components:e,...n}=t;return(0,s.kt)(tvo,(0,p.Z)({},Jxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}evo.isMDXComponent=!0;const nvo={toc:[]},ovo="wrapper";function pvo(t){let{components:e,...n}=t;return(0,s.kt)(ovo,(0,p.Z)({},nvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pvo.isMDXComponent=!0;const rvo={toc:[]},svo="wrapper";function cvo(t){let{components:e,...n}=t;return(0,s.kt)(svo,(0,p.Z)({},rvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}cvo.isMDXComponent=!0;const avo={toc:[]},ivo="wrapper";function lvo(t){let{components:e,...n}=t;return(0,s.kt)(ivo,(0,p.Z)({},avo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lvo.isMDXComponent=!0;const uvo={toc:[]},mvo="wrapper";function dvo(t){let{components:e,...n}=t;return(0,s.kt)(mvo,(0,p.Z)({},uvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dvo.isMDXComponent=!0;const hvo={toc:[]},fvo="wrapper";function kvo(t){let{components:e,...n}=t;return(0,s.kt)(fvo,(0,p.Z)({},hvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kvo.isMDXComponent=!0;const yvo={toc:[]},Dvo="wrapper";function Mvo(t){let{components:e,...n}=t;return(0,s.kt)(Dvo,(0,p.Z)({},yvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Mvo.isMDXComponent=!0;const Xvo={toc:[]},_vo="wrapper";function wvo(t){let{components:e,...n}=t;return(0,s.kt)(_vo,(0,p.Z)({},Xvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wvo.isMDXComponent=!0;const Tvo={toc:[]},Cvo="wrapper";function gvo(t){let{components:e,...n}=t;return(0,s.kt)(Cvo,(0,p.Z)({},Tvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}gvo.isMDXComponent=!0;const xvo={toc:[]},vvo="wrapper";function Lvo(t){let{components:e,...n}=t;return(0,s.kt)(vvo,(0,p.Z)({},xvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Lvo.isMDXComponent=!0;const Zvo={toc:[]},bvo="wrapper";function Nvo(t){let{components:e,...n}=t;return(0,s.kt)(bvo,(0,p.Z)({},Zvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Nvo.isMDXComponent=!0;const zvo={toc:[]},Avo="wrapper";function Pvo(t){let{components:e,...n}=t;return(0,s.kt)(Avo,(0,p.Z)({},zvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Pvo.isMDXComponent=!0;const Ivo={toc:[]},Wvo="wrapper";function Rvo(t){let{components:e,...n}=t;return(0,s.kt)(Wvo,(0,p.Z)({},Ivo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Rvo.isMDXComponent=!0;const Svo={toc:[]},Bvo="wrapper";function Gvo(t){let{components:e,...n}=t;return(0,s.kt)(Bvo,(0,p.Z)({},Svo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Gvo.isMDXComponent=!0;const Evo={toc:[]},Ovo="wrapper";function Uvo(t){let{components:e,...n}=t;return(0,s.kt)(Ovo,(0,p.Z)({},Evo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Uvo.isMDXComponent=!0;const Fvo={toc:[]},Vvo="wrapper";function qvo(t){let{components:e,...n}=t;return(0,s.kt)(Vvo,(0,p.Z)({},Fvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}qvo.isMDXComponent=!0;const jvo={toc:[]},Hvo="wrapper";function Yvo(t){let{components:e,...n}=t;return(0,s.kt)(Hvo,(0,p.Z)({},jvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"MotionCanvas Shape properties"))}Yvo.isMDXComponent=!0;const Qvo={toc:[]},$vo="wrapper";function Kvo(t){let{components:e,...n}=t;return(0,s.kt)($vo,(0,p.Z)({},Qvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get position, rotation and scale from Matrix transformation as Shape properties"))}Kvo.isMDXComponent=!0;const Jvo={toc:[]},tLo="wrapper";function eLo(t){let{components:e,...n}=t;return(0,s.kt)(tLo,(0,p.Z)({},Jvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Matrix transformation"))}eLo.isMDXComponent=!0;const nLo={toc:[]},oLo="wrapper";function pLo(t){let{components:e,...n}=t;return(0,s.kt)(oLo,(0,p.Z)({},nLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," that can be used to build SVGDocument."))}pLo.isMDXComponent=!0;const rLo={toc:[]},sLo="wrapper";function cLo(t){let{components:e,...n}=t;return(0,s.kt)(sLo,(0,p.Z)({},rLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse an SVG string as ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData"),"."))}cLo.isMDXComponent=!0;const aLo={toc:[]},iLo="wrapper";function lLo(t){let{components:e,...n}=t;return(0,s.kt)(iLo,(0,p.Z)({},aLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"And SVG string to be parsed."))}lLo.isMDXComponent=!0;const uLo={toc:[]},mLo="wrapper";function dLo(t){let{components:e,...n}=t;return(0,s.kt)(mLo,(0,p.Z)({},uLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dLo.isMDXComponent=!0;const hLo={toc:[]},fLo="wrapper";function kLo(t){let{components:e,...n}=t;return(0,s.kt)(fLo,(0,p.Z)({},hLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kLo.isMDXComponent=!0;const yLo={toc:[]},DLo="wrapper";function MLo(t){let{components:e,...n}=t;return(0,s.kt)(DLo,(0,p.Z)({},yLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}MLo.isMDXComponent=!0;const XLo={toc:[]},_Lo="wrapper";function wLo(t){let{components:e,...n}=t;return(0,s.kt)(_Lo,(0,p.Z)({},XLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wLo.isMDXComponent=!0;const TLo={toc:[]},CLo="wrapper";function gLo(t){let{components:e,...n}=t;return(0,s.kt)(CLo,(0,p.Z)({},TLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}gLo.isMDXComponent=!0;const xLo={toc:[]},vLo="wrapper";function LLo(t){let{components:e,...n}=t;return(0,s.kt)(vLo,(0,p.Z)({},xLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}LLo.isMDXComponent=!0;const ZLo={toc:[]},bLo="wrapper";function NLo(t){let{components:e,...n}=t;return(0,s.kt)(bLo,(0,p.Z)({},ZLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}NLo.isMDXComponent=!0;const zLo={toc:[]},ALo="wrapper";function PLo(t){let{components:e,...n}=t;return(0,s.kt)(ALo,(0,p.Z)({},zLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}PLo.isMDXComponent=!0;const ILo={toc:[]},WLo="wrapper";function RLo(t){let{components:e,...n}=t;return(0,s.kt)(WLo,(0,p.Z)({},ILo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}RLo.isMDXComponent=!0;const SLo={toc:[]},BLo="wrapper";function GLo(t){let{components:e,...n}=t;return(0,s.kt)(BLo,(0,p.Z)({},SLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}GLo.isMDXComponent=!0;const ELo={toc:[]},OLo="wrapper";function ULo(t){let{components:e,...n}=t;return(0,s.kt)(OLo,(0,p.Z)({},ELo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}ULo.isMDXComponent=!0;const FLo={toc:[]},VLo="wrapper";function qLo(t){let{components:e,...n}=t;return(0,s.kt)(VLo,(0,p.Z)({},FLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qLo.isMDXComponent=!0;const jLo={toc:[]},HLo="wrapper";function YLo(t){let{components:e,...n}=t;return(0,s.kt)(HLo,(0,p.Z)({},jLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}YLo.isMDXComponent=!0;const QLo={toc:[]},$Lo="wrapper";function KLo(t){let{components:e,...n}=t;return(0,s.kt)($Lo,(0,p.Z)({},QLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}KLo.isMDXComponent=!0;const JLo={toc:[]},tZo="wrapper";function eZo(t){let{components:e,...n}=t;return(0,s.kt)(tZo,(0,p.Z)({},JLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}eZo.isMDXComponent=!0;const nZo={toc:[]},oZo="wrapper";function pZo(t){let{components:e,...n}=t;return(0,s.kt)(oZo,(0,p.Z)({},nZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pZo.isMDXComponent=!0;const rZo={toc:[]},sZo="wrapper";function cZo(t){let{components:e,...n}=t;return(0,s.kt)(sZo,(0,p.Z)({},rZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}cZo.isMDXComponent=!0;const aZo={toc:[]},iZo="wrapper";function lZo(t){let{components:e,...n}=t;return(0,s.kt)(iZo,(0,p.Z)({},aZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}lZo.isMDXComponent=!0;const uZo={toc:[]},mZo="wrapper";function dZo(t){let{components:e,...n}=t;return(0,s.kt)(mZo,(0,p.Z)({},uZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}dZo.isMDXComponent=!0;const hZo={toc:[]},fZo="wrapper";function kZo(t){let{components:e,...n}=t;return(0,s.kt)(fZo,(0,p.Z)({},hZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}kZo.isMDXComponent=!0;const yZo={toc:[]},DZo="wrapper";function MZo(t){let{components:e,...n}=t;return(0,s.kt)(DZo,(0,p.Z)({},yZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}MZo.isMDXComponent=!0;const XZo={toc:[]},_Zo="wrapper";function wZo(t){let{components:e,...n}=t;return(0,s.kt)(_Zo,(0,p.Z)({},XZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}wZo.isMDXComponent=!0;const TZo={toc:[]},CZo="wrapper";function gZo(t){let{components:e,...n}=t;return(0,s.kt)(CZo,(0,p.Z)({},TZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gZo.isMDXComponent=!0;const xZo={toc:[]},vZo="wrapper";function LZo(t){let{components:e,...n}=t;return(0,s.kt)(vZo,(0,p.Z)({},xZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}LZo.isMDXComponent=!0;const ZZo={toc:[]},bZo="wrapper";function NZo(t){let{components:e,...n}=t;return(0,s.kt)(bZo,(0,p.Z)({},ZZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}NZo.isMDXComponent=!0;const zZo={toc:[]},AZo="wrapper";function PZo(t){let{components:e,...n}=t;return(0,s.kt)(AZo,(0,p.Z)({},zZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}PZo.isMDXComponent=!0;const IZo={toc:[]},WZo="wrapper";function RZo(t){let{components:e,...n}=t;return(0,s.kt)(WZo,(0,p.Z)({},IZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}RZo.isMDXComponent=!0;const SZo={toc:[]},BZo="wrapper";function GZo(t){let{components:e,...n}=t;return(0,s.kt)(BZo,(0,p.Z)({},SZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}GZo.isMDXComponent=!0;const EZo={toc:[]},OZo="wrapper";function UZo(t){let{components:e,...n}=t;return(0,s.kt)(OZo,(0,p.Z)({},EZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}UZo.isMDXComponent=!0;const FZo={toc:[]},VZo="wrapper";function qZo(t){let{components:e,...n}=t;return(0,s.kt)(VZo,(0,p.Z)({},FZo,n,{components:e,mdxType:"MDXLayout"}))}qZo.isMDXComponent=!0;const jZo={toc:[]},HZo="wrapper";function YZo(t){let{components:e,...n}=t;return(0,s.kt)(HZo,(0,p.Z)({},jZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}YZo.isMDXComponent=!0;const QZo={toc:[]},$Zo="wrapper";function KZo(t){let{components:e,...n}=t;return(0,s.kt)($Zo,(0,p.Z)({},QZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}KZo.isMDXComponent=!0;const JZo={toc:[]},tbo="wrapper";function ebo(t){let{components:e,...n}=t;return(0,s.kt)(tbo,(0,p.Z)({},JZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}ebo.isMDXComponent=!0;const nbo={toc:[]},obo="wrapper";function pbo(t){let{components:e,...n}=t;return(0,s.kt)(obo,(0,p.Z)({},nbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}pbo.isMDXComponent=!0;const rbo={toc:[]},sbo="wrapper";function cbo(t){let{components:e,...n}=t;return(0,s.kt)(sbo,(0,p.Z)({},rbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}cbo.isMDXComponent=!0;const abo={toc:[]},ibo="wrapper";function lbo(t){let{components:e,...n}=t;return(0,s.kt)(ibo,(0,p.Z)({},abo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lbo.isMDXComponent=!0;const ubo={toc:[]},mbo="wrapper";function dbo(t){let{components:e,...n}=t;return(0,s.kt)(mbo,(0,p.Z)({},ubo,n,{components:e,mdxType:"MDXLayout"}))}dbo.isMDXComponent=!0;const hbo={toc:[]},fbo="wrapper";function kbo(t){let{components:e,...n}=t;return(0,s.kt)(fbo,(0,p.Z)({},hbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kbo.isMDXComponent=!0;const ybo={toc:[]},Dbo="wrapper";function Mbo(t){let{components:e,...n}=t;return(0,s.kt)(Dbo,(0,p.Z)({},ybo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Mbo.isMDXComponent=!0;const Xbo={toc:[]},_bo="wrapper";function wbo(t){let{components:e,...n}=t;return(0,s.kt)(_bo,(0,p.Z)({},Xbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wbo.isMDXComponent=!0;const Tbo={toc:[]},Cbo="wrapper";function gbo(t){let{components:e,...n}=t;return(0,s.kt)(Cbo,(0,p.Z)({},Tbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}gbo.isMDXComponent=!0;const xbo={toc:[]},vbo="wrapper";function Lbo(t){let{components:e,...n}=t;return(0,s.kt)(vbo,(0,p.Z)({},xbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Lbo.isMDXComponent=!0;const Zbo={toc:[]},bbo="wrapper";function Nbo(t){let{components:e,...n}=t;return(0,s.kt)(bbo,(0,p.Z)({},Zbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Nbo.isMDXComponent=!0;const zbo={toc:[]},Abo="wrapper";function Pbo(t){let{components:e,...n}=t;return(0,s.kt)(Abo,(0,p.Z)({},zbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Pbo.isMDXComponent=!0;const Ibo={toc:[]},Wbo="wrapper";function Rbo(t){let{components:e,...n}=t;return(0,s.kt)(Wbo,(0,p.Z)({},Ibo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Rbo.isMDXComponent=!0;const Sbo={toc:[]},Bbo="wrapper";function Gbo(t){let{components:e,...n}=t;return(0,s.kt)(Bbo,(0,p.Z)({},Sbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Gbo.isMDXComponent=!0;const Ebo={toc:[]},Obo="wrapper";function Ubo(t){let{components:e,...n}=t;return(0,s.kt)(Obo,(0,p.Z)({},Ebo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Ubo.isMDXComponent=!0;const Fbo={toc:[]},Vbo="wrapper";function qbo(t){let{components:e,...n}=t;return(0,s.kt)(Vbo,(0,p.Z)({},Fbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qbo.isMDXComponent=!0;const jbo={toc:[]},Hbo="wrapper";function Ybo(t){let{components:e,...n}=t;return(0,s.kt)(Hbo,(0,p.Z)({},jbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Ybo.isMDXComponent=!0;const Qbo={toc:[]},$bo="wrapper";function Kbo(t){let{components:e,...n}=t;return(0,s.kt)($bo,(0,p.Z)({},Qbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Kbo.isMDXComponent=!0;const Jbo={toc:[]},tNo="wrapper";function eNo(t){let{components:e,...n}=t;return(0,s.kt)(tNo,(0,p.Z)({},Jbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}eNo.isMDXComponent=!0;const nNo={toc:[]},oNo="wrapper";function pNo(t){let{components:e,...n}=t;return(0,s.kt)(oNo,(0,p.Z)({},nNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pNo.isMDXComponent=!0;const rNo={toc:[]},sNo="wrapper";function cNo(t){let{components:e,...n}=t;return(0,s.kt)(sNo,(0,p.Z)({},rNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cNo.isMDXComponent=!0;const aNo={toc:[]},iNo="wrapper";function lNo(t){let{components:e,...n}=t;return(0,s.kt)(iNo,(0,p.Z)({},aNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lNo.isMDXComponent=!0;const uNo={toc:[]},mNo="wrapper";function dNo(t){let{components:e,...n}=t;return(0,s.kt)(mNo,(0,p.Z)({},uNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dNo.isMDXComponent=!0;const hNo={toc:[]},fNo="wrapper";function kNo(t){let{components:e,...n}=t;return(0,s.kt)(fNo,(0,p.Z)({},hNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}kNo.isMDXComponent=!0;const yNo={toc:[]},DNo="wrapper";function MNo(t){let{components:e,...n}=t;return(0,s.kt)(DNo,(0,p.Z)({},yNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}MNo.isMDXComponent=!0;const XNo={toc:[]},_No="wrapper";function wNo(t){let{components:e,...n}=t;return(0,s.kt)(_No,(0,p.Z)({},XNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}wNo.isMDXComponent=!0;const TNo={toc:[]},CNo="wrapper";function gNo(t){let{components:e,...n}=t;return(0,s.kt)(CNo,(0,p.Z)({},TNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}gNo.isMDXComponent=!0;const xNo={toc:[]},vNo="wrapper";function LNo(t){let{components:e,...n}=t;return(0,s.kt)(vNo,(0,p.Z)({},xNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}LNo.isMDXComponent=!0;const ZNo={toc:[]},bNo="wrapper";function NNo(t){let{components:e,...n}=t;return(0,s.kt)(bNo,(0,p.Z)({},ZNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NNo.isMDXComponent=!0;const zNo={toc:[]},ANo="wrapper";function PNo(t){let{components:e,...n}=t;return(0,s.kt)(ANo,(0,p.Z)({},zNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}PNo.isMDXComponent=!0;const INo={toc:[]},WNo="wrapper";function RNo(t){let{components:e,...n}=t;return(0,s.kt)(WNo,(0,p.Z)({},INo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}RNo.isMDXComponent=!0;const SNo={toc:[]},BNo="wrapper";function GNo(t){let{components:e,...n}=t;return(0,s.kt)(BNo,(0,p.Z)({},SNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}GNo.isMDXComponent=!0;const ENo={toc:[]},ONo="wrapper";function UNo(t){let{components:e,...n}=t;return(0,s.kt)(ONo,(0,p.Z)({},ENo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}UNo.isMDXComponent=!0;const FNo={toc:[]},VNo="wrapper";function qNo(t){let{components:e,...n}=t;return(0,s.kt)(VNo,(0,p.Z)({},FNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qNo.isMDXComponent=!0;const jNo={toc:[]},HNo="wrapper";function YNo(t){let{components:e,...n}=t;return(0,s.kt)(HNo,(0,p.Z)({},jNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}YNo.isMDXComponent=!0;const QNo={toc:[]},$No="wrapper";function KNo(t){let{components:e,...n}=t;return(0,s.kt)($No,(0,p.Z)({},QNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}KNo.isMDXComponent=!0;const JNo={toc:[]},tzo="wrapper";function ezo(t){let{components:e,...n}=t;return(0,s.kt)(tzo,(0,p.Z)({},JNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}ezo.isMDXComponent=!0;const nzo={toc:[]},ozo="wrapper";function pzo(t){let{components:e,...n}=t;return(0,s.kt)(ozo,(0,p.Z)({},nzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pzo.isMDXComponent=!0;const rzo={toc:[]},szo="wrapper";function czo(t){let{components:e,...n}=t;return(0,s.kt)(szo,(0,p.Z)({},rzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}czo.isMDXComponent=!0;const azo={toc:[]},izo="wrapper";function lzo(t){let{components:e,...n}=t;return(0,s.kt)(izo,(0,p.Z)({},azo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lzo.isMDXComponent=!0;const uzo={toc:[]},mzo="wrapper";function dzo(t){let{components:e,...n}=t;return(0,s.kt)(mzo,(0,p.Z)({},uzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dzo.isMDXComponent=!0;const hzo={toc:[]},fzo="wrapper";function kzo(t){let{components:e,...n}=t;return(0,s.kt)(fzo,(0,p.Z)({},hzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kzo.isMDXComponent=!0;const yzo={toc:[]},Dzo="wrapper";function Mzo(t){let{components:e,...n}=t;return(0,s.kt)(Dzo,(0,p.Z)({},yzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mzo.isMDXComponent=!0;const Xzo={toc:[]},_zo="wrapper";function wzo(t){let{components:e,...n}=t;return(0,s.kt)(_zo,(0,p.Z)({},Xzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wzo.isMDXComponent=!0;const Tzo={toc:[]},Czo="wrapper";function gzo(t){let{components:e,...n}=t;return(0,s.kt)(Czo,(0,p.Z)({},Tzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}gzo.isMDXComponent=!0;const xzo={toc:[]},vzo="wrapper";function Lzo(t){let{components:e,...n}=t;return(0,s.kt)(vzo,(0,p.Z)({},xzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lzo.isMDXComponent=!0;const Zzo={toc:[]},bzo="wrapper";function Nzo(t){let{components:e,...n}=t;return(0,s.kt)(bzo,(0,p.Z)({},Zzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Nzo.isMDXComponent=!0;const zzo={toc:[]},Azo="wrapper";function Pzo(t){let{components:e,...n}=t;return(0,s.kt)(Azo,(0,p.Z)({},zzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pzo.isMDXComponent=!0;const Izo={toc:[]},Wzo="wrapper";function Rzo(t){let{components:e,...n}=t;return(0,s.kt)(Wzo,(0,p.Z)({},Izo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Rzo.isMDXComponent=!0;const Szo={toc:[]},Bzo="wrapper";function Gzo(t){let{components:e,...n}=t;return(0,s.kt)(Bzo,(0,p.Z)({},Szo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gzo.isMDXComponent=!0;const Ezo={toc:[]},Ozo="wrapper";function Uzo(t){let{components:e,...n}=t;return(0,s.kt)(Ozo,(0,p.Z)({},Ezo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Uzo.isMDXComponent=!0;const Fzo={toc:[]},Vzo="wrapper";function qzo(t){let{components:e,...n}=t;return(0,s.kt)(Vzo,(0,p.Z)({},Fzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qzo.isMDXComponent=!0;const jzo={toc:[]},Hzo="wrapper";function Yzo(t){let{components:e,...n}=t;return(0,s.kt)(Hzo,(0,p.Z)({},jzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Yzo.isMDXComponent=!0;const Qzo={toc:[]},$zo="wrapper";function Kzo(t){let{components:e,...n}=t;return(0,s.kt)($zo,(0,p.Z)({},Qzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kzo.isMDXComponent=!0;const Jzo={toc:[]},tAo="wrapper";function eAo(t){let{components:e,...n}=t;return(0,s.kt)(tAo,(0,p.Z)({},Jzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}eAo.isMDXComponent=!0;const nAo={toc:[]},oAo="wrapper";function pAo(t){let{components:e,...n}=t;return(0,s.kt)(oAo,(0,p.Z)({},nAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pAo.isMDXComponent=!0;const rAo={toc:[]},sAo="wrapper";function cAo(t){let{components:e,...n}=t;return(0,s.kt)(sAo,(0,p.Z)({},rAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cAo.isMDXComponent=!0;const aAo={toc:[]},iAo="wrapper";function lAo(t){let{components:e,...n}=t;return(0,s.kt)(iAo,(0,p.Z)({},aAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lAo.isMDXComponent=!0;const uAo={toc:[]},mAo="wrapper";function dAo(t){let{components:e,...n}=t;return(0,s.kt)(mAo,(0,p.Z)({},uAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dAo.isMDXComponent=!0;const hAo={toc:[]},fAo="wrapper";function kAo(t){let{components:e,...n}=t;return(0,s.kt)(fAo,(0,p.Z)({},hAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kAo.isMDXComponent=!0;const yAo={toc:[]},DAo="wrapper";function MAo(t){let{components:e,...n}=t;return(0,s.kt)(DAo,(0,p.Z)({},yAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}MAo.isMDXComponent=!0;const XAo={toc:[]},_Ao="wrapper";function wAo(t){let{components:e,...n}=t;return(0,s.kt)(_Ao,(0,p.Z)({},XAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wAo.isMDXComponent=!0;const TAo={toc:[]},CAo="wrapper";function gAo(t){let{components:e,...n}=t;return(0,s.kt)(CAo,(0,p.Z)({},TAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}gAo.isMDXComponent=!0;const xAo={toc:[]},vAo="wrapper";function LAo(t){let{components:e,...n}=t;return(0,s.kt)(vAo,(0,p.Z)({},xAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}LAo.isMDXComponent=!0;const ZAo={toc:[]},bAo="wrapper";function NAo(t){let{components:e,...n}=t;return(0,s.kt)(bAo,(0,p.Z)({},ZAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}NAo.isMDXComponent=!0;const zAo={toc:[]},AAo="wrapper";function PAo(t){let{components:e,...n}=t;return(0,s.kt)(AAo,(0,p.Z)({},zAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}PAo.isMDXComponent=!0;const IAo={toc:[]},WAo="wrapper";function RAo(t){let{components:e,...n}=t;return(0,s.kt)(WAo,(0,p.Z)({},IAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}RAo.isMDXComponent=!0;const SAo={toc:[]},BAo="wrapper";function GAo(t){let{components:e,...n}=t;return(0,s.kt)(BAo,(0,p.Z)({},SAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}GAo.isMDXComponent=!0;const EAo={toc:[]},OAo="wrapper";function UAo(t){let{components:e,...n}=t;return(0,s.kt)(OAo,(0,p.Z)({},EAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}UAo.isMDXComponent=!0;const FAo={toc:[]},VAo="wrapper";function qAo(t){let{components:e,...n}=t;return(0,s.kt)(VAo,(0,p.Z)({},FAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qAo.isMDXComponent=!0;const jAo={toc:[]},HAo="wrapper";function YAo(t){let{components:e,...n}=t;return(0,s.kt)(HAo,(0,p.Z)({},jAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}YAo.isMDXComponent=!0;const QAo={toc:[]},$Ao="wrapper";function KAo(t){let{components:e,...n}=t;return(0,s.kt)($Ao,(0,p.Z)({},QAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}KAo.isMDXComponent=!0;const JAo={toc:[]},tPo="wrapper";function ePo(t){let{components:e,...n}=t;return(0,s.kt)(tPo,(0,p.Z)({},JAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}ePo.isMDXComponent=!0;const nPo={toc:[]},oPo="wrapper";function pPo(t){let{components:e,...n}=t;return(0,s.kt)(oPo,(0,p.Z)({},nPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pPo.isMDXComponent=!0;const rPo={toc:[]},sPo="wrapper";function cPo(t){let{components:e,...n}=t;return(0,s.kt)(sPo,(0,p.Z)({},rPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cPo.isMDXComponent=!0;const aPo={toc:[]},iPo="wrapper";function lPo(t){let{components:e,...n}=t;return(0,s.kt)(iPo,(0,p.Z)({},aPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lPo.isMDXComponent=!0;const uPo={toc:[]},mPo="wrapper";function dPo(t){let{components:e,...n}=t;return(0,s.kt)(mPo,(0,p.Z)({},uPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dPo.isMDXComponent=!0;const hPo={toc:[]},fPo="wrapper";function kPo(t){let{components:e,...n}=t;return(0,s.kt)(fPo,(0,p.Z)({},hPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}kPo.isMDXComponent=!0;const yPo={toc:[]},DPo="wrapper";function MPo(t){let{components:e,...n}=t;return(0,s.kt)(DPo,(0,p.Z)({},yPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}MPo.isMDXComponent=!0;const XPo={toc:[]},_Po="wrapper";function wPo(t){let{components:e,...n}=t;return(0,s.kt)(_Po,(0,p.Z)({},XPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wPo.isMDXComponent=!0;const TPo={toc:[]},CPo="wrapper";function gPo(t){let{components:e,...n}=t;return(0,s.kt)(CPo,(0,p.Z)({},TPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}gPo.isMDXComponent=!0;const xPo={toc:[]},vPo="wrapper";function LPo(t){let{components:e,...n}=t;return(0,s.kt)(vPo,(0,p.Z)({},xPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}LPo.isMDXComponent=!0;const ZPo={toc:[]},bPo="wrapper";function NPo(t){let{components:e,...n}=t;return(0,s.kt)(bPo,(0,p.Z)({},ZPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}NPo.isMDXComponent=!0;const zPo={toc:[]},APo="wrapper";function PPo(t){let{components:e,...n}=t;return(0,s.kt)(APo,(0,p.Z)({},zPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}PPo.isMDXComponent=!0;const IPo={toc:[]},WPo="wrapper";function RPo(t){let{components:e,...n}=t;return(0,s.kt)(WPo,(0,p.Z)({},IPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}RPo.isMDXComponent=!0;const SPo={toc:[]},BPo="wrapper";function GPo(t){let{components:e,...n}=t;return(0,s.kt)(BPo,(0,p.Z)({},SPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}GPo.isMDXComponent=!0;const EPo={toc:[]},OPo="wrapper";function UPo(t){let{components:e,...n}=t;return(0,s.kt)(OPo,(0,p.Z)({},EPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}UPo.isMDXComponent=!0;const FPo={toc:[]},VPo="wrapper";function qPo(t){let{components:e,...n}=t;return(0,s.kt)(VPo,(0,p.Z)({},FPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}qPo.isMDXComponent=!0;const jPo={toc:[]},HPo="wrapper";function YPo(t){let{components:e,...n}=t;return(0,s.kt)(HPo,(0,p.Z)({},jPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}YPo.isMDXComponent=!0;const QPo={toc:[]},$Po="wrapper";function KPo(t){let{components:e,...n}=t;return(0,s.kt)($Po,(0,p.Z)({},QPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}KPo.isMDXComponent=!0;const JPo={toc:[]},tIo="wrapper";function eIo(t){let{components:e,...n}=t;return(0,s.kt)(tIo,(0,p.Z)({},JPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}eIo.isMDXComponent=!0;const nIo={toc:[]},oIo="wrapper";function pIo(t){let{components:e,...n}=t;return(0,s.kt)(oIo,(0,p.Z)({},nIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pIo.isMDXComponent=!0;const rIo={toc:[]},sIo="wrapper";function cIo(t){let{components:e,...n}=t;return(0,s.kt)(sIo,(0,p.Z)({},rIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cIo.isMDXComponent=!0;const aIo={toc:[]},iIo="wrapper";function lIo(t){let{components:e,...n}=t;return(0,s.kt)(iIo,(0,p.Z)({},aIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}lIo.isMDXComponent=!0;const uIo={toc:[]},mIo="wrapper";function dIo(t){let{components:e,...n}=t;return(0,s.kt)(mIo,(0,p.Z)({},uIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dIo.isMDXComponent=!0;const hIo={toc:[]},fIo="wrapper";function kIo(t){let{components:e,...n}=t;return(0,s.kt)(fIo,(0,p.Z)({},hIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}kIo.isMDXComponent=!0;const yIo={toc:[]},DIo="wrapper";function MIo(t){let{components:e,...n}=t;return(0,s.kt)(DIo,(0,p.Z)({},yIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}MIo.isMDXComponent=!0;const XIo={toc:[]},_Io="wrapper";function wIo(t){let{components:e,...n}=t;return(0,s.kt)(_Io,(0,p.Z)({},XIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wIo.isMDXComponent=!0;const TIo={toc:[]},CIo="wrapper";function gIo(t){let{components:e,...n}=t;return(0,s.kt)(CIo,(0,p.Z)({},TIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}gIo.isMDXComponent=!0;const xIo={toc:[]},vIo="wrapper";function LIo(t){let{components:e,...n}=t;return(0,s.kt)(vIo,(0,p.Z)({},xIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}LIo.isMDXComponent=!0;const ZIo={toc:[]},bIo="wrapper";function NIo(t){let{components:e,...n}=t;return(0,s.kt)(bIo,(0,p.Z)({},ZIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}NIo.isMDXComponent=!0;const zIo={toc:[]},AIo="wrapper";function PIo(t){let{components:e,...n}=t;return(0,s.kt)(AIo,(0,p.Z)({},zIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}PIo.isMDXComponent=!0;const IIo={toc:[]},WIo="wrapper";function RIo(t){let{components:e,...n}=t;return(0,s.kt)(WIo,(0,p.Z)({},IIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}RIo.isMDXComponent=!0;const SIo={toc:[]},BIo="wrapper";function GIo(t){let{components:e,...n}=t;return(0,s.kt)(BIo,(0,p.Z)({},SIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}GIo.isMDXComponent=!0;const EIo={toc:[]},OIo="wrapper";function UIo(t){let{components:e,...n}=t;return(0,s.kt)(OIo,(0,p.Z)({},EIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}UIo.isMDXComponent=!0;const FIo={toc:[]},VIo="wrapper";function qIo(t){let{components:e,...n}=t;return(0,s.kt)(VIo,(0,p.Z)({},FIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}qIo.isMDXComponent=!0;const jIo={toc:[]},HIo="wrapper";function YIo(t){let{components:e,...n}=t;return(0,s.kt)(HIo,(0,p.Z)({},jIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}YIo.isMDXComponent=!0;const QIo={toc:[]},$Io="wrapper";function KIo(t){let{components:e,...n}=t;return(0,s.kt)($Io,(0,p.Z)({},QIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}KIo.isMDXComponent=!0;const JIo={toc:[]},tWo="wrapper";function eWo(t){let{components:e,...n}=t;return(0,s.kt)(tWo,(0,p.Z)({},JIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}eWo.isMDXComponent=!0;const nWo={toc:[]},oWo="wrapper";function pWo(t){let{components:e,...n}=t;return(0,s.kt)(oWo,(0,p.Z)({},nWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}pWo.isMDXComponent=!0;const rWo={toc:[]},sWo="wrapper";function cWo(t){let{components:e,...n}=t;return(0,s.kt)(sWo,(0,p.Z)({},rWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}cWo.isMDXComponent=!0;const aWo={toc:[]},iWo="wrapper";function lWo(t){let{components:e,...n}=t;return(0,s.kt)(iWo,(0,p.Z)({},aWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}lWo.isMDXComponent=!0;const uWo={toc:[]},mWo="wrapper";function dWo(t){let{components:e,...n}=t;return(0,s.kt)(mWo,(0,p.Z)({},uWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dWo.isMDXComponent=!0;const hWo={toc:[]},fWo="wrapper";function kWo(t){let{components:e,...n}=t;return(0,s.kt)(fWo,(0,p.Z)({},hWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}kWo.isMDXComponent=!0;const yWo={toc:[]},DWo="wrapper";function MWo(t){let{components:e,...n}=t;return(0,s.kt)(DWo,(0,p.Z)({},yWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MWo.isMDXComponent=!0;const XWo={toc:[]},_Wo="wrapper";function wWo(t){let{components:e,...n}=t;return(0,s.kt)(_Wo,(0,p.Z)({},XWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wWo.isMDXComponent=!0;const TWo={toc:[]},CWo="wrapper";function gWo(t){let{components:e,...n}=t;return(0,s.kt)(CWo,(0,p.Z)({},TWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}gWo.isMDXComponent=!0;const xWo={toc:[]},vWo="wrapper";function LWo(t){let{components:e,...n}=t;return(0,s.kt)(vWo,(0,p.Z)({},xWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}LWo.isMDXComponent=!0;const ZWo={toc:[]},bWo="wrapper";function NWo(t){let{components:e,...n}=t;return(0,s.kt)(bWo,(0,p.Z)({},ZWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}NWo.isMDXComponent=!0;const zWo={toc:[]},AWo="wrapper";function PWo(t){let{components:e,...n}=t;return(0,s.kt)(AWo,(0,p.Z)({},zWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PWo.isMDXComponent=!0;const IWo={toc:[]},WWo="wrapper";function RWo(t){let{components:e,...n}=t;return(0,s.kt)(WWo,(0,p.Z)({},IWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}RWo.isMDXComponent=!0;const SWo={toc:[]},BWo="wrapper";function GWo(t){let{components:e,...n}=t;return(0,s.kt)(BWo,(0,p.Z)({},SWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}GWo.isMDXComponent=!0;const EWo={toc:[]},OWo="wrapper";function UWo(t){let{components:e,...n}=t;return(0,s.kt)(OWo,(0,p.Z)({},EWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}UWo.isMDXComponent=!0;const FWo={toc:[]},VWo="wrapper";function qWo(t){let{components:e,...n}=t;return(0,s.kt)(VWo,(0,p.Z)({},FWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qWo.isMDXComponent=!0;const jWo={toc:[]},HWo="wrapper";function YWo(t){let{components:e,...n}=t;return(0,s.kt)(HWo,(0,p.Z)({},jWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}YWo.isMDXComponent=!0;const QWo={toc:[]},$Wo="wrapper";function KWo(t){let{components:e,...n}=t;return(0,s.kt)($Wo,(0,p.Z)({},QWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}KWo.isMDXComponent=!0;const JWo={toc:[]},tRo="wrapper";function eRo(t){let{components:e,...n}=t;return(0,s.kt)(tRo,(0,p.Z)({},JWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}eRo.isMDXComponent=!0;const nRo={toc:[]},oRo="wrapper";function pRo(t){let{components:e,...n}=t;return(0,s.kt)(oRo,(0,p.Z)({},nRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}pRo.isMDXComponent=!0;const rRo={toc:[]},sRo="wrapper";function cRo(t){let{components:e,...n}=t;return(0,s.kt)(sRo,(0,p.Z)({},rRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}cRo.isMDXComponent=!0;const aRo={toc:[]},iRo="wrapper";function lRo(t){let{components:e,...n}=t;return(0,s.kt)(iRo,(0,p.Z)({},aRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lRo.isMDXComponent=!0;const uRo={toc:[]},mRo="wrapper";function dRo(t){let{components:e,...n}=t;return(0,s.kt)(mRo,(0,p.Z)({},uRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}dRo.isMDXComponent=!0;const hRo={toc:[]},fRo="wrapper";function kRo(t){let{components:e,...n}=t;return(0,s.kt)(fRo,(0,p.Z)({},hRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}kRo.isMDXComponent=!0;const yRo={toc:[]},DRo="wrapper";function MRo(t){let{components:e,...n}=t;return(0,s.kt)(DRo,(0,p.Z)({},yRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}MRo.isMDXComponent=!0;const XRo={toc:[]},_Ro="wrapper";function wRo(t){let{components:e,...n}=t;return(0,s.kt)(_Ro,(0,p.Z)({},XRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}wRo.isMDXComponent=!0;const TRo={toc:[]},CRo="wrapper";function gRo(t){let{components:e,...n}=t;return(0,s.kt)(CRo,(0,p.Z)({},TRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}gRo.isMDXComponent=!0;const xRo={toc:[]},vRo="wrapper";function LRo(t){let{components:e,...n}=t;return(0,s.kt)(vRo,(0,p.Z)({},xRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}LRo.isMDXComponent=!0;const ZRo={toc:[]},bRo="wrapper";function NRo(t){let{components:e,...n}=t;return(0,s.kt)(bRo,(0,p.Z)({},ZRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}NRo.isMDXComponent=!0;const zRo={toc:[]},ARo="wrapper";function PRo(t){let{components:e,...n}=t;return(0,s.kt)(ARo,(0,p.Z)({},zRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}PRo.isMDXComponent=!0;const IRo={toc:[]},WRo="wrapper";function RRo(t){let{components:e,...n}=t;return(0,s.kt)(WRo,(0,p.Z)({},IRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}RRo.isMDXComponent=!0;const SRo={toc:[]},BRo="wrapper";function GRo(t){let{components:e,...n}=t;return(0,s.kt)(BRo,(0,p.Z)({},SRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}GRo.isMDXComponent=!0;const ERo={toc:[]},ORo="wrapper";function URo(t){let{components:e,...n}=t;return(0,s.kt)(ORo,(0,p.Z)({},ERo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}URo.isMDXComponent=!0;const FRo={toc:[]},VRo="wrapper";function qRo(t){let{components:e,...n}=t;return(0,s.kt)(VRo,(0,p.Z)({},FRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}qRo.isMDXComponent=!0;const jRo={toc:[]},HRo="wrapper";function YRo(t){let{components:e,...n}=t;return(0,s.kt)(HRo,(0,p.Z)({},jRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}YRo.isMDXComponent=!0;const QRo={toc:[]},$Ro="wrapper";function KRo(t){let{components:e,...n}=t;return(0,s.kt)($Ro,(0,p.Z)({},QRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}KRo.isMDXComponent=!0;const JRo={toc:[]},tSo="wrapper";function eSo(t){let{components:e,...n}=t;return(0,s.kt)(tSo,(0,p.Z)({},JRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eSo.isMDXComponent=!0;const nSo={toc:[]},oSo="wrapper";function pSo(t){let{components:e,...n}=t;return(0,s.kt)(oSo,(0,p.Z)({},nSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}pSo.isMDXComponent=!0;const rSo={toc:[]},sSo="wrapper";function cSo(t){let{components:e,...n}=t;return(0,s.kt)(sSo,(0,p.Z)({},rSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cSo.isMDXComponent=!0;const aSo={toc:[]},iSo="wrapper";function lSo(t){let{components:e,...n}=t;return(0,s.kt)(iSo,(0,p.Z)({},aSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}lSo.isMDXComponent=!0;const uSo={toc:[]},mSo="wrapper";function dSo(t){let{components:e,...n}=t;return(0,s.kt)(mSo,(0,p.Z)({},uSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}dSo.isMDXComponent=!0;const hSo={toc:[]},fSo="wrapper";function kSo(t){let{components:e,...n}=t;return(0,s.kt)(fSo,(0,p.Z)({},hSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kSo.isMDXComponent=!0;const ySo={toc:[]},DSo="wrapper";function MSo(t){let{components:e,...n}=t;return(0,s.kt)(DSo,(0,p.Z)({},ySo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}MSo.isMDXComponent=!0;const XSo={toc:[]},_So="wrapper";function wSo(t){let{components:e,...n}=t;return(0,s.kt)(_So,(0,p.Z)({},XSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wSo.isMDXComponent=!0;const TSo={toc:[]},CSo="wrapper";function gSo(t){let{components:e,...n}=t;return(0,s.kt)(CSo,(0,p.Z)({},TSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}gSo.isMDXComponent=!0;const xSo={toc:[]},vSo="wrapper";function LSo(t){let{components:e,...n}=t;return(0,s.kt)(vSo,(0,p.Z)({},xSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LSo.isMDXComponent=!0;const ZSo={toc:[]},bSo="wrapper";function NSo(t){let{components:e,...n}=t;return(0,s.kt)(bSo,(0,p.Z)({},ZSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}NSo.isMDXComponent=!0;const zSo={toc:[]},ASo="wrapper";function PSo(t){let{components:e,...n}=t;return(0,s.kt)(ASo,(0,p.Z)({},zSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}PSo.isMDXComponent=!0;const ISo={toc:[]},WSo="wrapper";function RSo(t){let{components:e,...n}=t;return(0,s.kt)(WSo,(0,p.Z)({},ISo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}RSo.isMDXComponent=!0;const SSo={toc:[]},BSo="wrapper";function GSo(t){let{components:e,...n}=t;return(0,s.kt)(BSo,(0,p.Z)({},SSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}GSo.isMDXComponent=!0;const ESo={toc:[]},OSo="wrapper";function USo(t){let{components:e,...n}=t;return(0,s.kt)(OSo,(0,p.Z)({},ESo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}USo.isMDXComponent=!0;const FSo={toc:[]},VSo="wrapper";function qSo(t){let{components:e,...n}=t;return(0,s.kt)(VSo,(0,p.Z)({},FSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}qSo.isMDXComponent=!0;const jSo={toc:[]},HSo="wrapper";function YSo(t){let{components:e,...n}=t;return(0,s.kt)(HSo,(0,p.Z)({},jSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}YSo.isMDXComponent=!0;const QSo={toc:[]},$So="wrapper";function KSo(t){let{components:e,...n}=t;return(0,s.kt)($So,(0,p.Z)({},QSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}KSo.isMDXComponent=!0;const JSo={toc:[]},tBo="wrapper";function eBo(t){let{components:e,...n}=t;return(0,s.kt)(tBo,(0,p.Z)({},JSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}eBo.isMDXComponent=!0;const nBo={toc:[]},oBo="wrapper";function pBo(t){let{components:e,...n}=t;return(0,s.kt)(oBo,(0,p.Z)({},nBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}pBo.isMDXComponent=!0;const rBo={toc:[]},sBo="wrapper";function cBo(t){let{components:e,...n}=t;return(0,s.kt)(sBo,(0,p.Z)({},rBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}cBo.isMDXComponent=!0;const aBo={toc:[]},iBo="wrapper";function lBo(t){let{components:e,...n}=t;return(0,s.kt)(iBo,(0,p.Z)({},aBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}lBo.isMDXComponent=!0;const uBo={toc:[]},mBo="wrapper";function dBo(t){let{components:e,...n}=t;return(0,s.kt)(mBo,(0,p.Z)({},uBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}dBo.isMDXComponent=!0;const hBo={toc:[]},fBo="wrapper";function kBo(t){let{components:e,...n}=t;return(0,s.kt)(fBo,(0,p.Z)({},hBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}kBo.isMDXComponent=!0;const yBo={toc:[]},DBo="wrapper";function MBo(t){let{components:e,...n}=t;return(0,s.kt)(DBo,(0,p.Z)({},yBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}MBo.isMDXComponent=!0;const XBo={toc:[]},_Bo="wrapper";function wBo(t){let{components:e,...n}=t;return(0,s.kt)(_Bo,(0,p.Z)({},XBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wBo.isMDXComponent=!0;const TBo={toc:[]},CBo="wrapper";function gBo(t){let{components:e,...n}=t;return(0,s.kt)(CBo,(0,p.Z)({},TBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}gBo.isMDXComponent=!0;const xBo={toc:[]},vBo="wrapper";function LBo(t){let{components:e,...n}=t;return(0,s.kt)(vBo,(0,p.Z)({},xBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}LBo.isMDXComponent=!0;const ZBo={toc:[]},bBo="wrapper";function NBo(t){let{components:e,...n}=t;return(0,s.kt)(bBo,(0,p.Z)({},ZBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}NBo.isMDXComponent=!0;const zBo={toc:[]},ABo="wrapper";function PBo(t){let{components:e,...n}=t;return(0,s.kt)(ABo,(0,p.Z)({},zBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}PBo.isMDXComponent=!0;const IBo={toc:[]},WBo="wrapper";function RBo(t){let{components:e,...n}=t;return(0,s.kt)(WBo,(0,p.Z)({},IBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}RBo.isMDXComponent=!0;const SBo={toc:[]},BBo="wrapper";function GBo(t){let{components:e,...n}=t;return(0,s.kt)(BBo,(0,p.Z)({},SBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}GBo.isMDXComponent=!0;const EBo={toc:[]},OBo="wrapper";function UBo(t){let{components:e,...n}=t;return(0,s.kt)(OBo,(0,p.Z)({},EBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}UBo.isMDXComponent=!0;const FBo={toc:[]},VBo="wrapper";function qBo(t){let{components:e,...n}=t;return(0,s.kt)(VBo,(0,p.Z)({},FBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}qBo.isMDXComponent=!0;const jBo={toc:[]},HBo="wrapper";function YBo(t){let{components:e,...n}=t;return(0,s.kt)(HBo,(0,p.Z)({},jBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}YBo.isMDXComponent=!0;const QBo={toc:[]},$Bo="wrapper";function KBo(t){let{components:e,...n}=t;return(0,s.kt)($Bo,(0,p.Z)({},QBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}KBo.isMDXComponent=!0;const JBo={toc:[]},tGo="wrapper";function eGo(t){let{components:e,...n}=t;return(0,s.kt)(tGo,(0,p.Z)({},JBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}eGo.isMDXComponent=!0;const nGo={toc:[]},oGo="wrapper";function pGo(t){let{components:e,...n}=t;return(0,s.kt)(oGo,(0,p.Z)({},nGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}pGo.isMDXComponent=!0;const rGo={toc:[]},sGo="wrapper";function cGo(t){let{components:e,...n}=t;return(0,s.kt)(sGo,(0,p.Z)({},rGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}cGo.isMDXComponent=!0;const aGo={toc:[]},iGo="wrapper";function lGo(t){let{components:e,...n}=t;return(0,s.kt)(iGo,(0,p.Z)({},aGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lGo.isMDXComponent=!0;const uGo={toc:[]},mGo="wrapper";function dGo(t){let{components:e,...n}=t;return(0,s.kt)(mGo,(0,p.Z)({},uGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}dGo.isMDXComponent=!0;const hGo={toc:[]},fGo="wrapper";function kGo(t){let{components:e,...n}=t;return(0,s.kt)(fGo,(0,p.Z)({},hGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}kGo.isMDXComponent=!0;const yGo={toc:[]},DGo="wrapper";function MGo(t){let{components:e,...n}=t;return(0,s.kt)(DGo,(0,p.Z)({},yGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}MGo.isMDXComponent=!0;const XGo={toc:[]},_Go="wrapper";function wGo(t){let{components:e,...n}=t;return(0,s.kt)(_Go,(0,p.Z)({},XGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}wGo.isMDXComponent=!0;const TGo={toc:[]},CGo="wrapper";function gGo(t){let{components:e,...n}=t;return(0,s.kt)(CGo,(0,p.Z)({},TGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}gGo.isMDXComponent=!0;const xGo={toc:[]},vGo="wrapper";function LGo(t){let{components:e,...n}=t;return(0,s.kt)(vGo,(0,p.Z)({},xGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}LGo.isMDXComponent=!0;const ZGo={toc:[]},bGo="wrapper";function NGo(t){let{components:e,...n}=t;return(0,s.kt)(bGo,(0,p.Z)({},ZGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."))}NGo.isMDXComponent=!0;const zGo={toc:[]},AGo="wrapper";function PGo(t){let{components:e,...n}=t;return(0,s.kt)(AGo,(0,p.Z)({},zGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}PGo.isMDXComponent=!0;const IGo={toc:[]},WGo="wrapper";function RGo(t){let{components:e,...n}=t;return(0,s.kt)(WGo,(0,p.Z)({},IGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}RGo.isMDXComponent=!0;const SGo={toc:[]},BGo="wrapper";function GGo(t){let{components:e,...n}=t;return(0,s.kt)(BGo,(0,p.Z)({},SGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}GGo.isMDXComponent=!0;const EGo={toc:[]},OGo="wrapper";function UGo(t){let{components:e,...n}=t;return(0,s.kt)(OGo,(0,p.Z)({},EGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}UGo.isMDXComponent=!0;const FGo={toc:[]},VGo="wrapper";function qGo(t){let{components:e,...n}=t;return(0,s.kt)(VGo,(0,p.Z)({},FGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qGo.isMDXComponent=!0;const jGo={toc:[]},HGo="wrapper";function YGo(t){let{components:e,...n}=t;return(0,s.kt)(HGo,(0,p.Z)({},jGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}YGo.isMDXComponent=!0;const QGo={toc:[]},$Go="wrapper";function KGo(t){let{components:e,...n}=t;return(0,s.kt)($Go,(0,p.Z)({},QGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}KGo.isMDXComponent=!0;const JGo={toc:[]},tEo="wrapper";function eEo(t){let{components:e,...n}=t;return(0,s.kt)(tEo,(0,p.Z)({},JGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}eEo.isMDXComponent=!0;const nEo={toc:[]},oEo="wrapper";function pEo(t){let{components:e,...n}=t;return(0,s.kt)(oEo,(0,p.Z)({},nEo,n,{components:e,mdxType:"MDXLayout"}))}pEo.isMDXComponent=!0;const rEo={toc:[]},sEo="wrapper";function cEo(t){let{components:e,...n}=t;return(0,s.kt)(sEo,(0,p.Z)({},rEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cEo.isMDXComponent=!0;const aEo={toc:[]},iEo="wrapper";function lEo(t){let{components:e,...n}=t;return(0,s.kt)(iEo,(0,p.Z)({},aEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lEo.isMDXComponent=!0;const uEo={toc:[]},mEo="wrapper";function dEo(t){let{components:e,...n}=t;return(0,s.kt)(mEo,(0,p.Z)({},uEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}dEo.isMDXComponent=!0;const hEo={toc:[]},fEo="wrapper";function kEo(t){let{components:e,...n}=t;return(0,s.kt)(fEo,(0,p.Z)({},hEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}kEo.isMDXComponent=!0;const yEo={toc:[]},DEo="wrapper";function MEo(t){let{components:e,...n}=t;return(0,s.kt)(DEo,(0,p.Z)({},yEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}MEo.isMDXComponent=!0;const XEo={toc:[]},_Eo="wrapper";function wEo(t){let{components:e,...n}=t;return(0,s.kt)(_Eo,(0,p.Z)({},XEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}wEo.isMDXComponent=!0;const TEo={toc:[]},CEo="wrapper";function gEo(t){let{components:e,...n}=t;return(0,s.kt)(CEo,(0,p.Z)({},TEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}gEo.isMDXComponent=!0;const xEo={toc:[]},vEo="wrapper";function LEo(t){let{components:e,...n}=t;return(0,s.kt)(vEo,(0,p.Z)({},xEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The smoothness of the spline when using auto-calculated handles."))}LEo.isMDXComponent=!0;const ZEo={toc:[]},bEo="wrapper";function NEo(t){let{components:e,...n}=t;return(0,s.kt)(bEo,(0,p.Z)({},ZEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}NEo.isMDXComponent=!0;const zEo={toc:[]},AEo="wrapper";function PEo(t){let{components:e,...n}=t;return(0,s.kt)(AEo,(0,p.Z)({},zEo,n,{components:e,mdxType:"MDXLayout"}))}PEo.isMDXComponent=!0;const IEo={toc:[]},WEo="wrapper";function REo(t){let{components:e,...n}=t;return(0,s.kt)(WEo,(0,p.Z)({},IEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}REo.isMDXComponent=!0;const SEo={toc:[]},BEo="wrapper";function GEo(t){let{components:e,...n}=t;return(0,s.kt)(BEo,(0,p.Z)({},SEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}GEo.isMDXComponent=!0;const EEo={toc:[]},OEo="wrapper";function UEo(t){let{components:e,...n}=t;return(0,s.kt)(OEo,(0,p.Z)({},EEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}UEo.isMDXComponent=!0;const FEo={toc:[]},VEo="wrapper";function qEo(t){let{components:e,...n}=t;return(0,s.kt)(VEo,(0,p.Z)({},FEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qEo.isMDXComponent=!0;const jEo={toc:[]},HEo="wrapper";function YEo(t){let{components:e,...n}=t;return(0,s.kt)(HEo,(0,p.Z)({},jEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}YEo.isMDXComponent=!0;const QEo={toc:[]},$Eo="wrapper";function KEo(t){let{components:e,...n}=t;return(0,s.kt)($Eo,(0,p.Z)({},QEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}KEo.isMDXComponent=!0;const JEo={toc:[]},tOo="wrapper";function eOo(t){let{components:e,...n}=t;return(0,s.kt)(tOo,(0,p.Z)({},JEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}eOo.isMDXComponent=!0;const nOo={toc:[]},oOo="wrapper";function pOo(t){let{components:e,...n}=t;return(0,s.kt)(oOo,(0,p.Z)({},nOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pOo.isMDXComponent=!0;const rOo={toc:[]},sOo="wrapper";function cOo(t){let{components:e,...n}=t;return(0,s.kt)(sOo,(0,p.Z)({},rOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}cOo.isMDXComponent=!0;const aOo={toc:[]},iOo="wrapper";function lOo(t){let{components:e,...n}=t;return(0,s.kt)(iOo,(0,p.Z)({},aOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lOo.isMDXComponent=!0;const uOo={toc:[]},mOo="wrapper";function dOo(t){let{components:e,...n}=t;return(0,s.kt)(mOo,(0,p.Z)({},uOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}dOo.isMDXComponent=!0;const hOo={toc:[]},fOo="wrapper";function kOo(t){let{components:e,...n}=t;return(0,s.kt)(fOo,(0,p.Z)({},hOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}kOo.isMDXComponent=!0;const yOo={toc:[]},DOo="wrapper";function MOo(t){let{components:e,...n}=t;return(0,s.kt)(DOo,(0,p.Z)({},yOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}MOo.isMDXComponent=!0;const XOo={toc:[]},_Oo="wrapper";function wOo(t){let{components:e,...n}=t;return(0,s.kt)(_Oo,(0,p.Z)({},XOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wOo.isMDXComponent=!0;const TOo={toc:[]},COo="wrapper";function gOo(t){let{components:e,...n}=t;return(0,s.kt)(COo,(0,p.Z)({},TOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}gOo.isMDXComponent=!0;const xOo={toc:[]},vOo="wrapper";function LOo(t){let{components:e,...n}=t;return(0,s.kt)(vOo,(0,p.Z)({},xOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}LOo.isMDXComponent=!0;const ZOo={toc:[]},bOo="wrapper";function NOo(t){let{components:e,...n}=t;return(0,s.kt)(bOo,(0,p.Z)({},ZOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}NOo.isMDXComponent=!0;const zOo={toc:[]},AOo="wrapper";function POo(t){let{components:e,...n}=t;return(0,s.kt)(AOo,(0,p.Z)({},zOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}POo.isMDXComponent=!0;const IOo={toc:[]},WOo="wrapper";function ROo(t){let{components:e,...n}=t;return(0,s.kt)(WOo,(0,p.Z)({},IOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}ROo.isMDXComponent=!0;const SOo={toc:[]},BOo="wrapper";function GOo(t){let{components:e,...n}=t;return(0,s.kt)(BOo,(0,p.Z)({},SOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}GOo.isMDXComponent=!0;const EOo={toc:[]},OOo="wrapper";function UOo(t){let{components:e,...n}=t;return(0,s.kt)(OOo,(0,p.Z)({},EOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}UOo.isMDXComponent=!0;const FOo={toc:[]},VOo="wrapper";function qOo(t){let{components:e,...n}=t;return(0,s.kt)(VOo,(0,p.Z)({},FOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qOo.isMDXComponent=!0;const jOo={toc:[]},HOo="wrapper";function YOo(t){let{components:e,...n}=t;return(0,s.kt)(HOo,(0,p.Z)({},jOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}YOo.isMDXComponent=!0;const QOo={toc:[]},$Oo="wrapper";function KOo(t){let{components:e,...n}=t;return(0,s.kt)($Oo,(0,p.Z)({},QOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}KOo.isMDXComponent=!0;const JOo={toc:[]},tUo="wrapper";function eUo(t){let{components:e,...n}=t;return(0,s.kt)(tUo,(0,p.Z)({},JOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}eUo.isMDXComponent=!0;const nUo={toc:[]},oUo="wrapper";function pUo(t){let{components:e,...n}=t;return(0,s.kt)(oUo,(0,p.Z)({},nUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}pUo.isMDXComponent=!0;const rUo={toc:[]},sUo="wrapper";function cUo(t){let{components:e,...n}=t;return(0,s.kt)(sUo,(0,p.Z)({},rUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}cUo.isMDXComponent=!0;const aUo={toc:[]},iUo="wrapper";function lUo(t){let{components:e,...n}=t;return(0,s.kt)(iUo,(0,p.Z)({},aUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lUo.isMDXComponent=!0;const uUo={toc:[]},mUo="wrapper";function dUo(t){let{components:e,...n}=t;return(0,s.kt)(mUo,(0,p.Z)({},uUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}dUo.isMDXComponent=!0;const hUo={toc:[]},fUo="wrapper";function kUo(t){let{components:e,...n}=t;return(0,s.kt)(fUo,(0,p.Z)({},hUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}kUo.isMDXComponent=!0;const yUo={toc:[]},DUo="wrapper";function MUo(t){let{components:e,...n}=t;return(0,s.kt)(DUo,(0,p.Z)({},yUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}MUo.isMDXComponent=!0;const XUo={toc:[]},_Uo="wrapper";function wUo(t){let{components:e,...n}=t;return(0,s.kt)(_Uo,(0,p.Z)({},XUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}wUo.isMDXComponent=!0;const TUo={toc:[]},CUo="wrapper";function gUo(t){let{components:e,...n}=t;return(0,s.kt)(CUo,(0,p.Z)({},TUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}gUo.isMDXComponent=!0;const xUo={toc:[]},vUo="wrapper";function LUo(t){let{components:e,...n}=t;return(0,s.kt)(vUo,(0,p.Z)({},xUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}LUo.isMDXComponent=!0;const ZUo={toc:[]},bUo="wrapper";function NUo(t){let{components:e,...n}=t;return(0,s.kt)(bUo,(0,p.Z)({},ZUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}NUo.isMDXComponent=!0;const zUo={toc:[]},AUo="wrapper";function PUo(t){let{components:e,...n}=t;return(0,s.kt)(AUo,(0,p.Z)({},zUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}PUo.isMDXComponent=!0;const IUo={toc:[]},WUo="wrapper";function RUo(t){let{components:e,...n}=t;return(0,s.kt)(WUo,(0,p.Z)({},IUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}RUo.isMDXComponent=!0;const SUo={toc:[]},BUo="wrapper";function GUo(t){let{components:e,...n}=t;return(0,s.kt)(BUo,(0,p.Z)({},SUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}GUo.isMDXComponent=!0;const EUo={toc:[]},OUo="wrapper";function UUo(t){let{components:e,...n}=t;return(0,s.kt)(OUo,(0,p.Z)({},EUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}UUo.isMDXComponent=!0;const FUo={toc:[]},VUo="wrapper";function qUo(t){let{components:e,...n}=t;return(0,s.kt)(VUo,(0,p.Z)({},FUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}qUo.isMDXComponent=!0;const jUo={toc:[]},HUo="wrapper";function YUo(t){let{components:e,...n}=t;return(0,s.kt)(HUo,(0,p.Z)({},jUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}YUo.isMDXComponent=!0;const QUo={toc:[]},$Uo="wrapper";function KUo(t){let{components:e,...n}=t;return(0,s.kt)($Uo,(0,p.Z)({},QUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}KUo.isMDXComponent=!0;const JUo={toc:[]},tFo="wrapper";function eFo(t){let{components:e,...n}=t;return(0,s.kt)(tFo,(0,p.Z)({},JUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}eFo.isMDXComponent=!0;const nFo={toc:[]},oFo="wrapper";function pFo(t){let{components:e,...n}=t;return(0,s.kt)(oFo,(0,p.Z)({},nFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}pFo.isMDXComponent=!0;const rFo={toc:[]},sFo="wrapper";function cFo(t){let{components:e,...n}=t;return(0,s.kt)(sFo,(0,p.Z)({},rFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}cFo.isMDXComponent=!0;const aFo={toc:[]},iFo="wrapper";function lFo(t){let{components:e,...n}=t;return(0,s.kt)(iFo,(0,p.Z)({},aFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}lFo.isMDXComponent=!0;const uFo={toc:[]},mFo="wrapper";function dFo(t){let{components:e,...n}=t;return(0,s.kt)(mFo,(0,p.Z)({},uFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}dFo.isMDXComponent=!0;const hFo={toc:[]},fFo="wrapper";function kFo(t){let{components:e,...n}=t;return(0,s.kt)(fFo,(0,p.Z)({},hFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}kFo.isMDXComponent=!0;const yFo={toc:[]},DFo="wrapper";function MFo(t){let{components:e,...n}=t;return(0,s.kt)(DFo,(0,p.Z)({},yFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}MFo.isMDXComponent=!0;const XFo={toc:[]},_Fo="wrapper";function wFo(t){let{components:e,...n}=t;return(0,s.kt)(_Fo,(0,p.Z)({},XFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wFo.isMDXComponent=!0;const TFo={toc:[]},CFo="wrapper";function gFo(t){let{components:e,...n}=t;return(0,s.kt)(CFo,(0,p.Z)({},TFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}gFo.isMDXComponent=!0;const xFo={toc:[]},vFo="wrapper";function LFo(t){let{components:e,...n}=t;return(0,s.kt)(vFo,(0,p.Z)({},xFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}LFo.isMDXComponent=!0;const ZFo={toc:[]},bFo="wrapper";function NFo(t){let{components:e,...n}=t;return(0,s.kt)(bFo,(0,p.Z)({},ZFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}NFo.isMDXComponent=!0;const zFo={toc:[]},AFo="wrapper";function PFo(t){let{components:e,...n}=t;return(0,s.kt)(AFo,(0,p.Z)({},zFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}PFo.isMDXComponent=!0;const IFo={toc:[]},WFo="wrapper";function RFo(t){let{components:e,...n}=t;return(0,s.kt)(WFo,(0,p.Z)({},IFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}RFo.isMDXComponent=!0;const SFo={toc:[]},BFo="wrapper";function GFo(t){let{components:e,...n}=t;return(0,s.kt)(BFo,(0,p.Z)({},SFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}GFo.isMDXComponent=!0;const EFo={toc:[]},OFo="wrapper";function UFo(t){let{components:e,...n}=t;return(0,s.kt)(OFo,(0,p.Z)({},EFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}UFo.isMDXComponent=!0;const FFo={toc:[]},VFo="wrapper";function qFo(t){let{components:e,...n}=t;return(0,s.kt)(VFo,(0,p.Z)({},FFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qFo.isMDXComponent=!0;const jFo={toc:[]},HFo="wrapper";function YFo(t){let{components:e,...n}=t;return(0,s.kt)(HFo,(0,p.Z)({},jFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}YFo.isMDXComponent=!0;const QFo={toc:[]},$Fo="wrapper";function KFo(t){let{components:e,...n}=t;return(0,s.kt)($Fo,(0,p.Z)({},QFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}KFo.isMDXComponent=!0;const JFo={toc:[]},tVo="wrapper";function eVo(t){let{components:e,...n}=t;return(0,s.kt)(tVo,(0,p.Z)({},JFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}eVo.isMDXComponent=!0;const nVo={toc:[]},oVo="wrapper";function pVo(t){let{components:e,...n}=t;return(0,s.kt)(oVo,(0,p.Z)({},nVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pVo.isMDXComponent=!0;const rVo={toc:[]},sVo="wrapper";function cVo(t){let{components:e,...n}=t;return(0,s.kt)(sVo,(0,p.Z)({},rVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}cVo.isMDXComponent=!0;const aVo={toc:[]},iVo="wrapper";function lVo(t){let{components:e,...n}=t;return(0,s.kt)(iVo,(0,p.Z)({},aVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lVo.isMDXComponent=!0;const uVo={toc:[]},mVo="wrapper";function dVo(t){let{components:e,...n}=t;return(0,s.kt)(mVo,(0,p.Z)({},uVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}dVo.isMDXComponent=!0;const hVo={toc:[]},fVo="wrapper";function kVo(t){let{components:e,...n}=t;return(0,s.kt)(fVo,(0,p.Z)({},hVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kVo.isMDXComponent=!0;const yVo={toc:[]},DVo="wrapper";function MVo(t){let{components:e,...n}=t;return(0,s.kt)(DVo,(0,p.Z)({},yVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}MVo.isMDXComponent=!0;const XVo={toc:[]},_Vo="wrapper";function wVo(t){let{components:e,...n}=t;return(0,s.kt)(_Vo,(0,p.Z)({},XVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wVo.isMDXComponent=!0;const TVo={toc:[]},CVo="wrapper";function gVo(t){let{components:e,...n}=t;return(0,s.kt)(CVo,(0,p.Z)({},TVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}gVo.isMDXComponent=!0;const xVo={toc:[]},vVo="wrapper";function LVo(t){let{components:e,...n}=t;return(0,s.kt)(vVo,(0,p.Z)({},xVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LVo.isMDXComponent=!0;const ZVo={toc:[]},bVo="wrapper";function NVo(t){let{components:e,...n}=t;return(0,s.kt)(bVo,(0,p.Z)({},ZVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}NVo.isMDXComponent=!0;const zVo={toc:[]},AVo="wrapper";function PVo(t){let{components:e,...n}=t;return(0,s.kt)(AVo,(0,p.Z)({},zVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}PVo.isMDXComponent=!0;const IVo={toc:[]},WVo="wrapper";function RVo(t){let{components:e,...n}=t;return(0,s.kt)(WVo,(0,p.Z)({},IVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}RVo.isMDXComponent=!0;const SVo={toc:[]},BVo="wrapper";function GVo(t){let{components:e,...n}=t;return(0,s.kt)(BVo,(0,p.Z)({},SVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}GVo.isMDXComponent=!0;const EVo={toc:[]},OVo="wrapper";function UVo(t){let{components:e,...n}=t;return(0,s.kt)(OVo,(0,p.Z)({},EVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}UVo.isMDXComponent=!0;const FVo={toc:[]},VVo="wrapper";function qVo(t){let{components:e,...n}=t;return(0,s.kt)(VVo,(0,p.Z)({},FVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}qVo.isMDXComponent=!0;const jVo={toc:[]},HVo="wrapper";function YVo(t){let{components:e,...n}=t;return(0,s.kt)(HVo,(0,p.Z)({},jVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}YVo.isMDXComponent=!0;const QVo={toc:[]},$Vo="wrapper";function KVo(t){let{components:e,...n}=t;return(0,s.kt)($Vo,(0,p.Z)({},QVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}KVo.isMDXComponent=!0;const JVo={toc:[]},tqo="wrapper";function eqo(t){let{components:e,...n}=t;return(0,s.kt)(tqo,(0,p.Z)({},JVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}eqo.isMDXComponent=!0;const nqo={toc:[]},oqo="wrapper";function pqo(t){let{components:e,...n}=t;return(0,s.kt)(oqo,(0,p.Z)({},nqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}pqo.isMDXComponent=!0;const rqo={toc:[]},sqo="wrapper";function cqo(t){let{components:e,...n}=t;return(0,s.kt)(sqo,(0,p.Z)({},rqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}cqo.isMDXComponent=!0;const aqo={toc:[]},iqo="wrapper";function lqo(t){let{components:e,...n}=t;return(0,s.kt)(iqo,(0,p.Z)({},aqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lqo.isMDXComponent=!0;const uqo={toc:[]},mqo="wrapper";function dqo(t){let{components:e,...n}=t;return(0,s.kt)(mqo,(0,p.Z)({},uqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}dqo.isMDXComponent=!0;const hqo={toc:[]},fqo="wrapper";function kqo(t){let{components:e,...n}=t;return(0,s.kt)(fqo,(0,p.Z)({},hqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}kqo.isMDXComponent=!0;const yqo={toc:[]},Dqo="wrapper";function Mqo(t){let{components:e,...n}=t;return(0,s.kt)(Dqo,(0,p.Z)({},yqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Mqo.isMDXComponent=!0;const Xqo={toc:[]},_qo="wrapper";function wqo(t){let{components:e,...n}=t;return(0,s.kt)(_qo,(0,p.Z)({},Xqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wqo.isMDXComponent=!0;const Tqo={toc:[]},Cqo="wrapper";function gqo(t){let{components:e,...n}=t;return(0,s.kt)(Cqo,(0,p.Z)({},Tqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gqo.isMDXComponent=!0;const xqo={toc:[]},vqo="wrapper";function Lqo(t){let{components:e,...n}=t;return(0,s.kt)(vqo,(0,p.Z)({},xqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Lqo.isMDXComponent=!0;const Zqo={toc:[]},bqo="wrapper";function Nqo(t){let{components:e,...n}=t;return(0,s.kt)(bqo,(0,p.Z)({},Zqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Nqo.isMDXComponent=!0;const zqo={toc:[]},Aqo="wrapper";function Pqo(t){let{components:e,...n}=t;return(0,s.kt)(Aqo,(0,p.Z)({},zqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Pqo.isMDXComponent=!0;const Iqo={toc:[]},Wqo="wrapper";function Rqo(t){let{components:e,...n}=t;return(0,s.kt)(Wqo,(0,p.Z)({},Iqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Rqo.isMDXComponent=!0;const Sqo={toc:[]},Bqo="wrapper";function Gqo(t){let{components:e,...n}=t;return(0,s.kt)(Bqo,(0,p.Z)({},Sqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Gqo.isMDXComponent=!0;const Eqo={toc:[]},Oqo="wrapper";function Uqo(t){let{components:e,...n}=t;return(0,s.kt)(Oqo,(0,p.Z)({},Eqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Uqo.isMDXComponent=!0;const Fqo={toc:[]},Vqo="wrapper";function qqo(t){let{components:e,...n}=t;return(0,s.kt)(Vqo,(0,p.Z)({},Fqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}qqo.isMDXComponent=!0;const jqo={toc:[]},Hqo="wrapper";function Yqo(t){let{components:e,...n}=t;return(0,s.kt)(Hqo,(0,p.Z)({},jqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Yqo.isMDXComponent=!0;const Qqo={toc:[]},$qo="wrapper";function Kqo(t){let{components:e,...n}=t;return(0,s.kt)($qo,(0,p.Z)({},Qqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Kqo.isMDXComponent=!0;const Jqo={toc:[]},tjo="wrapper";function ejo(t){let{components:e,...n}=t;return(0,s.kt)(tjo,(0,p.Z)({},Jqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ejo.isMDXComponent=!0;const njo={toc:[]},ojo="wrapper";function pjo(t){let{components:e,...n}=t;return(0,s.kt)(ojo,(0,p.Z)({},njo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pjo.isMDXComponent=!0;const rjo={toc:[]},sjo="wrapper";function cjo(t){let{components:e,...n}=t;return(0,s.kt)(sjo,(0,p.Z)({},rjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cjo.isMDXComponent=!0;const ajo={toc:[]},ijo="wrapper";function ljo(t){let{components:e,...n}=t;return(0,s.kt)(ijo,(0,p.Z)({},ajo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ljo.isMDXComponent=!0;const ujo={toc:[]},mjo="wrapper";function djo(t){let{components:e,...n}=t;return(0,s.kt)(mjo,(0,p.Z)({},ujo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}djo.isMDXComponent=!0;const hjo={toc:[]},fjo="wrapper";function kjo(t){let{components:e,...n}=t;return(0,s.kt)(fjo,(0,p.Z)({},hjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}kjo.isMDXComponent=!0;const yjo={toc:[]},Djo="wrapper";function Mjo(t){let{components:e,...n}=t;return(0,s.kt)(Djo,(0,p.Z)({},yjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Mjo.isMDXComponent=!0;const Xjo={toc:[]},_jo="wrapper";function wjo(t){let{components:e,...n}=t;return(0,s.kt)(_jo,(0,p.Z)({},Xjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}wjo.isMDXComponent=!0;const Tjo={toc:[]},Cjo="wrapper";function gjo(t){let{components:e,...n}=t;return(0,s.kt)(Cjo,(0,p.Z)({},Tjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gjo.isMDXComponent=!0;const xjo={toc:[]},vjo="wrapper";function Ljo(t){let{components:e,...n}=t;return(0,s.kt)(vjo,(0,p.Z)({},xjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Ljo.isMDXComponent=!0;const Zjo={toc:[]},bjo="wrapper";function Njo(t){let{components:e,...n}=t;return(0,s.kt)(bjo,(0,p.Z)({},Zjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Njo.isMDXComponent=!0;const zjo={toc:[]},Ajo="wrapper";function Pjo(t){let{components:e,...n}=t;return(0,s.kt)(Ajo,(0,p.Z)({},zjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Pjo.isMDXComponent=!0;const Ijo={toc:[]},Wjo="wrapper";function Rjo(t){let{components:e,...n}=t;return(0,s.kt)(Wjo,(0,p.Z)({},Ijo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Rjo.isMDXComponent=!0;const Sjo={toc:[]},Bjo="wrapper";function Gjo(t){let{components:e,...n}=t;return(0,s.kt)(Bjo,(0,p.Z)({},Sjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Gjo.isMDXComponent=!0;const Ejo={toc:[]},Ojo="wrapper";function Ujo(t){let{components:e,...n}=t;return(0,s.kt)(Ojo,(0,p.Z)({},Ejo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Ujo.isMDXComponent=!0;const Fjo={toc:[]},Vjo="wrapper";function qjo(t){let{components:e,...n}=t;return(0,s.kt)(Vjo,(0,p.Z)({},Fjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qjo.isMDXComponent=!0;const jjo={toc:[]},Hjo="wrapper";function Yjo(t){let{components:e,...n}=t;return(0,s.kt)(Hjo,(0,p.Z)({},jjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Yjo.isMDXComponent=!0;const Qjo={toc:[]},$jo="wrapper";function Kjo(t){let{components:e,...n}=t;return(0,s.kt)($jo,(0,p.Z)({},Qjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Kjo.isMDXComponent=!0;const Jjo={toc:[]},tHo="wrapper";function eHo(t){let{components:e,...n}=t;return(0,s.kt)(tHo,(0,p.Z)({},Jjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}eHo.isMDXComponent=!0;const nHo={toc:[]},oHo="wrapper";function pHo(t){let{components:e,...n}=t;return(0,s.kt)(oHo,(0,p.Z)({},nHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pHo.isMDXComponent=!0;const rHo={toc:[]},sHo="wrapper";function cHo(t){let{components:e,...n}=t;return(0,s.kt)(sHo,(0,p.Z)({},rHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}cHo.isMDXComponent=!0;const aHo={toc:[]},iHo="wrapper";function lHo(t){let{components:e,...n}=t;return(0,s.kt)(iHo,(0,p.Z)({},aHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}lHo.isMDXComponent=!0;const uHo={toc:[]},mHo="wrapper";function dHo(t){let{components:e,...n}=t;return(0,s.kt)(mHo,(0,p.Z)({},uHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}dHo.isMDXComponent=!0;const hHo={toc:[]},fHo="wrapper";function kHo(t){let{components:e,...n}=t;return(0,s.kt)(fHo,(0,p.Z)({},hHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}kHo.isMDXComponent=!0;const yHo={toc:[]},DHo="wrapper";function MHo(t){let{components:e,...n}=t;return(0,s.kt)(DHo,(0,p.Z)({},yHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}MHo.isMDXComponent=!0;const XHo={toc:[]},_Ho="wrapper";function wHo(t){let{components:e,...n}=t;return(0,s.kt)(_Ho,(0,p.Z)({},XHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}wHo.isMDXComponent=!0;const THo={toc:[]},CHo="wrapper";function gHo(t){let{components:e,...n}=t;return(0,s.kt)(CHo,(0,p.Z)({},THo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}gHo.isMDXComponent=!0;const xHo={toc:[]},vHo="wrapper";function LHo(t){let{components:e,...n}=t;return(0,s.kt)(vHo,(0,p.Z)({},xHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}LHo.isMDXComponent=!0;const ZHo={toc:[]},bHo="wrapper";function NHo(t){let{components:e,...n}=t;return(0,s.kt)(bHo,(0,p.Z)({},ZHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}NHo.isMDXComponent=!0;const zHo={toc:[]},AHo="wrapper";function PHo(t){let{components:e,...n}=t;return(0,s.kt)(AHo,(0,p.Z)({},zHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}PHo.isMDXComponent=!0;const IHo={toc:[]},WHo="wrapper";function RHo(t){let{components:e,...n}=t;return(0,s.kt)(WHo,(0,p.Z)({},IHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}RHo.isMDXComponent=!0;const SHo={toc:[]},BHo="wrapper";function GHo(t){let{components:e,...n}=t;return(0,s.kt)(BHo,(0,p.Z)({},SHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}GHo.isMDXComponent=!0;const EHo={toc:[]},OHo="wrapper";function UHo(t){let{components:e,...n}=t;return(0,s.kt)(OHo,(0,p.Z)({},EHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}UHo.isMDXComponent=!0;const FHo={toc:[]},VHo="wrapper";function qHo(t){let{components:e,...n}=t;return(0,s.kt)(VHo,(0,p.Z)({},FHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qHo.isMDXComponent=!0;const jHo={toc:[]},HHo="wrapper";function YHo(t){let{components:e,...n}=t;return(0,s.kt)(HHo,(0,p.Z)({},jHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}YHo.isMDXComponent=!0;const QHo={toc:[]},$Ho="wrapper";function KHo(t){let{components:e,...n}=t;return(0,s.kt)($Ho,(0,p.Z)({},QHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}KHo.isMDXComponent=!0;const JHo={toc:[]},tYo="wrapper";function eYo(t){let{components:e,...n}=t;return(0,s.kt)(tYo,(0,p.Z)({},JHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}eYo.isMDXComponent=!0;const nYo={toc:[]},oYo="wrapper";function pYo(t){let{components:e,...n}=t;return(0,s.kt)(oYo,(0,p.Z)({},nYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pYo.isMDXComponent=!0;const rYo={toc:[]},sYo="wrapper";function cYo(t){let{components:e,...n}=t;return(0,s.kt)(sYo,(0,p.Z)({},rYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cYo.isMDXComponent=!0;const aYo={toc:[]},iYo="wrapper";function lYo(t){let{components:e,...n}=t;return(0,s.kt)(iYo,(0,p.Z)({},aYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lYo.isMDXComponent=!0;const uYo={toc:[]},mYo="wrapper";function dYo(t){let{components:e,...n}=t;return(0,s.kt)(mYo,(0,p.Z)({},uYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dYo.isMDXComponent=!0;const hYo={toc:[]},fYo="wrapper";function kYo(t){let{components:e,...n}=t;return(0,s.kt)(fYo,(0,p.Z)({},hYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}kYo.isMDXComponent=!0;const yYo={toc:[]},DYo="wrapper";function MYo(t){let{components:e,...n}=t;return(0,s.kt)(DYo,(0,p.Z)({},yYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}MYo.isMDXComponent=!0;const XYo={toc:[]},_Yo="wrapper";function wYo(t){let{components:e,...n}=t;return(0,s.kt)(_Yo,(0,p.Z)({},XYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wYo.isMDXComponent=!0;const TYo={toc:[]},CYo="wrapper";function gYo(t){let{components:e,...n}=t;return(0,s.kt)(CYo,(0,p.Z)({},TYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}gYo.isMDXComponent=!0;const xYo={toc:[]},vYo="wrapper";function LYo(t){let{components:e,...n}=t;return(0,s.kt)(vYo,(0,p.Z)({},xYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}LYo.isMDXComponent=!0;const ZYo={toc:[]},bYo="wrapper";function NYo(t){let{components:e,...n}=t;return(0,s.kt)(bYo,(0,p.Z)({},ZYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}NYo.isMDXComponent=!0;const zYo={toc:[]},AYo="wrapper";function PYo(t){let{components:e,...n}=t;return(0,s.kt)(AYo,(0,p.Z)({},zYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PYo.isMDXComponent=!0;const IYo={toc:[]},WYo="wrapper";function RYo(t){let{components:e,...n}=t;return(0,s.kt)(WYo,(0,p.Z)({},IYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}RYo.isMDXComponent=!0;const SYo={toc:[]},BYo="wrapper";function GYo(t){let{components:e,...n}=t;return(0,s.kt)(BYo,(0,p.Z)({},SYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}GYo.isMDXComponent=!0;const EYo={toc:[]},OYo="wrapper";function UYo(t){let{components:e,...n}=t;return(0,s.kt)(OYo,(0,p.Z)({},EYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}UYo.isMDXComponent=!0;const FYo={toc:[]},VYo="wrapper";function qYo(t){let{components:e,...n}=t;return(0,s.kt)(VYo,(0,p.Z)({},FYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qYo.isMDXComponent=!0;const jYo={toc:[]},HYo="wrapper";function YYo(t){let{components:e,...n}=t;return(0,s.kt)(HYo,(0,p.Z)({},jYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}YYo.isMDXComponent=!0;const QYo={toc:[]},$Yo="wrapper";function KYo(t){let{components:e,...n}=t;return(0,s.kt)($Yo,(0,p.Z)({},QYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}KYo.isMDXComponent=!0;const JYo={toc:[]},tQo="wrapper";function eQo(t){let{components:e,...n}=t;return(0,s.kt)(tQo,(0,p.Z)({},JYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}eQo.isMDXComponent=!0;const nQo={toc:[]},oQo="wrapper";function pQo(t){let{components:e,...n}=t;return(0,s.kt)(oQo,(0,p.Z)({},nQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pQo.isMDXComponent=!0;const rQo={toc:[]},sQo="wrapper";function cQo(t){let{components:e,...n}=t;return(0,s.kt)(sQo,(0,p.Z)({},rQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cQo.isMDXComponent=!0;const aQo={toc:[]},iQo="wrapper";function lQo(t){let{components:e,...n}=t;return(0,s.kt)(iQo,(0,p.Z)({},aQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lQo.isMDXComponent=!0;const uQo={toc:[]},mQo="wrapper";function dQo(t){let{components:e,...n}=t;return(0,s.kt)(mQo,(0,p.Z)({},uQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}dQo.isMDXComponent=!0;const hQo={toc:[]},fQo="wrapper";function kQo(t){let{components:e,...n}=t;return(0,s.kt)(fQo,(0,p.Z)({},hQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}kQo.isMDXComponent=!0;const yQo={toc:[]},DQo="wrapper";function MQo(t){let{components:e,...n}=t;return(0,s.kt)(DQo,(0,p.Z)({},yQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MQo.isMDXComponent=!0;const XQo={toc:[]},_Qo="wrapper";function wQo(t){let{components:e,...n}=t;return(0,s.kt)(_Qo,(0,p.Z)({},XQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wQo.isMDXComponent=!0;const TQo={toc:[]},CQo="wrapper";function gQo(t){let{components:e,...n}=t;return(0,s.kt)(CQo,(0,p.Z)({},TQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}gQo.isMDXComponent=!0;const xQo={toc:[]},vQo="wrapper";function LQo(t){let{components:e,...n}=t;return(0,s.kt)(vQo,(0,p.Z)({},xQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}LQo.isMDXComponent=!0;const ZQo={toc:[]},bQo="wrapper";function NQo(t){let{components:e,...n}=t;return(0,s.kt)(bQo,(0,p.Z)({},ZQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NQo.isMDXComponent=!0;const zQo={toc:[]},AQo="wrapper";function PQo(t){let{components:e,...n}=t;return(0,s.kt)(AQo,(0,p.Z)({},zQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}PQo.isMDXComponent=!0;const IQo={toc:[]},WQo="wrapper";function RQo(t){let{components:e,...n}=t;return(0,s.kt)(WQo,(0,p.Z)({},IQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}RQo.isMDXComponent=!0;const SQo={toc:[]},BQo="wrapper";function GQo(t){let{components:e,...n}=t;return(0,s.kt)(BQo,(0,p.Z)({},SQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GQo.isMDXComponent=!0;const EQo={toc:[]},OQo="wrapper";function UQo(t){let{components:e,...n}=t;return(0,s.kt)(OQo,(0,p.Z)({},EQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}UQo.isMDXComponent=!0;const FQo={toc:[]},VQo="wrapper";function qQo(t){let{components:e,...n}=t;return(0,s.kt)(VQo,(0,p.Z)({},FQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qQo.isMDXComponent=!0;const jQo={toc:[]},HQo="wrapper";function YQo(t){let{components:e,...n}=t;return(0,s.kt)(HQo,(0,p.Z)({},jQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}YQo.isMDXComponent=!0;const QQo={toc:[]},$Qo="wrapper";function KQo(t){let{components:e,...n}=t;return(0,s.kt)($Qo,(0,p.Z)({},QQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}KQo.isMDXComponent=!0;const JQo={toc:[]},t$o="wrapper";function e$o(t){let{components:e,...n}=t;return(0,s.kt)(t$o,(0,p.Z)({},JQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}e$o.isMDXComponent=!0;const n$o={toc:[]},o$o="wrapper";function p$o(t){let{components:e,...n}=t;return(0,s.kt)(o$o,(0,p.Z)({},n$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}p$o.isMDXComponent=!0;const r$o={toc:[]},s$o="wrapper";function c$o(t){let{components:e,...n}=t;return(0,s.kt)(s$o,(0,p.Z)({},r$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}c$o.isMDXComponent=!0;const a$o={toc:[]},i$o="wrapper";function l$o(t){let{components:e,...n}=t;return(0,s.kt)(i$o,(0,p.Z)({},a$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}l$o.isMDXComponent=!0;const u$o={toc:[]},m$o="wrapper";function d$o(t){let{components:e,...n}=t;return(0,s.kt)(m$o,(0,p.Z)({},u$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}d$o.isMDXComponent=!0;const h$o={toc:[]},f$o="wrapper";function k$o(t){let{components:e,...n}=t;return(0,s.kt)(f$o,(0,p.Z)({},h$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}k$o.isMDXComponent=!0;const y$o={toc:[]},D$o="wrapper";function M$o(t){let{components:e,...n}=t;return(0,s.kt)(D$o,(0,p.Z)({},y$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}M$o.isMDXComponent=!0;const X$o={toc:[]},_$o="wrapper";function w$o(t){let{components:e,...n}=t;return(0,s.kt)(_$o,(0,p.Z)({},X$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}w$o.isMDXComponent=!0;const T$o={toc:[]},C$o="wrapper";function g$o(t){let{components:e,...n}=t;return(0,s.kt)(C$o,(0,p.Z)({},T$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}g$o.isMDXComponent=!0;const x$o={toc:[]},v$o="wrapper";function L$o(t){let{components:e,...n}=t;return(0,s.kt)(v$o,(0,p.Z)({},x$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}L$o.isMDXComponent=!0;const Z$o={toc:[]},b$o="wrapper";function N$o(t){let{components:e,...n}=t;return(0,s.kt)(b$o,(0,p.Z)({},Z$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}N$o.isMDXComponent=!0;const z$o={toc:[]},A$o="wrapper";function P$o(t){let{components:e,...n}=t;return(0,s.kt)(A$o,(0,p.Z)({},z$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}P$o.isMDXComponent=!0;const I$o={toc:[]},W$o="wrapper";function R$o(t){let{components:e,...n}=t;return(0,s.kt)(W$o,(0,p.Z)({},I$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}R$o.isMDXComponent=!0;const S$o={toc:[]},B$o="wrapper";function G$o(t){let{components:e,...n}=t;return(0,s.kt)(B$o,(0,p.Z)({},S$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}G$o.isMDXComponent=!0;const E$o={toc:[]},O$o="wrapper";function U$o(t){let{components:e,...n}=t;return(0,s.kt)(O$o,(0,p.Z)({},E$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}U$o.isMDXComponent=!0;const F$o={toc:[]},V$o="wrapper";function q$o(t){let{components:e,...n}=t;return(0,s.kt)(V$o,(0,p.Z)({},F$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}q$o.isMDXComponent=!0;const j$o={toc:[]},H$o="wrapper";function Y$o(t){let{components:e,...n}=t;return(0,s.kt)(H$o,(0,p.Z)({},j$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Y$o.isMDXComponent=!0;const Q$o={toc:[]},$$o="wrapper";function K$o(t){let{components:e,...n}=t;return(0,s.kt)($$o,(0,p.Z)({},Q$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}K$o.isMDXComponent=!0;const J$o={toc:[]},tKo="wrapper";function eKo(t){let{components:e,...n}=t;return(0,s.kt)(tKo,(0,p.Z)({},J$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}eKo.isMDXComponent=!0;const nKo={toc:[]},oKo="wrapper";function pKo(t){let{components:e,...n}=t;return(0,s.kt)(oKo,(0,p.Z)({},nKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pKo.isMDXComponent=!0;const rKo={toc:[]},sKo="wrapper";function cKo(t){let{components:e,...n}=t;return(0,s.kt)(sKo,(0,p.Z)({},rKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}cKo.isMDXComponent=!0;const aKo={toc:[]},iKo="wrapper";function lKo(t){let{components:e,...n}=t;return(0,s.kt)(iKo,(0,p.Z)({},aKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}lKo.isMDXComponent=!0;const uKo={toc:[]},mKo="wrapper";function dKo(t){let{components:e,...n}=t;return(0,s.kt)(mKo,(0,p.Z)({},uKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}dKo.isMDXComponent=!0;const hKo={toc:[]},fKo="wrapper";function kKo(t){let{components:e,...n}=t;return(0,s.kt)(fKo,(0,p.Z)({},hKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}kKo.isMDXComponent=!0;const yKo={toc:[]},DKo="wrapper";function MKo(t){let{components:e,...n}=t;return(0,s.kt)(DKo,(0,p.Z)({},yKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}MKo.isMDXComponent=!0;const XKo={toc:[]},_Ko="wrapper";function wKo(t){let{components:e,...n}=t;return(0,s.kt)(_Ko,(0,p.Z)({},XKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}wKo.isMDXComponent=!0;const TKo={toc:[]},CKo="wrapper";function gKo(t){let{components:e,...n}=t;return(0,s.kt)(CKo,(0,p.Z)({},TKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gKo.isMDXComponent=!0;const xKo={toc:[]},vKo="wrapper";function LKo(t){let{components:e,...n}=t;return(0,s.kt)(vKo,(0,p.Z)({},xKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}LKo.isMDXComponent=!0;const ZKo={toc:[]},bKo="wrapper";function NKo(t){let{components:e,...n}=t;return(0,s.kt)(bKo,(0,p.Z)({},ZKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}NKo.isMDXComponent=!0;const zKo={toc:[]},AKo="wrapper";function PKo(t){let{components:e,...n}=t;return(0,s.kt)(AKo,(0,p.Z)({},zKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}PKo.isMDXComponent=!0;const IKo={toc:[]},WKo="wrapper";function RKo(t){let{components:e,...n}=t;return(0,s.kt)(WKo,(0,p.Z)({},IKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}RKo.isMDXComponent=!0;const SKo={toc:[]},BKo="wrapper";function GKo(t){let{components:e,...n}=t;return(0,s.kt)(BKo,(0,p.Z)({},SKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}GKo.isMDXComponent=!0;const EKo={toc:[]},OKo="wrapper";function UKo(t){let{components:e,...n}=t;return(0,s.kt)(OKo,(0,p.Z)({},EKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}UKo.isMDXComponent=!0;const FKo={toc:[]},VKo="wrapper";function qKo(t){let{components:e,...n}=t;return(0,s.kt)(VKo,(0,p.Z)({},FKo,n,{components:e,mdxType:"MDXLayout"}))}qKo.isMDXComponent=!0;const jKo={toc:[]},HKo="wrapper";function YKo(t){let{components:e,...n}=t;return(0,s.kt)(HKo,(0,p.Z)({},jKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}YKo.isMDXComponent=!0;const QKo={toc:[]},$Ko="wrapper";function KKo(t){let{components:e,...n}=t;return(0,s.kt)($Ko,(0,p.Z)({},QKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}KKo.isMDXComponent=!0;const JKo={toc:[]},tJo="wrapper";function eJo(t){let{components:e,...n}=t;return(0,s.kt)(tJo,(0,p.Z)({},JKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}eJo.isMDXComponent=!0;const nJo={toc:[]},oJo="wrapper";function pJo(t){let{components:e,...n}=t;return(0,s.kt)(oJo,(0,p.Z)({},nJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}pJo.isMDXComponent=!0;const rJo={toc:[]},sJo="wrapper";function cJo(t){let{components:e,...n}=t;return(0,s.kt)(sJo,(0,p.Z)({},rJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}cJo.isMDXComponent=!0;const aJo={toc:[]},iJo="wrapper";function lJo(t){let{components:e,...n}=t;return(0,s.kt)(iJo,(0,p.Z)({},aJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lJo.isMDXComponent=!0;const uJo={toc:[]},mJo="wrapper";function dJo(t){let{components:e,...n}=t;return(0,s.kt)(mJo,(0,p.Z)({},uJo,n,{components:e,mdxType:"MDXLayout"}))}dJo.isMDXComponent=!0;const hJo={toc:[]},fJo="wrapper";function kJo(t){let{components:e,...n}=t;return(0,s.kt)(fJo,(0,p.Z)({},hJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kJo.isMDXComponent=!0;const yJo={toc:[]},DJo="wrapper";function MJo(t){let{components:e,...n}=t;return(0,s.kt)(DJo,(0,p.Z)({},yJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}MJo.isMDXComponent=!0;const XJo={toc:[]},_Jo="wrapper";function wJo(t){let{components:e,...n}=t;return(0,s.kt)(_Jo,(0,p.Z)({},XJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wJo.isMDXComponent=!0;const TJo={toc:[]},CJo="wrapper";function gJo(t){let{components:e,...n}=t;return(0,s.kt)(CJo,(0,p.Z)({},TJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}gJo.isMDXComponent=!0;const xJo={toc:[]},vJo="wrapper";function LJo(t){let{components:e,...n}=t;return(0,s.kt)(vJo,(0,p.Z)({},xJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LJo.isMDXComponent=!0;const ZJo={toc:[]},bJo="wrapper";function NJo(t){let{components:e,...n}=t;return(0,s.kt)(bJo,(0,p.Z)({},ZJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NJo.isMDXComponent=!0;const zJo={toc:[]},AJo="wrapper";function PJo(t){let{components:e,...n}=t;return(0,s.kt)(AJo,(0,p.Z)({},zJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}PJo.isMDXComponent=!0;const IJo={toc:[]},WJo="wrapper";function RJo(t){let{components:e,...n}=t;return(0,s.kt)(WJo,(0,p.Z)({},IJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}RJo.isMDXComponent=!0;const SJo={toc:[]},BJo="wrapper";function GJo(t){let{components:e,...n}=t;return(0,s.kt)(BJo,(0,p.Z)({},SJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}GJo.isMDXComponent=!0;const EJo={toc:[]},OJo="wrapper";function UJo(t){let{components:e,...n}=t;return(0,s.kt)(OJo,(0,p.Z)({},EJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}UJo.isMDXComponent=!0;const FJo={toc:[]},VJo="wrapper";function qJo(t){let{components:e,...n}=t;return(0,s.kt)(VJo,(0,p.Z)({},FJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qJo.isMDXComponent=!0;const jJo={toc:[]},HJo="wrapper";function YJo(t){let{components:e,...n}=t;return(0,s.kt)(HJo,(0,p.Z)({},jJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}YJo.isMDXComponent=!0;const QJo={toc:[]},$Jo="wrapper";function KJo(t){let{components:e,...n}=t;return(0,s.kt)($Jo,(0,p.Z)({},QJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}KJo.isMDXComponent=!0;const JJo={toc:[]},t0o="wrapper";function e0o(t){let{components:e,...n}=t;return(0,s.kt)(t0o,(0,p.Z)({},JJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}e0o.isMDXComponent=!0;const n0o={toc:[]},o0o="wrapper";function p0o(t){let{components:e,...n}=t;return(0,s.kt)(o0o,(0,p.Z)({},n0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}p0o.isMDXComponent=!0;const r0o={toc:[]},s0o="wrapper";function c0o(t){let{components:e,...n}=t;return(0,s.kt)(s0o,(0,p.Z)({},r0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}c0o.isMDXComponent=!0;const a0o={toc:[]},i0o="wrapper";function l0o(t){let{components:e,...n}=t;return(0,s.kt)(i0o,(0,p.Z)({},a0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}l0o.isMDXComponent=!0;const u0o={toc:[]},m0o="wrapper";function d0o(t){let{components:e,...n}=t;return(0,s.kt)(m0o,(0,p.Z)({},u0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}d0o.isMDXComponent=!0;const h0o={toc:[]},f0o="wrapper";function k0o(t){let{components:e,...n}=t;return(0,s.kt)(f0o,(0,p.Z)({},h0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}k0o.isMDXComponent=!0;const y0o={toc:[]},D0o="wrapper";function M0o(t){let{components:e,...n}=t;return(0,s.kt)(D0o,(0,p.Z)({},y0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}M0o.isMDXComponent=!0;const X0o={toc:[]},_0o="wrapper";function w0o(t){let{components:e,...n}=t;return(0,s.kt)(_0o,(0,p.Z)({},X0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}w0o.isMDXComponent=!0;const T0o={toc:[]},C0o="wrapper";function g0o(t){let{components:e,...n}=t;return(0,s.kt)(C0o,(0,p.Z)({},T0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}g0o.isMDXComponent=!0;const x0o={toc:[]},v0o="wrapper";function L0o(t){let{components:e,...n}=t;return(0,s.kt)(v0o,(0,p.Z)({},x0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}L0o.isMDXComponent=!0;const Z0o={toc:[]},b0o="wrapper";function N0o(t){let{components:e,...n}=t;return(0,s.kt)(b0o,(0,p.Z)({},Z0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}N0o.isMDXComponent=!0;const z0o={toc:[]},A0o="wrapper";function P0o(t){let{components:e,...n}=t;return(0,s.kt)(A0o,(0,p.Z)({},z0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}P0o.isMDXComponent=!0;const I0o={toc:[]},W0o="wrapper";function R0o(t){let{components:e,...n}=t;return(0,s.kt)(W0o,(0,p.Z)({},I0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}R0o.isMDXComponent=!0;const S0o={toc:[]},B0o="wrapper";function G0o(t){let{components:e,...n}=t;return(0,s.kt)(B0o,(0,p.Z)({},S0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}G0o.isMDXComponent=!0;const E0o={toc:[]},O0o="wrapper";function U0o(t){let{components:e,...n}=t;return(0,s.kt)(O0o,(0,p.Z)({},E0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}U0o.isMDXComponent=!0;const F0o={toc:[]},V0o="wrapper";function q0o(t){let{components:e,...n}=t;return(0,s.kt)(V0o,(0,p.Z)({},F0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}q0o.isMDXComponent=!0;const j0o={toc:[]},H0o="wrapper";function Y0o(t){let{components:e,...n}=t;return(0,s.kt)(H0o,(0,p.Z)({},j0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Y0o.isMDXComponent=!0;const Q0o={toc:[]},$0o="wrapper";function K0o(t){let{components:e,...n}=t;return(0,s.kt)($0o,(0,p.Z)({},Q0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}K0o.isMDXComponent=!0;const J0o={toc:[]},t3o="wrapper";function e3o(t){let{components:e,...n}=t;return(0,s.kt)(t3o,(0,p.Z)({},J0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}e3o.isMDXComponent=!0;const n3o={toc:[]},o3o="wrapper";function p3o(t){let{components:e,...n}=t;return(0,s.kt)(o3o,(0,p.Z)({},n3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}p3o.isMDXComponent=!0;const r3o={toc:[]},s3o="wrapper";function c3o(t){let{components:e,...n}=t;return(0,s.kt)(s3o,(0,p.Z)({},r3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}c3o.isMDXComponent=!0;const a3o={toc:[]},i3o="wrapper";function l3o(t){let{components:e,...n}=t;return(0,s.kt)(i3o,(0,p.Z)({},a3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}l3o.isMDXComponent=!0;const u3o={toc:[]},m3o="wrapper";function d3o(t){let{components:e,...n}=t;return(0,s.kt)(m3o,(0,p.Z)({},u3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}d3o.isMDXComponent=!0;const h3o={toc:[]},f3o="wrapper";function k3o(t){let{components:e,...n}=t;return(0,s.kt)(f3o,(0,p.Z)({},h3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}k3o.isMDXComponent=!0;const y3o={toc:[]},D3o="wrapper";function M3o(t){let{components:e,...n}=t;return(0,s.kt)(D3o,(0,p.Z)({},y3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}M3o.isMDXComponent=!0;const X3o={toc:[]},_3o="wrapper";function w3o(t){let{components:e,...n}=t;return(0,s.kt)(_3o,(0,p.Z)({},X3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}w3o.isMDXComponent=!0;const T3o={toc:[]},C3o="wrapper";function g3o(t){let{components:e,...n}=t;return(0,s.kt)(C3o,(0,p.Z)({},T3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}g3o.isMDXComponent=!0;const x3o={toc:[]},v3o="wrapper";function L3o(t){let{components:e,...n}=t;return(0,s.kt)(v3o,(0,p.Z)({},x3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}L3o.isMDXComponent=!0;const Z3o={toc:[]},b3o="wrapper";function N3o(t){let{components:e,...n}=t;return(0,s.kt)(b3o,(0,p.Z)({},Z3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}N3o.isMDXComponent=!0;const z3o={toc:[]},A3o="wrapper";function P3o(t){let{components:e,...n}=t;return(0,s.kt)(A3o,(0,p.Z)({},z3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}P3o.isMDXComponent=!0;const I3o={toc:[]},W3o="wrapper";function R3o(t){let{components:e,...n}=t;return(0,s.kt)(W3o,(0,p.Z)({},I3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}R3o.isMDXComponent=!0;const S3o={toc:[]},B3o="wrapper";function G3o(t){let{components:e,...n}=t;return(0,s.kt)(B3o,(0,p.Z)({},S3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}G3o.isMDXComponent=!0;const E3o={toc:[]},O3o="wrapper";function U3o(t){let{components:e,...n}=t;return(0,s.kt)(O3o,(0,p.Z)({},E3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}U3o.isMDXComponent=!0;const F3o={toc:[]},V3o="wrapper";function q3o(t){let{components:e,...n}=t;return(0,s.kt)(V3o,(0,p.Z)({},F3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}q3o.isMDXComponent=!0;const j3o={toc:[]},H3o="wrapper";function Y3o(t){let{components:e,...n}=t;return(0,s.kt)(H3o,(0,p.Z)({},j3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Y3o.isMDXComponent=!0;const Q3o={toc:[]},$3o="wrapper";function K3o(t){let{components:e,...n}=t;return(0,s.kt)($3o,(0,p.Z)({},Q3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}K3o.isMDXComponent=!0;const J3o={toc:[]},t1o="wrapper";function e1o(t){let{components:e,...n}=t;return(0,s.kt)(t1o,(0,p.Z)({},J3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}e1o.isMDXComponent=!0;const n1o={toc:[]},o1o="wrapper";function p1o(t){let{components:e,...n}=t;return(0,s.kt)(o1o,(0,p.Z)({},n1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}p1o.isMDXComponent=!0;const r1o={toc:[]},s1o="wrapper";function c1o(t){let{components:e,...n}=t;return(0,s.kt)(s1o,(0,p.Z)({},r1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}c1o.isMDXComponent=!0;const a1o={toc:[]},i1o="wrapper";function l1o(t){let{components:e,...n}=t;return(0,s.kt)(i1o,(0,p.Z)({},a1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}l1o.isMDXComponent=!0;const u1o={toc:[]},m1o="wrapper";function d1o(t){let{components:e,...n}=t;return(0,s.kt)(m1o,(0,p.Z)({},u1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}d1o.isMDXComponent=!0;const h1o={toc:[]},f1o="wrapper";function k1o(t){let{components:e,...n}=t;return(0,s.kt)(f1o,(0,p.Z)({},h1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}k1o.isMDXComponent=!0;const y1o={toc:[]},D1o="wrapper";function M1o(t){let{components:e,...n}=t;return(0,s.kt)(D1o,(0,p.Z)({},y1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}M1o.isMDXComponent=!0;const X1o={toc:[]},_1o="wrapper";function w1o(t){let{components:e,...n}=t;return(0,s.kt)(_1o,(0,p.Z)({},X1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}w1o.isMDXComponent=!0;const T1o={toc:[]},C1o="wrapper";function g1o(t){let{components:e,...n}=t;return(0,s.kt)(C1o,(0,p.Z)({},T1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}g1o.isMDXComponent=!0;const x1o={toc:[]},v1o="wrapper";function L1o(t){let{components:e,...n}=t;return(0,s.kt)(v1o,(0,p.Z)({},x1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}L1o.isMDXComponent=!0;const Z1o={toc:[]},b1o="wrapper";function N1o(t){let{components:e,...n}=t;return(0,s.kt)(b1o,(0,p.Z)({},Z1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}N1o.isMDXComponent=!0;const z1o={toc:[]},A1o="wrapper";function P1o(t){let{components:e,...n}=t;return(0,s.kt)(A1o,(0,p.Z)({},z1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}P1o.isMDXComponent=!0;const I1o={toc:[]},W1o="wrapper";function R1o(t){let{components:e,...n}=t;return(0,s.kt)(W1o,(0,p.Z)({},I1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}R1o.isMDXComponent=!0;const S1o={toc:[]},B1o="wrapper";function G1o(t){let{components:e,...n}=t;return(0,s.kt)(B1o,(0,p.Z)({},S1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}G1o.isMDXComponent=!0;const E1o={toc:[]},O1o="wrapper";function U1o(t){let{components:e,...n}=t;return(0,s.kt)(O1o,(0,p.Z)({},E1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}U1o.isMDXComponent=!0;const F1o={toc:[]},V1o="wrapper";function q1o(t){let{components:e,...n}=t;return(0,s.kt)(V1o,(0,p.Z)({},F1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}q1o.isMDXComponent=!0;const j1o={toc:[]},H1o="wrapper";function Y1o(t){let{components:e,...n}=t;return(0,s.kt)(H1o,(0,p.Z)({},j1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Y1o.isMDXComponent=!0;const Q1o={toc:[]},$1o="wrapper";function K1o(t){let{components:e,...n}=t;return(0,s.kt)($1o,(0,p.Z)({},Q1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}K1o.isMDXComponent=!0;const J1o={toc:[]},t8o="wrapper";function e8o(t){let{components:e,...n}=t;return(0,s.kt)(t8o,(0,p.Z)({},J1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}e8o.isMDXComponent=!0;const n8o={toc:[]},o8o="wrapper";function p8o(t){let{components:e,...n}=t;return(0,s.kt)(o8o,(0,p.Z)({},n8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}p8o.isMDXComponent=!0;const r8o={toc:[]},s8o="wrapper";function c8o(t){let{components:e,...n}=t;return(0,s.kt)(s8o,(0,p.Z)({},r8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}c8o.isMDXComponent=!0;const a8o={toc:[]},i8o="wrapper";function l8o(t){let{components:e,...n}=t;return(0,s.kt)(i8o,(0,p.Z)({},a8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}l8o.isMDXComponent=!0;const u8o={toc:[]},m8o="wrapper";function d8o(t){let{components:e,...n}=t;return(0,s.kt)(m8o,(0,p.Z)({},u8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}d8o.isMDXComponent=!0;const h8o={toc:[]},f8o="wrapper";function k8o(t){let{components:e,...n}=t;return(0,s.kt)(f8o,(0,p.Z)({},h8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}k8o.isMDXComponent=!0;const y8o={toc:[]},D8o="wrapper";function M8o(t){let{components:e,...n}=t;return(0,s.kt)(D8o,(0,p.Z)({},y8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}M8o.isMDXComponent=!0;const X8o={toc:[]},_8o="wrapper";function w8o(t){let{components:e,...n}=t;return(0,s.kt)(_8o,(0,p.Z)({},X8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}w8o.isMDXComponent=!0;const T8o={toc:[]},C8o="wrapper";function g8o(t){let{components:e,...n}=t;return(0,s.kt)(C8o,(0,p.Z)({},T8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}g8o.isMDXComponent=!0;const x8o={toc:[]},v8o="wrapper";function L8o(t){let{components:e,...n}=t;return(0,s.kt)(v8o,(0,p.Z)({},x8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}L8o.isMDXComponent=!0;const Z8o={toc:[]},b8o="wrapper";function N8o(t){let{components:e,...n}=t;return(0,s.kt)(b8o,(0,p.Z)({},Z8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}N8o.isMDXComponent=!0;const z8o={toc:[]},A8o="wrapper";function P8o(t){let{components:e,...n}=t;return(0,s.kt)(A8o,(0,p.Z)({},z8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}P8o.isMDXComponent=!0;const I8o={toc:[]},W8o="wrapper";function R8o(t){let{components:e,...n}=t;return(0,s.kt)(W8o,(0,p.Z)({},I8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}R8o.isMDXComponent=!0;const S8o={toc:[]},B8o="wrapper";function G8o(t){let{components:e,...n}=t;return(0,s.kt)(B8o,(0,p.Z)({},S8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}G8o.isMDXComponent=!0;const E8o={toc:[]},O8o="wrapper";function U8o(t){let{components:e,...n}=t;return(0,s.kt)(O8o,(0,p.Z)({},E8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}U8o.isMDXComponent=!0;const F8o={toc:[]},V8o="wrapper";function q8o(t){let{components:e,...n}=t;return(0,s.kt)(V8o,(0,p.Z)({},F8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}q8o.isMDXComponent=!0;const j8o={toc:[]},H8o="wrapper";function Y8o(t){let{components:e,...n}=t;return(0,s.kt)(H8o,(0,p.Z)({},j8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Y8o.isMDXComponent=!0;const Q8o={toc:[]},$8o="wrapper";function K8o(t){let{components:e,...n}=t;return(0,s.kt)($8o,(0,p.Z)({},Q8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}K8o.isMDXComponent=!0;const J8o={toc:[]},t2o="wrapper";function e2o(t){let{components:e,...n}=t;return(0,s.kt)(t2o,(0,p.Z)({},J8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}e2o.isMDXComponent=!0;const n2o={toc:[]},o2o="wrapper";function p2o(t){let{components:e,...n}=t;return(0,s.kt)(o2o,(0,p.Z)({},n2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}p2o.isMDXComponent=!0;const r2o={toc:[]},s2o="wrapper";function c2o(t){let{components:e,...n}=t;return(0,s.kt)(s2o,(0,p.Z)({},r2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}c2o.isMDXComponent=!0;const a2o={toc:[]},i2o="wrapper";function l2o(t){let{components:e,...n}=t;return(0,s.kt)(i2o,(0,p.Z)({},a2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}l2o.isMDXComponent=!0;const u2o={toc:[]},m2o="wrapper";function d2o(t){let{components:e,...n}=t;return(0,s.kt)(m2o,(0,p.Z)({},u2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}d2o.isMDXComponent=!0;const h2o={toc:[]},f2o="wrapper";function k2o(t){let{components:e,...n}=t;return(0,s.kt)(f2o,(0,p.Z)({},h2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}k2o.isMDXComponent=!0;const y2o={toc:[]},D2o="wrapper";function M2o(t){let{components:e,...n}=t;return(0,s.kt)(D2o,(0,p.Z)({},y2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}M2o.isMDXComponent=!0;const X2o={toc:[]},_2o="wrapper";function w2o(t){let{components:e,...n}=t;return(0,s.kt)(_2o,(0,p.Z)({},X2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}w2o.isMDXComponent=!0;const T2o={toc:[]},C2o="wrapper";function g2o(t){let{components:e,...n}=t;return(0,s.kt)(C2o,(0,p.Z)({},T2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}g2o.isMDXComponent=!0;const x2o={toc:[]},v2o="wrapper";function L2o(t){let{components:e,...n}=t;return(0,s.kt)(v2o,(0,p.Z)({},x2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}L2o.isMDXComponent=!0;const Z2o={toc:[]},b2o="wrapper";function N2o(t){let{components:e,...n}=t;return(0,s.kt)(b2o,(0,p.Z)({},Z2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}N2o.isMDXComponent=!0;const z2o={toc:[]},A2o="wrapper";function P2o(t){let{components:e,...n}=t;return(0,s.kt)(A2o,(0,p.Z)({},z2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}P2o.isMDXComponent=!0;const I2o={toc:[]},W2o="wrapper";function R2o(t){let{components:e,...n}=t;return(0,s.kt)(W2o,(0,p.Z)({},I2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}R2o.isMDXComponent=!0;const S2o={toc:[]},B2o="wrapper";function G2o(t){let{components:e,...n}=t;return(0,s.kt)(B2o,(0,p.Z)({},S2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}G2o.isMDXComponent=!0;const E2o={toc:[]},O2o="wrapper";function U2o(t){let{components:e,...n}=t;return(0,s.kt)(O2o,(0,p.Z)({},E2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}U2o.isMDXComponent=!0;const F2o={toc:[]},V2o="wrapper";function q2o(t){let{components:e,...n}=t;return(0,s.kt)(V2o,(0,p.Z)({},F2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}q2o.isMDXComponent=!0;const j2o={toc:[]},H2o="wrapper";function Y2o(t){let{components:e,...n}=t;return(0,s.kt)(H2o,(0,p.Z)({},j2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}Y2o.isMDXComponent=!0;const Q2o={toc:[]},$2o="wrapper";function K2o(t){let{components:e,...n}=t;return(0,s.kt)($2o,(0,p.Z)({},Q2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}K2o.isMDXComponent=!0;const J2o={toc:[]},t4o="wrapper";function e4o(t){let{components:e,...n}=t;return(0,s.kt)(t4o,(0,p.Z)({},J2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}e4o.isMDXComponent=!0;const n4o={toc:[]},o4o="wrapper";function p4o(t){let{components:e,...n}=t;return(0,s.kt)(o4o,(0,p.Z)({},n4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}p4o.isMDXComponent=!0;const r4o={toc:[]},s4o="wrapper";function c4o(t){let{components:e,...n}=t;return(0,s.kt)(s4o,(0,p.Z)({},r4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}c4o.isMDXComponent=!0;const a4o={toc:[]},i4o="wrapper";function l4o(t){let{components:e,...n}=t;return(0,s.kt)(i4o,(0,p.Z)({},a4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}l4o.isMDXComponent=!0;const u4o={toc:[]},m4o="wrapper";function d4o(t){let{components:e,...n}=t;return(0,s.kt)(m4o,(0,p.Z)({},u4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}d4o.isMDXComponent=!0;const h4o={toc:[]},f4o="wrapper";function k4o(t){let{components:e,...n}=t;return(0,s.kt)(f4o,(0,p.Z)({},h4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}k4o.isMDXComponent=!0;const y4o={toc:[]},D4o="wrapper";function M4o(t){let{components:e,...n}=t;return(0,s.kt)(D4o,(0,p.Z)({},y4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}M4o.isMDXComponent=!0;const X4o={toc:[]},_4o="wrapper";function w4o(t){let{components:e,...n}=t;return(0,s.kt)(_4o,(0,p.Z)({},X4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}w4o.isMDXComponent=!0;const T4o={toc:[]},C4o="wrapper";function g4o(t){let{components:e,...n}=t;return(0,s.kt)(C4o,(0,p.Z)({},T4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}g4o.isMDXComponent=!0;const x4o={toc:[]},v4o="wrapper";function L4o(t){let{components:e,...n}=t;return(0,s.kt)(v4o,(0,p.Z)({},x4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}L4o.isMDXComponent=!0;const Z4o={toc:[]},b4o="wrapper";function N4o(t){let{components:e,...n}=t;return(0,s.kt)(b4o,(0,p.Z)({},Z4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}N4o.isMDXComponent=!0;const z4o={toc:[]},A4o="wrapper";function P4o(t){let{components:e,...n}=t;return(0,s.kt)(A4o,(0,p.Z)({},z4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}P4o.isMDXComponent=!0;const I4o={toc:[]},W4o="wrapper";function R4o(t){let{components:e,...n}=t;return(0,s.kt)(W4o,(0,p.Z)({},I4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}R4o.isMDXComponent=!0;const S4o={toc:[]},B4o="wrapper";function G4o(t){let{components:e,...n}=t;return(0,s.kt)(B4o,(0,p.Z)({},S4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}G4o.isMDXComponent=!0;const E4o={toc:[]},O4o="wrapper";function U4o(t){let{components:e,...n}=t;return(0,s.kt)(O4o,(0,p.Z)({},E4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}U4o.isMDXComponent=!0;const F4o={toc:[]},V4o="wrapper";function q4o(t){let{components:e,...n}=t;return(0,s.kt)(V4o,(0,p.Z)({},F4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}q4o.isMDXComponent=!0;const j4o={toc:[]},H4o="wrapper";function Y4o(t){let{components:e,...n}=t;return(0,s.kt)(H4o,(0,p.Z)({},j4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Y4o.isMDXComponent=!0;const Q4o={toc:[]},$4o="wrapper";function K4o(t){let{components:e,...n}=t;return(0,s.kt)($4o,(0,p.Z)({},Q4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}K4o.isMDXComponent=!0;const J4o={toc:[]},t6o="wrapper";function e6o(t){let{components:e,...n}=t;return(0,s.kt)(t6o,(0,p.Z)({},J4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}e6o.isMDXComponent=!0;const n6o={toc:[]},o6o="wrapper";function p6o(t){let{components:e,...n}=t;return(0,s.kt)(o6o,(0,p.Z)({},n6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}p6o.isMDXComponent=!0;const r6o={toc:[]},s6o="wrapper";function c6o(t){let{components:e,...n}=t;return(0,s.kt)(s6o,(0,p.Z)({},r6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}c6o.isMDXComponent=!0;const a6o={toc:[]},i6o="wrapper";function l6o(t){let{components:e,...n}=t;return(0,s.kt)(i6o,(0,p.Z)({},a6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}l6o.isMDXComponent=!0;const u6o={toc:[]},m6o="wrapper";function d6o(t){let{components:e,...n}=t;return(0,s.kt)(m6o,(0,p.Z)({},u6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}d6o.isMDXComponent=!0;const h6o={toc:[]},f6o="wrapper";function k6o(t){let{components:e,...n}=t;return(0,s.kt)(f6o,(0,p.Z)({},h6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}k6o.isMDXComponent=!0;const y6o={toc:[]},D6o="wrapper";function M6o(t){let{components:e,...n}=t;return(0,s.kt)(D6o,(0,p.Z)({},y6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}M6o.isMDXComponent=!0;const X6o={toc:[]},_6o="wrapper";function w6o(t){let{components:e,...n}=t;return(0,s.kt)(_6o,(0,p.Z)({},X6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}w6o.isMDXComponent=!0;const T6o={toc:[]},C6o="wrapper";function g6o(t){let{components:e,...n}=t;return(0,s.kt)(C6o,(0,p.Z)({},T6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}g6o.isMDXComponent=!0;const x6o={toc:[]},v6o="wrapper";function L6o(t){let{components:e,...n}=t;return(0,s.kt)(v6o,(0,p.Z)({},x6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}L6o.isMDXComponent=!0;const Z6o={toc:[]},b6o="wrapper";function N6o(t){let{components:e,...n}=t;return(0,s.kt)(b6o,(0,p.Z)({},Z6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}N6o.isMDXComponent=!0;const z6o={toc:[]},A6o="wrapper";function P6o(t){let{components:e,...n}=t;return(0,s.kt)(A6o,(0,p.Z)({},z6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}P6o.isMDXComponent=!0;const I6o={toc:[]},W6o="wrapper";function R6o(t){let{components:e,...n}=t;return(0,s.kt)(W6o,(0,p.Z)({},I6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}R6o.isMDXComponent=!0;const S6o={toc:[]},B6o="wrapper";function G6o(t){let{components:e,...n}=t;return(0,s.kt)(B6o,(0,p.Z)({},S6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}G6o.isMDXComponent=!0;const E6o={toc:[]},O6o="wrapper";function U6o(t){let{components:e,...n}=t;return(0,s.kt)(O6o,(0,p.Z)({},E6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}U6o.isMDXComponent=!0;const F6o={toc:[]},V6o="wrapper";function q6o(t){let{components:e,...n}=t;return(0,s.kt)(V6o,(0,p.Z)({},F6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}q6o.isMDXComponent=!0;const j6o={toc:[]},H6o="wrapper";function Y6o(t){let{components:e,...n}=t;return(0,s.kt)(H6o,(0,p.Z)({},j6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Y6o.isMDXComponent=!0;const Q6o={toc:[]},$6o="wrapper";function K6o(t){let{components:e,...n}=t;return(0,s.kt)($6o,(0,p.Z)({},Q6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}K6o.isMDXComponent=!0;const J6o={toc:[]},t5o="wrapper";function e5o(t){let{components:e,...n}=t;return(0,s.kt)(t5o,(0,p.Z)({},J6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}e5o.isMDXComponent=!0;const n5o={toc:[]},o5o="wrapper";function p5o(t){let{components:e,...n}=t;return(0,s.kt)(o5o,(0,p.Z)({},n5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}p5o.isMDXComponent=!0;const r5o={toc:[]},s5o="wrapper";function c5o(t){let{components:e,...n}=t;return(0,s.kt)(s5o,(0,p.Z)({},r5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}c5o.isMDXComponent=!0;const a5o={toc:[]},i5o="wrapper";function l5o(t){let{components:e,...n}=t;return(0,s.kt)(i5o,(0,p.Z)({},a5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}l5o.isMDXComponent=!0;const u5o={toc:[]},m5o="wrapper";function d5o(t){let{components:e,...n}=t;return(0,s.kt)(m5o,(0,p.Z)({},u5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}d5o.isMDXComponent=!0;const h5o={toc:[]},f5o="wrapper";function k5o(t){let{components:e,...n}=t;return(0,s.kt)(f5o,(0,p.Z)({},h5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}k5o.isMDXComponent=!0;const y5o={toc:[]},D5o="wrapper";function M5o(t){let{components:e,...n}=t;return(0,s.kt)(D5o,(0,p.Z)({},y5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}M5o.isMDXComponent=!0;const X5o={toc:[]},_5o="wrapper";function w5o(t){let{components:e,...n}=t;return(0,s.kt)(_5o,(0,p.Z)({},X5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}w5o.isMDXComponent=!0;const T5o={toc:[]},C5o="wrapper";function g5o(t){let{components:e,...n}=t;return(0,s.kt)(C5o,(0,p.Z)({},T5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}g5o.isMDXComponent=!0;const x5o={toc:[]},v5o="wrapper";function L5o(t){let{components:e,...n}=t;return(0,s.kt)(v5o,(0,p.Z)({},x5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}L5o.isMDXComponent=!0;const Z5o={toc:[]},b5o="wrapper";function N5o(t){let{components:e,...n}=t;return(0,s.kt)(b5o,(0,p.Z)({},Z5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}N5o.isMDXComponent=!0;const z5o={toc:[]},A5o="wrapper";function P5o(t){let{components:e,...n}=t;return(0,s.kt)(A5o,(0,p.Z)({},z5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut for"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontWeight={700} />\n")))}P5o.isMDXComponent=!0;const I5o={toc:[]},W5o="wrapper";function R5o(t){let{components:e,...n}=t;return(0,s.kt)(W5o,(0,p.Z)({},I5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a bold text node."))}R5o.isMDXComponent=!0;const S5o={toc:[]},B5o="wrapper";function G5o(t){let{components:e,...n}=t;return(0,s.kt)(B5o,(0,p.Z)({},S5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional text properties."))}G5o.isMDXComponent=!0;const E5o={toc:[]},O5o="wrapper";function U5o(t){let{components:e,...n}=t;return(0,s.kt)(O5o,(0,p.Z)({},E5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut for"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontStyle={'italic'} />\n")))}U5o.isMDXComponent=!0;const F5o={toc:[]},V5o="wrapper";function q5o(t){let{components:e,...n}=t;return(0,s.kt)(V5o,(0,p.Z)({},F5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an italic text node."))}q5o.isMDXComponent=!0;const j5o={toc:[]},H5o="wrapper";function Y5o(t){let{components:e,...n}=t;return(0,s.kt)(H5o,(0,p.Z)({},j5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional text properties."))}Y5o.isMDXComponent=!0;const Q5o={toc:[]},$5o="wrapper";function K5o(t){let{components:e,...n}=t;return(0,s.kt)($5o,(0,p.Z)({},Q5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}K5o.isMDXComponent=!0;const J5o={toc:[]},t7o="wrapper";function e7o(t){let{components:e,...n}=t;return(0,s.kt)(t7o,(0,p.Z)({},J5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}e7o.isMDXComponent=!0;const n7o={toc:[]},o7o="wrapper";function p7o(t){let{components:e,...n}=t;return(0,s.kt)(o7o,(0,p.Z)({},n7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}p7o.isMDXComponent=!0;const r7o={toc:[]},s7o="wrapper";function c7o(t){let{components:e,...n}=t;return(0,s.kt)(s7o,(0,p.Z)({},r7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}c7o.isMDXComponent=!0;const a7o={toc:[]},i7o="wrapper";function l7o(t){let{components:e,...n}=t;return(0,s.kt)(i7o,(0,p.Z)({},a7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}l7o.isMDXComponent=!0;const u7o={toc:[]},m7o="wrapper";function d7o(t){let{components:e,...n}=t;return(0,s.kt)(m7o,(0,p.Z)({},u7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}d7o.isMDXComponent=!0;const h7o={toc:[]},f7o="wrapper";function k7o(t){let{components:e,...n}=t;return(0,s.kt)(f7o,(0,p.Z)({},h7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}k7o.isMDXComponent=!0;const y7o={toc:[]},D7o="wrapper";function M7o(t){let{components:e,...n}=t;return(0,s.kt)(D7o,(0,p.Z)({},y7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}M7o.isMDXComponent=!0;const X7o={toc:[]},_7o="wrapper";function w7o(t){let{components:e,...n}=t;return(0,s.kt)(_7o,(0,p.Z)({},X7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}w7o.isMDXComponent=!0;const T7o={toc:[]},C7o="wrapper";function g7o(t){let{components:e,...n}=t;return(0,s.kt)(C7o,(0,p.Z)({},T7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}g7o.isMDXComponent=!0;const x7o={toc:[]},v7o="wrapper";function L7o(t){let{components:e,...n}=t;return(0,s.kt)(v7o,(0,p.Z)({},x7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}L7o.isMDXComponent=!0;const Z7o={toc:[]},b7o="wrapper";function N7o(t){let{components:e,...n}=t;return(0,s.kt)(b7o,(0,p.Z)({},Z7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}N7o.isMDXComponent=!0;const z7o={toc:[]},A7o="wrapper";function P7o(t){let{components:e,...n}=t;return(0,s.kt)(A7o,(0,p.Z)({},z7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}P7o.isMDXComponent=!0;const I7o={toc:[]},W7o="wrapper";function R7o(t){let{components:e,...n}=t;return(0,s.kt)(W7o,(0,p.Z)({},I7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}R7o.isMDXComponent=!0;const S7o={toc:[]},B7o="wrapper";function G7o(t){let{components:e,...n}=t;return(0,s.kt)(B7o,(0,p.Z)({},S7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}G7o.isMDXComponent=!0;const E7o={toc:[]},O7o="wrapper";function U7o(t){let{components:e,...n}=t;return(0,s.kt)(O7o,(0,p.Z)({},E7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}U7o.isMDXComponent=!0;const F7o={toc:[]},V7o="wrapper";function q7o(t){let{components:e,...n}=t;return(0,s.kt)(V7o,(0,p.Z)({},F7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}q7o.isMDXComponent=!0;const j7o={toc:[]},H7o="wrapper";function Y7o(t){let{components:e,...n}=t;return(0,s.kt)(H7o,(0,p.Z)({},j7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Y7o.isMDXComponent=!0;const Q7o={toc:[]},$7o="wrapper";function K7o(t){let{components:e,...n}=t;return(0,s.kt)($7o,(0,p.Z)({},Q7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}K7o.isMDXComponent=!0;const J7o={toc:[]},t9o="wrapper";function e9o(t){let{components:e,...n}=t;return(0,s.kt)(t9o,(0,p.Z)({},J7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}e9o.isMDXComponent=!0;const n9o={toc:[]},o9o="wrapper";function p9o(t){let{components:e,...n}=t;return(0,s.kt)(o9o,(0,p.Z)({},n9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}p9o.isMDXComponent=!0;const r9o={toc:[]},s9o="wrapper";function c9o(t){let{components:e,...n}=t;return(0,s.kt)(s9o,(0,p.Z)({},r9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}c9o.isMDXComponent=!0;const a9o={toc:[]},i9o="wrapper";function l9o(t){let{components:e,...n}=t;return(0,s.kt)(i9o,(0,p.Z)({},a9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}l9o.isMDXComponent=!0;const u9o={toc:[]},m9o="wrapper";function d9o(t){let{components:e,...n}=t;return(0,s.kt)(m9o,(0,p.Z)({},u9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}d9o.isMDXComponent=!0;const h9o={toc:[]},f9o="wrapper";function k9o(t){let{components:e,...n}=t;return(0,s.kt)(f9o,(0,p.Z)({},h9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}k9o.isMDXComponent=!0;const y9o={toc:[]},D9o="wrapper";function M9o(t){let{components:e,...n}=t;return(0,s.kt)(D9o,(0,p.Z)({},y9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}M9o.isMDXComponent=!0;const X9o={toc:[]},_9o="wrapper";function w9o(t){let{components:e,...n}=t;return(0,s.kt)(_9o,(0,p.Z)({},X9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}w9o.isMDXComponent=!0;const T9o={toc:[]},C9o="wrapper";function g9o(t){let{components:e,...n}=t;return(0,s.kt)(C9o,(0,p.Z)({},T9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}g9o.isMDXComponent=!0;const x9o={toc:[]},v9o="wrapper";function L9o(t){let{components:e,...n}=t;return(0,s.kt)(v9o,(0,p.Z)({},x9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}L9o.isMDXComponent=!0;const Z9o={toc:[]},b9o="wrapper";function N9o(t){let{components:e,...n}=t;return(0,s.kt)(b9o,(0,p.Z)({},Z9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}N9o.isMDXComponent=!0;const z9o={toc:[]},A9o="wrapper";function P9o(t){let{components:e,...n}=t;return(0,s.kt)(A9o,(0,p.Z)({},z9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}P9o.isMDXComponent=!0;const I9o={toc:[]},W9o="wrapper";function R9o(t){let{components:e,...n}=t;return(0,s.kt)(W9o,(0,p.Z)({},I9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}R9o.isMDXComponent=!0;const S9o={toc:[]},B9o="wrapper";function G9o(t){let{components:e,...n}=t;return(0,s.kt)(B9o,(0,p.Z)({},S9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}G9o.isMDXComponent=!0;const E9o={toc:[]},O9o="wrapper";function U9o(t){let{components:e,...n}=t;return(0,s.kt)(O9o,(0,p.Z)({},E9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}U9o.isMDXComponent=!0;const F9o={toc:[]},V9o="wrapper";function q9o(t){let{components:e,...n}=t;return(0,s.kt)(V9o,(0,p.Z)({},F9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}q9o.isMDXComponent=!0;const j9o={toc:[]},H9o="wrapper";function Y9o(t){let{components:e,...n}=t;return(0,s.kt)(H9o,(0,p.Z)({},j9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Y9o.isMDXComponent=!0;const Q9o={toc:[]},$9o="wrapper";function K9o(t){let{components:e,...n}=t;return(0,s.kt)($9o,(0,p.Z)({},Q9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}K9o.isMDXComponent=!0;const J9o={toc:[]},ttp="wrapper";function etp(t){let{components:e,...n}=t;return(0,s.kt)(ttp,(0,p.Z)({},J9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}etp.isMDXComponent=!0;const ntp={toc:[]},otp="wrapper";function ptp(t){let{components:e,...n}=t;return(0,s.kt)(otp,(0,p.Z)({},ntp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"1"))}ptp.isMDXComponent=!0;const rtp={toc:[]},stp="wrapper";function ctp(t){let{components:e,...n}=t;return(0,s.kt)(stp,(0,p.Z)({},rtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rate at which the video plays, as multiples of the normal speed."))}ctp.isMDXComponent=!0;const atp={toc:[]},itp="wrapper";function ltp(t){let{components:e,...n}=t;return(0,s.kt)(itp,(0,p.Z)({},atp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ltp.isMDXComponent=!0;const utp={toc:[]},mtp="wrapper";function dtp(t){let{components:e,...n}=t;return(0,s.kt)(mtp,(0,p.Z)({},utp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}dtp.isMDXComponent=!0;const htp={toc:[]},ftp="wrapper";function ktp(t){let{components:e,...n}=t;return(0,s.kt)(ftp,(0,p.Z)({},htp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}ktp.isMDXComponent=!0;const ytp={toc:[]},Dtp="wrapper";function Mtp(t){let{components:e,...n}=t;return(0,s.kt)(Dtp,(0,p.Z)({},ytp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Mtp.isMDXComponent=!0;const Xtp={toc:[]},_tp="wrapper";function wtp(t){let{components:e,...n}=t;return(0,s.kt)(_tp,(0,p.Z)({},Xtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}wtp.isMDXComponent=!0;const Ttp={toc:[]},Ctp="wrapper";function gtp(t){let{components:e,...n}=t;return(0,s.kt)(Ctp,(0,p.Z)({},Ttp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}gtp.isMDXComponent=!0;const xtp={toc:[]},vtp="wrapper";function Ltp(t){let{components:e,...n}=t;return(0,s.kt)(vtp,(0,p.Z)({},xtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Ltp.isMDXComponent=!0;const Ztp={toc:[]},btp="wrapper";function Ntp(t){let{components:e,...n}=t;return(0,s.kt)(btp,(0,p.Z)({},Ztp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Ntp.isMDXComponent=!0;const ztp={toc:[]},Atp="wrapper";function Ptp(t){let{components:e,...n}=t;return(0,s.kt)(Atp,(0,p.Z)({},ztp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Ptp.isMDXComponent=!0;const Itp={toc:[]},Wtp="wrapper";function Rtp(t){let{components:e,...n}=t;return(0,s.kt)(Wtp,(0,p.Z)({},Itp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Rtp.isMDXComponent=!0;const Stp={toc:[]},Btp="wrapper";function Gtp(t){let{components:e,...n}=t;return(0,s.kt)(Btp,(0,p.Z)({},Stp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Gtp.isMDXComponent=!0;const Etp={toc:[]},Otp="wrapper";function Utp(t){let{components:e,...n}=t;return(0,s.kt)(Otp,(0,p.Z)({},Etp,n,{components:e,mdxType:"MDXLayout"}))}Utp.isMDXComponent=!0;const Ftp={toc:[]},Vtp="wrapper";function qtp(t){let{components:e,...n}=t;return(0,s.kt)(Vtp,(0,p.Z)({},Ftp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}qtp.isMDXComponent=!0;const jtp={toc:[]},Htp="wrapper";function Ytp(t){let{components:e,...n}=t;return(0,s.kt)(Htp,(0,p.Z)({},jtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Ytp.isMDXComponent=!0;const Qtp={toc:[]},$tp="wrapper";function Ktp(t){let{components:e,...n}=t;return(0,s.kt)($tp,(0,p.Z)({},Qtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Ktp.isMDXComponent=!0;const Jtp={toc:[]},tep="wrapper";function eep(t){let{components:e,...n}=t;return(0,s.kt)(tep,(0,p.Z)({},Jtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}eep.isMDXComponent=!0;const nep={toc:[]},oep="wrapper";function pep(t){let{components:e,...n}=t;return(0,s.kt)(oep,(0,p.Z)({},nep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}pep.isMDXComponent=!0;const rep={toc:[]},sep="wrapper";function cep(t){let{components:e,...n}=t;return(0,s.kt)(sep,(0,p.Z)({},rep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}cep.isMDXComponent=!0;const aep={toc:[]},iep="wrapper";function lep(t){let{components:e,...n}=t;return(0,s.kt)(iep,(0,p.Z)({},aep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}lep.isMDXComponent=!0;const uep={toc:[]},mep="wrapper";function dep(t){let{components:e,...n}=t;return(0,s.kt)(mep,(0,p.Z)({},uep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}dep.isMDXComponent=!0;const hep={toc:[]},fep="wrapper";function kep(t){let{components:e,...n}=t;return(0,s.kt)(fep,(0,p.Z)({},hep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}kep.isMDXComponent=!0;const yep={toc:[]},Dep="wrapper";function Mep(t){let{components:e,...n}=t;return(0,s.kt)(Dep,(0,p.Z)({},yep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Mep.isMDXComponent=!0;const Xep={toc:[]},_ep="wrapper";function wep(t){let{components:e,...n}=t;return(0,s.kt)(_ep,(0,p.Z)({},Xep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}wep.isMDXComponent=!0;const Tep={toc:[]},Cep="wrapper";function gep(t){let{components:e,...n}=t;return(0,s.kt)(Cep,(0,p.Z)({},Tep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}gep.isMDXComponent=!0;const xep={toc:[]},vep="wrapper";function Lep(t){let{components:e,...n}=t;return(0,s.kt)(vep,(0,p.Z)({},xep,n,{components:e,mdxType:"MDXLayout"}))}Lep.isMDXComponent=!0;const Zep={toc:[]},bep="wrapper";function Nep(t){let{components:e,...n}=t;return(0,s.kt)(bep,(0,p.Z)({},Zep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}Nep.isMDXComponent=!0;const zep={toc:[]},Aep="wrapper";function Pep(t){let{components:e,...n}=t;return(0,s.kt)(Aep,(0,p.Z)({},zep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}Pep.isMDXComponent=!0;const Iep={toc:[]},Wep="wrapper";function Rep(t){let{components:e,...n}=t;return(0,s.kt)(Wep,(0,p.Z)({},Iep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Rep.isMDXComponent=!0;const Sep={toc:[]},Bep="wrapper";function Gep(t){let{components:e,...n}=t;return(0,s.kt)(Bep,(0,p.Z)({},Sep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Gep.isMDXComponent=!0;const Eep={toc:[]},Oep="wrapper";function Uep(t){let{components:e,...n}=t;return(0,s.kt)(Oep,(0,p.Z)({},Eep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Uep.isMDXComponent=!0;const Fep={toc:[]},Vep="wrapper";function qep(t){let{components:e,...n}=t;return(0,s.kt)(Vep,(0,p.Z)({},Fep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qep.isMDXComponent=!0;const jep={toc:[]},Hep="wrapper";function Yep(t){let{components:e,...n}=t;return(0,s.kt)(Hep,(0,p.Z)({},jep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Yep.isMDXComponent=!0;const Qep={toc:[]},$ep="wrapper";function Kep(t){let{components:e,...n}=t;return(0,s.kt)($ep,(0,p.Z)({},Qep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Kep.isMDXComponent=!0;const Jep={toc:[]},tnp="wrapper";function enp(t){let{components:e,...n}=t;return(0,s.kt)(tnp,(0,p.Z)({},Jep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}enp.isMDXComponent=!0;const nnp={toc:[]},onp="wrapper";function pnp(t){let{components:e,...n}=t;return(0,s.kt)(onp,(0,p.Z)({},nnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pnp.isMDXComponent=!0;const rnp={toc:[]},snp="wrapper";function cnp(t){let{components:e,...n}=t;return(0,s.kt)(snp,(0,p.Z)({},rnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}cnp.isMDXComponent=!0;const anp={toc:[]},inp="wrapper";function lnp(t){let{components:e,...n}=t;return(0,s.kt)(inp,(0,p.Z)({},anp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lnp.isMDXComponent=!0;const unp={toc:[]},mnp="wrapper";function dnp(t){let{components:e,...n}=t;return(0,s.kt)(mnp,(0,p.Z)({},unp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}dnp.isMDXComponent=!0;const hnp={toc:[]},fnp="wrapper";function knp(t){let{components:e,...n}=t;return(0,s.kt)(fnp,(0,p.Z)({},hnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}knp.isMDXComponent=!0;const ynp={toc:[]},Dnp="wrapper";function Mnp(t){let{components:e,...n}=t;return(0,s.kt)(Dnp,(0,p.Z)({},ynp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Mnp.isMDXComponent=!0;const Xnp={toc:[]},_np="wrapper";function wnp(t){let{components:e,...n}=t;return(0,s.kt)(_np,(0,p.Z)({},Xnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wnp.isMDXComponent=!0;const Tnp={toc:[]},Cnp="wrapper";function gnp(t){let{components:e,...n}=t;return(0,s.kt)(Cnp,(0,p.Z)({},Tnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}gnp.isMDXComponent=!0;const xnp={toc:[]},vnp="wrapper";function Lnp(t){let{components:e,...n}=t;return(0,s.kt)(vnp,(0,p.Z)({},xnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Lnp.isMDXComponent=!0;const Znp={toc:[]},bnp="wrapper";function Nnp(t){let{components:e,...n}=t;return(0,s.kt)(bnp,(0,p.Z)({},Znp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Nnp.isMDXComponent=!0;const znp={toc:[]},Anp="wrapper";function Pnp(t){let{components:e,...n}=t;return(0,s.kt)(Anp,(0,p.Z)({},znp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Pnp.isMDXComponent=!0;const Inp={toc:[]},Wnp="wrapper";function Rnp(t){let{components:e,...n}=t;return(0,s.kt)(Wnp,(0,p.Z)({},Inp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Rnp.isMDXComponent=!0;const Snp={toc:[]},Bnp="wrapper";function Gnp(t){let{components:e,...n}=t;return(0,s.kt)(Bnp,(0,p.Z)({},Snp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Gnp.isMDXComponent=!0;const Enp={toc:[]},Onp="wrapper";function Unp(t){let{components:e,...n}=t;return(0,s.kt)(Onp,(0,p.Z)({},Enp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Unp.isMDXComponent=!0;const Fnp={toc:[]},Vnp="wrapper";function qnp(t){let{components:e,...n}=t;return(0,s.kt)(Vnp,(0,p.Z)({},Fnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qnp.isMDXComponent=!0;const jnp={toc:[]},Hnp="wrapper";function Ynp(t){let{components:e,...n}=t;return(0,s.kt)(Hnp,(0,p.Z)({},jnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Ynp.isMDXComponent=!0;const Qnp={toc:[]},$np="wrapper";function Knp(t){let{components:e,...n}=t;return(0,s.kt)($np,(0,p.Z)({},Qnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Knp.isMDXComponent=!0;const Jnp={toc:[]},top="wrapper";function eop(t){let{components:e,...n}=t;return(0,s.kt)(top,(0,p.Z)({},Jnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}eop.isMDXComponent=!0;const nop={toc:[]},oop="wrapper";function pop(t){let{components:e,...n}=t;return(0,s.kt)(oop,(0,p.Z)({},nop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}pop.isMDXComponent=!0;const rop={toc:[]},sop="wrapper";function cop(t){let{components:e,...n}=t;return(0,s.kt)(sop,(0,p.Z)({},rop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}cop.isMDXComponent=!0;const aop={toc:[]},iop="wrapper";function lop(t){let{components:e,...n}=t;return(0,s.kt)(iop,(0,p.Z)({},aop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lop.isMDXComponent=!0;const uop={toc:[]},mop="wrapper";function dop(t){let{components:e,...n}=t;return(0,s.kt)(mop,(0,p.Z)({},uop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}dop.isMDXComponent=!0;const hop={toc:[]},fop="wrapper";function kop(t){let{components:e,...n}=t;return(0,s.kt)(fop,(0,p.Z)({},hop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}kop.isMDXComponent=!0;const yop={toc:[]},Dop="wrapper";function Mop(t){let{components:e,...n}=t;return(0,s.kt)(Dop,(0,p.Z)({},yop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Mop.isMDXComponent=!0;const Xop={toc:[]},_op="wrapper";function wop(t){let{components:e,...n}=t;return(0,s.kt)(_op,(0,p.Z)({},Xop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}wop.isMDXComponent=!0;const Top={toc:[]},Cop="wrapper";function gop(t){let{components:e,...n}=t;return(0,s.kt)(Cop,(0,p.Z)({},Top,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}gop.isMDXComponent=!0;const xop={toc:[]},vop="wrapper";function Lop(t){let{components:e,...n}=t;return(0,s.kt)(vop,(0,p.Z)({},xop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lop.isMDXComponent=!0;const Zop={toc:[]},bop="wrapper";function Nop(t){let{components:e,...n}=t;return(0,s.kt)(bop,(0,p.Z)({},Zop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Nop.isMDXComponent=!0;const zop={toc:[]},Aop="wrapper";function Pop(t){let{components:e,...n}=t;return(0,s.kt)(Aop,(0,p.Z)({},zop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Pop.isMDXComponent=!0;const Iop={toc:[]},Wop="wrapper";function Rop(t){let{components:e,...n}=t;return(0,s.kt)(Wop,(0,p.Z)({},Iop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Rop.isMDXComponent=!0;const Sop={toc:[]},Bop="wrapper";function Gop(t){let{components:e,...n}=t;return(0,s.kt)(Bop,(0,p.Z)({},Sop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Gop.isMDXComponent=!0;const Eop={toc:[]},Oop="wrapper";function Uop(t){let{components:e,...n}=t;return(0,s.kt)(Oop,(0,p.Z)({},Eop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Uop.isMDXComponent=!0;const Fop={toc:[]},Vop="wrapper";function qop(t){let{components:e,...n}=t;return(0,s.kt)(Vop,(0,p.Z)({},Fop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}qop.isMDXComponent=!0;const jop={toc:[]},Hop="wrapper";function Yop(t){let{components:e,...n}=t;return(0,s.kt)(Hop,(0,p.Z)({},jop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Yop.isMDXComponent=!0;const Qop={toc:[]},$op="wrapper";function Kop(t){let{components:e,...n}=t;return(0,s.kt)($op,(0,p.Z)({},Qop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Kop.isMDXComponent=!0;const Jop={toc:[]},tpp="wrapper";function epp(t){let{components:e,...n}=t;return(0,s.kt)(tpp,(0,p.Z)({},Jop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}epp.isMDXComponent=!0;const npp={toc:[]},opp="wrapper";function ppp(t){let{components:e,...n}=t;return(0,s.kt)(opp,(0,p.Z)({},npp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}ppp.isMDXComponent=!0;const rpp={toc:[]},spp="wrapper";function cpp(t){let{components:e,...n}=t;return(0,s.kt)(spp,(0,p.Z)({},rpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}cpp.isMDXComponent=!0;const app={toc:[]},ipp="wrapper";function lpp(t){let{components:e,...n}=t;return(0,s.kt)(ipp,(0,p.Z)({},app,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}lpp.isMDXComponent=!0;const upp={toc:[]},mpp="wrapper";function dpp(t){let{components:e,...n}=t;return(0,s.kt)(mpp,(0,p.Z)({},upp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}dpp.isMDXComponent=!0;const hpp={toc:[]},fpp="wrapper";function kpp(t){let{components:e,...n}=t;return(0,s.kt)(fpp,(0,p.Z)({},hpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}kpp.isMDXComponent=!0;const ypp={toc:[]},Dpp="wrapper";function Mpp(t){let{components:e,...n}=t;return(0,s.kt)(Dpp,(0,p.Z)({},ypp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Mpp.isMDXComponent=!0;const Xpp={toc:[]},_pp="wrapper";function wpp(t){let{components:e,...n}=t;return(0,s.kt)(_pp,(0,p.Z)({},Xpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wpp.isMDXComponent=!0;const Tpp={toc:[]},Cpp="wrapper";function gpp(t){let{components:e,...n}=t;return(0,s.kt)(Cpp,(0,p.Z)({},Tpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}gpp.isMDXComponent=!0;const xpp={toc:[]},vpp="wrapper";function Lpp(t){let{components:e,...n}=t;return(0,s.kt)(vpp,(0,p.Z)({},xpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Lpp.isMDXComponent=!0;const Zpp={toc:[]},bpp="wrapper";function Npp(t){let{components:e,...n}=t;return(0,s.kt)(bpp,(0,p.Z)({},Zpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Npp.isMDXComponent=!0;const zpp={toc:[]},App="wrapper";function Ppp(t){let{components:e,...n}=t;return(0,s.kt)(App,(0,p.Z)({},zpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Ppp.isMDXComponent=!0;const Ipp={toc:[]},Wpp="wrapper";function Rpp(t){let{components:e,...n}=t;return(0,s.kt)(Wpp,(0,p.Z)({},Ipp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Rpp.isMDXComponent=!0;const Spp={toc:[]},Bpp="wrapper";function Gpp(t){let{components:e,...n}=t;return(0,s.kt)(Bpp,(0,p.Z)({},Spp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gpp.isMDXComponent=!0;const Epp={toc:[]},Opp="wrapper";function Upp(t){let{components:e,...n}=t;return(0,s.kt)(Opp,(0,p.Z)({},Epp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Upp.isMDXComponent=!0;const Fpp={toc:[]},Vpp="wrapper";function qpp(t){let{components:e,...n}=t;return(0,s.kt)(Vpp,(0,p.Z)({},Fpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qpp.isMDXComponent=!0;const jpp={toc:[]},Hpp="wrapper";function Ypp(t){let{components:e,...n}=t;return(0,s.kt)(Hpp,(0,p.Z)({},jpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Ypp.isMDXComponent=!0;const Qpp={toc:[]},$pp="wrapper";function Kpp(t){let{components:e,...n}=t;return(0,s.kt)($pp,(0,p.Z)({},Qpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kpp.isMDXComponent=!0;const Jpp={toc:[]},trp="wrapper";function erp(t){let{components:e,...n}=t;return(0,s.kt)(trp,(0,p.Z)({},Jpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}erp.isMDXComponent=!0;const nrp={toc:[]},orp="wrapper";function prp(t){let{components:e,...n}=t;return(0,s.kt)(orp,(0,p.Z)({},nrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}prp.isMDXComponent=!0;const rrp={toc:[]},srp="wrapper";function crp(t){let{components:e,...n}=t;return(0,s.kt)(srp,(0,p.Z)({},rrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}crp.isMDXComponent=!0;const arp={toc:[]},irp="wrapper";function lrp(t){let{components:e,...n}=t;return(0,s.kt)(irp,(0,p.Z)({},arp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lrp.isMDXComponent=!0;const urp={toc:[]},mrp="wrapper";function drp(t){let{components:e,...n}=t;return(0,s.kt)(mrp,(0,p.Z)({},urp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}drp.isMDXComponent=!0;const hrp={toc:[]},frp="wrapper";function krp(t){let{components:e,...n}=t;return(0,s.kt)(frp,(0,p.Z)({},hrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}krp.isMDXComponent=!0;const yrp={toc:[]},Drp="wrapper";function Mrp(t){let{components:e,...n}=t;return(0,s.kt)(Drp,(0,p.Z)({},yrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mrp.isMDXComponent=!0;const Xrp={toc:[]},_rp="wrapper";function wrp(t){let{components:e,...n}=t;return(0,s.kt)(_rp,(0,p.Z)({},Xrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wrp.isMDXComponent=!0;const Trp={toc:[]},Crp="wrapper";function grp(t){let{components:e,...n}=t;return(0,s.kt)(Crp,(0,p.Z)({},Trp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}grp.isMDXComponent=!0;const xrp={toc:[]},vrp="wrapper";function Lrp(t){let{components:e,...n}=t;return(0,s.kt)(vrp,(0,p.Z)({},xrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lrp.isMDXComponent=!0;const Zrp={toc:[]},brp="wrapper";function Nrp(t){let{components:e,...n}=t;return(0,s.kt)(brp,(0,p.Z)({},Zrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Nrp.isMDXComponent=!0;const zrp={toc:[]},Arp="wrapper";function Prp(t){let{components:e,...n}=t;return(0,s.kt)(Arp,(0,p.Z)({},zrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Prp.isMDXComponent=!0;const Irp={toc:[]},Wrp="wrapper";function Rrp(t){let{components:e,...n}=t;return(0,s.kt)(Wrp,(0,p.Z)({},Irp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Rrp.isMDXComponent=!0;const Srp={toc:[]},Brp="wrapper";function Grp(t){let{components:e,...n}=t;return(0,s.kt)(Brp,(0,p.Z)({},Srp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Grp.isMDXComponent=!0;const Erp={toc:[]},Orp="wrapper";function Urp(t){let{components:e,...n}=t;return(0,s.kt)(Orp,(0,p.Z)({},Erp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Urp.isMDXComponent=!0;const Frp={toc:[]},Vrp="wrapper";function qrp(t){let{components:e,...n}=t;return(0,s.kt)(Vrp,(0,p.Z)({},Frp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}qrp.isMDXComponent=!0;const jrp={toc:[]},Hrp="wrapper";function Yrp(t){let{components:e,...n}=t;return(0,s.kt)(Hrp,(0,p.Z)({},jrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Yrp.isMDXComponent=!0;const Qrp={toc:[]},$rp="wrapper";function Krp(t){let{components:e,...n}=t;return(0,s.kt)($rp,(0,p.Z)({},Qrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Krp.isMDXComponent=!0;const Jrp={toc:[]},tsp="wrapper";function esp(t){let{components:e,...n}=t;return(0,s.kt)(tsp,(0,p.Z)({},Jrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}esp.isMDXComponent=!0;const nsp={toc:[]},osp="wrapper";function psp(t){let{components:e,...n}=t;return(0,s.kt)(osp,(0,p.Z)({},nsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}psp.isMDXComponent=!0;const rsp={toc:[]},ssp="wrapper";function csp(t){let{components:e,...n}=t;return(0,s.kt)(ssp,(0,p.Z)({},rsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}csp.isMDXComponent=!0;const asp={toc:[]},isp="wrapper";function lsp(t){let{components:e,...n}=t;return(0,s.kt)(isp,(0,p.Z)({},asp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lsp.isMDXComponent=!0;const usp={toc:[]},msp="wrapper";function dsp(t){let{components:e,...n}=t;return(0,s.kt)(msp,(0,p.Z)({},usp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}dsp.isMDXComponent=!0;const hsp={toc:[]},fsp="wrapper";function ksp(t){let{components:e,...n}=t;return(0,s.kt)(fsp,(0,p.Z)({},hsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}ksp.isMDXComponent=!0;const ysp={toc:[]},Dsp="wrapper";function Msp(t){let{components:e,...n}=t;return(0,s.kt)(Dsp,(0,p.Z)({},ysp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Msp.isMDXComponent=!0;const Xsp={toc:[]},_sp="wrapper";function wsp(t){let{components:e,...n}=t;return(0,s.kt)(_sp,(0,p.Z)({},Xsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wsp.isMDXComponent=!0;const Tsp={toc:[]},Csp="wrapper";function gsp(t){let{components:e,...n}=t;return(0,s.kt)(Csp,(0,p.Z)({},Tsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gsp.isMDXComponent=!0;const xsp={toc:[]},vsp="wrapper";function Lsp(t){let{components:e,...n}=t;return(0,s.kt)(vsp,(0,p.Z)({},xsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Lsp.isMDXComponent=!0;const Zsp={toc:[]},bsp="wrapper";function Nsp(t){let{components:e,...n}=t;return(0,s.kt)(bsp,(0,p.Z)({},Zsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Nsp.isMDXComponent=!0;const zsp={toc:[]},Asp="wrapper";function Psp(t){let{components:e,...n}=t;return(0,s.kt)(Asp,(0,p.Z)({},zsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Psp.isMDXComponent=!0;const Isp={toc:[]},Wsp="wrapper";function Rsp(t){let{components:e,...n}=t;return(0,s.kt)(Wsp,(0,p.Z)({},Isp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Rsp.isMDXComponent=!0;const Ssp={toc:[]},Bsp="wrapper";function Gsp(t){let{components:e,...n}=t;return(0,s.kt)(Bsp,(0,p.Z)({},Ssp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Gsp.isMDXComponent=!0;const Esp={toc:[]},Osp="wrapper";function Usp(t){let{components:e,...n}=t;return(0,s.kt)(Osp,(0,p.Z)({},Esp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Usp.isMDXComponent=!0;const Fsp={toc:[]},Vsp="wrapper";function qsp(t){let{components:e,...n}=t;return(0,s.kt)(Vsp,(0,p.Z)({},Fsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}qsp.isMDXComponent=!0;const jsp={toc:[]},Hsp="wrapper";function Ysp(t){let{components:e,...n}=t;return(0,s.kt)(Hsp,(0,p.Z)({},jsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Ysp.isMDXComponent=!0;const Qsp={toc:[]},$sp="wrapper";function Ksp(t){let{components:e,...n}=t;return(0,s.kt)($sp,(0,p.Z)({},Qsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Ksp.isMDXComponent=!0;const Jsp={toc:[]},tcp="wrapper";function ecp(t){let{components:e,...n}=t;return(0,s.kt)(tcp,(0,p.Z)({},Jsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ecp.isMDXComponent=!0;const ncp={toc:[]},ocp="wrapper";function pcp(t){let{components:e,...n}=t;return(0,s.kt)(ocp,(0,p.Z)({},ncp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pcp.isMDXComponent=!0;const rcp={toc:[]},scp="wrapper";function ccp(t){let{components:e,...n}=t;return(0,s.kt)(scp,(0,p.Z)({},rcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}ccp.isMDXComponent=!0;const acp={toc:[]},icp="wrapper";function lcp(t){let{components:e,...n}=t;return(0,s.kt)(icp,(0,p.Z)({},acp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lcp.isMDXComponent=!0;const ucp={toc:[]},mcp="wrapper";function dcp(t){let{components:e,...n}=t;return(0,s.kt)(mcp,(0,p.Z)({},ucp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}dcp.isMDXComponent=!0;const hcp={toc:[]},fcp="wrapper";function kcp(t){let{components:e,...n}=t;return(0,s.kt)(fcp,(0,p.Z)({},hcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}kcp.isMDXComponent=!0;const ycp={toc:[]},Dcp="wrapper";function Mcp(t){let{components:e,...n}=t;return(0,s.kt)(Dcp,(0,p.Z)({},ycp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Mcp.isMDXComponent=!0;const Xcp={toc:[]},_cp="wrapper";function wcp(t){let{components:e,...n}=t;return(0,s.kt)(_cp,(0,p.Z)({},Xcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}wcp.isMDXComponent=!0;const Tcp={toc:[]},Ccp="wrapper";function gcp(t){let{components:e,...n}=t;return(0,s.kt)(Ccp,(0,p.Z)({},Tcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gcp.isMDXComponent=!0;const xcp={toc:[]},vcp="wrapper";function Lcp(t){let{components:e,...n}=t;return(0,s.kt)(vcp,(0,p.Z)({},xcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Lcp.isMDXComponent=!0;const Zcp={toc:[]},bcp="wrapper";function Ncp(t){let{components:e,...n}=t;return(0,s.kt)(bcp,(0,p.Z)({},Zcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Ncp.isMDXComponent=!0;const zcp={toc:[]},Acp="wrapper";function Pcp(t){let{components:e,...n}=t;return(0,s.kt)(Acp,(0,p.Z)({},zcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Pcp.isMDXComponent=!0;const Icp={toc:[]},Wcp="wrapper";function Rcp(t){let{components:e,...n}=t;return(0,s.kt)(Wcp,(0,p.Z)({},Icp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Rcp.isMDXComponent=!0;const Scp={toc:[]},Bcp="wrapper";function Gcp(t){let{components:e,...n}=t;return(0,s.kt)(Bcp,(0,p.Z)({},Scp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Gcp.isMDXComponent=!0;const Ecp={toc:[]},Ocp="wrapper";function Ucp(t){let{components:e,...n}=t;return(0,s.kt)(Ocp,(0,p.Z)({},Ecp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Ucp.isMDXComponent=!0;const Fcp={toc:[]},Vcp="wrapper";function qcp(t){let{components:e,...n}=t;return(0,s.kt)(Vcp,(0,p.Z)({},Fcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qcp.isMDXComponent=!0;const jcp={toc:[]},Hcp="wrapper";function Ycp(t){let{components:e,...n}=t;return(0,s.kt)(Hcp,(0,p.Z)({},jcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ycp.isMDXComponent=!0;const Qcp={toc:[]},$cp="wrapper";function Kcp(t){let{components:e,...n}=t;return(0,s.kt)($cp,(0,p.Z)({},Qcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Kcp.isMDXComponent=!0;const Jcp={toc:[]},tap="wrapper";function eap(t){let{components:e,...n}=t;return(0,s.kt)(tap,(0,p.Z)({},Jcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}eap.isMDXComponent=!0;const nap={toc:[]},oap="wrapper";function pap(t){let{components:e,...n}=t;return(0,s.kt)(oap,(0,p.Z)({},nap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pap.isMDXComponent=!0;const rap={toc:[]},sap="wrapper";function cap(t){let{components:e,...n}=t;return(0,s.kt)(sap,(0,p.Z)({},rap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}cap.isMDXComponent=!0;const aap={toc:[]},iap="wrapper";function lap(t){let{components:e,...n}=t;return(0,s.kt)(iap,(0,p.Z)({},aap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}lap.isMDXComponent=!0;const uap={toc:[]},map="wrapper";function dap(t){let{components:e,...n}=t;return(0,s.kt)(map,(0,p.Z)({},uap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}dap.isMDXComponent=!0;const hap={toc:[]},fap="wrapper";function kap(t){let{components:e,...n}=t;return(0,s.kt)(fap,(0,p.Z)({},hap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}kap.isMDXComponent=!0;const yap={toc:[]},Dap="wrapper";function Map(t){let{components:e,...n}=t;return(0,s.kt)(Dap,(0,p.Z)({},yap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Map.isMDXComponent=!0;const Xap={toc:[]},_ap="wrapper";function wap(t){let{components:e,...n}=t;return(0,s.kt)(_ap,(0,p.Z)({},Xap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}wap.isMDXComponent=!0;const Tap={toc:[]},Cap="wrapper";function gap(t){let{components:e,...n}=t;return(0,s.kt)(Cap,(0,p.Z)({},Tap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}gap.isMDXComponent=!0;const xap={toc:[]},vap="wrapper";function Lap(t){let{components:e,...n}=t;return(0,s.kt)(vap,(0,p.Z)({},xap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}Lap.isMDXComponent=!0;const Zap={toc:[]},bap="wrapper";function Nap(t){let{components:e,...n}=t;return(0,s.kt)(bap,(0,p.Z)({},Zap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Nap.isMDXComponent=!0;const zap={toc:[]},Aap="wrapper";function Pap(t){let{components:e,...n}=t;return(0,s.kt)(Aap,(0,p.Z)({},zap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Pap.isMDXComponent=!0;const Iap={toc:[]},Wap="wrapper";function Rap(t){let{components:e,...n}=t;return(0,s.kt)(Wap,(0,p.Z)({},Iap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Rap.isMDXComponent=!0;const Sap={toc:[]},Bap="wrapper";function Gap(t){let{components:e,...n}=t;return(0,s.kt)(Bap,(0,p.Z)({},Sap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Gap.isMDXComponent=!0;const Eap={toc:[]},Oap="wrapper";function Uap(t){let{components:e,...n}=t;return(0,s.kt)(Oap,(0,p.Z)({},Eap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Uap.isMDXComponent=!0;const Fap={toc:[]},Vap="wrapper";function qap(t){let{components:e,...n}=t;return(0,s.kt)(Vap,(0,p.Z)({},Fap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qap.isMDXComponent=!0;const jap={toc:[]},Hap="wrapper";function Yap(t){let{components:e,...n}=t;return(0,s.kt)(Hap,(0,p.Z)({},jap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Yap.isMDXComponent=!0;const Qap={toc:[]},$ap="wrapper";function Kap(t){let{components:e,...n}=t;return(0,s.kt)($ap,(0,p.Z)({},Qap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Kap.isMDXComponent=!0;const Jap={toc:[]},tip="wrapper";function eip(t){let{components:e,...n}=t;return(0,s.kt)(tip,(0,p.Z)({},Jap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}eip.isMDXComponent=!0;const nip={toc:[]},oip="wrapper";function pip(t){let{components:e,...n}=t;return(0,s.kt)(oip,(0,p.Z)({},nip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pip.isMDXComponent=!0;const rip={toc:[]},sip="wrapper";function cip(t){let{components:e,...n}=t;return(0,s.kt)(sip,(0,p.Z)({},rip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cip.isMDXComponent=!0;const aip={toc:[]},iip="wrapper";function lip(t){let{components:e,...n}=t;return(0,s.kt)(iip,(0,p.Z)({},aip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lip.isMDXComponent=!0;const uip={toc:[]},mip="wrapper";function dip(t){let{components:e,...n}=t;return(0,s.kt)(mip,(0,p.Z)({},uip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dip.isMDXComponent=!0;const hip={toc:[]},fip="wrapper";function kip(t){let{components:e,...n}=t;return(0,s.kt)(fip,(0,p.Z)({},hip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}kip.isMDXComponent=!0;const yip={toc:[]},Dip="wrapper";function Mip(t){let{components:e,...n}=t;return(0,s.kt)(Dip,(0,p.Z)({},yip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Mip.isMDXComponent=!0;const Xip={toc:[]},_ip="wrapper";function wip(t){let{components:e,...n}=t;return(0,s.kt)(_ip,(0,p.Z)({},Xip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wip.isMDXComponent=!0;const Tip={toc:[]},Cip="wrapper";function gip(t){let{components:e,...n}=t;return(0,s.kt)(Cip,(0,p.Z)({},Tip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}gip.isMDXComponent=!0;const xip={toc:[]},vip="wrapper";function Lip(t){let{components:e,...n}=t;return(0,s.kt)(vip,(0,p.Z)({},xip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Lip.isMDXComponent=!0;const Zip={toc:[]},bip="wrapper";function Nip(t){let{components:e,...n}=t;return(0,s.kt)(bip,(0,p.Z)({},Zip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Nip.isMDXComponent=!0;const zip={toc:[]},Aip="wrapper";function Pip(t){let{components:e,...n}=t;return(0,s.kt)(Aip,(0,p.Z)({},zip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pip.isMDXComponent=!0;const Iip={toc:[]},Wip="wrapper";function Rip(t){let{components:e,...n}=t;return(0,s.kt)(Wip,(0,p.Z)({},Iip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Rip.isMDXComponent=!0;const Sip={toc:[]},Bip="wrapper";function Gip(t){let{components:e,...n}=t;return(0,s.kt)(Bip,(0,p.Z)({},Sip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Gip.isMDXComponent=!0;const Eip={toc:[]},Oip="wrapper";function Uip(t){let{components:e,...n}=t;return(0,s.kt)(Oip,(0,p.Z)({},Eip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Uip.isMDXComponent=!0;const Fip={toc:[]},Vip="wrapper";function qip(t){let{components:e,...n}=t;return(0,s.kt)(Vip,(0,p.Z)({},Fip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qip.isMDXComponent=!0;const jip={toc:[]},Hip="wrapper";function Yip(t){let{components:e,...n}=t;return(0,s.kt)(Hip,(0,p.Z)({},jip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Yip.isMDXComponent=!0;const Qip={toc:[]},$ip="wrapper";function Kip(t){let{components:e,...n}=t;return(0,s.kt)($ip,(0,p.Z)({},Qip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Kip.isMDXComponent=!0;const Jip={toc:[]},tlp="wrapper";function elp(t){let{components:e,...n}=t;return(0,s.kt)(tlp,(0,p.Z)({},Jip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}elp.isMDXComponent=!0;const nlp={toc:[]},olp="wrapper";function plp(t){let{components:e,...n}=t;return(0,s.kt)(olp,(0,p.Z)({},nlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}plp.isMDXComponent=!0;const rlp={toc:[]},slp="wrapper";function clp(t){let{components:e,...n}=t;return(0,s.kt)(slp,(0,p.Z)({},rlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}clp.isMDXComponent=!0;const alp={toc:[]},ilp="wrapper";function llp(t){let{components:e,...n}=t;return(0,s.kt)(ilp,(0,p.Z)({},alp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}llp.isMDXComponent=!0;const ulp={toc:[]},mlp="wrapper";function dlp(t){let{components:e,...n}=t;return(0,s.kt)(mlp,(0,p.Z)({},ulp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}dlp.isMDXComponent=!0;const hlp={toc:[]},flp="wrapper";function klp(t){let{components:e,...n}=t;return(0,s.kt)(flp,(0,p.Z)({},hlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}klp.isMDXComponent=!0;const ylp={toc:[]},Dlp="wrapper";function Mlp(t){let{components:e,...n}=t;return(0,s.kt)(Dlp,(0,p.Z)({},ylp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Mlp.isMDXComponent=!0;const Xlp={toc:[]},_lp="wrapper";function wlp(t){let{components:e,...n}=t;return(0,s.kt)(_lp,(0,p.Z)({},Xlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wlp.isMDXComponent=!0;const Tlp={toc:[]},Clp="wrapper";function glp(t){let{components:e,...n}=t;return(0,s.kt)(Clp,(0,p.Z)({},Tlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}glp.isMDXComponent=!0;const xlp={toc:[]},vlp="wrapper";function Llp(t){let{components:e,...n}=t;return(0,s.kt)(vlp,(0,p.Z)({},xlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Llp.isMDXComponent=!0;const Zlp={toc:[]},blp="wrapper";function Nlp(t){let{components:e,...n}=t;return(0,s.kt)(blp,(0,p.Z)({},Zlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Nlp.isMDXComponent=!0;const zlp={toc:[]},Alp="wrapper";function Plp(t){let{components:e,...n}=t;return(0,s.kt)(Alp,(0,p.Z)({},zlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Plp.isMDXComponent=!0;const Ilp={toc:[]},Wlp="wrapper";function Rlp(t){let{components:e,...n}=t;return(0,s.kt)(Wlp,(0,p.Z)({},Ilp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Rlp.isMDXComponent=!0;const Slp={toc:[]},Blp="wrapper";function Glp(t){let{components:e,...n}=t;return(0,s.kt)(Blp,(0,p.Z)({},Slp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Glp.isMDXComponent=!0;const Elp={toc:[]},Olp="wrapper";function Ulp(t){let{components:e,...n}=t;return(0,s.kt)(Olp,(0,p.Z)({},Elp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ulp.isMDXComponent=!0;const Flp={toc:[]},Vlp="wrapper";function qlp(t){let{components:e,...n}=t;return(0,s.kt)(Vlp,(0,p.Z)({},Flp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qlp.isMDXComponent=!0;const jlp={toc:[]},Hlp="wrapper";function Ylp(t){let{components:e,...n}=t;return(0,s.kt)(Hlp,(0,p.Z)({},jlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ylp.isMDXComponent=!0;const Qlp={toc:[]},$lp="wrapper";function Klp(t){let{components:e,...n}=t;return(0,s.kt)($lp,(0,p.Z)({},Qlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Klp.isMDXComponent=!0;const Jlp={toc:[]},tup="wrapper";function eup(t){let{components:e,...n}=t;return(0,s.kt)(tup,(0,p.Z)({},Jlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eup.isMDXComponent=!0;const nup={toc:[]},oup="wrapper";function pup(t){let{components:e,...n}=t;return(0,s.kt)(oup,(0,p.Z)({},nup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pup.isMDXComponent=!0;const rup={toc:[]},sup="wrapper";function cup(t){let{components:e,...n}=t;return(0,s.kt)(sup,(0,p.Z)({},rup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cup.isMDXComponent=!0;const aup={toc:[]},iup="wrapper";function lup(t){let{components:e,...n}=t;return(0,s.kt)(iup,(0,p.Z)({},aup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lup.isMDXComponent=!0;const uup={toc:[]},mup="wrapper";function dup(t){let{components:e,...n}=t;return(0,s.kt)(mup,(0,p.Z)({},uup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dup.isMDXComponent=!0;const hup={toc:[]},fup="wrapper";function kup(t){let{components:e,...n}=t;return(0,s.kt)(fup,(0,p.Z)({},hup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kup.isMDXComponent=!0;const yup={toc:[]},Dup="wrapper";function Mup(t){let{components:e,...n}=t;return(0,s.kt)(Dup,(0,p.Z)({},yup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Mup.isMDXComponent=!0;const Xup={toc:[]},_up="wrapper";function wup(t){let{components:e,...n}=t;return(0,s.kt)(_up,(0,p.Z)({},Xup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wup.isMDXComponent=!0;const Tup={toc:[]},Cup="wrapper";function gup(t){let{components:e,...n}=t;return(0,s.kt)(Cup,(0,p.Z)({},Tup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}gup.isMDXComponent=!0;const xup={toc:[]},vup="wrapper";function Lup(t){let{components:e,...n}=t;return(0,s.kt)(vup,(0,p.Z)({},xup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Lup.isMDXComponent=!0;const Zup={toc:[]},bup="wrapper";function Nup(t){let{components:e,...n}=t;return(0,s.kt)(bup,(0,p.Z)({},Zup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Nup.isMDXComponent=!0;const zup={toc:[]},Aup="wrapper";function Pup(t){let{components:e,...n}=t;return(0,s.kt)(Aup,(0,p.Z)({},zup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Pup.isMDXComponent=!0;const Iup={toc:[]},Wup="wrapper";function Rup(t){let{components:e,...n}=t;return(0,s.kt)(Wup,(0,p.Z)({},Iup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Rup.isMDXComponent=!0;const Sup={toc:[]},Bup="wrapper";function Gup(t){let{components:e,...n}=t;return(0,s.kt)(Bup,(0,p.Z)({},Sup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Gup.isMDXComponent=!0;const Eup={toc:[]},Oup="wrapper";function Uup(t){let{components:e,...n}=t;return(0,s.kt)(Oup,(0,p.Z)({},Eup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Uup.isMDXComponent=!0;const Fup={toc:[]},Vup="wrapper";function qup(t){let{components:e,...n}=t;return(0,s.kt)(Vup,(0,p.Z)({},Fup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qup.isMDXComponent=!0;const jup={toc:[]},Hup="wrapper";function Yup(t){let{components:e,...n}=t;return(0,s.kt)(Hup,(0,p.Z)({},jup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Yup.isMDXComponent=!0;const Qup={toc:[]},$up="wrapper";function Kup(t){let{components:e,...n}=t;return(0,s.kt)($up,(0,p.Z)({},Qup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Kup.isMDXComponent=!0;const Jup={toc:[]},tmp="wrapper";function emp(t){let{components:e,...n}=t;return(0,s.kt)(tmp,(0,p.Z)({},Jup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}emp.isMDXComponent=!0;const nmp={toc:[]},omp="wrapper";function pmp(t){let{components:e,...n}=t;return(0,s.kt)(omp,(0,p.Z)({},nmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pmp.isMDXComponent=!0;const rmp={toc:[]},smp="wrapper";function cmp(t){let{components:e,...n}=t;return(0,s.kt)(smp,(0,p.Z)({},rmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cmp.isMDXComponent=!0;const amp={toc:[]},imp="wrapper";function lmp(t){let{components:e,...n}=t;return(0,s.kt)(imp,(0,p.Z)({},amp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lmp.isMDXComponent=!0;const ump={toc:[]},mmp="wrapper";function dmp(t){let{components:e,...n}=t;return(0,s.kt)(mmp,(0,p.Z)({},ump,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}dmp.isMDXComponent=!0;const hmp={toc:[]},fmp="wrapper";function kmp(t){let{components:e,...n}=t;return(0,s.kt)(fmp,(0,p.Z)({},hmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}kmp.isMDXComponent=!0;const ymp={toc:[]},Dmp="wrapper";function Mmp(t){let{components:e,...n}=t;return(0,s.kt)(Dmp,(0,p.Z)({},ymp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Mmp.isMDXComponent=!0;const Xmp={toc:[]},_mp="wrapper";function wmp(t){let{components:e,...n}=t;return(0,s.kt)(_mp,(0,p.Z)({},Xmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wmp.isMDXComponent=!0;const Tmp={toc:[]},Cmp="wrapper";function gmp(t){let{components:e,...n}=t;return(0,s.kt)(Cmp,(0,p.Z)({},Tmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}gmp.isMDXComponent=!0;const xmp={toc:[]},vmp="wrapper";function Lmp(t){let{components:e,...n}=t;return(0,s.kt)(vmp,(0,p.Z)({},xmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lmp.isMDXComponent=!0;const Zmp={toc:[]},bmp="wrapper";function Nmp(t){let{components:e,...n}=t;return(0,s.kt)(bmp,(0,p.Z)({},Zmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Nmp.isMDXComponent=!0;const zmp={toc:[]},Amp="wrapper";function Pmp(t){let{components:e,...n}=t;return(0,s.kt)(Amp,(0,p.Z)({},zmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Pmp.isMDXComponent=!0;const Imp={toc:[]},Wmp="wrapper";function Rmp(t){let{components:e,...n}=t;return(0,s.kt)(Wmp,(0,p.Z)({},Imp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Rmp.isMDXComponent=!0;const Smp={toc:[]},Bmp="wrapper";function Gmp(t){let{components:e,...n}=t;return(0,s.kt)(Bmp,(0,p.Z)({},Smp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Gmp.isMDXComponent=!0;const Emp={toc:[]},Omp="wrapper";function Ump(t){let{components:e,...n}=t;return(0,s.kt)(Omp,(0,p.Z)({},Emp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Ump.isMDXComponent=!0;const Fmp={toc:[]},Vmp="wrapper";function qmp(t){let{components:e,...n}=t;return(0,s.kt)(Vmp,(0,p.Z)({},Fmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}qmp.isMDXComponent=!0;const jmp={toc:[]},Hmp="wrapper";function Ymp(t){let{components:e,...n}=t;return(0,s.kt)(Hmp,(0,p.Z)({},jmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Ymp.isMDXComponent=!0;const Qmp={toc:[]},$mp="wrapper";function Kmp(t){let{components:e,...n}=t;return(0,s.kt)($mp,(0,p.Z)({},Qmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Kmp.isMDXComponent=!0;const Jmp={toc:[]},tdp="wrapper";function edp(t){let{components:e,...n}=t;return(0,s.kt)(tdp,(0,p.Z)({},Jmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}edp.isMDXComponent=!0;const ndp={toc:[]},odp="wrapper";function pdp(t){let{components:e,...n}=t;return(0,s.kt)(odp,(0,p.Z)({},ndp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}pdp.isMDXComponent=!0;const rdp={toc:[]},sdp="wrapper";function cdp(t){let{components:e,...n}=t;return(0,s.kt)(sdp,(0,p.Z)({},rdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}cdp.isMDXComponent=!0;const adp={toc:[]},idp="wrapper";function ldp(t){let{components:e,...n}=t;return(0,s.kt)(idp,(0,p.Z)({},adp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ldp.isMDXComponent=!0;const udp={toc:[]},mdp="wrapper";function ddp(t){let{components:e,...n}=t;return(0,s.kt)(mdp,(0,p.Z)({},udp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}ddp.isMDXComponent=!0;const hdp={toc:[]},fdp="wrapper";function kdp(t){let{components:e,...n}=t;return(0,s.kt)(fdp,(0,p.Z)({},hdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}kdp.isMDXComponent=!0;const ydp={toc:[]},Ddp="wrapper";function Mdp(t){let{components:e,...n}=t;return(0,s.kt)(Ddp,(0,p.Z)({},ydp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Mdp.isMDXComponent=!0;const Xdp={toc:[]},_dp="wrapper";function wdp(t){let{components:e,...n}=t;return(0,s.kt)(_dp,(0,p.Z)({},Xdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}wdp.isMDXComponent=!0;const Tdp={toc:[]},Cdp="wrapper";function gdp(t){let{components:e,...n}=t;return(0,s.kt)(Cdp,(0,p.Z)({},Tdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}gdp.isMDXComponent=!0;const xdp={toc:[]},vdp="wrapper";function Ldp(t){let{components:e,...n}=t;return(0,s.kt)(vdp,(0,p.Z)({},xdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Ldp.isMDXComponent=!0;const Zdp={toc:[]},bdp="wrapper";function Ndp(t){let{components:e,...n}=t;return(0,s.kt)(bdp,(0,p.Z)({},Zdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Ndp.isMDXComponent=!0;const zdp={toc:[]},Adp="wrapper";function Pdp(t){let{components:e,...n}=t;return(0,s.kt)(Adp,(0,p.Z)({},zdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Pdp.isMDXComponent=!0;const Idp={toc:[]},Wdp="wrapper";function Rdp(t){let{components:e,...n}=t;return(0,s.kt)(Wdp,(0,p.Z)({},Idp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Rdp.isMDXComponent=!0;const Sdp={toc:[]},Bdp="wrapper";function Gdp(t){let{components:e,...n}=t;return(0,s.kt)(Bdp,(0,p.Z)({},Sdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Gdp.isMDXComponent=!0;const Edp={toc:[]},Odp="wrapper";function Udp(t){let{components:e,...n}=t;return(0,s.kt)(Odp,(0,p.Z)({},Edp,n,{components:e,mdxType:"MDXLayout"}))}Udp.isMDXComponent=!0;const Fdp={toc:[]},Vdp="wrapper";function qdp(t){let{components:e,...n}=t;return(0,s.kt)(Vdp,(0,p.Z)({},Fdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}qdp.isMDXComponent=!0;const jdp={toc:[]},Hdp="wrapper";function Ydp(t){let{components:e,...n}=t;return(0,s.kt)(Hdp,(0,p.Z)({},jdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Ydp.isMDXComponent=!0;const Qdp={toc:[]},$dp="wrapper";function Kdp(t){let{components:e,...n}=t;return(0,s.kt)($dp,(0,p.Z)({},Qdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Kdp.isMDXComponent=!0;const Jdp={toc:[]},thp="wrapper";function ehp(t){let{components:e,...n}=t;return(0,s.kt)(thp,(0,p.Z)({},Jdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}ehp.isMDXComponent=!0;const nhp={toc:[]},ohp="wrapper";function php(t){let{components:e,...n}=t;return(0,s.kt)(ohp,(0,p.Z)({},nhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}php.isMDXComponent=!0;const rhp={toc:[]},shp="wrapper";function chp(t){let{components:e,...n}=t;return(0,s.kt)(shp,(0,p.Z)({},rhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}chp.isMDXComponent=!0;const ahp={toc:[]},ihp="wrapper";function lhp(t){let{components:e,...n}=t;return(0,s.kt)(ihp,(0,p.Z)({},ahp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}lhp.isMDXComponent=!0;const uhp={toc:[]},mhp="wrapper";function dhp(t){let{components:e,...n}=t;return(0,s.kt)(mhp,(0,p.Z)({},uhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}dhp.isMDXComponent=!0;const hhp={toc:[]},fhp="wrapper";function khp(t){let{components:e,...n}=t;return(0,s.kt)(fhp,(0,p.Z)({},hhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}khp.isMDXComponent=!0;const yhp={toc:[]},Dhp="wrapper";function Mhp(t){let{components:e,...n}=t;return(0,s.kt)(Dhp,(0,p.Z)({},yhp,n,{components:e,mdxType:"MDXLayout"}))}Mhp.isMDXComponent=!0;const Xhp={toc:[]},_hp="wrapper";function whp(t){let{components:e,...n}=t;return(0,s.kt)(_hp,(0,p.Z)({},Xhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}whp.isMDXComponent=!0;const Thp={toc:[]},Chp="wrapper";function ghp(t){let{components:e,...n}=t;return(0,s.kt)(Chp,(0,p.Z)({},Thp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}ghp.isMDXComponent=!0;const xhp={toc:[]},vhp="wrapper";function Lhp(t){let{components:e,...n}=t;return(0,s.kt)(vhp,(0,p.Z)({},xhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lhp.isMDXComponent=!0;const Zhp={toc:[]},bhp="wrapper";function Nhp(t){let{components:e,...n}=t;return(0,s.kt)(bhp,(0,p.Z)({},Zhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Nhp.isMDXComponent=!0;const zhp={toc:[]},Ahp="wrapper";function Php(t){let{components:e,...n}=t;return(0,s.kt)(Ahp,(0,p.Z)({},zhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Php.isMDXComponent=!0;const Ihp={toc:[]},Whp="wrapper";function Rhp(t){let{components:e,...n}=t;return(0,s.kt)(Whp,(0,p.Z)({},Ihp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Rhp.isMDXComponent=!0;const Shp={toc:[]},Bhp="wrapper";function Ghp(t){let{components:e,...n}=t;return(0,s.kt)(Bhp,(0,p.Z)({},Shp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ghp.isMDXComponent=!0;const Ehp={toc:[]},Ohp="wrapper";function Uhp(t){let{components:e,...n}=t;return(0,s.kt)(Ohp,(0,p.Z)({},Ehp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Uhp.isMDXComponent=!0;const Fhp={toc:[]},Vhp="wrapper";function qhp(t){let{components:e,...n}=t;return(0,s.kt)(Vhp,(0,p.Z)({},Fhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}qhp.isMDXComponent=!0;const jhp={toc:[]},Hhp="wrapper";function Yhp(t){let{components:e,...n}=t;return(0,s.kt)(Hhp,(0,p.Z)({},jhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Yhp.isMDXComponent=!0;const Qhp={toc:[]},$hp="wrapper";function Khp(t){let{components:e,...n}=t;return(0,s.kt)($hp,(0,p.Z)({},Qhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Khp.isMDXComponent=!0;const Jhp={toc:[]},tfp="wrapper";function efp(t){let{components:e,...n}=t;return(0,s.kt)(tfp,(0,p.Z)({},Jhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}efp.isMDXComponent=!0;const nfp={toc:[]},ofp="wrapper";function pfp(t){let{components:e,...n}=t;return(0,s.kt)(ofp,(0,p.Z)({},nfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}pfp.isMDXComponent=!0;const rfp={toc:[]},sfp="wrapper";function cfp(t){let{components:e,...n}=t;return(0,s.kt)(sfp,(0,p.Z)({},rfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}cfp.isMDXComponent=!0;const afp={toc:[]},ifp="wrapper";function lfp(t){let{components:e,...n}=t;return(0,s.kt)(ifp,(0,p.Z)({},afp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}lfp.isMDXComponent=!0;const ufp={toc:[]},mfp="wrapper";function dfp(t){let{components:e,...n}=t;return(0,s.kt)(mfp,(0,p.Z)({},ufp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}dfp.isMDXComponent=!0;const hfp={toc:[]},ffp="wrapper";function kfp(t){let{components:e,...n}=t;return(0,s.kt)(ffp,(0,p.Z)({},hfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}kfp.isMDXComponent=!0;const yfp={toc:[]},Dfp="wrapper";function Mfp(t){let{components:e,...n}=t;return(0,s.kt)(Dfp,(0,p.Z)({},yfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Mfp.isMDXComponent=!0;const Xfp={toc:[]},_fp="wrapper";function wfp(t){let{components:e,...n}=t;return(0,s.kt)(_fp,(0,p.Z)({},Xfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}wfp.isMDXComponent=!0;const Tfp={toc:[]},Cfp="wrapper";function gfp(t){let{components:e,...n}=t;return(0,s.kt)(Cfp,(0,p.Z)({},Tfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}gfp.isMDXComponent=!0;const xfp={toc:[]},vfp="wrapper";function Lfp(t){let{components:e,...n}=t;return(0,s.kt)(vfp,(0,p.Z)({},xfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Lfp.isMDXComponent=!0;const Zfp={toc:[]},bfp="wrapper";function Nfp(t){let{components:e,...n}=t;return(0,s.kt)(bfp,(0,p.Z)({},Zfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Nfp.isMDXComponent=!0;const zfp={toc:[]},Afp="wrapper";function Pfp(t){let{components:e,...n}=t;return(0,s.kt)(Afp,(0,p.Z)({},zfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Pfp.isMDXComponent=!0;const Ifp={toc:[]},Wfp="wrapper";function Rfp(t){let{components:e,...n}=t;return(0,s.kt)(Wfp,(0,p.Z)({},Ifp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Rfp.isMDXComponent=!0;const Sfp={toc:[]},Bfp="wrapper";function Gfp(t){let{components:e,...n}=t;return(0,s.kt)(Bfp,(0,p.Z)({},Sfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Gfp.isMDXComponent=!0;const Efp={toc:[]},Ofp="wrapper";function Ufp(t){let{components:e,...n}=t;return(0,s.kt)(Ofp,(0,p.Z)({},Efp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Ufp.isMDXComponent=!0;const Ffp={toc:[]},Vfp="wrapper";function qfp(t){let{components:e,...n}=t;return(0,s.kt)(Vfp,(0,p.Z)({},Ffp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qfp.isMDXComponent=!0;const jfp={toc:[]},Hfp="wrapper";function Yfp(t){let{components:e,...n}=t;return(0,s.kt)(Hfp,(0,p.Z)({},jfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Yfp.isMDXComponent=!0;const Qfp={toc:[]},$fp="wrapper";function Kfp(t){let{components:e,...n}=t;return(0,s.kt)($fp,(0,p.Z)({},Qfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the cardinal point corresponding to the given origin."))}Kfp.isMDXComponent=!0;const Jfp={toc:[]},tkp="wrapper";function ekp(t){let{components:e,...n}=t;return(0,s.kt)(tkp,(0,p.Z)({},Jfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin or direction of the point."))}ekp.isMDXComponent=!0;const nkp={toc:[]},okp="wrapper";function pkp(t){let{components:e,...n}=t;return(0,s.kt)(okp,(0,p.Z)({},nkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}pkp.isMDXComponent=!0;const rkp={toc:[]},skp="wrapper";function ckp(t){let{components:e,...n}=t;return(0,s.kt)(skp,(0,p.Z)({},rkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}ckp.isMDXComponent=!0;const akp={toc:[]},ikp="wrapper";function lkp(t){let{components:e,...n}=t;return(0,s.kt)(ikp,(0,p.Z)({},akp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}lkp.isMDXComponent=!0;const ukp={toc:[]},mkp="wrapper";function dkp(t){let{components:e,...n}=t;return(0,s.kt)(mkp,(0,p.Z)({},ukp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dkp.isMDXComponent=!0;const hkp={toc:[]},fkp="wrapper";function kkp(t){let{components:e,...n}=t;return(0,s.kt)(fkp,(0,p.Z)({},hkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kkp.isMDXComponent=!0;const ykp={toc:[]},Dkp="wrapper";function Mkp(t){let{components:e,...n}=t;return(0,s.kt)(Dkp,(0,p.Z)({},ykp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mkp.isMDXComponent=!0;const Xkp={toc:[]},_kp="wrapper";function wkp(t){let{components:e,...n}=t;return(0,s.kt)(_kp,(0,p.Z)({},Xkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}wkp.isMDXComponent=!0;const Tkp={toc:[]},Ckp="wrapper";function gkp(t){let{components:e,...n}=t;return(0,s.kt)(Ckp,(0,p.Z)({},Tkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}gkp.isMDXComponent=!0;const xkp={toc:[]},vkp="wrapper";function Lkp(t){let{components:e,...n}=t;return(0,s.kt)(vkp,(0,p.Z)({},xkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Lkp.isMDXComponent=!0;const Zkp={toc:[]},bkp="wrapper";function Nkp(t){let{components:e,...n}=t;return(0,s.kt)(bkp,(0,p.Z)({},Zkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Nkp.isMDXComponent=!0;const zkp={toc:[]},Akp="wrapper";function Pkp(t){let{components:e,...n}=t;return(0,s.kt)(Akp,(0,p.Z)({},zkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Pkp.isMDXComponent=!0;const Ikp={toc:[]},Wkp="wrapper";function Rkp(t){let{components:e,...n}=t;return(0,s.kt)(Wkp,(0,p.Z)({},Ikp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Rkp.isMDXComponent=!0;const Skp={toc:[]},Bkp="wrapper";function Gkp(t){let{components:e,...n}=t;return(0,s.kt)(Bkp,(0,p.Z)({},Skp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Gkp.isMDXComponent=!0;const Ekp={toc:[]},Okp="wrapper";function Ukp(t){let{components:e,...n}=t;return(0,s.kt)(Okp,(0,p.Z)({},Ekp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Ukp.isMDXComponent=!0;const Fkp={toc:[]},Vkp="wrapper";function qkp(t){let{components:e,...n}=t;return(0,s.kt)(Vkp,(0,p.Z)({},Fkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qkp.isMDXComponent=!0;const jkp={toc:[]},Hkp="wrapper";function Ykp(t){let{components:e,...n}=t;return(0,s.kt)(Hkp,(0,p.Z)({},jkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Ykp.isMDXComponent=!0;const Qkp={toc:[]},$kp="wrapper";function Kkp(t){let{components:e,...n}=t;return(0,s.kt)($kp,(0,p.Z)({},Qkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Kkp.isMDXComponent=!0;const Jkp={toc:[]},typ="wrapper";function eyp(t){let{components:e,...n}=t;return(0,s.kt)(typ,(0,p.Z)({},Jkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}eyp.isMDXComponent=!0;const nyp={toc:[]},oyp="wrapper";function pyp(t){let{components:e,...n}=t;return(0,s.kt)(oyp,(0,p.Z)({},nyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}pyp.isMDXComponent=!0;const ryp={toc:[]},syp="wrapper";function cyp(t){let{components:e,...n}=t;return(0,s.kt)(syp,(0,p.Z)({},ryp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cyp.isMDXComponent=!0;const ayp={toc:[]},iyp="wrapper";function lyp(t){let{components:e,...n}=t;return(0,s.kt)(iyp,(0,p.Z)({},ayp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lyp.isMDXComponent=!0;const uyp={toc:[]},myp="wrapper";function dyp(t){let{components:e,...n}=t;return(0,s.kt)(myp,(0,p.Z)({},uyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}dyp.isMDXComponent=!0;const hyp={toc:[]},fyp="wrapper";function kyp(t){let{components:e,...n}=t;return(0,s.kt)(fyp,(0,p.Z)({},hyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kyp.isMDXComponent=!0;const yyp={toc:[]},Dyp="wrapper";function Myp(t){let{components:e,...n}=t;return(0,s.kt)(Dyp,(0,p.Z)({},yyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Myp.isMDXComponent=!0;const Xyp={toc:[]},_yp="wrapper";function wyp(t){let{components:e,...n}=t;return(0,s.kt)(_yp,(0,p.Z)({},Xyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}wyp.isMDXComponent=!0;const Typ={toc:[]},Cyp="wrapper";function gyp(t){let{components:e,...n}=t;return(0,s.kt)(Cyp,(0,p.Z)({},Typ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gyp.isMDXComponent=!0;const xyp={toc:[]},vyp="wrapper";function Lyp(t){let{components:e,...n}=t;return(0,s.kt)(vyp,(0,p.Z)({},xyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Lyp.isMDXComponent=!0;const Zyp={toc:[]},byp="wrapper";function Nyp(t){let{components:e,...n}=t;return(0,s.kt)(byp,(0,p.Z)({},Zyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nyp.isMDXComponent=!0;const zyp={toc:[]},Ayp="wrapper";function Pyp(t){let{components:e,...n}=t;return(0,s.kt)(Ayp,(0,p.Z)({},zyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Pyp.isMDXComponent=!0;const Iyp={toc:[]},Wyp="wrapper";function Ryp(t){let{components:e,...n}=t;return(0,s.kt)(Wyp,(0,p.Z)({},Iyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ryp.isMDXComponent=!0;const Syp={toc:[]},Byp="wrapper";function Gyp(t){let{components:e,...n}=t;return(0,s.kt)(Byp,(0,p.Z)({},Syp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Gyp.isMDXComponent=!0;const Eyp={toc:[]},Oyp="wrapper";function Uyp(t){let{components:e,...n}=t;return(0,s.kt)(Oyp,(0,p.Z)({},Eyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Uyp.isMDXComponent=!0;const Fyp={toc:[]},Vyp="wrapper";function qyp(t){let{components:e,...n}=t;return(0,s.kt)(Vyp,(0,p.Z)({},Fyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}qyp.isMDXComponent=!0;const jyp={toc:[]},Hyp="wrapper";function Yyp(t){let{components:e,...n}=t;return(0,s.kt)(Hyp,(0,p.Z)({},jyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Yyp.isMDXComponent=!0;const Qyp={toc:[]},$yp="wrapper";function Kyp(t){let{components:e,...n}=t;return(0,s.kt)($yp,(0,p.Z)({},Qyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Kyp.isMDXComponent=!0;const Jyp={toc:[]},tDp="wrapper";function eDp(t){let{components:e,...n}=t;return(0,s.kt)(tDp,(0,p.Z)({},Jyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eDp.isMDXComponent=!0;const nDp={toc:[]},oDp="wrapper";function pDp(t){let{components:e,...n}=t;return(0,s.kt)(oDp,(0,p.Z)({},nDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find a node by its key."))}pDp.isMDXComponent=!0;const rDp={toc:[]},sDp="wrapper";function cDp(t){let{components:e,...n}=t;return(0,s.kt)(sDp,(0,p.Z)({},rDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The key of the node."))}cDp.isMDXComponent=!0;const aDp={toc:[]},iDp="wrapper";function lDp(t){let{components:e,...n}=t;return(0,s.kt)(iDp,(0,p.Z)({},aDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}lDp.isMDXComponent=!0;const uDp={toc:[]},mDp="wrapper";function dDp(t){let{components:e,...n}=t;return(0,s.kt)(mDp,(0,p.Z)({},uDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dDp.isMDXComponent=!0;const hDp={toc:[]},fDp="wrapper";function kDp(t){let{components:e,...n}=t;return(0,s.kt)(fDp,(0,p.Z)({},hDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}kDp.isMDXComponent=!0;const yDp={toc:[]},DDp="wrapper";function MDp(t){let{components:e,...n}=t;return(0,s.kt)(DDp,(0,p.Z)({},yDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MDp.isMDXComponent=!0;const XDp={toc:[]},_Dp="wrapper";function wDp(t){let{components:e,...n}=t;return(0,s.kt)(_Dp,(0,p.Z)({},XDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wDp.isMDXComponent=!0;const TDp={toc:[]},CDp="wrapper";function gDp(t){let{components:e,...n}=t;return(0,s.kt)(CDp,(0,p.Z)({},TDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}gDp.isMDXComponent=!0;const xDp={toc:[]},vDp="wrapper";function LDp(t){let{components:e,...n}=t;return(0,s.kt)(vDp,(0,p.Z)({},xDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}LDp.isMDXComponent=!0;const ZDp={toc:[]},bDp="wrapper";function NDp(t){let{components:e,...n}=t;return(0,s.kt)(bDp,(0,p.Z)({},ZDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}NDp.isMDXComponent=!0;const zDp={toc:[]},ADp="wrapper";function PDp(t){let{components:e,...n}=t;return(0,s.kt)(ADp,(0,p.Z)({},zDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}PDp.isMDXComponent=!0;const IDp={toc:[]},WDp="wrapper";function RDp(t){let{components:e,...n}=t;return(0,s.kt)(WDp,(0,p.Z)({},IDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}RDp.isMDXComponent=!0;const SDp={toc:[]},BDp="wrapper";function GDp(t){let{components:e,...n}=t;return(0,s.kt)(BDp,(0,p.Z)({},SDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}GDp.isMDXComponent=!0;const EDp={toc:[]},ODp="wrapper";function UDp(t){let{components:e,...n}=t;return(0,s.kt)(ODp,(0,p.Z)({},EDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}UDp.isMDXComponent=!0;const FDp={toc:[]},VDp="wrapper";function qDp(t){let{components:e,...n}=t;return(0,s.kt)(VDp,(0,p.Z)({},FDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qDp.isMDXComponent=!0;const jDp={toc:[]},HDp="wrapper";function YDp(t){let{components:e,...n}=t;return(0,s.kt)(HDp,(0,p.Z)({},jDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}YDp.isMDXComponent=!0;const QDp={toc:[]},$Dp="wrapper";function KDp(t){let{components:e,...n}=t;return(0,s.kt)($Dp,(0,p.Z)({},QDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}KDp.isMDXComponent=!0;const JDp={toc:[]},tMp="wrapper";function eMp(t){let{components:e,...n}=t;return(0,s.kt)(tMp,(0,p.Z)({},JDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}eMp.isMDXComponent=!0;const nMp={toc:[]},oMp="wrapper";function pMp(t){let{components:e,...n}=t;return(0,s.kt)(oMp,(0,p.Z)({},nMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}pMp.isMDXComponent=!0;const rMp={toc:[]},sMp="wrapper";function cMp(t){let{components:e,...n}=t;return(0,s.kt)(sMp,(0,p.Z)({},rMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}cMp.isMDXComponent=!0;const aMp={toc:[]},iMp="wrapper";function lMp(t){let{components:e,...n}=t;return(0,s.kt)(iMp,(0,p.Z)({},aMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lMp.isMDXComponent=!0;const uMp={toc:[]},mMp="wrapper";function dMp(t){let{components:e,...n}=t;return(0,s.kt)(mMp,(0,p.Z)({},uMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}dMp.isMDXComponent=!0;const hMp={toc:[]},fMp="wrapper";function kMp(t){let{components:e,...n}=t;return(0,s.kt)(fMp,(0,p.Z)({},hMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kMp.isMDXComponent=!0;const yMp={toc:[]},DMp="wrapper";function MMp(t){let{components:e,...n}=t;return(0,s.kt)(DMp,(0,p.Z)({},yMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}MMp.isMDXComponent=!0;const XMp={toc:[]},_Mp="wrapper";function wMp(t){let{components:e,...n}=t;return(0,s.kt)(_Mp,(0,p.Z)({},XMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wMp.isMDXComponent=!0;const TMp={toc:[]},CMp="wrapper";function gMp(t){let{components:e,...n}=t;return(0,s.kt)(CMp,(0,p.Z)({},TMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}gMp.isMDXComponent=!0;const xMp={toc:[]},vMp="wrapper";function LMp(t){let{components:e,...n}=t;return(0,s.kt)(vMp,(0,p.Z)({},xMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}LMp.isMDXComponent=!0;const ZMp={toc:[]},bMp="wrapper";function NMp(t){let{components:e,...n}=t;return(0,s.kt)(bMp,(0,p.Z)({},ZMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}NMp.isMDXComponent=!0;const zMp={toc:[]},AMp="wrapper";function PMp(t){let{components:e,...n}=t;return(0,s.kt)(AMp,(0,p.Z)({},zMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}PMp.isMDXComponent=!0;const IMp={toc:[]},WMp="wrapper";function RMp(t){let{components:e,...n}=t;return(0,s.kt)(WMp,(0,p.Z)({},IMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}RMp.isMDXComponent=!0;const SMp={toc:[]},BMp="wrapper";function GMp(t){let{components:e,...n}=t;return(0,s.kt)(BMp,(0,p.Z)({},SMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}GMp.isMDXComponent=!0;const EMp={toc:[]},OMp="wrapper";function UMp(t){let{components:e,...n}=t;return(0,s.kt)(OMp,(0,p.Z)({},EMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}UMp.isMDXComponent=!0;const FMp={toc:[]},VMp="wrapper";function qMp(t){let{components:e,...n}=t;return(0,s.kt)(VMp,(0,p.Z)({},FMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qMp.isMDXComponent=!0;const jMp={toc:[]},HMp="wrapper";function YMp(t){let{components:e,...n}=t;return(0,s.kt)(HMp,(0,p.Z)({},jMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}YMp.isMDXComponent=!0;const QMp={toc:[]},$Mp="wrapper";function KMp(t){let{components:e,...n}=t;return(0,s.kt)($Mp,(0,p.Z)({},QMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}KMp.isMDXComponent=!0;const JMp={toc:[]},tXp="wrapper";function eXp(t){let{components:e,...n}=t;return(0,s.kt)(tXp,(0,p.Z)({},JMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}eXp.isMDXComponent=!0;const nXp={toc:[]},oXp="wrapper";function pXp(t){let{components:e,...n}=t;return(0,s.kt)(oXp,(0,p.Z)({},nXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pXp.isMDXComponent=!0;const rXp={toc:[]},sXp="wrapper";function cXp(t){let{components:e,...n}=t;return(0,s.kt)(sXp,(0,p.Z)({},rXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cXp.isMDXComponent=!0;const aXp={toc:[]},iXp="wrapper";function lXp(t){let{components:e,...n}=t;return(0,s.kt)(iXp,(0,p.Z)({},aXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lXp.isMDXComponent=!0;const uXp={toc:[]},mXp="wrapper";function dXp(t){let{components:e,...n}=t;return(0,s.kt)(mXp,(0,p.Z)({},uXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}dXp.isMDXComponent=!0;const hXp={toc:[]},fXp="wrapper";function kXp(t){let{components:e,...n}=t;return(0,s.kt)(fXp,(0,p.Z)({},hXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kXp.isMDXComponent=!0;const yXp={toc:[]},DXp="wrapper";function MXp(t){let{components:e,...n}=t;return(0,s.kt)(DXp,(0,p.Z)({},yXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}MXp.isMDXComponent=!0;const XXp={toc:[]},_Xp="wrapper";function wXp(t){let{components:e,...n}=t;return(0,s.kt)(_Xp,(0,p.Z)({},XXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wXp.isMDXComponent=!0;const TXp={toc:[]},CXp="wrapper";function gXp(t){let{components:e,...n}=t;return(0,s.kt)(CXp,(0,p.Z)({},TXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}gXp.isMDXComponent=!0;const xXp={toc:[]},vXp="wrapper";function LXp(t){let{components:e,...n}=t;return(0,s.kt)(vXp,(0,p.Z)({},xXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}LXp.isMDXComponent=!0;const ZXp={toc:[]},bXp="wrapper";function NXp(t){let{components:e,...n}=t;return(0,s.kt)(bXp,(0,p.Z)({},ZXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NXp.isMDXComponent=!0;const zXp={toc:[]},AXp="wrapper";function PXp(t){let{components:e,...n}=t;return(0,s.kt)(AXp,(0,p.Z)({},zXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}PXp.isMDXComponent=!0;const IXp={toc:[]},WXp="wrapper";function RXp(t){let{components:e,...n}=t;return(0,s.kt)(WXp,(0,p.Z)({},IXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}RXp.isMDXComponent=!0;const SXp={toc:[]},BXp="wrapper";function GXp(t){let{components:e,...n}=t;return(0,s.kt)(BXp,(0,p.Z)({},SXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}GXp.isMDXComponent=!0;const EXp={toc:[]},OXp="wrapper";function UXp(t){let{components:e,...n}=t;return(0,s.kt)(OXp,(0,p.Z)({},EXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}UXp.isMDXComponent=!0;const FXp={toc:[]},VXp="wrapper";function qXp(t){let{components:e,...n}=t;return(0,s.kt)(VXp,(0,p.Z)({},FXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}qXp.isMDXComponent=!0;const jXp={toc:[]},HXp="wrapper";function YXp(t){let{components:e,...n}=t;return(0,s.kt)(HXp,(0,p.Z)({},jXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}YXp.isMDXComponent=!0;const QXp={toc:[]},$Xp="wrapper";function KXp(t){let{components:e,...n}=t;return(0,s.kt)($Xp,(0,p.Z)({},QXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}KXp.isMDXComponent=!0;const JXp={toc:[]},t_p="wrapper";function e_p(t){let{components:e,...n}=t;return(0,s.kt)(t_p,(0,p.Z)({},JXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}e_p.isMDXComponent=!0;const n_p={toc:[]},o_p="wrapper";function p_p(t){let{components:e,...n}=t;return(0,s.kt)(o_p,(0,p.Z)({},n_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node's parent to\nworld space."))}p_p.isMDXComponent=!0;const r_p={toc:[]},s_p="wrapper";function c_p(t){let{components:e,...n}=t;return(0,s.kt)(s_p,(0,p.Z)({},r_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent-to-world matrix for this node."))}c_p.isMDXComponent=!0;const a_p={toc:[]},i_p="wrapper";function l_p(t){let{components:e,...n}=t;return(0,s.kt)(i_p,(0,p.Z)({},a_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}l_p.isMDXComponent=!0;const u_p={toc:[]},m_p="wrapper";function d_p(t){let{components:e,...n}=t;return(0,s.kt)(m_p,(0,p.Z)({},u_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}d_p.isMDXComponent=!0;const h_p={toc:[]},f_p="wrapper";function k_p(t){let{components:e,...n}=t;return(0,s.kt)(f_p,(0,p.Z)({},h_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.kt)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}k_p.isMDXComponent=!0;const y_p={toc:[]},D_p="wrapper";function M_p(t){let{components:e,...n}=t;return(0,s.kt)(D_p,(0,p.Z)({},y_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current children of this node."))}M_p.isMDXComponent=!0;const X_p={toc:[]},__p="wrapper";function w_p(t){let{components:e,...n}=t;return(0,s.kt)(__p,(0,p.Z)({},X_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}w_p.isMDXComponent=!0;const T_p={toc:[]},C_p="wrapper";function g_p(t){let{components:e,...n}=t;return(0,s.kt)(C_p,(0,p.Z)({},T_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}g_p.isMDXComponent=!0;const x_p={toc:[]},v_p="wrapper";function L_p(t){let{components:e,...n}=t;return(0,s.kt)(v_p,(0,p.Z)({},x_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}L_p.isMDXComponent=!0;const Z_p={toc:[]},b_p="wrapper";function N_p(t){let{components:e,...n}=t;return(0,s.kt)(b_p,(0,p.Z)({},Z_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}N_p.isMDXComponent=!0;const z_p={toc:[]},A_p="wrapper";function P_p(t){let{components:e,...n}=t;return(0,s.kt)(A_p,(0,p.Z)({},z_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}P_p.isMDXComponent=!0;const I_p={toc:[]},W_p="wrapper";function R_p(t){let{components:e,...n}=t;return(0,s.kt)(W_p,(0,p.Z)({},I_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}R_p.isMDXComponent=!0;const S_p={toc:[]},B_p="wrapper";function G_p(t){let{components:e,...n}=t;return(0,s.kt)(B_p,(0,p.Z)({},S_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}G_p.isMDXComponent=!0;const E_p={toc:[]},O_p="wrapper";function U_p(t){let{components:e,...n}=t;return(0,s.kt)(O_p,(0,p.Z)({},E_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}U_p.isMDXComponent=!0;const F_p={toc:[]},V_p="wrapper";function q_p(t){let{components:e,...n}=t;return(0,s.kt)(V_p,(0,p.Z)({},F_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}q_p.isMDXComponent=!0;const j_p={toc:[]},H_p="wrapper";function Y_p(t){let{components:e,...n}=t;return(0,s.kt)(H_p,(0,p.Z)({},j_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Y_p.isMDXComponent=!0;const Q_p={toc:[]},$_p="wrapper";function K_p(t){let{components:e,...n}=t;return(0,s.kt)($_p,(0,p.Z)({},Q_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}K_p.isMDXComponent=!0;const J_p={toc:[]},twp="wrapper";function ewp(t){let{components:e,...n}=t;return(0,s.kt)(twp,(0,p.Z)({},J_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}ewp.isMDXComponent=!0;const nwp={toc:[]},owp="wrapper";function pwp(t){let{components:e,...n}=t;return(0,s.kt)(owp,(0,p.Z)({},nwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}pwp.isMDXComponent=!0;const rwp={toc:[]},swp="wrapper";function cwp(t){let{components:e,...n}=t;return(0,s.kt)(swp,(0,p.Z)({},rwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}cwp.isMDXComponent=!0;const awp={toc:[]},iwp="wrapper";function lwp(t){let{components:e,...n}=t;return(0,s.kt)(iwp,(0,p.Z)({},awp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}lwp.isMDXComponent=!0;const uwp={toc:[]},mwp="wrapper";function dwp(t){let{components:e,...n}=t;return(0,s.kt)(mwp,(0,p.Z)({},uwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}dwp.isMDXComponent=!0;const hwp={toc:[]},fwp="wrapper";function kwp(t){let{components:e,...n}=t;return(0,s.kt)(fwp,(0,p.Z)({},hwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}kwp.isMDXComponent=!0;const ywp={toc:[]},Dwp="wrapper";function Mwp(t){let{components:e,...n}=t;return(0,s.kt)(Dwp,(0,p.Z)({},ywp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Mwp.isMDXComponent=!0;const Xwp={toc:[]},_wp="wrapper";function wwp(t){let{components:e,...n}=t;return(0,s.kt)(_wp,(0,p.Z)({},Xwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}wwp.isMDXComponent=!0;const Twp={toc:[]},Cwp="wrapper";function gwp(t){let{components:e,...n}=t;return(0,s.kt)(Cwp,(0,p.Z)({},Twp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gwp.isMDXComponent=!0;const xwp={toc:[]},vwp="wrapper";function Lwp(t){let{components:e,...n}=t;return(0,s.kt)(vwp,(0,p.Z)({},xwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Lwp.isMDXComponent=!0;const Zwp={toc:[]},bwp="wrapper";function Nwp(t){let{components:e,...n}=t;return(0,s.kt)(bwp,(0,p.Z)({},Zwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Nwp.isMDXComponent=!0;const zwp={toc:[]},Awp="wrapper";function Pwp(t){let{components:e,...n}=t;return(0,s.kt)(Awp,(0,p.Z)({},zwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pwp.isMDXComponent=!0;const Iwp={toc:[]},Wwp="wrapper";function Rwp(t){let{components:e,...n}=t;return(0,s.kt)(Wwp,(0,p.Z)({},Iwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Rwp.isMDXComponent=!0;const Swp={toc:[]},Bwp="wrapper";function Gwp(t){let{components:e,...n}=t;return(0,s.kt)(Bwp,(0,p.Z)({},Swp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Gwp.isMDXComponent=!0;const Ewp={toc:[]},Owp="wrapper";function Uwp(t){let{components:e,...n}=t;return(0,s.kt)(Owp,(0,p.Z)({},Ewp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Uwp.isMDXComponent=!0;const Fwp={toc:[]},Vwp="wrapper";function qwp(t){let{components:e,...n}=t;return(0,s.kt)(Vwp,(0,p.Z)({},Fwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qwp.isMDXComponent=!0;const jwp={toc:[]},Hwp="wrapper";function Ywp(t){let{components:e,...n}=t;return(0,s.kt)(Hwp,(0,p.Z)({},jwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Ywp.isMDXComponent=!0;const Qwp={toc:[]},$wp="wrapper";function Kwp(t){let{components:e,...n}=t;return(0,s.kt)($wp,(0,p.Z)({},Qwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Kwp.isMDXComponent=!0;const Jwp={toc:[]},tTp="wrapper";function eTp(t){let{components:e,...n}=t;return(0,s.kt)(tTp,(0,p.Z)({},Jwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}eTp.isMDXComponent=!0;const nTp={toc:[]},oTp="wrapper";function pTp(t){let{components:e,...n}=t;return(0,s.kt)(oTp,(0,p.Z)({},nTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}pTp.isMDXComponent=!0;const rTp={toc:[]},sTp="wrapper";function cTp(t){let{components:e,...n}=t;return(0,s.kt)(sTp,(0,p.Z)({},rTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}cTp.isMDXComponent=!0;const aTp={toc:[]},iTp="wrapper";function lTp(t){let{components:e,...n}=t;return(0,s.kt)(iTp,(0,p.Z)({},aTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}lTp.isMDXComponent=!0;const uTp={toc:[]},mTp="wrapper";function dTp(t){let{components:e,...n}=t;return(0,s.kt)(mTp,(0,p.Z)({},uTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}dTp.isMDXComponent=!0;const hTp={toc:[]},fTp="wrapper";function kTp(t){let{components:e,...n}=t;return(0,s.kt)(fTp,(0,p.Z)({},hTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}kTp.isMDXComponent=!0;const yTp={toc:[]},DTp="wrapper";function MTp(t){let{components:e,...n}=t;return(0,s.kt)(DTp,(0,p.Z)({},yTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}MTp.isMDXComponent=!0;const XTp={toc:[]},_Tp="wrapper";function wTp(t){let{components:e,...n}=t;return(0,s.kt)(_Tp,(0,p.Z)({},XTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wTp.isMDXComponent=!0;const TTp={toc:[]},CTp="wrapper";function gTp(t){let{components:e,...n}=t;return(0,s.kt)(CTp,(0,p.Z)({},TTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gTp.isMDXComponent=!0;const xTp={toc:[]},vTp="wrapper";function LTp(t){let{components:e,...n}=t;return(0,s.kt)(vTp,(0,p.Z)({},xTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LTp.isMDXComponent=!0;const ZTp={toc:[]},bTp="wrapper";function NTp(t){let{components:e,...n}=t;return(0,s.kt)(bTp,(0,p.Z)({},ZTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}NTp.isMDXComponent=!0;const zTp={toc:[]},ATp="wrapper";function PTp(t){let{components:e,...n}=t;return(0,s.kt)(ATp,(0,p.Z)({},zTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}PTp.isMDXComponent=!0;const ITp={toc:[]},WTp="wrapper";function RTp(t){let{components:e,...n}=t;return(0,s.kt)(WTp,(0,p.Z)({},ITp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}RTp.isMDXComponent=!0;const STp={toc:[]},BTp="wrapper";function GTp(t){let{components:e,...n}=t;return(0,s.kt)(BTp,(0,p.Z)({},STp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}GTp.isMDXComponent=!0;const ETp={toc:[]},OTp="wrapper";function UTp(t){let{components:e,...n}=t;return(0,s.kt)(OTp,(0,p.Z)({},ETp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}UTp.isMDXComponent=!0;const FTp={toc:[]},VTp="wrapper";function qTp(t){let{components:e,...n}=t;return(0,s.kt)(VTp,(0,p.Z)({},FTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qTp.isMDXComponent=!0;const jTp={toc:[]},HTp="wrapper";function YTp(t){let{components:e,...n}=t;return(0,s.kt)(HTp,(0,p.Z)({},jTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}YTp.isMDXComponent=!0;const QTp={toc:[]},$Tp="wrapper";function KTp(t){let{components:e,...n}=t;return(0,s.kt)($Tp,(0,p.Z)({},QTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}KTp.isMDXComponent=!0;const JTp={toc:[]},tCp="wrapper";function eCp(t){let{components:e,...n}=t;return(0,s.kt)(tCp,(0,p.Z)({},JTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}eCp.isMDXComponent=!0;const nCp={toc:[]},oCp="wrapper";function pCp(t){let{components:e,...n}=t;return(0,s.kt)(oCp,(0,p.Z)({},nCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}pCp.isMDXComponent=!0;const rCp={toc:[]},sCp="wrapper";function cCp(t){let{components:e,...n}=t;return(0,s.kt)(sCp,(0,p.Z)({},rCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}cCp.isMDXComponent=!0;const aCp={toc:[]},iCp="wrapper";function lCp(t){let{components:e,...n}=t;return(0,s.kt)(iCp,(0,p.Z)({},aCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lCp.isMDXComponent=!0;const uCp={toc:[]},mCp="wrapper";function dCp(t){let{components:e,...n}=t;return(0,s.kt)(mCp,(0,p.Z)({},uCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}dCp.isMDXComponent=!0;const hCp={toc:[]},fCp="wrapper";function kCp(t){let{components:e,...n}=t;return(0,s.kt)(fCp,(0,p.Z)({},hCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kCp.isMDXComponent=!0;const yCp={toc:[]},DCp="wrapper";function MCp(t){let{components:e,...n}=t;return(0,s.kt)(DCp,(0,p.Z)({},yCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}MCp.isMDXComponent=!0;const XCp={toc:[]},_Cp="wrapper";function wCp(t){let{components:e,...n}=t;return(0,s.kt)(_Cp,(0,p.Z)({},XCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wCp.isMDXComponent=!0;const TCp={toc:[]},CCp="wrapper";function gCp(t){let{components:e,...n}=t;return(0,s.kt)(CCp,(0,p.Z)({},TCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}gCp.isMDXComponent=!0;const xCp={toc:[]},vCp="wrapper";function LCp(t){let{components:e,...n}=t;return(0,s.kt)(vCp,(0,p.Z)({},xCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}LCp.isMDXComponent=!0;const ZCp={toc:[]},bCp="wrapper";function NCp(t){let{components:e,...n}=t;return(0,s.kt)(bCp,(0,p.Z)({},ZCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}NCp.isMDXComponent=!0;const zCp={toc:[]},ACp="wrapper";function PCp(t){let{components:e,...n}=t;return(0,s.kt)(ACp,(0,p.Z)({},zCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}PCp.isMDXComponent=!0;const ICp={toc:[]},WCp="wrapper";function RCp(t){let{components:e,...n}=t;return(0,s.kt)(WCp,(0,p.Z)({},ICp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}RCp.isMDXComponent=!0;const SCp={toc:[]},BCp="wrapper";function GCp(t){let{components:e,...n}=t;return(0,s.kt)(BCp,(0,p.Z)({},SCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}GCp.isMDXComponent=!0;const ECp={toc:[]},OCp="wrapper";function UCp(t){let{components:e,...n}=t;return(0,s.kt)(OCp,(0,p.Z)({},ECp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}UCp.isMDXComponent=!0;const FCp={toc:[]},VCp="wrapper";function qCp(t){let{components:e,...n}=t;return(0,s.kt)(VCp,(0,p.Z)({},FCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qCp.isMDXComponent=!0;const jCp={toc:[]},HCp="wrapper";function YCp(t){let{components:e,...n}=t;return(0,s.kt)(HCp,(0,p.Z)({},jCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}YCp.isMDXComponent=!0;const QCp={toc:[]},$Cp="wrapper";function KCp(t){let{components:e,...n}=t;return(0,s.kt)($Cp,(0,p.Z)({},QCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}KCp.isMDXComponent=!0;const JCp={toc:[]},tgp="wrapper";function egp(t){let{components:e,...n}=t;return(0,s.kt)(tgp,(0,p.Z)({},JCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}egp.isMDXComponent=!0;const ngp={toc:[]},ogp="wrapper";function pgp(t){let{components:e,...n}=t;return(0,s.kt)(ogp,(0,p.Z)({},ngp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}pgp.isMDXComponent=!0;const rgp={toc:[]},sgp="wrapper";function cgp(t){let{components:e,...n}=t;return(0,s.kt)(sgp,(0,p.Z)({},rgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}cgp.isMDXComponent=!0;const agp={toc:[]},igp="wrapper";function lgp(t){let{components:e,...n}=t;return(0,s.kt)(igp,(0,p.Z)({},agp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}lgp.isMDXComponent=!0;const ugp={toc:[]},mgp="wrapper";function dgp(t){let{components:e,...n}=t;return(0,s.kt)(mgp,(0,p.Z)({},ugp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}dgp.isMDXComponent=!0;const hgp={toc:[]},fgp="wrapper";function kgp(t){let{components:e,...n}=t;return(0,s.kt)(fgp,(0,p.Z)({},hgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kgp.isMDXComponent=!0;const ygp={toc:[]},Dgp="wrapper";function Mgp(t){let{components:e,...n}=t;return(0,s.kt)(Dgp,(0,p.Z)({},ygp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Mgp.isMDXComponent=!0;const Xgp={toc:[]},_gp="wrapper";function wgp(t){let{components:e,...n}=t;return(0,s.kt)(_gp,(0,p.Z)({},Xgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}wgp.isMDXComponent=!0;const Tgp={toc:[]},Cgp="wrapper";function ggp(t){let{components:e,...n}=t;return(0,s.kt)(Cgp,(0,p.Z)({},Tgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}ggp.isMDXComponent=!0;const xgp={toc:[]},vgp="wrapper";function Lgp(t){let{components:e,...n}=t;return(0,s.kt)(vgp,(0,p.Z)({},xgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lgp.isMDXComponent=!0;const Zgp={toc:[]},bgp="wrapper";function Ngp(t){let{components:e,...n}=t;return(0,s.kt)(bgp,(0,p.Z)({},Zgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Ngp.isMDXComponent=!0;const zgp={toc:[]},Agp="wrapper";function Pgp(t){let{components:e,...n}=t;return(0,s.kt)(Agp,(0,p.Z)({},zgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Pgp.isMDXComponent=!0;const Igp={toc:[]},Wgp="wrapper";function Rgp(t){let{components:e,...n}=t;return(0,s.kt)(Wgp,(0,p.Z)({},Igp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Rgp.isMDXComponent=!0;const Sgp={toc:[]},Bgp="wrapper";function Ggp(t){let{components:e,...n}=t;return(0,s.kt)(Bgp,(0,p.Z)({},Sgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ggp.isMDXComponent=!0;const Egp={toc:[]},Ogp="wrapper";function Ugp(t){let{components:e,...n}=t;return(0,s.kt)(Ogp,(0,p.Z)({},Egp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Ugp.isMDXComponent=!0;const Fgp={toc:[]},Vgp="wrapper";function qgp(t){let{components:e,...n}=t;return(0,s.kt)(Vgp,(0,p.Z)({},Fgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}qgp.isMDXComponent=!0;const jgp={toc:[]},Hgp="wrapper";function Ygp(t){let{components:e,...n}=t;return(0,s.kt)(Hgp,(0,p.Z)({},jgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Ygp.isMDXComponent=!0;const Qgp={toc:[]},$gp="wrapper";function Kgp(t){let{components:e,...n}=t;return(0,s.kt)($gp,(0,p.Z)({},Qgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kgp.isMDXComponent=!0;const Jgp={toc:[]},txp="wrapper";function exp(t){let{components:e,...n}=t;return(0,s.kt)(txp,(0,p.Z)({},Jgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}exp.isMDXComponent=!0;const nxp={toc:[]},oxp="wrapper";function pxp(t){let{components:e,...n}=t;return(0,s.kt)(oxp,(0,p.Z)({},nxp,n,{components:e,mdxType:"MDXLayout"}))}pxp.isMDXComponent=!0;const rxp={toc:[]},sxp="wrapper";function cxp(t){let{components:e,...n}=t;return(0,s.kt)(sxp,(0,p.Z)({},rxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}cxp.isMDXComponent=!0;const axp={toc:[]},ixp="wrapper";function lxp(t){let{components:e,...n}=t;return(0,s.kt)(ixp,(0,p.Z)({},axp,n,{components:e,mdxType:"MDXLayout"}))}lxp.isMDXComponent=!0;const uxp={toc:[]},mxp="wrapper";function dxp(t){let{components:e,...n}=t;return(0,s.kt)(mxp,(0,p.Z)({},uxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dxp.isMDXComponent=!0;const hxp={toc:[]},fxp="wrapper";function kxp(t){let{components:e,...n}=t;return(0,s.kt)(fxp,(0,p.Z)({},hxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}kxp.isMDXComponent=!0;const yxp={toc:[]},Dxp="wrapper";function Mxp(t){let{components:e,...n}=t;return(0,s.kt)(Dxp,(0,p.Z)({},yxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Mxp.isMDXComponent=!0;const Xxp={toc:[]},_xp="wrapper";function wxp(t){let{components:e,...n}=t;return(0,s.kt)(_xp,(0,p.Z)({},Xxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}wxp.isMDXComponent=!0;const Txp={toc:[]},Cxp="wrapper";function gxp(t){let{components:e,...n}=t;return(0,s.kt)(Cxp,(0,p.Z)({},Txp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gxp.isMDXComponent=!0;const xxp={toc:[]},vxp="wrapper";function Lxp(t){let{components:e,...n}=t;return(0,s.kt)(vxp,(0,p.Z)({},xxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Lxp.isMDXComponent=!0;const Zxp={toc:[]},bxp="wrapper";function Nxp(t){let{components:e,...n}=t;return(0,s.kt)(bxp,(0,p.Z)({},Zxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Nxp.isMDXComponent=!0;const zxp={toc:[]},Axp="wrapper";function Pxp(t){let{components:e,...n}=t;return(0,s.kt)(Axp,(0,p.Z)({},zxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Pxp.isMDXComponent=!0;const Ixp={toc:[]},Wxp="wrapper";function Rxp(t){let{components:e,...n}=t;return(0,s.kt)(Wxp,(0,p.Z)({},Ixp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Rxp.isMDXComponent=!0;const Sxp={toc:[]},Bxp="wrapper";function Gxp(t){let{components:e,...n}=t;return(0,s.kt)(Bxp,(0,p.Z)({},Sxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Gxp.isMDXComponent=!0;const Exp={toc:[]},Oxp="wrapper";function Uxp(t){let{components:e,...n}=t;return(0,s.kt)(Oxp,(0,p.Z)({},Exp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Uxp.isMDXComponent=!0;const Fxp={toc:[]},Vxp="wrapper";function qxp(t){let{components:e,...n}=t;return(0,s.kt)(Vxp,(0,p.Z)({},Fxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}qxp.isMDXComponent=!0;const jxp={toc:[]},Hxp="wrapper";function Yxp(t){let{components:e,...n}=t;return(0,s.kt)(Hxp,(0,p.Z)({},jxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yxp.isMDXComponent=!0;const Qxp={toc:[]},$xp="wrapper";function Kxp(t){let{components:e,...n}=t;return(0,s.kt)($xp,(0,p.Z)({},Qxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Kxp.isMDXComponent=!0;const Jxp={toc:[]},tvp="wrapper";function evp(t){let{components:e,...n}=t;return(0,s.kt)(tvp,(0,p.Z)({},Jxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}evp.isMDXComponent=!0;const nvp={toc:[]},ovp="wrapper";function pvp(t){let{components:e,...n}=t;return(0,s.kt)(ovp,(0,p.Z)({},nvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pvp.isMDXComponent=!0;const rvp={toc:[]},svp="wrapper";function cvp(t){let{components:e,...n}=t;return(0,s.kt)(svp,(0,p.Z)({},rvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cvp.isMDXComponent=!0;const avp={toc:[]},ivp="wrapper";function lvp(t){let{components:e,...n}=t;return(0,s.kt)(ivp,(0,p.Z)({},avp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lvp.isMDXComponent=!0;const uvp={toc:[]},mvp="wrapper";function dvp(t){let{components:e,...n}=t;return(0,s.kt)(mvp,(0,p.Z)({},uvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dvp.isMDXComponent=!0;const hvp={toc:[]},fvp="wrapper";function kvp(t){let{components:e,...n}=t;return(0,s.kt)(fvp,(0,p.Z)({},hvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kvp.isMDXComponent=!0;const yvp={toc:[]},Dvp="wrapper";function Mvp(t){let{components:e,...n}=t;return(0,s.kt)(Dvp,(0,p.Z)({},yvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Mvp.isMDXComponent=!0;const Xvp={toc:[]},_vp="wrapper";function wvp(t){let{components:e,...n}=t;return(0,s.kt)(_vp,(0,p.Z)({},Xvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wvp.isMDXComponent=!0;const Tvp={toc:[]},Cvp="wrapper";function gvp(t){let{components:e,...n}=t;return(0,s.kt)(Cvp,(0,p.Z)({},Tvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}gvp.isMDXComponent=!0;const xvp={toc:[]},vvp="wrapper";function Lvp(t){let{components:e,...n}=t;return(0,s.kt)(vvp,(0,p.Z)({},xvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Lvp.isMDXComponent=!0;const Zvp={toc:[]},bvp="wrapper";function Nvp(t){let{components:e,...n}=t;return(0,s.kt)(bvp,(0,p.Z)({},Zvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Nvp.isMDXComponent=!0;const zvp={toc:[]},Avp="wrapper";function Pvp(t){let{components:e,...n}=t;return(0,s.kt)(Avp,(0,p.Z)({},zvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Pvp.isMDXComponent=!0;const Ivp={toc:[]},Wvp="wrapper";function Rvp(t){let{components:e,...n}=t;return(0,s.kt)(Wvp,(0,p.Z)({},Ivp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Rvp.isMDXComponent=!0;const Svp={toc:[]},Bvp="wrapper";function Gvp(t){let{components:e,...n}=t;return(0,s.kt)(Bvp,(0,p.Z)({},Svp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Gvp.isMDXComponent=!0;const Evp={toc:[]},Ovp="wrapper";function Uvp(t){let{components:e,...n}=t;return(0,s.kt)(Ovp,(0,p.Z)({},Evp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Uvp.isMDXComponent=!0;const Fvp={toc:[]},Vvp="wrapper";function qvp(t){let{components:e,...n}=t;return(0,s.kt)(Vvp,(0,p.Z)({},Fvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qvp.isMDXComponent=!0;const jvp={toc:[]},Hvp="wrapper";function Yvp(t){let{components:e,...n}=t;return(0,s.kt)(Hvp,(0,p.Z)({},jvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code to display."))}Yvp.isMDXComponent=!0;const Qvp={toc:[]},$vp="wrapper";function Kvp(t){let{components:e,...n}=t;return(0,s.kt)($vp,(0,p.Z)({},Qvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check out ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.kt)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}Kvp.isMDXComponent=!0;const Jvp={toc:[]},tLp="wrapper";function eLp(t){let{components:e,...n}=t;return(0,s.kt)(tLp,(0,p.Z)({},Jvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Custom drawing logic for the code."))}eLp.isMDXComponent=!0;const nLp={toc:[]},oLp="wrapper";function pLp(t){let{components:e,...n}=t;return(0,s.kt)(oLp,(0,p.Z)({},nLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defaults to a shared ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.kt)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}pLp.isMDXComponent=!0;const rLp={toc:[]},sLp="wrapper";function cLp(t){let{components:e,...n}=t;return(0,s.kt)(sLp,(0,p.Z)({},rLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The code highlighter to use for this code node."))}cLp.isMDXComponent=!0;const aLp={toc:[]},iLp="wrapper";function lLp(t){let{components:e,...n}=t;return(0,s.kt)(iLp,(0,p.Z)({},aLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lLp.isMDXComponent=!0;const uLp={toc:[]},mLp="wrapper";function dLp(t){let{components:e,...n}=t;return(0,s.kt)(mLp,(0,p.Z)({},uLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}dLp.isMDXComponent=!0;const hLp={toc:[]},fLp="wrapper";function kLp(t){let{components:e,...n}=t;return(0,s.kt)(fLp,(0,p.Z)({},hLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CodeProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}kLp.isMDXComponent=!0;const yLp={toc:[]},DLp="wrapper";function MLp(t){let{components:e,...n}=t;return(0,s.kt)(DLp,(0,p.Z)({},yLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}MLp.isMDXComponent=!0;const XLp={toc:[]},_Lp="wrapper";function wLp(t){let{components:e,...n}=t;return(0,s.kt)(_Lp,(0,p.Z)({},XLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wLp.isMDXComponent=!0;const TLp={toc:[]},CLp="wrapper";function gLp(t){let{components:e,...n}=t;return(0,s.kt)(CLp,(0,p.Z)({},TLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}gLp.isMDXComponent=!0;const xLp={toc:[]},vLp="wrapper";function LLp(t){let{components:e,...n}=t;return(0,s.kt)(vLp,(0,p.Z)({},xLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Either a single ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.kt)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.kt)("p",null,"You can use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.kt)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.kt)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}LLp.isMDXComponent=!0;const ZLp={toc:[]},bLp="wrapper";function NLp(t){let{components:e,...n}=t;return(0,s.kt)(bLp,(0,p.Z)({},ZLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The currently selected code range."))}NLp.isMDXComponent=!0;const zLp={toc:[]},ALp="wrapper";function PLp(t){let{components:e,...n}=t;return(0,s.kt)(ALp,(0,p.Z)({},zLp,n,{components:e,mdxType:"MDXLayout"}))}PLp.isMDXComponent=!0;const ILp={toc:[]},WLp="wrapper";function RLp(t){let{components:e,...n}=t;return(0,s.kt)(WLp,(0,p.Z)({},ILp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CodeProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}RLp.isMDXComponent=!0;const SLp={toc:[]},BLp="wrapper";function GLp(t){let{components:e,...n}=t;return(0,s.kt)(BLp,(0,p.Z)({},SLp,n,{components:e,mdxType:"MDXLayout"}))}GLp.isMDXComponent=!0;const ELp={toc:[]},OLp="wrapper";function ULp(t){let{components:e,...n}=t;return(0,s.kt)(OLp,(0,p.Z)({},ELp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ULp.isMDXComponent=!0;const FLp={toc:[]},VLp="wrapper";function qLp(t){let{components:e,...n}=t;return(0,s.kt)(VLp,(0,p.Z)({},FLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}qLp.isMDXComponent=!0;const jLp={toc:[]},HLp="wrapper";function YLp(t){let{components:e,...n}=t;return(0,s.kt)(HLp,(0,p.Z)({},jLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YLp.isMDXComponent=!0;const QLp={toc:[]},$Lp="wrapper";function KLp(t){let{components:e,...n}=t;return(0,s.kt)($Lp,(0,p.Z)({},QLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}KLp.isMDXComponent=!0;const JLp={toc:[]},tZp="wrapper";function eZp(t){let{components:e,...n}=t;return(0,s.kt)(tZp,(0,p.Z)({},JLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eZp.isMDXComponent=!0;const nZp={toc:[]},oZp="wrapper";function pZp(t){let{components:e,...n}=t;return(0,s.kt)(oZp,(0,p.Z)({},nZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pZp.isMDXComponent=!0;const rZp={toc:[]},sZp="wrapper";function cZp(t){let{components:e,...n}=t;return(0,s.kt)(sZp,(0,p.Z)({},rZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}cZp.isMDXComponent=!0;const aZp={toc:[]},iZp="wrapper";function lZp(t){let{components:e,...n}=t;return(0,s.kt)(iZp,(0,p.Z)({},aZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}lZp.isMDXComponent=!0;const uZp={toc:[]},mZp="wrapper";function dZp(t){let{components:e,...n}=t;return(0,s.kt)(mZp,(0,p.Z)({},uZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dZp.isMDXComponent=!0;const hZp={toc:[]},fZp="wrapper";function kZp(t){let{components:e,...n}=t;return(0,s.kt)(fZp,(0,p.Z)({},hZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}kZp.isMDXComponent=!0;const yZp={toc:[]},DZp="wrapper";function MZp(t){let{components:e,...n}=t;return(0,s.kt)(DZp,(0,p.Z)({},yZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MZp.isMDXComponent=!0;const XZp={toc:[]},_Zp="wrapper";function wZp(t){let{components:e,...n}=t;return(0,s.kt)(_Zp,(0,p.Z)({},XZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wZp.isMDXComponent=!0;const TZp={toc:[]},CZp="wrapper";function gZp(t){let{components:e,...n}=t;return(0,s.kt)(CZp,(0,p.Z)({},TZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gZp.isMDXComponent=!0;const xZp={toc:[]},vZp="wrapper";function LZp(t){let{components:e,...n}=t;return(0,s.kt)(vZp,(0,p.Z)({},xZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}LZp.isMDXComponent=!0;const ZZp={toc:[]},bZp="wrapper";function NZp(t){let{components:e,...n}=t;return(0,s.kt)(bZp,(0,p.Z)({},ZZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}NZp.isMDXComponent=!0;const zZp={toc:[]},AZp="wrapper";function PZp(t){let{components:e,...n}=t;return(0,s.kt)(AZp,(0,p.Z)({},zZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}PZp.isMDXComponent=!0;const IZp={toc:[]},WZp="wrapper";function RZp(t){let{components:e,...n}=t;return(0,s.kt)(WZp,(0,p.Z)({},IZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}RZp.isMDXComponent=!0;const SZp={toc:[]},BZp="wrapper";function GZp(t){let{components:e,...n}=t;return(0,s.kt)(BZp,(0,p.Z)({},SZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}GZp.isMDXComponent=!0;const EZp={toc:[]},OZp="wrapper";function UZp(t){let{components:e,...n}=t;return(0,s.kt)(OZp,(0,p.Z)({},EZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}UZp.isMDXComponent=!0;const FZp={toc:[]},VZp="wrapper";function qZp(t){let{components:e,...n}=t;return(0,s.kt)(VZp,(0,p.Z)({},FZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qZp.isMDXComponent=!0;const jZp={toc:[]},HZp="wrapper";function YZp(t){let{components:e,...n}=t;return(0,s.kt)(HZp,(0,p.Z)({},jZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}YZp.isMDXComponent=!0;const QZp={toc:[]},$Zp="wrapper";function KZp(t){let{components:e,...n}=t;return(0,s.kt)($Zp,(0,p.Z)({},QZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}KZp.isMDXComponent=!0;const JZp={toc:[]},tbp="wrapper";function ebp(t){let{components:e,...n}=t;return(0,s.kt)(tbp,(0,p.Z)({},JZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}ebp.isMDXComponent=!0;const nbp={toc:[]},obp="wrapper";function pbp(t){let{components:e,...n}=t;return(0,s.kt)(obp,(0,p.Z)({},nbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pbp.isMDXComponent=!0;const rbp={toc:[]},sbp="wrapper";function cbp(t){let{components:e,...n}=t;return(0,s.kt)(sbp,(0,p.Z)({},rbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cbp.isMDXComponent=!0;const abp={toc:[]},ibp="wrapper";function lbp(t){let{components:e,...n}=t;return(0,s.kt)(ibp,(0,p.Z)({},abp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lbp.isMDXComponent=!0;const ubp={toc:[]},mbp="wrapper";function dbp(t){let{components:e,...n}=t;return(0,s.kt)(mbp,(0,p.Z)({},ubp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dbp.isMDXComponent=!0;const hbp={toc:[]},fbp="wrapper";function kbp(t){let{components:e,...n}=t;return(0,s.kt)(fbp,(0,p.Z)({},hbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kbp.isMDXComponent=!0;const ybp={toc:[]},Dbp="wrapper";function Mbp(t){let{components:e,...n}=t;return(0,s.kt)(Dbp,(0,p.Z)({},ybp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mbp.isMDXComponent=!0;const Xbp={toc:[]},_bp="wrapper";function wbp(t){let{components:e,...n}=t;return(0,s.kt)(_bp,(0,p.Z)({},Xbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wbp.isMDXComponent=!0;const Tbp={toc:[]},Cbp="wrapper";function gbp(t){let{components:e,...n}=t;return(0,s.kt)(Cbp,(0,p.Z)({},Tbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}gbp.isMDXComponent=!0;const xbp={toc:[]},vbp="wrapper";function Lbp(t){let{components:e,...n}=t;return(0,s.kt)(vbp,(0,p.Z)({},xbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Lbp.isMDXComponent=!0;const Zbp={toc:[]},bbp="wrapper";function Nbp(t){let{components:e,...n}=t;return(0,s.kt)(bbp,(0,p.Z)({},Zbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nbp.isMDXComponent=!0;const zbp={toc:[]},Abp="wrapper";function Pbp(t){let{components:e,...n}=t;return(0,s.kt)(Abp,(0,p.Z)({},zbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Pbp.isMDXComponent=!0;const Ibp={toc:[]},Wbp="wrapper";function Rbp(t){let{components:e,...n}=t;return(0,s.kt)(Wbp,(0,p.Z)({},Ibp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Rbp.isMDXComponent=!0;const Sbp={toc:[]},Bbp="wrapper";function Gbp(t){let{components:e,...n}=t;return(0,s.kt)(Bbp,(0,p.Z)({},Sbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Gbp.isMDXComponent=!0;const Ebp={toc:[]},Obp="wrapper";function Ubp(t){let{components:e,...n}=t;return(0,s.kt)(Obp,(0,p.Z)({},Ebp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ubp.isMDXComponent=!0;const Fbp={toc:[]},Vbp="wrapper";function qbp(t){let{components:e,...n}=t;return(0,s.kt)(Vbp,(0,p.Z)({},Fbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qbp.isMDXComponent=!0;const jbp={toc:[]},Hbp="wrapper";function Ybp(t){let{components:e,...n}=t;return(0,s.kt)(Hbp,(0,p.Z)({},jbp,n,{components:e,mdxType:"MDXLayout"}))}Ybp.isMDXComponent=!0;const Qbp={toc:[]},$bp="wrapper";function Kbp(t){let{components:e,...n}=t;return(0,s.kt)($bp,(0,p.Z)({},Qbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Kbp.isMDXComponent=!0;const Jbp={toc:[]},tNp="wrapper";function eNp(t){let{components:e,...n}=t;return(0,s.kt)(tNp,(0,p.Z)({},Jbp,n,{components:e,mdxType:"MDXLayout"}))}eNp.isMDXComponent=!0;const nNp={toc:[]},oNp="wrapper";function pNp(t){let{components:e,...n}=t;return(0,s.kt)(oNp,(0,p.Z)({},nNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pNp.isMDXComponent=!0;const rNp={toc:[]},sNp="wrapper";function cNp(t){let{components:e,...n}=t;return(0,s.kt)(sNp,(0,p.Z)({},rNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}cNp.isMDXComponent=!0;const aNp={toc:[]},iNp="wrapper";function lNp(t){let{components:e,...n}=t;return(0,s.kt)(iNp,(0,p.Z)({},aNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lNp.isMDXComponent=!0;const uNp={toc:[]},mNp="wrapper";function dNp(t){let{components:e,...n}=t;return(0,s.kt)(mNp,(0,p.Z)({},uNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}dNp.isMDXComponent=!0;const hNp={toc:[]},fNp="wrapper";function kNp(t){let{components:e,...n}=t;return(0,s.kt)(fNp,(0,p.Z)({},hNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kNp.isMDXComponent=!0;const yNp={toc:[]},DNp="wrapper";function MNp(t){let{components:e,...n}=t;return(0,s.kt)(DNp,(0,p.Z)({},yNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}MNp.isMDXComponent=!0;const XNp={toc:[]},_Np="wrapper";function wNp(t){let{components:e,...n}=t;return(0,s.kt)(_Np,(0,p.Z)({},XNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wNp.isMDXComponent=!0;const TNp={toc:[]},CNp="wrapper";function gNp(t){let{components:e,...n}=t;return(0,s.kt)(CNp,(0,p.Z)({},TNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}gNp.isMDXComponent=!0;const xNp={toc:[]},vNp="wrapper";function LNp(t){let{components:e,...n}=t;return(0,s.kt)(vNp,(0,p.Z)({},xNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LNp.isMDXComponent=!0;const ZNp={toc:[]},bNp="wrapper";function NNp(t){let{components:e,...n}=t;return(0,s.kt)(bNp,(0,p.Z)({},ZNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}NNp.isMDXComponent=!0;const zNp={toc:[]},ANp="wrapper";function PNp(t){let{components:e,...n}=t;return(0,s.kt)(ANp,(0,p.Z)({},zNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PNp.isMDXComponent=!0;const INp={toc:[]},WNp="wrapper";function RNp(t){let{components:e,...n}=t;return(0,s.kt)(WNp,(0,p.Z)({},INp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}RNp.isMDXComponent=!0;const SNp={toc:[]},BNp="wrapper";function GNp(t){let{components:e,...n}=t;return(0,s.kt)(BNp,(0,p.Z)({},SNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GNp.isMDXComponent=!0;const ENp={toc:[]},ONp="wrapper";function UNp(t){let{components:e,...n}=t;return(0,s.kt)(ONp,(0,p.Z)({},ENp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}UNp.isMDXComponent=!0;const FNp={toc:[]},VNp="wrapper";function qNp(t){let{components:e,...n}=t;return(0,s.kt)(VNp,(0,p.Z)({},FNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qNp.isMDXComponent=!0;const jNp={toc:[]},HNp="wrapper";function YNp(t){let{components:e,...n}=t;return(0,s.kt)(HNp,(0,p.Z)({},jNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YNp.isMDXComponent=!0;const QNp={toc:[]},$Np="wrapper";function KNp(t){let{components:e,...n}=t;return(0,s.kt)($Np,(0,p.Z)({},QNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KNp.isMDXComponent=!0;const JNp={toc:[]},tzp="wrapper";function ezp(t){let{components:e,...n}=t;return(0,s.kt)(tzp,(0,p.Z)({},JNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ezp.isMDXComponent=!0;const nzp={toc:[]},ozp="wrapper";function pzp(t){let{components:e,...n}=t;return(0,s.kt)(ozp,(0,p.Z)({},nzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pzp.isMDXComponent=!0;const rzp={toc:[]},szp="wrapper";function czp(t){let{components:e,...n}=t;return(0,s.kt)(szp,(0,p.Z)({},rzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}czp.isMDXComponent=!0;const azp={toc:[]},izp="wrapper";function lzp(t){let{components:e,...n}=t;return(0,s.kt)(izp,(0,p.Z)({},azp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lzp.isMDXComponent=!0;const uzp={toc:[]},mzp="wrapper";function dzp(t){let{components:e,...n}=t;return(0,s.kt)(mzp,(0,p.Z)({},uzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dzp.isMDXComponent=!0;const hzp={toc:[]},fzp="wrapper";function kzp(t){let{components:e,...n}=t;return(0,s.kt)(fzp,(0,p.Z)({},hzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kzp.isMDXComponent=!0;const yzp={toc:[]},Dzp="wrapper";function Mzp(t){let{components:e,...n}=t;return(0,s.kt)(Dzp,(0,p.Z)({},yzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Mzp.isMDXComponent=!0;const Xzp={toc:[]},_zp="wrapper";function wzp(t){let{components:e,...n}=t;return(0,s.kt)(_zp,(0,p.Z)({},Xzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wzp.isMDXComponent=!0;const Tzp={toc:[]},Czp="wrapper";function gzp(t){let{components:e,...n}=t;return(0,s.kt)(Czp,(0,p.Z)({},Tzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}gzp.isMDXComponent=!0;const xzp={toc:[]},vzp="wrapper";function Lzp(t){let{components:e,...n}=t;return(0,s.kt)(vzp,(0,p.Z)({},xzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Lzp.isMDXComponent=!0;const Zzp={toc:[]},bzp="wrapper";function Nzp(t){let{components:e,...n}=t;return(0,s.kt)(bzp,(0,p.Z)({},Zzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Nzp.isMDXComponent=!0;const zzp={toc:[]},Azp="wrapper";function Pzp(t){let{components:e,...n}=t;return(0,s.kt)(Azp,(0,p.Z)({},zzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Pzp.isMDXComponent=!0;const Izp={toc:[]},Wzp="wrapper";function Rzp(t){let{components:e,...n}=t;return(0,s.kt)(Wzp,(0,p.Z)({},Izp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Rzp.isMDXComponent=!0;const Szp={toc:[]},Bzp="wrapper";function Gzp(t){let{components:e,...n}=t;return(0,s.kt)(Bzp,(0,p.Z)({},Szp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Gzp.isMDXComponent=!0;const Ezp={toc:[]},Ozp="wrapper";function Uzp(t){let{components:e,...n}=t;return(0,s.kt)(Ozp,(0,p.Z)({},Ezp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Uzp.isMDXComponent=!0;const Fzp={toc:[]},Vzp="wrapper";function qzp(t){let{components:e,...n}=t;return(0,s.kt)(Vzp,(0,p.Z)({},Fzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qzp.isMDXComponent=!0;const jzp={toc:[]},Hzp="wrapper";function Yzp(t){let{components:e,...n}=t;return(0,s.kt)(Hzp,(0,p.Z)({},jzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Yzp.isMDXComponent=!0;const Qzp={toc:[]},$zp="wrapper";function Kzp(t){let{components:e,...n}=t;return(0,s.kt)($zp,(0,p.Z)({},Qzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Kzp.isMDXComponent=!0;const Jzp={toc:[]},tAp="wrapper";function eAp(t){let{components:e,...n}=t;return(0,s.kt)(tAp,(0,p.Z)({},Jzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}eAp.isMDXComponent=!0;const nAp={toc:[]},oAp="wrapper";function pAp(t){let{components:e,...n}=t;return(0,s.kt)(oAp,(0,p.Z)({},nAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pAp.isMDXComponent=!0;const rAp={toc:[]},sAp="wrapper";function cAp(t){let{components:e,...n}=t;return(0,s.kt)(sAp,(0,p.Z)({},rAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}cAp.isMDXComponent=!0;const aAp={toc:[]},iAp="wrapper";function lAp(t){let{components:e,...n}=t;return(0,s.kt)(iAp,(0,p.Z)({},aAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lAp.isMDXComponent=!0;const uAp={toc:[]},mAp="wrapper";function dAp(t){let{components:e,...n}=t;return(0,s.kt)(mAp,(0,p.Z)({},uAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}dAp.isMDXComponent=!0;const hAp={toc:[]},fAp="wrapper";function kAp(t){let{components:e,...n}=t;return(0,s.kt)(fAp,(0,p.Z)({},hAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}kAp.isMDXComponent=!0;const yAp={toc:[]},DAp="wrapper";function MAp(t){let{components:e,...n}=t;return(0,s.kt)(DAp,(0,p.Z)({},yAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}MAp.isMDXComponent=!0;const XAp={toc:[]},_Ap="wrapper";function wAp(t){let{components:e,...n}=t;return(0,s.kt)(_Ap,(0,p.Z)({},XAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wAp.isMDXComponent=!0;const TAp={toc:[]},CAp="wrapper";function gAp(t){let{components:e,...n}=t;return(0,s.kt)(CAp,(0,p.Z)({},TAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}gAp.isMDXComponent=!0;const xAp={toc:[]},vAp="wrapper";function LAp(t){let{components:e,...n}=t;return(0,s.kt)(vAp,(0,p.Z)({},xAp,n,{components:e,mdxType:"MDXLayout"}))}LAp.isMDXComponent=!0;const ZAp={toc:[]},bAp="wrapper";function NAp(t){let{components:e,...n}=t;return(0,s.kt)(bAp,(0,p.Z)({},ZAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}NAp.isMDXComponent=!0;const zAp={toc:[]},AAp="wrapper";function PAp(t){let{components:e,...n}=t;return(0,s.kt)(AAp,(0,p.Z)({},zAp,n,{components:e,mdxType:"MDXLayout"}))}PAp.isMDXComponent=!0;const IAp={toc:[]},WAp="wrapper";function RAp(t){let{components:e,...n}=t;return(0,s.kt)(WAp,(0,p.Z)({},IAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}RAp.isMDXComponent=!0;const SAp={toc:[]},BAp="wrapper";function GAp(t){let{components:e,...n}=t;return(0,s.kt)(BAp,(0,p.Z)({},SAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}GAp.isMDXComponent=!0;const EAp={toc:[]},OAp="wrapper";function UAp(t){let{components:e,...n}=t;return(0,s.kt)(OAp,(0,p.Z)({},EAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}UAp.isMDXComponent=!0;const FAp={toc:[]},VAp="wrapper";function qAp(t){let{components:e,...n}=t;return(0,s.kt)(VAp,(0,p.Z)({},FAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qAp.isMDXComponent=!0;const jAp={toc:[]},HAp="wrapper";function YAp(t){let{components:e,...n}=t;return(0,s.kt)(HAp,(0,p.Z)({},jAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}YAp.isMDXComponent=!0;const QAp={toc:[]},$Ap="wrapper";function KAp(t){let{components:e,...n}=t;return(0,s.kt)($Ap,(0,p.Z)({},QAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}KAp.isMDXComponent=!0;const JAp={toc:[]},tPp="wrapper";function ePp(t){let{components:e,...n}=t;return(0,s.kt)(tPp,(0,p.Z)({},JAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ePp.isMDXComponent=!0;const nPp={toc:[]},oPp="wrapper";function pPp(t){let{components:e,...n}=t;return(0,s.kt)(oPp,(0,p.Z)({},nPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pPp.isMDXComponent=!0;const rPp={toc:[]},sPp="wrapper";function cPp(t){let{components:e,...n}=t;return(0,s.kt)(sPp,(0,p.Z)({},rPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cPp.isMDXComponent=!0;const aPp={toc:[]},iPp="wrapper";function lPp(t){let{components:e,...n}=t;return(0,s.kt)(iPp,(0,p.Z)({},aPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lPp.isMDXComponent=!0;const uPp={toc:[]},mPp="wrapper";function dPp(t){let{components:e,...n}=t;return(0,s.kt)(mPp,(0,p.Z)({},uPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dPp.isMDXComponent=!0;const hPp={toc:[]},fPp="wrapper";function kPp(t){let{components:e,...n}=t;return(0,s.kt)(fPp,(0,p.Z)({},hPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}kPp.isMDXComponent=!0;const yPp={toc:[]},DPp="wrapper";function MPp(t){let{components:e,...n}=t;return(0,s.kt)(DPp,(0,p.Z)({},yPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes custom drawing logic used by the Code node."))}MPp.isMDXComponent=!0;const XPp={toc:[]},_Pp="wrapper";function wPp(t){let{components:e,...n}=t;return(0,s.kt)(_Pp,(0,p.Z)({},XPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"token(ctx, text, position, color, selection) {\n  const blur = map(3, 0, selection);\n  const alpha = map(0.5, 1, selection);\n  ctx.globalAlpha *= alpha;\n  ctx.filter = `blur(${blur}px)`;\n  ctx.fillStyle = color;\n  ctx.fillText(text, position.x, position.y);\n}\n")))}wPp.isMDXComponent=!0;const TPp={toc:[]},CPp="wrapper";function gPp(t){let{components:e,...n}=t;return(0,s.kt)(CPp,(0,p.Z)({},TPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Custom drawing logic for individual code tokens."))}gPp.isMDXComponent=!0;const xPp={toc:[]},vPp="wrapper";function LPp(t){let{components:e,...n}=t;return(0,s.kt)(vPp,(0,p.Z)({},xPp,n,{components:e,mdxType:"MDXLayout"}))}LPp.isMDXComponent=!0;const ZPp={toc:[]},bPp="wrapper";function NPp(t){let{components:e,...n}=t;return(0,s.kt)(bPp,(0,p.Z)({},ZPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NPp.isMDXComponent=!0;const zPp={toc:[]},APp="wrapper";function PPp(t){let{components:e,...n}=t;return(0,s.kt)(APp,(0,p.Z)({},zPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}PPp.isMDXComponent=!0;const IPp={toc:[]},WPp="wrapper";function RPp(t){let{components:e,...n}=t;return(0,s.kt)(WPp,(0,p.Z)({},IPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}RPp.isMDXComponent=!0;const SPp={toc:[]},BPp="wrapper";function GPp(t){let{components:e,...n}=t;return(0,s.kt)(BPp,(0,p.Z)({},SPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}GPp.isMDXComponent=!0;const EPp={toc:[]},OPp="wrapper";function UPp(t){let{components:e,...n}=t;return(0,s.kt)(OPp,(0,p.Z)({},EPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UPp.isMDXComponent=!0;const FPp={toc:[]},VPp="wrapper";function qPp(t){let{components:e,...n}=t;return(0,s.kt)(VPp,(0,p.Z)({},FPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qPp.isMDXComponent=!0;const jPp={toc:[]},HPp="wrapper";function YPp(t){let{components:e,...n}=t;return(0,s.kt)(HPp,(0,p.Z)({},jPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}YPp.isMDXComponent=!0;const QPp={toc:[]},$Pp="wrapper";function KPp(t){let{components:e,...n}=t;return(0,s.kt)($Pp,(0,p.Z)({},QPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}KPp.isMDXComponent=!0;const JPp={toc:[]},tIp="wrapper";function eIp(t){let{components:e,...n}=t;return(0,s.kt)(tIp,(0,p.Z)({},JPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eIp.isMDXComponent=!0;const nIp={toc:[]},oIp="wrapper";function pIp(t){let{components:e,...n}=t;return(0,s.kt)(oIp,(0,p.Z)({},nIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pIp.isMDXComponent=!0;const rIp={toc:[]},sIp="wrapper";function cIp(t){let{components:e,...n}=t;return(0,s.kt)(sIp,(0,p.Z)({},rIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}cIp.isMDXComponent=!0;const aIp={toc:[]},iIp="wrapper";function lIp(t){let{components:e,...n}=t;return(0,s.kt)(iIp,(0,p.Z)({},aIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}lIp.isMDXComponent=!0;const uIp={toc:[]},mIp="wrapper";function dIp(t){let{components:e,...n}=t;return(0,s.kt)(mIp,(0,p.Z)({},uIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}dIp.isMDXComponent=!0;const hIp={toc:[]},fIp="wrapper";function kIp(t){let{components:e,...n}=t;return(0,s.kt)(fIp,(0,p.Z)({},hIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}kIp.isMDXComponent=!0;const yIp={toc:[]},DIp="wrapper";function MIp(t){let{components:e,...n}=t;return(0,s.kt)(DIp,(0,p.Z)({},yIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}MIp.isMDXComponent=!0;const XIp={toc:[]},_Ip="wrapper";function wIp(t){let{components:e,...n}=t;return(0,s.kt)(_Ip,(0,p.Z)({},XIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wIp.isMDXComponent=!0;const TIp={toc:[]},CIp="wrapper";function gIp(t){let{components:e,...n}=t;return(0,s.kt)(CIp,(0,p.Z)({},TIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}gIp.isMDXComponent=!0;const xIp={toc:[]},vIp="wrapper";function LIp(t){let{components:e,...n}=t;return(0,s.kt)(vIp,(0,p.Z)({},xIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}LIp.isMDXComponent=!0;const ZIp={toc:[]},bIp="wrapper";function NIp(t){let{components:e,...n}=t;return(0,s.kt)(bIp,(0,p.Z)({},ZIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NIp.isMDXComponent=!0;const zIp={toc:[]},AIp="wrapper";function PIp(t){let{components:e,...n}=t;return(0,s.kt)(AIp,(0,p.Z)({},zIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}PIp.isMDXComponent=!0;const IIp={toc:[]},WIp="wrapper";function RIp(t){let{components:e,...n}=t;return(0,s.kt)(WIp,(0,p.Z)({},IIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}RIp.isMDXComponent=!0;const SIp={toc:[]},BIp="wrapper";function GIp(t){let{components:e,...n}=t;return(0,s.kt)(BIp,(0,p.Z)({},SIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}GIp.isMDXComponent=!0;const EIp={toc:[]},OIp="wrapper";function UIp(t){let{components:e,...n}=t;return(0,s.kt)(OIp,(0,p.Z)({},EIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UIp.isMDXComponent=!0;const FIp={toc:[]},VIp="wrapper";function qIp(t){let{components:e,...n}=t;return(0,s.kt)(VIp,(0,p.Z)({},FIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qIp.isMDXComponent=!0;const jIp={toc:[]},HIp="wrapper";function YIp(t){let{components:e,...n}=t;return(0,s.kt)(HIp,(0,p.Z)({},jIp,n,{components:e,mdxType:"MDXLayout"}))}YIp.isMDXComponent=!0;const QIp={toc:[]},$Ip="wrapper";function KIp(t){let{components:e,...n}=t;return(0,s.kt)($Ip,(0,p.Z)({},QIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}KIp.isMDXComponent=!0;const JIp={toc:[]},tWp="wrapper";function eWp(t){let{components:e,...n}=t;return(0,s.kt)(tWp,(0,p.Z)({},JIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}eWp.isMDXComponent=!0;const nWp={toc:[]},oWp="wrapper";function pWp(t){let{components:e,...n}=t;return(0,s.kt)(oWp,(0,p.Z)({},nWp,n,{components:e,mdxType:"MDXLayout"}))}pWp.isMDXComponent=!0;const rWp={toc:[]},sWp="wrapper";function cWp(t){let{components:e,...n}=t;return(0,s.kt)(sWp,(0,p.Z)({},rWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}cWp.isMDXComponent=!0;const aWp={toc:[]},iWp="wrapper";function lWp(t){let{components:e,...n}=t;return(0,s.kt)(iWp,(0,p.Z)({},aWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}lWp.isMDXComponent=!0;const uWp={toc:[]},mWp="wrapper";function dWp(t){let{components:e,...n}=t;return(0,s.kt)(mWp,(0,p.Z)({},uWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dWp.isMDXComponent=!0;const hWp={toc:[]},fWp="wrapper";function kWp(t){let{components:e,...n}=t;return(0,s.kt)(fWp,(0,p.Z)({},hWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kWp.isMDXComponent=!0;const yWp={toc:[]},DWp="wrapper";function MWp(t){let{components:e,...n}=t;return(0,s.kt)(DWp,(0,p.Z)({},yWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MWp.isMDXComponent=!0;const XWp={toc:[]},_Wp="wrapper";function wWp(t){let{components:e,...n}=t;return(0,s.kt)(_Wp,(0,p.Z)({},XWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wWp.isMDXComponent=!0;const TWp={toc:[]},CWp="wrapper";function gWp(t){let{components:e,...n}=t;return(0,s.kt)(CWp,(0,p.Z)({},TWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gWp.isMDXComponent=!0;const xWp={toc:[]},vWp="wrapper";function LWp(t){let{components:e,...n}=t;return(0,s.kt)(vWp,(0,p.Z)({},xWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LWp.isMDXComponent=!0;const ZWp={toc:[]},bWp="wrapper";function NWp(t){let{components:e,...n}=t;return(0,s.kt)(bWp,(0,p.Z)({},ZWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}NWp.isMDXComponent=!0;const zWp={toc:[]},AWp="wrapper";function PWp(t){let{components:e,...n}=t;return(0,s.kt)(AWp,(0,p.Z)({},zWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}PWp.isMDXComponent=!0;const IWp={toc:[]},WWp="wrapper";function RWp(t){let{components:e,...n}=t;return(0,s.kt)(WWp,(0,p.Z)({},IWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}RWp.isMDXComponent=!0;const SWp={toc:[]},BWp="wrapper";function GWp(t){let{components:e,...n}=t;return(0,s.kt)(BWp,(0,p.Z)({},SWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}GWp.isMDXComponent=!0;const EWp={toc:[]},OWp="wrapper";function UWp(t){let{components:e,...n}=t;return(0,s.kt)(OWp,(0,p.Z)({},EWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UWp.isMDXComponent=!0;const FWp={toc:[]},VWp="wrapper";function qWp(t){let{components:e,...n}=t;return(0,s.kt)(VWp,(0,p.Z)({},FWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qWp.isMDXComponent=!0;const jWp={toc:[]},HWp="wrapper";function YWp(t){let{components:e,...n}=t;return(0,s.kt)(HWp,(0,p.Z)({},jWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YWp.isMDXComponent=!0;const QWp={toc:[]},$Wp="wrapper";function KWp(t){let{components:e,...n}=t;return(0,s.kt)($Wp,(0,p.Z)({},QWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KWp.isMDXComponent=!0;const JWp={toc:[]},tRp="wrapper";function eRp(t){let{components:e,...n}=t;return(0,s.kt)(tRp,(0,p.Z)({},JWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eRp.isMDXComponent=!0;const nRp={toc:[]},oRp="wrapper";function pRp(t){let{components:e,...n}=t;return(0,s.kt)(oRp,(0,p.Z)({},nRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pRp.isMDXComponent=!0;const rRp={toc:[]},sRp="wrapper";function cRp(t){let{components:e,...n}=t;return(0,s.kt)(sRp,(0,p.Z)({},rRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}cRp.isMDXComponent=!0;const aRp={toc:[]},iRp="wrapper";function lRp(t){let{components:e,...n}=t;return(0,s.kt)(iRp,(0,p.Z)({},aRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}lRp.isMDXComponent=!0;const uRp={toc:[]},mRp="wrapper";function dRp(t){let{components:e,...n}=t;return(0,s.kt)(mRp,(0,p.Z)({},uRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}dRp.isMDXComponent=!0;const hRp={toc:[]},fRp="wrapper";function kRp(t){let{components:e,...n}=t;return(0,s.kt)(fRp,(0,p.Z)({},hRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}kRp.isMDXComponent=!0;const yRp={toc:[]},DRp="wrapper";function MRp(t){let{components:e,...n}=t;return(0,s.kt)(DRp,(0,p.Z)({},yRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}MRp.isMDXComponent=!0;const XRp={toc:[]},_Rp="wrapper";function wRp(t){let{components:e,...n}=t;return(0,s.kt)(_Rp,(0,p.Z)({},XRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wRp.isMDXComponent=!0;const TRp={toc:[]},CRp="wrapper";function gRp(t){let{components:e,...n}=t;return(0,s.kt)(CRp,(0,p.Z)({},TRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}gRp.isMDXComponent=!0;const xRp={toc:[]},vRp="wrapper";function LRp(t){let{components:e,...n}=t;return(0,s.kt)(vRp,(0,p.Z)({},xRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}LRp.isMDXComponent=!0;const ZRp={toc:[]},bRp="wrapper";function NRp(t){let{components:e,...n}=t;return(0,s.kt)(bRp,(0,p.Z)({},ZRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}NRp.isMDXComponent=!0;const zRp={toc:[]},ARp="wrapper";function PRp(t){let{components:e,...n}=t;return(0,s.kt)(ARp,(0,p.Z)({},zRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}PRp.isMDXComponent=!0;const IRp={toc:[]},WRp="wrapper";function RRp(t){let{components:e,...n}=t;return(0,s.kt)(WRp,(0,p.Z)({},IRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}RRp.isMDXComponent=!0;const SRp={toc:[]},BRp="wrapper";function GRp(t){let{components:e,...n}=t;return(0,s.kt)(BRp,(0,p.Z)({},SRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}GRp.isMDXComponent=!0;const ERp={toc:[]},ORp="wrapper";function URp(t){let{components:e,...n}=t;return(0,s.kt)(ORp,(0,p.Z)({},ERp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}URp.isMDXComponent=!0;const FRp={toc:[]},VRp="wrapper";function qRp(t){let{components:e,...n}=t;return(0,s.kt)(VRp,(0,p.Z)({},FRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}qRp.isMDXComponent=!0;const jRp={toc:[]},HRp="wrapper";function YRp(t){let{components:e,...n}=t;return(0,s.kt)(HRp,(0,p.Z)({},jRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}YRp.isMDXComponent=!0;const QRp={toc:[]},$Rp="wrapper";function KRp(t){let{components:e,...n}=t;return(0,s.kt)($Rp,(0,p.Z)({},QRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}KRp.isMDXComponent=!0;const JRp={toc:[]},tSp="wrapper";function eSp(t){let{components:e,...n}=t;return(0,s.kt)(tSp,(0,p.Z)({},JRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}eSp.isMDXComponent=!0;const nSp={toc:[]},oSp="wrapper";function pSp(t){let{components:e,...n}=t;return(0,s.kt)(oSp,(0,p.Z)({},nSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}pSp.isMDXComponent=!0;const rSp={toc:[]},sSp="wrapper";function cSp(t){let{components:e,...n}=t;return(0,s.kt)(sSp,(0,p.Z)({},rSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cSp.isMDXComponent=!0;const aSp={toc:[]},iSp="wrapper";function lSp(t){let{components:e,...n}=t;return(0,s.kt)(iSp,(0,p.Z)({},aSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}lSp.isMDXComponent=!0;const uSp={toc:[]},mSp="wrapper";function dSp(t){let{components:e,...n}=t;return(0,s.kt)(mSp,(0,p.Z)({},uSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}dSp.isMDXComponent=!0;const hSp={toc:[]},fSp="wrapper";function kSp(t){let{components:e,...n}=t;return(0,s.kt)(fSp,(0,p.Z)({},hSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}kSp.isMDXComponent=!0;const ySp={toc:[]},DSp="wrapper";function MSp(t){let{components:e,...n}=t;return(0,s.kt)(DSp,(0,p.Z)({},ySp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}MSp.isMDXComponent=!0;const XSp={toc:[]},_Sp="wrapper";function wSp(t){let{components:e,...n}=t;return(0,s.kt)(_Sp,(0,p.Z)({},XSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}wSp.isMDXComponent=!0;const TSp={toc:[]},CSp="wrapper";function gSp(t){let{components:e,...n}=t;return(0,s.kt)(CSp,(0,p.Z)({},TSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gSp.isMDXComponent=!0;const xSp={toc:[]},vSp="wrapper";function LSp(t){let{components:e,...n}=t;return(0,s.kt)(vSp,(0,p.Z)({},xSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}LSp.isMDXComponent=!0;const ZSp={toc:[]},bSp="wrapper";function NSp(t){let{components:e,...n}=t;return(0,s.kt)(bSp,(0,p.Z)({},ZSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}NSp.isMDXComponent=!0;const zSp={toc:[]},ASp="wrapper";function PSp(t){let{components:e,...n}=t;return(0,s.kt)(ASp,(0,p.Z)({},zSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}PSp.isMDXComponent=!0;const ISp={toc:[]},WSp="wrapper";function RSp(t){let{components:e,...n}=t;return(0,s.kt)(WSp,(0,p.Z)({},ISp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}RSp.isMDXComponent=!0;const SSp={toc:[]},BSp="wrapper";function GSp(t){let{components:e,...n}=t;return(0,s.kt)(BSp,(0,p.Z)({},SSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}GSp.isMDXComponent=!0;const ESp={toc:[]},OSp="wrapper";function USp(t){let{components:e,...n}=t;return(0,s.kt)(OSp,(0,p.Z)({},ESp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}USp.isMDXComponent=!0;const FSp={toc:[]},VSp="wrapper";function qSp(t){let{components:e,...n}=t;return(0,s.kt)(VSp,(0,p.Z)({},FSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qSp.isMDXComponent=!0;const jSp={toc:[]},HSp="wrapper";function YSp(t){let{components:e,...n}=t;return(0,s.kt)(HSp,(0,p.Z)({},jSp,n,{components:e,mdxType:"MDXLayout"}))}YSp.isMDXComponent=!0;const QSp={toc:[]},$Sp="wrapper";function KSp(t){let{components:e,...n}=t;return(0,s.kt)($Sp,(0,p.Z)({},QSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}KSp.isMDXComponent=!0;const JSp={toc:[]},tBp="wrapper";function eBp(t){let{components:e,...n}=t;return(0,s.kt)(tBp,(0,p.Z)({},JSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}eBp.isMDXComponent=!0;const nBp={toc:[]},oBp="wrapper";function pBp(t){let{components:e,...n}=t;return(0,s.kt)(oBp,(0,p.Z)({},nBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}pBp.isMDXComponent=!0;const rBp={toc:[]},sBp="wrapper";function cBp(t){let{components:e,...n}=t;return(0,s.kt)(sBp,(0,p.Z)({},rBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}cBp.isMDXComponent=!0;const aBp={toc:[]},iBp="wrapper";function lBp(t){let{components:e,...n}=t;return(0,s.kt)(iBp,(0,p.Z)({},aBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lBp.isMDXComponent=!0;const uBp={toc:[]},mBp="wrapper";function dBp(t){let{components:e,...n}=t;return(0,s.kt)(mBp,(0,p.Z)({},uBp,n,{components:e,mdxType:"MDXLayout"}))}dBp.isMDXComponent=!0;const hBp={toc:[]},fBp="wrapper";function kBp(t){let{components:e,...n}=t;return(0,s.kt)(fBp,(0,p.Z)({},hBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}kBp.isMDXComponent=!0;const yBp={toc:[]},DBp="wrapper";function MBp(t){let{components:e,...n}=t;return(0,s.kt)(DBp,(0,p.Z)({},yBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MBp.isMDXComponent=!0;const XBp={toc:[]},_Bp="wrapper";function wBp(t){let{components:e,...n}=t;return(0,s.kt)(_Bp,(0,p.Z)({},XBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wBp.isMDXComponent=!0;const TBp={toc:[]},CBp="wrapper";function gBp(t){let{components:e,...n}=t;return(0,s.kt)(CBp,(0,p.Z)({},TBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gBp.isMDXComponent=!0;const xBp={toc:[]},vBp="wrapper";function LBp(t){let{components:e,...n}=t;return(0,s.kt)(vBp,(0,p.Z)({},xBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}LBp.isMDXComponent=!0;const ZBp={toc:[]},bBp="wrapper";function NBp(t){let{components:e,...n}=t;return(0,s.kt)(bBp,(0,p.Z)({},ZBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}NBp.isMDXComponent=!0;const zBp={toc:[]},ABp="wrapper";function PBp(t){let{components:e,...n}=t;return(0,s.kt)(ABp,(0,p.Z)({},zBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}PBp.isMDXComponent=!0;const IBp={toc:[]},WBp="wrapper";function RBp(t){let{components:e,...n}=t;return(0,s.kt)(WBp,(0,p.Z)({},IBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}RBp.isMDXComponent=!0;const SBp={toc:[]},BBp="wrapper";function GBp(t){let{components:e,...n}=t;return(0,s.kt)(BBp,(0,p.Z)({},SBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}GBp.isMDXComponent=!0;const EBp={toc:[]},OBp="wrapper";function UBp(t){let{components:e,...n}=t;return(0,s.kt)(OBp,(0,p.Z)({},EBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UBp.isMDXComponent=!0;const FBp={toc:[]},VBp="wrapper";function qBp(t){let{components:e,...n}=t;return(0,s.kt)(VBp,(0,p.Z)({},FBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}qBp.isMDXComponent=!0;const jBp={toc:[]},HBp="wrapper";function YBp(t){let{components:e,...n}=t;return(0,s.kt)(HBp,(0,p.Z)({},jBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YBp.isMDXComponent=!0;const QBp={toc:[]},$Bp="wrapper";function KBp(t){let{components:e,...n}=t;return(0,s.kt)($Bp,(0,p.Z)({},QBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}KBp.isMDXComponent=!0;const JBp={toc:[]},tGp="wrapper";function eGp(t){let{components:e,...n}=t;return(0,s.kt)(tGp,(0,p.Z)({},JBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}eGp.isMDXComponent=!0;const nGp={toc:[]},oGp="wrapper";function pGp(t){let{components:e,...n}=t;return(0,s.kt)(oGp,(0,p.Z)({},nGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}pGp.isMDXComponent=!0;const rGp={toc:[]},sGp="wrapper";function cGp(t){let{components:e,...n}=t;return(0,s.kt)(sGp,(0,p.Z)({},rGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}cGp.isMDXComponent=!0;const aGp={toc:[]},iGp="wrapper";function lGp(t){let{components:e,...n}=t;return(0,s.kt)(iGp,(0,p.Z)({},aGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}lGp.isMDXComponent=!0;const uGp={toc:[]},mGp="wrapper";function dGp(t){let{components:e,...n}=t;return(0,s.kt)(mGp,(0,p.Z)({},uGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dGp.isMDXComponent=!0;const hGp={toc:[]},fGp="wrapper";function kGp(t){let{components:e,...n}=t;return(0,s.kt)(fGp,(0,p.Z)({},hGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}kGp.isMDXComponent=!0;const yGp={toc:[]},DGp="wrapper";function MGp(t){let{components:e,...n}=t;return(0,s.kt)(DGp,(0,p.Z)({},yGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MGp.isMDXComponent=!0;const XGp={toc:[]},_Gp="wrapper";function wGp(t){let{components:e,...n}=t;return(0,s.kt)(_Gp,(0,p.Z)({},XGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wGp.isMDXComponent=!0;const TGp={toc:[]},CGp="wrapper";function gGp(t){let{components:e,...n}=t;return(0,s.kt)(CGp,(0,p.Z)({},TGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gGp.isMDXComponent=!0;const xGp={toc:[]},vGp="wrapper";function LGp(t){let{components:e,...n}=t;return(0,s.kt)(vGp,(0,p.Z)({},xGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}LGp.isMDXComponent=!0;const ZGp={toc:[]},bGp="wrapper";function NGp(t){let{components:e,...n}=t;return(0,s.kt)(bGp,(0,p.Z)({},ZGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}NGp.isMDXComponent=!0;const zGp={toc:[]},AGp="wrapper";function PGp(t){let{components:e,...n}=t;return(0,s.kt)(AGp,(0,p.Z)({},zGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}PGp.isMDXComponent=!0;const IGp={toc:[]},WGp="wrapper";function RGp(t){let{components:e,...n}=t;return(0,s.kt)(WGp,(0,p.Z)({},IGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}RGp.isMDXComponent=!0;const SGp={toc:[]},BGp="wrapper";function GGp(t){let{components:e,...n}=t;return(0,s.kt)(BGp,(0,p.Z)({},SGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}GGp.isMDXComponent=!0;const EGp={toc:[]},OGp="wrapper";function UGp(t){let{components:e,...n}=t;return(0,s.kt)(OGp,(0,p.Z)({},EGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}UGp.isMDXComponent=!0;const FGp={toc:[]},VGp="wrapper";function qGp(t){let{components:e,...n}=t;return(0,s.kt)(VGp,(0,p.Z)({},FGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qGp.isMDXComponent=!0;const jGp={toc:[]},HGp="wrapper";function YGp(t){let{components:e,...n}=t;return(0,s.kt)(HGp,(0,p.Z)({},jGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}YGp.isMDXComponent=!0;const QGp={toc:[]},$Gp="wrapper";function KGp(t){let{components:e,...n}=t;return(0,s.kt)($Gp,(0,p.Z)({},QGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}KGp.isMDXComponent=!0;const JGp={toc:[]},tEp="wrapper";function eEp(t){let{components:e,...n}=t;return(0,s.kt)(tEp,(0,p.Z)({},JGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eEp.isMDXComponent=!0;const nEp={toc:[]},oEp="wrapper";function pEp(t){let{components:e,...n}=t;return(0,s.kt)(oEp,(0,p.Z)({},nEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pEp.isMDXComponent=!0;const rEp={toc:[]},sEp="wrapper";function cEp(t){let{components:e,...n}=t;return(0,s.kt)(sEp,(0,p.Z)({},rEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cEp.isMDXComponent=!0;const aEp={toc:[]},iEp="wrapper";function lEp(t){let{components:e,...n}=t;return(0,s.kt)(iEp,(0,p.Z)({},aEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lEp.isMDXComponent=!0;const uEp={toc:[]},mEp="wrapper";function dEp(t){let{components:e,...n}=t;return(0,s.kt)(mEp,(0,p.Z)({},uEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}dEp.isMDXComponent=!0;const hEp={toc:[]},fEp="wrapper";function kEp(t){let{components:e,...n}=t;return(0,s.kt)(fEp,(0,p.Z)({},hEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}kEp.isMDXComponent=!0;const yEp={toc:[]},DEp="wrapper";function MEp(t){let{components:e,...n}=t;return(0,s.kt)(DEp,(0,p.Z)({},yEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MEp.isMDXComponent=!0;const XEp={toc:[]},_Ep="wrapper";function wEp(t){let{components:e,...n}=t;return(0,s.kt)(_Ep,(0,p.Z)({},XEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}wEp.isMDXComponent=!0;const TEp={toc:[]},CEp="wrapper";function gEp(t){let{components:e,...n}=t;return(0,s.kt)(CEp,(0,p.Z)({},TEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gEp.isMDXComponent=!0;const xEp={toc:[]},vEp="wrapper";function LEp(t){let{components:e,...n}=t;return(0,s.kt)(vEp,(0,p.Z)({},xEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}LEp.isMDXComponent=!0;const ZEp={toc:[]},bEp="wrapper";function NEp(t){let{components:e,...n}=t;return(0,s.kt)(bEp,(0,p.Z)({},ZEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}NEp.isMDXComponent=!0;const zEp={toc:[]},AEp="wrapper";function PEp(t){let{components:e,...n}=t;return(0,s.kt)(AEp,(0,p.Z)({},zEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}PEp.isMDXComponent=!0;const IEp={toc:[]},WEp="wrapper";function REp(t){let{components:e,...n}=t;return(0,s.kt)(WEp,(0,p.Z)({},IEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}REp.isMDXComponent=!0;const SEp={toc:[]},BEp="wrapper";function GEp(t){let{components:e,...n}=t;return(0,s.kt)(BEp,(0,p.Z)({},SEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}GEp.isMDXComponent=!0;const EEp={toc:[]},OEp="wrapper";function UEp(t){let{components:e,...n}=t;return(0,s.kt)(OEp,(0,p.Z)({},EEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}UEp.isMDXComponent=!0;const FEp={toc:[]},VEp="wrapper";function qEp(t){let{components:e,...n}=t;return(0,s.kt)(VEp,(0,p.Z)({},FEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}qEp.isMDXComponent=!0;const jEp={toc:[]},HEp="wrapper";function YEp(t){let{components:e,...n}=t;return(0,s.kt)(HEp,(0,p.Z)({},jEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}YEp.isMDXComponent=!0;const QEp={toc:[]},$Ep="wrapper";function KEp(t){let{components:e,...n}=t;return(0,s.kt)($Ep,(0,p.Z)({},QEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}KEp.isMDXComponent=!0;const JEp={toc:[]},tOp="wrapper";function eOp(t){let{components:e,...n}=t;return(0,s.kt)(tOp,(0,p.Z)({},JEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eOp.isMDXComponent=!0;const nOp={toc:[]},oOp="wrapper";function pOp(t){let{components:e,...n}=t;return(0,s.kt)(oOp,(0,p.Z)({},nOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pOp.isMDXComponent=!0;const rOp={toc:[]},sOp="wrapper";function cOp(t){let{components:e,...n}=t;return(0,s.kt)(sOp,(0,p.Z)({},rOp,n,{components:e,mdxType:"MDXLayout"}))}cOp.isMDXComponent=!0;const aOp={toc:[]},iOp="wrapper";function lOp(t){let{components:e,...n}=t;return(0,s.kt)(iOp,(0,p.Z)({},aOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}lOp.isMDXComponent=!0;const uOp={toc:[]},mOp="wrapper";function dOp(t){let{components:e,...n}=t;return(0,s.kt)(mOp,(0,p.Z)({},uOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}dOp.isMDXComponent=!0;const hOp={toc:[]},fOp="wrapper";function kOp(t){let{components:e,...n}=t;return(0,s.kt)(fOp,(0,p.Z)({},hOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}kOp.isMDXComponent=!0;const yOp={toc:[]},DOp="wrapper";function MOp(t){let{components:e,...n}=t;return(0,s.kt)(DOp,(0,p.Z)({},yOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}MOp.isMDXComponent=!0;const XOp={toc:[]},_Op="wrapper";function wOp(t){let{components:e,...n}=t;return(0,s.kt)(_Op,(0,p.Z)({},XOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}wOp.isMDXComponent=!0;const TOp={toc:[]},COp="wrapper";function gOp(t){let{components:e,...n}=t;return(0,s.kt)(COp,(0,p.Z)({},TOp,n,{components:e,mdxType:"MDXLayout"}))}gOp.isMDXComponent=!0;const xOp={toc:[]},vOp="wrapper";function LOp(t){let{components:e,...n}=t;return(0,s.kt)(vOp,(0,p.Z)({},xOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}LOp.isMDXComponent=!0;const ZOp={toc:[]},bOp="wrapper";function NOp(t){let{components:e,...n}=t;return(0,s.kt)(bOp,(0,p.Z)({},ZOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}NOp.isMDXComponent=!0;const zOp={toc:[]},AOp="wrapper";function POp(t){let{components:e,...n}=t;return(0,s.kt)(AOp,(0,p.Z)({},zOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}POp.isMDXComponent=!0;const IOp={toc:[]},WOp="wrapper";function ROp(t){let{components:e,...n}=t;return(0,s.kt)(WOp,(0,p.Z)({},IOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ROp.isMDXComponent=!0;const SOp={toc:[]},BOp="wrapper";function GOp(t){let{components:e,...n}=t;return(0,s.kt)(BOp,(0,p.Z)({},SOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}GOp.isMDXComponent=!0;const EOp={toc:[]},OOp="wrapper";function UOp(t){let{components:e,...n}=t;return(0,s.kt)(OOp,(0,p.Z)({},EOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}UOp.isMDXComponent=!0;const FOp={toc:[]},VOp="wrapper";function qOp(t){let{components:e,...n}=t;return(0,s.kt)(VOp,(0,p.Z)({},FOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}qOp.isMDXComponent=!0;const jOp={toc:[]},HOp="wrapper";function YOp(t){let{components:e,...n}=t;return(0,s.kt)(HOp,(0,p.Z)({},jOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YOp.isMDXComponent=!0;const QOp={toc:[]},$Op="wrapper";function KOp(t){let{components:e,...n}=t;return(0,s.kt)($Op,(0,p.Z)({},QOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}KOp.isMDXComponent=!0;const JOp={toc:[]},tUp="wrapper";function eUp(t){let{components:e,...n}=t;return(0,s.kt)(tUp,(0,p.Z)({},JOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eUp.isMDXComponent=!0;const nUp={toc:[]},oUp="wrapper";function pUp(t){let{components:e,...n}=t;return(0,s.kt)(oUp,(0,p.Z)({},nUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pUp.isMDXComponent=!0;const rUp={toc:[]},sUp="wrapper";function cUp(t){let{components:e,...n}=t;return(0,s.kt)(sUp,(0,p.Z)({},rUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cUp.isMDXComponent=!0;const aUp={toc:[]},iUp="wrapper";function lUp(t){let{components:e,...n}=t;return(0,s.kt)(iUp,(0,p.Z)({},aUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lUp.isMDXComponent=!0;const uUp={toc:[]},mUp="wrapper";function dUp(t){let{components:e,...n}=t;return(0,s.kt)(mUp,(0,p.Z)({},uUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}dUp.isMDXComponent=!0;const hUp={toc:[]},fUp="wrapper";function kUp(t){let{components:e,...n}=t;return(0,s.kt)(fUp,(0,p.Z)({},hUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}kUp.isMDXComponent=!0;const yUp={toc:[]},DUp="wrapper";function MUp(t){let{components:e,...n}=t;return(0,s.kt)(DUp,(0,p.Z)({},yUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}MUp.isMDXComponent=!0;const XUp={toc:[]},_Up="wrapper";function wUp(t){let{components:e,...n}=t;return(0,s.kt)(_Up,(0,p.Z)({},XUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wUp.isMDXComponent=!0;const TUp={toc:[]},CUp="wrapper";function gUp(t){let{components:e,...n}=t;return(0,s.kt)(CUp,(0,p.Z)({},TUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}gUp.isMDXComponent=!0;const xUp={toc:[]},vUp="wrapper";function LUp(t){let{components:e,...n}=t;return(0,s.kt)(vUp,(0,p.Z)({},xUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}LUp.isMDXComponent=!0;const ZUp={toc:[]},bUp="wrapper";function NUp(t){let{components:e,...n}=t;return(0,s.kt)(bUp,(0,p.Z)({},ZUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}NUp.isMDXComponent=!0;const zUp={toc:[]},AUp="wrapper";function PUp(t){let{components:e,...n}=t;return(0,s.kt)(AUp,(0,p.Z)({},zUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}PUp.isMDXComponent=!0;const IUp={toc:[]},WUp="wrapper";function RUp(t){let{components:e,...n}=t;return(0,s.kt)(WUp,(0,p.Z)({},IUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}RUp.isMDXComponent=!0;const SUp={toc:[]},BUp="wrapper";function GUp(t){let{components:e,...n}=t;return(0,s.kt)(BUp,(0,p.Z)({},SUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}GUp.isMDXComponent=!0;const EUp={toc:[]},OUp="wrapper";function UUp(t){let{components:e,...n}=t;return(0,s.kt)(OUp,(0,p.Z)({},EUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}UUp.isMDXComponent=!0;const FUp={toc:[]},VUp="wrapper";function qUp(t){let{components:e,...n}=t;return(0,s.kt)(VUp,(0,p.Z)({},FUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qUp.isMDXComponent=!0;const jUp={toc:[]},HUp="wrapper";function YUp(t){let{components:e,...n}=t;return(0,s.kt)(HUp,(0,p.Z)({},jUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}YUp.isMDXComponent=!0;const QUp={toc:[]},$Up="wrapper";function KUp(t){let{components:e,...n}=t;return(0,s.kt)($Up,(0,p.Z)({},QUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}KUp.isMDXComponent=!0;const JUp={toc:[]},tFp="wrapper";function eFp(t){let{components:e,...n}=t;return(0,s.kt)(tFp,(0,p.Z)({},JUp,n,{components:e,mdxType:"MDXLayout"}))}eFp.isMDXComponent=!0;const nFp={toc:[]},oFp="wrapper";function pFp(t){let{components:e,...n}=t;return(0,s.kt)(oFp,(0,p.Z)({},nFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}pFp.isMDXComponent=!0;const rFp={toc:[]},sFp="wrapper";function cFp(t){let{components:e,...n}=t;return(0,s.kt)(sFp,(0,p.Z)({},rFp,n,{components:e,mdxType:"MDXLayout"}))}cFp.isMDXComponent=!0;const aFp={toc:[]},iFp="wrapper";function lFp(t){let{components:e,...n}=t;return(0,s.kt)(iFp,(0,p.Z)({},aFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}lFp.isMDXComponent=!0;const uFp={toc:[]},mFp="wrapper";function dFp(t){let{components:e,...n}=t;return(0,s.kt)(mFp,(0,p.Z)({},uFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}dFp.isMDXComponent=!0;const hFp={toc:[]},fFp="wrapper";function kFp(t){let{components:e,...n}=t;return(0,s.kt)(fFp,(0,p.Z)({},hFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}kFp.isMDXComponent=!0;const yFp={toc:[]},DFp="wrapper";function MFp(t){let{components:e,...n}=t;return(0,s.kt)(DFp,(0,p.Z)({},yFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}MFp.isMDXComponent=!0;const XFp={toc:[]},_Fp="wrapper";function wFp(t){let{components:e,...n}=t;return(0,s.kt)(_Fp,(0,p.Z)({},XFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}wFp.isMDXComponent=!0;const TFp={toc:[]},CFp="wrapper";function gFp(t){let{components:e,...n}=t;return(0,s.kt)(CFp,(0,p.Z)({},TFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}gFp.isMDXComponent=!0;const xFp={toc:[]},vFp="wrapper";function LFp(t){let{components:e,...n}=t;return(0,s.kt)(vFp,(0,p.Z)({},xFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LFp.isMDXComponent=!0;const ZFp={toc:[]},bFp="wrapper";function NFp(t){let{components:e,...n}=t;return(0,s.kt)(bFp,(0,p.Z)({},ZFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}NFp.isMDXComponent=!0;const zFp={toc:[]},AFp="wrapper";function PFp(t){let{components:e,...n}=t;return(0,s.kt)(AFp,(0,p.Z)({},zFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PFp.isMDXComponent=!0;const IFp={toc:[]},WFp="wrapper";function RFp(t){let{components:e,...n}=t;return(0,s.kt)(WFp,(0,p.Z)({},IFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}RFp.isMDXComponent=!0;const SFp={toc:[]},BFp="wrapper";function GFp(t){let{components:e,...n}=t;return(0,s.kt)(BFp,(0,p.Z)({},SFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}GFp.isMDXComponent=!0;const EFp={toc:[]},OFp="wrapper";function UFp(t){let{components:e,...n}=t;return(0,s.kt)(OFp,(0,p.Z)({},EFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}UFp.isMDXComponent=!0;const FFp={toc:[]},VFp="wrapper";function qFp(t){let{components:e,...n}=t;return(0,s.kt)(VFp,(0,p.Z)({},FFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qFp.isMDXComponent=!0;const jFp={toc:[]},HFp="wrapper";function YFp(t){let{components:e,...n}=t;return(0,s.kt)(HFp,(0,p.Z)({},jFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}YFp.isMDXComponent=!0;const QFp={toc:[]},$Fp="wrapper";function KFp(t){let{components:e,...n}=t;return(0,s.kt)($Fp,(0,p.Z)({},QFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}KFp.isMDXComponent=!0;const JFp={toc:[]},tVp="wrapper";function eVp(t){let{components:e,...n}=t;return(0,s.kt)(tVp,(0,p.Z)({},JFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}eVp.isMDXComponent=!0;const nVp={toc:[]},oVp="wrapper";function pVp(t){let{components:e,...n}=t;return(0,s.kt)(oVp,(0,p.Z)({},nVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}pVp.isMDXComponent=!0;const rVp={toc:[]},sVp="wrapper";function cVp(t){let{components:e,...n}=t;return(0,s.kt)(sVp,(0,p.Z)({},rVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cVp.isMDXComponent=!0;const aVp={toc:[]},iVp="wrapper";function lVp(t){let{components:e,...n}=t;return(0,s.kt)(iVp,(0,p.Z)({},aVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lVp.isMDXComponent=!0;const uVp={toc:[]},mVp="wrapper";function dVp(t){let{components:e,...n}=t;return(0,s.kt)(mVp,(0,p.Z)({},uVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dVp.isMDXComponent=!0;const hVp={toc:[]},fVp="wrapper";function kVp(t){let{components:e,...n}=t;return(0,s.kt)(fVp,(0,p.Z)({},hVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kVp.isMDXComponent=!0;const yVp={toc:[]},DVp="wrapper";function MVp(t){let{components:e,...n}=t;return(0,s.kt)(DVp,(0,p.Z)({},yVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}MVp.isMDXComponent=!0;const XVp={toc:[]},_Vp="wrapper";function wVp(t){let{components:e,...n}=t;return(0,s.kt)(_Vp,(0,p.Z)({},XVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}wVp.isMDXComponent=!0;const TVp={toc:[]},CVp="wrapper";function gVp(t){let{components:e,...n}=t;return(0,s.kt)(CVp,(0,p.Z)({},TVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}gVp.isMDXComponent=!0;const xVp={toc:[]},vVp="wrapper";function LVp(t){let{components:e,...n}=t;return(0,s.kt)(vVp,(0,p.Z)({},xVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}LVp.isMDXComponent=!0;const ZVp={toc:[]},bVp="wrapper";function NVp(t){let{components:e,...n}=t;return(0,s.kt)(bVp,(0,p.Z)({},ZVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}NVp.isMDXComponent=!0;const zVp={toc:[]},AVp="wrapper";function PVp(t){let{components:e,...n}=t;return(0,s.kt)(AVp,(0,p.Z)({},zVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}PVp.isMDXComponent=!0;const IVp={toc:[]},WVp="wrapper";function RVp(t){let{components:e,...n}=t;return(0,s.kt)(WVp,(0,p.Z)({},IVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}RVp.isMDXComponent=!0;const SVp={toc:[]},BVp="wrapper";function GVp(t){let{components:e,...n}=t;return(0,s.kt)(BVp,(0,p.Z)({},SVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}GVp.isMDXComponent=!0;const EVp={toc:[]},OVp="wrapper";function UVp(t){let{components:e,...n}=t;return(0,s.kt)(OVp,(0,p.Z)({},EVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}UVp.isMDXComponent=!0;const FVp={toc:[]},VVp="wrapper";function qVp(t){let{components:e,...n}=t;return(0,s.kt)(VVp,(0,p.Z)({},FVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qVp.isMDXComponent=!0;const jVp={toc:[]},HVp="wrapper";function YVp(t){let{components:e,...n}=t;return(0,s.kt)(HVp,(0,p.Z)({},jVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}YVp.isMDXComponent=!0;const QVp={toc:[]},$Vp="wrapper";function KVp(t){let{components:e,...n}=t;return(0,s.kt)($Vp,(0,p.Z)({},QVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KVp.isMDXComponent=!0;const JVp={toc:[]},tqp="wrapper";function eqp(t){let{components:e,...n}=t;return(0,s.kt)(tqp,(0,p.Z)({},JVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}eqp.isMDXComponent=!0;const nqp={toc:[]},oqp="wrapper";function pqp(t){let{components:e,...n}=t;return(0,s.kt)(oqp,(0,p.Z)({},nqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}pqp.isMDXComponent=!0;const rqp={toc:[]},sqp="wrapper";function cqp(t){let{components:e,...n}=t;return(0,s.kt)(sqp,(0,p.Z)({},rqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}cqp.isMDXComponent=!0;const aqp={toc:[]},iqp="wrapper";function lqp(t){let{components:e,...n}=t;return(0,s.kt)(iqp,(0,p.Z)({},aqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lqp.isMDXComponent=!0;const uqp={toc:[]},mqp="wrapper";function dqp(t){let{components:e,...n}=t;return(0,s.kt)(mqp,(0,p.Z)({},uqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}dqp.isMDXComponent=!0;const hqp={toc:[]},fqp="wrapper";function kqp(t){let{components:e,...n}=t;return(0,s.kt)(fqp,(0,p.Z)({},hqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kqp.isMDXComponent=!0;const yqp={toc:[]},Dqp="wrapper";function Mqp(t){let{components:e,...n}=t;return(0,s.kt)(Dqp,(0,p.Z)({},yqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Mqp.isMDXComponent=!0;const Xqp={toc:[]},_qp="wrapper";function wqp(t){let{components:e,...n}=t;return(0,s.kt)(_qp,(0,p.Z)({},Xqp,n,{components:e,mdxType:"MDXLayout"}))}wqp.isMDXComponent=!0;const Tqp={toc:[]},Cqp="wrapper";function gqp(t){let{components:e,...n}=t;return(0,s.kt)(Cqp,(0,p.Z)({},Tqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}gqp.isMDXComponent=!0;const xqp={toc:[]},vqp="wrapper";function Lqp(t){let{components:e,...n}=t;return(0,s.kt)(vqp,(0,p.Z)({},xqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Lqp.isMDXComponent=!0;const Zqp={toc:[]},bqp="wrapper";function Nqp(t){let{components:e,...n}=t;return(0,s.kt)(bqp,(0,p.Z)({},Zqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Nqp.isMDXComponent=!0;const zqp={toc:[]},Aqp="wrapper";function Pqp(t){let{components:e,...n}=t;return(0,s.kt)(Aqp,(0,p.Z)({},zqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Pqp.isMDXComponent=!0;const Iqp={toc:[]},Wqp="wrapper";function Rqp(t){let{components:e,...n}=t;return(0,s.kt)(Wqp,(0,p.Z)({},Iqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Rqp.isMDXComponent=!0;const Sqp={toc:[]},Bqp="wrapper";function Gqp(t){let{components:e,...n}=t;return(0,s.kt)(Bqp,(0,p.Z)({},Sqp,n,{components:e,mdxType:"MDXLayout"}))}Gqp.isMDXComponent=!0;const Eqp={toc:[]},Oqp="wrapper";function Uqp(t){let{components:e,...n}=t;return(0,s.kt)(Oqp,(0,p.Z)({},Eqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Uqp.isMDXComponent=!0;const Fqp={toc:[]},Vqp="wrapper";function qqp(t){let{components:e,...n}=t;return(0,s.kt)(Vqp,(0,p.Z)({},Fqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qqp.isMDXComponent=!0;const jqp={toc:[]},Hqp="wrapper";function Yqp(t){let{components:e,...n}=t;return(0,s.kt)(Hqp,(0,p.Z)({},jqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Yqp.isMDXComponent=!0;const Qqp={toc:[]},$qp="wrapper";function Kqp(t){let{components:e,...n}=t;return(0,s.kt)($qp,(0,p.Z)({},Qqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Kqp.isMDXComponent=!0;const Jqp={toc:[]},tjp="wrapper";function ejp(t){let{components:e,...n}=t;return(0,s.kt)(tjp,(0,p.Z)({},Jqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ejp.isMDXComponent=!0;const njp={toc:[]},ojp="wrapper";function pjp(t){let{components:e,...n}=t;return(0,s.kt)(ojp,(0,p.Z)({},njp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}pjp.isMDXComponent=!0;const rjp={toc:[]},sjp="wrapper";function cjp(t){let{components:e,...n}=t;return(0,s.kt)(sjp,(0,p.Z)({},rjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}cjp.isMDXComponent=!0;const ajp={toc:[]},ijp="wrapper";function ljp(t){let{components:e,...n}=t;return(0,s.kt)(ijp,(0,p.Z)({},ajp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ljp.isMDXComponent=!0;const ujp={toc:[]},mjp="wrapper";function djp(t){let{components:e,...n}=t;return(0,s.kt)(mjp,(0,p.Z)({},ujp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}djp.isMDXComponent=!0;const hjp={toc:[]},fjp="wrapper";function kjp(t){let{components:e,...n}=t;return(0,s.kt)(fjp,(0,p.Z)({},hjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kjp.isMDXComponent=!0;const yjp={toc:[]},Djp="wrapper";function Mjp(t){let{components:e,...n}=t;return(0,s.kt)(Djp,(0,p.Z)({},yjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mjp.isMDXComponent=!0;const Xjp={toc:[]},_jp="wrapper";function wjp(t){let{components:e,...n}=t;return(0,s.kt)(_jp,(0,p.Z)({},Xjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wjp.isMDXComponent=!0;const Tjp={toc:[]},Cjp="wrapper";function gjp(t){let{components:e,...n}=t;return(0,s.kt)(Cjp,(0,p.Z)({},Tjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}gjp.isMDXComponent=!0;const xjp={toc:[]},vjp="wrapper";function Ljp(t){let{components:e,...n}=t;return(0,s.kt)(vjp,(0,p.Z)({},xjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ljp.isMDXComponent=!0;const Zjp={toc:[]},bjp="wrapper";function Njp(t){let{components:e,...n}=t;return(0,s.kt)(bjp,(0,p.Z)({},Zjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Njp.isMDXComponent=!0;const zjp={toc:[]},Ajp="wrapper";function Pjp(t){let{components:e,...n}=t;return(0,s.kt)(Ajp,(0,p.Z)({},zjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pjp.isMDXComponent=!0;const Ijp={toc:[]},Wjp="wrapper";function Rjp(t){let{components:e,...n}=t;return(0,s.kt)(Wjp,(0,p.Z)({},Ijp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Rjp.isMDXComponent=!0;const Sjp={toc:[]},Bjp="wrapper";function Gjp(t){let{components:e,...n}=t;return(0,s.kt)(Bjp,(0,p.Z)({},Sjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gjp.isMDXComponent=!0;const Ejp={toc:[]},Ojp="wrapper";function Ujp(t){let{components:e,...n}=t;return(0,s.kt)(Ojp,(0,p.Z)({},Ejp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ujp.isMDXComponent=!0;const Fjp={toc:[]},Vjp="wrapper";function qjp(t){let{components:e,...n}=t;return(0,s.kt)(Vjp,(0,p.Z)({},Fjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qjp.isMDXComponent=!0;const jjp={toc:[]},Hjp="wrapper";function Yjp(t){let{components:e,...n}=t;return(0,s.kt)(Hjp,(0,p.Z)({},jjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Yjp.isMDXComponent=!0;const Qjp={toc:[]},$jp="wrapper";function Kjp(t){let{components:e,...n}=t;return(0,s.kt)($jp,(0,p.Z)({},Qjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Kjp.isMDXComponent=!0;const Jjp={toc:[]},tHp="wrapper";function eHp(t){let{components:e,...n}=t;return(0,s.kt)(tHp,(0,p.Z)({},Jjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}eHp.isMDXComponent=!0;const nHp={toc:[]},oHp="wrapper";function pHp(t){let{components:e,...n}=t;return(0,s.kt)(oHp,(0,p.Z)({},nHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}pHp.isMDXComponent=!0;const rHp={toc:[]},sHp="wrapper";function cHp(t){let{components:e,...n}=t;return(0,s.kt)(sHp,(0,p.Z)({},rHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cHp.isMDXComponent=!0;const aHp={toc:[]},iHp="wrapper";function lHp(t){let{components:e,...n}=t;return(0,s.kt)(iHp,(0,p.Z)({},aHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lHp.isMDXComponent=!0;const uHp={toc:[]},mHp="wrapper";function dHp(t){let{components:e,...n}=t;return(0,s.kt)(mHp,(0,p.Z)({},uHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dHp.isMDXComponent=!0;const hHp={toc:[]},fHp="wrapper";function kHp(t){let{components:e,...n}=t;return(0,s.kt)(fHp,(0,p.Z)({},hHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kHp.isMDXComponent=!0;const yHp={toc:[]},DHp="wrapper";function MHp(t){let{components:e,...n}=t;return(0,s.kt)(DHp,(0,p.Z)({},yHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}MHp.isMDXComponent=!0;const XHp={toc:[]},_Hp="wrapper";function wHp(t){let{components:e,...n}=t;return(0,s.kt)(_Hp,(0,p.Z)({},XHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wHp.isMDXComponent=!0;const THp={toc:[]},CHp="wrapper";function gHp(t){let{components:e,...n}=t;return(0,s.kt)(CHp,(0,p.Z)({},THp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}gHp.isMDXComponent=!0;const xHp={toc:[]},vHp="wrapper";function LHp(t){let{components:e,...n}=t;return(0,s.kt)(vHp,(0,p.Z)({},xHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}LHp.isMDXComponent=!0;const ZHp={toc:[]},bHp="wrapper";function NHp(t){let{components:e,...n}=t;return(0,s.kt)(bHp,(0,p.Z)({},ZHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}NHp.isMDXComponent=!0;const zHp={toc:[]},AHp="wrapper";function PHp(t){let{components:e,...n}=t;return(0,s.kt)(AHp,(0,p.Z)({},zHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PHp.isMDXComponent=!0;const IHp={toc:[]},WHp="wrapper";function RHp(t){let{components:e,...n}=t;return(0,s.kt)(WHp,(0,p.Z)({},IHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}RHp.isMDXComponent=!0;const SHp={toc:[]},BHp="wrapper";function GHp(t){let{components:e,...n}=t;return(0,s.kt)(BHp,(0,p.Z)({},SHp,n,{components:e,mdxType:"MDXLayout"}))}GHp.isMDXComponent=!0;const EHp={toc:[]},OHp="wrapper";function UHp(t){let{components:e,...n}=t;return(0,s.kt)(OHp,(0,p.Z)({},EHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}UHp.isMDXComponent=!0;const FHp={toc:[]},VHp="wrapper";function qHp(t){let{components:e,...n}=t;return(0,s.kt)(VHp,(0,p.Z)({},FHp,n,{components:e,mdxType:"MDXLayout"}))}qHp.isMDXComponent=!0;const jHp={toc:[]},HHp="wrapper";function YHp(t){let{components:e,...n}=t;return(0,s.kt)(HHp,(0,p.Z)({},jHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YHp.isMDXComponent=!0;const QHp={toc:[]},$Hp="wrapper";function KHp(t){let{components:e,...n}=t;return(0,s.kt)($Hp,(0,p.Z)({},QHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}KHp.isMDXComponent=!0;const JHp={toc:[]},tYp="wrapper";function eYp(t){let{components:e,...n}=t;return(0,s.kt)(tYp,(0,p.Z)({},JHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eYp.isMDXComponent=!0;const nYp={toc:[]},oYp="wrapper";function pYp(t){let{components:e,...n}=t;return(0,s.kt)(oYp,(0,p.Z)({},nYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pYp.isMDXComponent=!0;const rYp={toc:[]},sYp="wrapper";function cYp(t){let{components:e,...n}=t;return(0,s.kt)(sYp,(0,p.Z)({},rYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cYp.isMDXComponent=!0;const aYp={toc:[]},iYp="wrapper";function lYp(t){let{components:e,...n}=t;return(0,s.kt)(iYp,(0,p.Z)({},aYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lYp.isMDXComponent=!0;const uYp={toc:[]},mYp="wrapper";function dYp(t){let{components:e,...n}=t;return(0,s.kt)(mYp,(0,p.Z)({},uYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}dYp.isMDXComponent=!0;const hYp={toc:[]},fYp="wrapper";function kYp(t){let{components:e,...n}=t;return(0,s.kt)(fYp,(0,p.Z)({},hYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}kYp.isMDXComponent=!0;const yYp={toc:[]},DYp="wrapper";function MYp(t){let{components:e,...n}=t;return(0,s.kt)(DYp,(0,p.Z)({},yYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MYp.isMDXComponent=!0;const XYp={toc:[]},_Yp="wrapper";function wYp(t){let{components:e,...n}=t;return(0,s.kt)(_Yp,(0,p.Z)({},XYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wYp.isMDXComponent=!0;const TYp={toc:[]},CYp="wrapper";function gYp(t){let{components:e,...n}=t;return(0,s.kt)(CYp,(0,p.Z)({},TYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gYp.isMDXComponent=!0;const xYp={toc:[]},vYp="wrapper";function LYp(t){let{components:e,...n}=t;return(0,s.kt)(vYp,(0,p.Z)({},xYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}LYp.isMDXComponent=!0;const ZYp={toc:[]},bYp="wrapper";function NYp(t){let{components:e,...n}=t;return(0,s.kt)(bYp,(0,p.Z)({},ZYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NYp.isMDXComponent=!0;const zYp={toc:[]},AYp="wrapper";function PYp(t){let{components:e,...n}=t;return(0,s.kt)(AYp,(0,p.Z)({},zYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}PYp.isMDXComponent=!0;const IYp={toc:[]},WYp="wrapper";function RYp(t){let{components:e,...n}=t;return(0,s.kt)(WYp,(0,p.Z)({},IYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}RYp.isMDXComponent=!0;const SYp={toc:[]},BYp="wrapper";function GYp(t){let{components:e,...n}=t;return(0,s.kt)(BYp,(0,p.Z)({},SYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}GYp.isMDXComponent=!0;const EYp={toc:[]},OYp="wrapper";function UYp(t){let{components:e,...n}=t;return(0,s.kt)(OYp,(0,p.Z)({},EYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}UYp.isMDXComponent=!0;const FYp={toc:[]},VYp="wrapper";function qYp(t){let{components:e,...n}=t;return(0,s.kt)(VYp,(0,p.Z)({},FYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qYp.isMDXComponent=!0;const jYp={toc:[]},HYp="wrapper";function YYp(t){let{components:e,...n}=t;return(0,s.kt)(HYp,(0,p.Z)({},jYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}YYp.isMDXComponent=!0;const QYp={toc:[]},$Yp="wrapper";function KYp(t){let{components:e,...n}=t;return(0,s.kt)($Yp,(0,p.Z)({},QYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}KYp.isMDXComponent=!0;const JYp={toc:[]},tQp="wrapper";function eQp(t){let{components:e,...n}=t;return(0,s.kt)(tQp,(0,p.Z)({},JYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eQp.isMDXComponent=!0;const nQp={toc:[]},oQp="wrapper";function pQp(t){let{components:e,...n}=t;return(0,s.kt)(oQp,(0,p.Z)({},nQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pQp.isMDXComponent=!0;const rQp={toc:[]},sQp="wrapper";function cQp(t){let{components:e,...n}=t;return(0,s.kt)(sQp,(0,p.Z)({},rQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}cQp.isMDXComponent=!0;const aQp={toc:[]},iQp="wrapper";function lQp(t){let{components:e,...n}=t;return(0,s.kt)(iQp,(0,p.Z)({},aQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}lQp.isMDXComponent=!0;const uQp={toc:[]},mQp="wrapper";function dQp(t){let{components:e,...n}=t;return(0,s.kt)(mQp,(0,p.Z)({},uQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}dQp.isMDXComponent=!0;const hQp={toc:[]},fQp="wrapper";function kQp(t){let{components:e,...n}=t;return(0,s.kt)(fQp,(0,p.Z)({},hQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}kQp.isMDXComponent=!0;const yQp={toc:[]},DQp="wrapper";function MQp(t){let{components:e,...n}=t;return(0,s.kt)(DQp,(0,p.Z)({},yQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MQp.isMDXComponent=!0;const XQp={toc:[]},_Qp="wrapper";function wQp(t){let{components:e,...n}=t;return(0,s.kt)(_Qp,(0,p.Z)({},XQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}wQp.isMDXComponent=!0;const TQp={toc:[]},CQp="wrapper";function gQp(t){let{components:e,...n}=t;return(0,s.kt)(CQp,(0,p.Z)({},TQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gQp.isMDXComponent=!0;const xQp={toc:[]},vQp="wrapper";function LQp(t){let{components:e,...n}=t;return(0,s.kt)(vQp,(0,p.Z)({},xQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}LQp.isMDXComponent=!0;const ZQp={toc:[]},bQp="wrapper";function NQp(t){let{components:e,...n}=t;return(0,s.kt)(bQp,(0,p.Z)({},ZQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}NQp.isMDXComponent=!0;const zQp={toc:[]},AQp="wrapper";function PQp(t){let{components:e,...n}=t;return(0,s.kt)(AQp,(0,p.Z)({},zQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}PQp.isMDXComponent=!0;const IQp={toc:[]},WQp="wrapper";function RQp(t){let{components:e,...n}=t;return(0,s.kt)(WQp,(0,p.Z)({},IQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}RQp.isMDXComponent=!0;const SQp={toc:[]},BQp="wrapper";function GQp(t){let{components:e,...n}=t;return(0,s.kt)(BQp,(0,p.Z)({},SQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}GQp.isMDXComponent=!0;const EQp={toc:[]},OQp="wrapper";function UQp(t){let{components:e,...n}=t;return(0,s.kt)(OQp,(0,p.Z)({},EQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}UQp.isMDXComponent=!0;const FQp={toc:[]},VQp="wrapper";function qQp(t){let{components:e,...n}=t;return(0,s.kt)(VQp,(0,p.Z)({},FQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}qQp.isMDXComponent=!0;const jQp={toc:[]},HQp="wrapper";function YQp(t){let{components:e,...n}=t;return(0,s.kt)(HQp,(0,p.Z)({},jQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}YQp.isMDXComponent=!0;const QQp={toc:[]},$Qp="wrapper";function KQp(t){let{components:e,...n}=t;return(0,s.kt)($Qp,(0,p.Z)({},QQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The points of the line."))}KQp.isMDXComponent=!0;const JQp={toc:[]},t$p="wrapper";function e$p(t){let{components:e,...n}=t;return(0,s.kt)(t$p,(0,p.Z)({},JQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the line's corners."))}e$p.isMDXComponent=!0;const n$p={toc:[]},o$p="wrapper";function p$p(t){let{components:e,...n}=t;return(0,s.kt)(o$p,(0,p.Z)({},n$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p$p.isMDXComponent=!0;const r$p={toc:[]},s$p="wrapper";function c$p(t){let{components:e,...n}=t;return(0,s.kt)(s$p,(0,p.Z)({},r$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}c$p.isMDXComponent=!0;const a$p={toc:[]},i$p="wrapper";function l$p(t){let{components:e,...n}=t;return(0,s.kt)(i$p,(0,p.Z)({},a$p,n,{components:e,mdxType:"MDXLayout"}))}l$p.isMDXComponent=!0;const u$p={toc:[]},m$p="wrapper";function d$p(t){let{components:e,...n}=t;return(0,s.kt)(m$p,(0,p.Z)({},u$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}d$p.isMDXComponent=!0;const h$p={toc:[]},f$p="wrapper";function k$p(t){let{components:e,...n}=t;return(0,s.kt)(f$p,(0,p.Z)({},h$p,n,{components:e,mdxType:"MDXLayout"}))}k$p.isMDXComponent=!0;const y$p={toc:[]},D$p="wrapper";function M$p(t){let{components:e,...n}=t;return(0,s.kt)(D$p,(0,p.Z)({},y$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}M$p.isMDXComponent=!0;const X$p={toc:[]},_$p="wrapper";function w$p(t){let{components:e,...n}=t;return(0,s.kt)(_$p,(0,p.Z)({},X$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}w$p.isMDXComponent=!0;const T$p={toc:[]},C$p="wrapper";function g$p(t){let{components:e,...n}=t;return(0,s.kt)(C$p,(0,p.Z)({},T$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}g$p.isMDXComponent=!0;const x$p={toc:[]},v$p="wrapper";function L$p(t){let{components:e,...n}=t;return(0,s.kt)(v$p,(0,p.Z)({},x$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}L$p.isMDXComponent=!0;const Z$p={toc:[]},b$p="wrapper";function N$p(t){let{components:e,...n}=t;return(0,s.kt)(b$p,(0,p.Z)({},Z$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}N$p.isMDXComponent=!0;const z$p={toc:[]},A$p="wrapper";function P$p(t){let{components:e,...n}=t;return(0,s.kt)(A$p,(0,p.Z)({},z$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}P$p.isMDXComponent=!0;const I$p={toc:[]},W$p="wrapper";function R$p(t){let{components:e,...n}=t;return(0,s.kt)(W$p,(0,p.Z)({},I$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}R$p.isMDXComponent=!0;const S$p={toc:[]},B$p="wrapper";function G$p(t){let{components:e,...n}=t;return(0,s.kt)(B$p,(0,p.Z)({},S$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}G$p.isMDXComponent=!0;const E$p={toc:[]},O$p="wrapper";function U$p(t){let{components:e,...n}=t;return(0,s.kt)(O$p,(0,p.Z)({},E$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}U$p.isMDXComponent=!0;const F$p={toc:[]},V$p="wrapper";function q$p(t){let{components:e,...n}=t;return(0,s.kt)(V$p,(0,p.Z)({},F$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}q$p.isMDXComponent=!0;const j$p={toc:[]},H$p="wrapper";function Y$p(t){let{components:e,...n}=t;return(0,s.kt)(H$p,(0,p.Z)({},j$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y$p.isMDXComponent=!0;const Q$p={toc:[]},$$p="wrapper";function K$p(t){let{components:e,...n}=t;return(0,s.kt)($$p,(0,p.Z)({},Q$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}K$p.isMDXComponent=!0;const J$p={toc:[]},tKp="wrapper";function eKp(t){let{components:e,...n}=t;return(0,s.kt)(tKp,(0,p.Z)({},J$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eKp.isMDXComponent=!0;const nKp={toc:[]},oKp="wrapper";function pKp(t){let{components:e,...n}=t;return(0,s.kt)(oKp,(0,p.Z)({},nKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pKp.isMDXComponent=!0;const rKp={toc:[]},sKp="wrapper";function cKp(t){let{components:e,...n}=t;return(0,s.kt)(sKp,(0,p.Z)({},rKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}cKp.isMDXComponent=!0;const aKp={toc:[]},iKp="wrapper";function lKp(t){let{components:e,...n}=t;return(0,s.kt)(iKp,(0,p.Z)({},aKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}lKp.isMDXComponent=!0;const uKp={toc:[]},mKp="wrapper";function dKp(t){let{components:e,...n}=t;return(0,s.kt)(mKp,(0,p.Z)({},uKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}dKp.isMDXComponent=!0;const hKp={toc:[]},fKp="wrapper";function kKp(t){let{components:e,...n}=t;return(0,s.kt)(fKp,(0,p.Z)({},hKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}kKp.isMDXComponent=!0;const yKp={toc:[]},DKp="wrapper";function MKp(t){let{components:e,...n}=t;return(0,s.kt)(DKp,(0,p.Z)({},yKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}MKp.isMDXComponent=!0;const XKp={toc:[]},_Kp="wrapper";function wKp(t){let{components:e,...n}=t;return(0,s.kt)(_Kp,(0,p.Z)({},XKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wKp.isMDXComponent=!0;const TKp={toc:[]},CKp="wrapper";function gKp(t){let{components:e,...n}=t;return(0,s.kt)(CKp,(0,p.Z)({},TKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}gKp.isMDXComponent=!0;const xKp={toc:[]},vKp="wrapper";function LKp(t){let{components:e,...n}=t;return(0,s.kt)(vKp,(0,p.Z)({},xKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}LKp.isMDXComponent=!0;const ZKp={toc:[]},bKp="wrapper";function NKp(t){let{components:e,...n}=t;return(0,s.kt)(bKp,(0,p.Z)({},ZKp,n,{components:e,mdxType:"MDXLayout"}))}NKp.isMDXComponent=!0;const zKp={toc:[]},AKp="wrapper";function PKp(t){let{components:e,...n}=t;return(0,s.kt)(AKp,(0,p.Z)({},zKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}PKp.isMDXComponent=!0;const IKp={toc:[]},WKp="wrapper";function RKp(t){let{components:e,...n}=t;return(0,s.kt)(WKp,(0,p.Z)({},IKp,n,{components:e,mdxType:"MDXLayout"}))}RKp.isMDXComponent=!0;const SKp={toc:[]},BKp="wrapper";function GKp(t){let{components:e,...n}=t;return(0,s.kt)(BKp,(0,p.Z)({},SKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GKp.isMDXComponent=!0;const EKp={toc:[]},OKp="wrapper";function UKp(t){let{components:e,...n}=t;return(0,s.kt)(OKp,(0,p.Z)({},EKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}UKp.isMDXComponent=!0;const FKp={toc:[]},VKp="wrapper";function qKp(t){let{components:e,...n}=t;return(0,s.kt)(VKp,(0,p.Z)({},FKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qKp.isMDXComponent=!0;const jKp={toc:[]},HKp="wrapper";function YKp(t){let{components:e,...n}=t;return(0,s.kt)(HKp,(0,p.Z)({},jKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YKp.isMDXComponent=!0;const QKp={toc:[]},$Kp="wrapper";function KKp(t){let{components:e,...n}=t;return(0,s.kt)($Kp,(0,p.Z)({},QKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KKp.isMDXComponent=!0;const JKp={toc:[]},tJp="wrapper";function eJp(t){let{components:e,...n}=t;return(0,s.kt)(tJp,(0,p.Z)({},JKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}eJp.isMDXComponent=!0;const nJp={toc:[]},oJp="wrapper";function pJp(t){let{components:e,...n}=t;return(0,s.kt)(oJp,(0,p.Z)({},nJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pJp.isMDXComponent=!0;const rJp={toc:[]},sJp="wrapper";function cJp(t){let{components:e,...n}=t;return(0,s.kt)(sJp,(0,p.Z)({},rJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cJp.isMDXComponent=!0;const aJp={toc:[]},iJp="wrapper";function lJp(t){let{components:e,...n}=t;return(0,s.kt)(iJp,(0,p.Z)({},aJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lJp.isMDXComponent=!0;const uJp={toc:[]},mJp="wrapper";function dJp(t){let{components:e,...n}=t;return(0,s.kt)(mJp,(0,p.Z)({},uJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dJp.isMDXComponent=!0;const hJp={toc:[]},fJp="wrapper";function kJp(t){let{components:e,...n}=t;return(0,s.kt)(fJp,(0,p.Z)({},hJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kJp.isMDXComponent=!0;const yJp={toc:[]},DJp="wrapper";function MJp(t){let{components:e,...n}=t;return(0,s.kt)(DJp,(0,p.Z)({},yJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}MJp.isMDXComponent=!0;const XJp={toc:[]},_Jp="wrapper";function wJp(t){let{components:e,...n}=t;return(0,s.kt)(_Jp,(0,p.Z)({},XJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wJp.isMDXComponent=!0;const TJp={toc:[]},CJp="wrapper";function gJp(t){let{components:e,...n}=t;return(0,s.kt)(CJp,(0,p.Z)({},TJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}gJp.isMDXComponent=!0;const xJp={toc:[]},vJp="wrapper";function LJp(t){let{components:e,...n}=t;return(0,s.kt)(vJp,(0,p.Z)({},xJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}LJp.isMDXComponent=!0;const ZJp={toc:[]},bJp="wrapper";function NJp(t){let{components:e,...n}=t;return(0,s.kt)(bJp,(0,p.Z)({},ZJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}NJp.isMDXComponent=!0;const zJp={toc:[]},AJp="wrapper";function PJp(t){let{components:e,...n}=t;return(0,s.kt)(AJp,(0,p.Z)({},zJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}PJp.isMDXComponent=!0;const IJp={toc:[]},WJp="wrapper";function RJp(t){let{components:e,...n}=t;return(0,s.kt)(WJp,(0,p.Z)({},IJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}RJp.isMDXComponent=!0;const SJp={toc:[]},BJp="wrapper";function GJp(t){let{components:e,...n}=t;return(0,s.kt)(BJp,(0,p.Z)({},SJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}GJp.isMDXComponent=!0;const EJp={toc:[]},OJp="wrapper";function UJp(t){let{components:e,...n}=t;return(0,s.kt)(OJp,(0,p.Z)({},EJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}UJp.isMDXComponent=!0;const FJp={toc:[]},VJp="wrapper";function qJp(t){let{components:e,...n}=t;return(0,s.kt)(VJp,(0,p.Z)({},FJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qJp.isMDXComponent=!0;const jJp={toc:[]},HJp="wrapper";function YJp(t){let{components:e,...n}=t;return(0,s.kt)(HJp,(0,p.Z)({},jJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}YJp.isMDXComponent=!0;const QJp={toc:[]},$Jp="wrapper";function KJp(t){let{components:e,...n}=t;return(0,s.kt)($Jp,(0,p.Z)({},QJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}KJp.isMDXComponent=!0;const JJp={toc:[]},t0p="wrapper";function e0p(t){let{components:e,...n}=t;return(0,s.kt)(t0p,(0,p.Z)({},JJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}e0p.isMDXComponent=!0;const n0p={toc:[]},o0p="wrapper";function p0p(t){let{components:e,...n}=t;return(0,s.kt)(o0p,(0,p.Z)({},n0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}p0p.isMDXComponent=!0;const r0p={toc:[]},s0p="wrapper";function c0p(t){let{components:e,...n}=t;return(0,s.kt)(s0p,(0,p.Z)({},r0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}c0p.isMDXComponent=!0;const a0p={toc:[]},i0p="wrapper";function l0p(t){let{components:e,...n}=t;return(0,s.kt)(i0p,(0,p.Z)({},a0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l0p.isMDXComponent=!0;const u0p={toc:[]},m0p="wrapper";function d0p(t){let{components:e,...n}=t;return(0,s.kt)(m0p,(0,p.Z)({},u0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}d0p.isMDXComponent=!0;const h0p={toc:[]},f0p="wrapper";function k0p(t){let{components:e,...n}=t;return(0,s.kt)(f0p,(0,p.Z)({},h0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}k0p.isMDXComponent=!0;const y0p={toc:[]},D0p="wrapper";function M0p(t){let{components:e,...n}=t;return(0,s.kt)(D0p,(0,p.Z)({},y0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}M0p.isMDXComponent=!0;const X0p={toc:[]},_0p="wrapper";function w0p(t){let{components:e,...n}=t;return(0,s.kt)(_0p,(0,p.Z)({},X0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w0p.isMDXComponent=!0;const T0p={toc:[]},C0p="wrapper";function g0p(t){let{components:e,...n}=t;return(0,s.kt)(C0p,(0,p.Z)({},T0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}g0p.isMDXComponent=!0;const x0p={toc:[]},v0p="wrapper";function L0p(t){let{components:e,...n}=t;return(0,s.kt)(v0p,(0,p.Z)({},x0p,n,{components:e,mdxType:"MDXLayout"}))}L0p.isMDXComponent=!0;const Z0p={toc:[]},b0p="wrapper";function N0p(t){let{components:e,...n}=t;return(0,s.kt)(b0p,(0,p.Z)({},Z0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}N0p.isMDXComponent=!0;const z0p={toc:[]},A0p="wrapper";function P0p(t){let{components:e,...n}=t;return(0,s.kt)(A0p,(0,p.Z)({},z0p,n,{components:e,mdxType:"MDXLayout"}))}P0p.isMDXComponent=!0;const I0p={toc:[]},W0p="wrapper";function R0p(t){let{components:e,...n}=t;return(0,s.kt)(W0p,(0,p.Z)({},I0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}R0p.isMDXComponent=!0;const S0p={toc:[]},B0p="wrapper";function G0p(t){let{components:e,...n}=t;return(0,s.kt)(B0p,(0,p.Z)({},S0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}G0p.isMDXComponent=!0;const E0p={toc:[]},O0p="wrapper";function U0p(t){let{components:e,...n}=t;return(0,s.kt)(O0p,(0,p.Z)({},E0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}U0p.isMDXComponent=!0;const F0p={toc:[]},V0p="wrapper";function q0p(t){let{components:e,...n}=t;return(0,s.kt)(V0p,(0,p.Z)({},F0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}q0p.isMDXComponent=!0;const j0p={toc:[]},H0p="wrapper";function Y0p(t){let{components:e,...n}=t;return(0,s.kt)(H0p,(0,p.Z)({},j0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Y0p.isMDXComponent=!0;const Q0p={toc:[]},$0p="wrapper";function K0p(t){let{components:e,...n}=t;return(0,s.kt)($0p,(0,p.Z)({},Q0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}K0p.isMDXComponent=!0;const J0p={toc:[]},t3p="wrapper";function e3p(t){let{components:e,...n}=t;return(0,s.kt)(t3p,(0,p.Z)({},J0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}e3p.isMDXComponent=!0;const n3p={toc:[]},o3p="wrapper";function p3p(t){let{components:e,...n}=t;return(0,s.kt)(o3p,(0,p.Z)({},n3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}p3p.isMDXComponent=!0;const r3p={toc:[]},s3p="wrapper";function c3p(t){let{components:e,...n}=t;return(0,s.kt)(s3p,(0,p.Z)({},r3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}c3p.isMDXComponent=!0;const a3p={toc:[]},i3p="wrapper";function l3p(t){let{components:e,...n}=t;return(0,s.kt)(i3p,(0,p.Z)({},a3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}l3p.isMDXComponent=!0;const u3p={toc:[]},m3p="wrapper";function d3p(t){let{components:e,...n}=t;return(0,s.kt)(m3p,(0,p.Z)({},u3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}d3p.isMDXComponent=!0;const h3p={toc:[]},f3p="wrapper";function k3p(t){let{components:e,...n}=t;return(0,s.kt)(f3p,(0,p.Z)({},h3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}k3p.isMDXComponent=!0;const y3p={toc:[]},D3p="wrapper";function M3p(t){let{components:e,...n}=t;return(0,s.kt)(D3p,(0,p.Z)({},y3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}M3p.isMDXComponent=!0;const X3p={toc:[]},_3p="wrapper";function w3p(t){let{components:e,...n}=t;return(0,s.kt)(_3p,(0,p.Z)({},X3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}w3p.isMDXComponent=!0;const T3p={toc:[]},C3p="wrapper";function g3p(t){let{components:e,...n}=t;return(0,s.kt)(C3p,(0,p.Z)({},T3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}g3p.isMDXComponent=!0;const x3p={toc:[]},v3p="wrapper";function L3p(t){let{components:e,...n}=t;return(0,s.kt)(v3p,(0,p.Z)({},x3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}L3p.isMDXComponent=!0;const Z3p={toc:[]},b3p="wrapper";function N3p(t){let{components:e,...n}=t;return(0,s.kt)(b3p,(0,p.Z)({},Z3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}N3p.isMDXComponent=!0;const z3p={toc:[]},A3p="wrapper";function P3p(t){let{components:e,...n}=t;return(0,s.kt)(A3p,(0,p.Z)({},z3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}P3p.isMDXComponent=!0;const I3p={toc:[]},W3p="wrapper";function R3p(t){let{components:e,...n}=t;return(0,s.kt)(W3p,(0,p.Z)({},I3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}R3p.isMDXComponent=!0;const S3p={toc:[]},B3p="wrapper";function G3p(t){let{components:e,...n}=t;return(0,s.kt)(B3p,(0,p.Z)({},S3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}G3p.isMDXComponent=!0;const E3p={toc:[]},O3p="wrapper";function U3p(t){let{components:e,...n}=t;return(0,s.kt)(O3p,(0,p.Z)({},E3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}U3p.isMDXComponent=!0;const F3p={toc:[]},V3p="wrapper";function q3p(t){let{components:e,...n}=t;return(0,s.kt)(V3p,(0,p.Z)({},F3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}q3p.isMDXComponent=!0;const j3p={toc:[]},H3p="wrapper";function Y3p(t){let{components:e,...n}=t;return(0,s.kt)(H3p,(0,p.Z)({},j3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Y3p.isMDXComponent=!0;const Q3p={toc:[]},$3p="wrapper";function K3p(t){let{components:e,...n}=t;return(0,s.kt)($3p,(0,p.Z)({},Q3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}K3p.isMDXComponent=!0;const J3p={toc:[]},t1p="wrapper";function e1p(t){let{components:e,...n}=t;return(0,s.kt)(t1p,(0,p.Z)({},J3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}e1p.isMDXComponent=!0;const n1p={toc:[]},o1p="wrapper";function p1p(t){let{components:e,...n}=t;return(0,s.kt)(o1p,(0,p.Z)({},n1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}p1p.isMDXComponent=!0;const r1p={toc:[]},s1p="wrapper";function c1p(t){let{components:e,...n}=t;return(0,s.kt)(s1p,(0,p.Z)({},r1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}c1p.isMDXComponent=!0;const a1p={toc:[]},i1p="wrapper";function l1p(t){let{components:e,...n}=t;return(0,s.kt)(i1p,(0,p.Z)({},a1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}l1p.isMDXComponent=!0;const u1p={toc:[]},m1p="wrapper";function d1p(t){let{components:e,...n}=t;return(0,s.kt)(m1p,(0,p.Z)({},u1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}d1p.isMDXComponent=!0;const h1p={toc:[]},f1p="wrapper";function k1p(t){let{components:e,...n}=t;return(0,s.kt)(f1p,(0,p.Z)({},h1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}k1p.isMDXComponent=!0;const y1p={toc:[]},D1p="wrapper";function M1p(t){let{components:e,...n}=t;return(0,s.kt)(D1p,(0,p.Z)({},y1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}M1p.isMDXComponent=!0;const X1p={toc:[]},_1p="wrapper";function w1p(t){let{components:e,...n}=t;return(0,s.kt)(_1p,(0,p.Z)({},X1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}w1p.isMDXComponent=!0;const T1p={toc:[]},C1p="wrapper";function g1p(t){let{components:e,...n}=t;return(0,s.kt)(C1p,(0,p.Z)({},T1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}g1p.isMDXComponent=!0;const x1p={toc:[]},v1p="wrapper";function L1p(t){let{components:e,...n}=t;return(0,s.kt)(v1p,(0,p.Z)({},x1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}L1p.isMDXComponent=!0;const Z1p={toc:[]},b1p="wrapper";function N1p(t){let{components:e,...n}=t;return(0,s.kt)(b1p,(0,p.Z)({},Z1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}N1p.isMDXComponent=!0;const z1p={toc:[]},A1p="wrapper";function P1p(t){let{components:e,...n}=t;return(0,s.kt)(A1p,(0,p.Z)({},z1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}P1p.isMDXComponent=!0;const I1p={toc:[]},W1p="wrapper";function R1p(t){let{components:e,...n}=t;return(0,s.kt)(W1p,(0,p.Z)({},I1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}R1p.isMDXComponent=!0;const S1p={toc:[]},B1p="wrapper";function G1p(t){let{components:e,...n}=t;return(0,s.kt)(B1p,(0,p.Z)({},S1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}G1p.isMDXComponent=!0;const E1p={toc:[]},O1p="wrapper";function U1p(t){let{components:e,...n}=t;return(0,s.kt)(O1p,(0,p.Z)({},E1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}U1p.isMDXComponent=!0;const F1p={toc:[]},V1p="wrapper";function q1p(t){let{components:e,...n}=t;return(0,s.kt)(V1p,(0,p.Z)({},F1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}q1p.isMDXComponent=!0;const j1p={toc:[]},H1p="wrapper";function Y1p(t){let{components:e,...n}=t;return(0,s.kt)(H1p,(0,p.Z)({},j1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Y1p.isMDXComponent=!0;const Q1p={toc:[]},$1p="wrapper";function K1p(t){let{components:e,...n}=t;return(0,s.kt)($1p,(0,p.Z)({},Q1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}K1p.isMDXComponent=!0;const J1p={toc:[]},t8p="wrapper";function e8p(t){let{components:e,...n}=t;return(0,s.kt)(t8p,(0,p.Z)({},J1p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the polygon's corners."))}e8p.isMDXComponent=!0;const n8p={toc:[]},o8p="wrapper";function p8p(t){let{components:e,...n}=t;return(0,s.kt)(o8p,(0,p.Z)({},n8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p8p.isMDXComponent=!0;const r8p={toc:[]},s8p="wrapper";function c8p(t){let{components:e,...n}=t;return(0,s.kt)(s8p,(0,p.Z)({},r8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}c8p.isMDXComponent=!0;const a8p={toc:[]},i8p="wrapper";function l8p(t){let{components:e,...n}=t;return(0,s.kt)(i8p,(0,p.Z)({},a8p,n,{components:e,mdxType:"MDXLayout"}))}l8p.isMDXComponent=!0;const u8p={toc:[]},m8p="wrapper";function d8p(t){let{components:e,...n}=t;return(0,s.kt)(m8p,(0,p.Z)({},u8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}d8p.isMDXComponent=!0;const h8p={toc:[]},f8p="wrapper";function k8p(t){let{components:e,...n}=t;return(0,s.kt)(f8p,(0,p.Z)({},h8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of sides of the polygon."))}k8p.isMDXComponent=!0;const y8p={toc:[]},D8p="wrapper";function M8p(t){let{components:e,...n}=t;return(0,s.kt)(D8p,(0,p.Z)({},y8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}M8p.isMDXComponent=!0;const X8p={toc:[]},_8p="wrapper";function w8p(t){let{components:e,...n}=t;return(0,s.kt)(_8p,(0,p.Z)({},X8p,n,{components:e,mdxType:"MDXLayout"}))}w8p.isMDXComponent=!0;const T8p={toc:[]},C8p="wrapper";function g8p(t){let{components:e,...n}=t;return(0,s.kt)(C8p,(0,p.Z)({},T8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}g8p.isMDXComponent=!0;const x8p={toc:[]},v8p="wrapper";function L8p(t){let{components:e,...n}=t;return(0,s.kt)(v8p,(0,p.Z)({},x8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}L8p.isMDXComponent=!0;const Z8p={toc:[]},b8p="wrapper";function N8p(t){let{components:e,...n}=t;return(0,s.kt)(b8p,(0,p.Z)({},Z8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}N8p.isMDXComponent=!0;const z8p={toc:[]},A8p="wrapper";function P8p(t){let{components:e,...n}=t;return(0,s.kt)(A8p,(0,p.Z)({},z8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}P8p.isMDXComponent=!0;const I8p={toc:[]},W8p="wrapper";function R8p(t){let{components:e,...n}=t;return(0,s.kt)(W8p,(0,p.Z)({},I8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}R8p.isMDXComponent=!0;const S8p={toc:[]},B8p="wrapper";function G8p(t){let{components:e,...n}=t;return(0,s.kt)(B8p,(0,p.Z)({},S8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}G8p.isMDXComponent=!0;const E8p={toc:[]},O8p="wrapper";function U8p(t){let{components:e,...n}=t;return(0,s.kt)(O8p,(0,p.Z)({},E8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}U8p.isMDXComponent=!0;const F8p={toc:[]},V8p="wrapper";function q8p(t){let{components:e,...n}=t;return(0,s.kt)(V8p,(0,p.Z)({},F8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}q8p.isMDXComponent=!0;const j8p={toc:[]},H8p="wrapper";function Y8p(t){let{components:e,...n}=t;return(0,s.kt)(H8p,(0,p.Z)({},j8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y8p.isMDXComponent=!0;const Q8p={toc:[]},$8p="wrapper";function K8p(t){let{components:e,...n}=t;return(0,s.kt)($8p,(0,p.Z)({},Q8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}K8p.isMDXComponent=!0;const J8p={toc:[]},t2p="wrapper";function e2p(t){let{components:e,...n}=t;return(0,s.kt)(t2p,(0,p.Z)({},J8p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}e2p.isMDXComponent=!0;const n2p={toc:[]},o2p="wrapper";function p2p(t){let{components:e,...n}=t;return(0,s.kt)(o2p,(0,p.Z)({},n2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}p2p.isMDXComponent=!0;const r2p={toc:[]},s2p="wrapper";function c2p(t){let{components:e,...n}=t;return(0,s.kt)(s2p,(0,p.Z)({},r2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}c2p.isMDXComponent=!0;const a2p={toc:[]},i2p="wrapper";function l2p(t){let{components:e,...n}=t;return(0,s.kt)(i2p,(0,p.Z)({},a2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}l2p.isMDXComponent=!0;const u2p={toc:[]},m2p="wrapper";function d2p(t){let{components:e,...n}=t;return(0,s.kt)(m2p,(0,p.Z)({},u2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}d2p.isMDXComponent=!0;const h2p={toc:[]},f2p="wrapper";function k2p(t){let{components:e,...n}=t;return(0,s.kt)(f2p,(0,p.Z)({},h2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}k2p.isMDXComponent=!0;const y2p={toc:[]},D2p="wrapper";function M2p(t){let{components:e,...n}=t;return(0,s.kt)(D2p,(0,p.Z)({},y2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}M2p.isMDXComponent=!0;const X2p={toc:[]},_2p="wrapper";function w2p(t){let{components:e,...n}=t;return(0,s.kt)(_2p,(0,p.Z)({},X2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}w2p.isMDXComponent=!0;const T2p={toc:[]},C2p="wrapper";function g2p(t){let{components:e,...n}=t;return(0,s.kt)(C2p,(0,p.Z)({},T2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}g2p.isMDXComponent=!0;const x2p={toc:[]},v2p="wrapper";function L2p(t){let{components:e,...n}=t;return(0,s.kt)(v2p,(0,p.Z)({},x2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}L2p.isMDXComponent=!0;const Z2p={toc:[]},b2p="wrapper";function N2p(t){let{components:e,...n}=t;return(0,s.kt)(b2p,(0,p.Z)({},Z2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}N2p.isMDXComponent=!0;const z2p={toc:[]},A2p="wrapper";function P2p(t){let{components:e,...n}=t;return(0,s.kt)(A2p,(0,p.Z)({},z2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}P2p.isMDXComponent=!0;const I2p={toc:[]},W2p="wrapper";function R2p(t){let{components:e,...n}=t;return(0,s.kt)(W2p,(0,p.Z)({},I2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}R2p.isMDXComponent=!0;const S2p={toc:[]},B2p="wrapper";function G2p(t){let{components:e,...n}=t;return(0,s.kt)(B2p,(0,p.Z)({},S2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}G2p.isMDXComponent=!0;const E2p={toc:[]},O2p="wrapper";function U2p(t){let{components:e,...n}=t;return(0,s.kt)(O2p,(0,p.Z)({},E2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}U2p.isMDXComponent=!0;const F2p={toc:[]},V2p="wrapper";function q2p(t){let{components:e,...n}=t;return(0,s.kt)(V2p,(0,p.Z)({},F2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}q2p.isMDXComponent=!0;const j2p={toc:[]},H2p="wrapper";function Y2p(t){let{components:e,...n}=t;return(0,s.kt)(H2p,(0,p.Z)({},j2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Y2p.isMDXComponent=!0;const Q2p={toc:[]},$2p="wrapper";function K2p(t){let{components:e,...n}=t;return(0,s.kt)($2p,(0,p.Z)({},Q2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}K2p.isMDXComponent=!0;const J2p={toc:[]},t4p="wrapper";function e4p(t){let{components:e,...n}=t;return(0,s.kt)(t4p,(0,p.Z)({},J2p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}e4p.isMDXComponent=!0;const n4p={toc:[]},o4p="wrapper";function p4p(t){let{components:e,...n}=t;return(0,s.kt)(o4p,(0,p.Z)({},n4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}p4p.isMDXComponent=!0;const r4p={toc:[]},s4p="wrapper";function c4p(t){let{components:e,...n}=t;return(0,s.kt)(s4p,(0,p.Z)({},r4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}c4p.isMDXComponent=!0;const a4p={toc:[]},i4p="wrapper";function l4p(t){let{components:e,...n}=t;return(0,s.kt)(i4p,(0,p.Z)({},a4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}l4p.isMDXComponent=!0;const u4p={toc:[]},m4p="wrapper";function d4p(t){let{components:e,...n}=t;return(0,s.kt)(m4p,(0,p.Z)({},u4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}d4p.isMDXComponent=!0;const h4p={toc:[]},f4p="wrapper";function k4p(t){let{components:e,...n}=t;return(0,s.kt)(f4p,(0,p.Z)({},h4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}k4p.isMDXComponent=!0;const y4p={toc:[]},D4p="wrapper";function M4p(t){let{components:e,...n}=t;return(0,s.kt)(D4p,(0,p.Z)({},y4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}M4p.isMDXComponent=!0;const X4p={toc:[]},_4p="wrapper";function w4p(t){let{components:e,...n}=t;return(0,s.kt)(_4p,(0,p.Z)({},X4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}w4p.isMDXComponent=!0;const T4p={toc:[]},C4p="wrapper";function g4p(t){let{components:e,...n}=t;return(0,s.kt)(C4p,(0,p.Z)({},T4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}g4p.isMDXComponent=!0;const x4p={toc:[]},v4p="wrapper";function L4p(t){let{components:e,...n}=t;return(0,s.kt)(v4p,(0,p.Z)({},x4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}L4p.isMDXComponent=!0;const Z4p={toc:[]},b4p="wrapper";function N4p(t){let{components:e,...n}=t;return(0,s.kt)(b4p,(0,p.Z)({},Z4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}N4p.isMDXComponent=!0;const z4p={toc:[]},A4p="wrapper";function P4p(t){let{components:e,...n}=t;return(0,s.kt)(A4p,(0,p.Z)({},z4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}P4p.isMDXComponent=!0;const I4p={toc:[]},W4p="wrapper";function R4p(t){let{components:e,...n}=t;return(0,s.kt)(W4p,(0,p.Z)({},I4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}R4p.isMDXComponent=!0;const S4p={toc:[]},B4p="wrapper";function G4p(t){let{components:e,...n}=t;return(0,s.kt)(B4p,(0,p.Z)({},S4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}G4p.isMDXComponent=!0;const E4p={toc:[]},O4p="wrapper";function U4p(t){let{components:e,...n}=t;return(0,s.kt)(O4p,(0,p.Z)({},E4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}U4p.isMDXComponent=!0;const F4p={toc:[]},V4p="wrapper";function q4p(t){let{components:e,...n}=t;return(0,s.kt)(V4p,(0,p.Z)({},F4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}q4p.isMDXComponent=!0;const j4p={toc:[]},H4p="wrapper";function Y4p(t){let{components:e,...n}=t;return(0,s.kt)(H4p,(0,p.Z)({},j4p,n,{components:e,mdxType:"MDXLayout"}))}Y4p.isMDXComponent=!0;const Q4p={toc:[]},$4p="wrapper";function K4p(t){let{components:e,...n}=t;return(0,s.kt)($4p,(0,p.Z)({},Q4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}K4p.isMDXComponent=!0;const J4p={toc:[]},t6p="wrapper";function e6p(t){let{components:e,...n}=t;return(0,s.kt)(t6p,(0,p.Z)({},J4p,n,{components:e,mdxType:"MDXLayout"}))}e6p.isMDXComponent=!0;const n6p={toc:[]},o6p="wrapper";function p6p(t){let{components:e,...n}=t;return(0,s.kt)(o6p,(0,p.Z)({},n6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}p6p.isMDXComponent=!0;const r6p={toc:[]},s6p="wrapper";function c6p(t){let{components:e,...n}=t;return(0,s.kt)(s6p,(0,p.Z)({},r6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}c6p.isMDXComponent=!0;const a6p={toc:[]},i6p="wrapper";function l6p(t){let{components:e,...n}=t;return(0,s.kt)(i6p,(0,p.Z)({},a6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}l6p.isMDXComponent=!0;const u6p={toc:[]},m6p="wrapper";function d6p(t){let{components:e,...n}=t;return(0,s.kt)(m6p,(0,p.Z)({},u6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}d6p.isMDXComponent=!0;const h6p={toc:[]},f6p="wrapper";function k6p(t){let{components:e,...n}=t;return(0,s.kt)(f6p,(0,p.Z)({},h6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}k6p.isMDXComponent=!0;const y6p={toc:[]},D6p="wrapper";function M6p(t){let{components:e,...n}=t;return(0,s.kt)(D6p,(0,p.Z)({},y6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}M6p.isMDXComponent=!0;const X6p={toc:[]},_6p="wrapper";function w6p(t){let{components:e,...n}=t;return(0,s.kt)(_6p,(0,p.Z)({},X6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w6p.isMDXComponent=!0;const T6p={toc:[]},C6p="wrapper";function g6p(t){let{components:e,...n}=t;return(0,s.kt)(C6p,(0,p.Z)({},T6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}g6p.isMDXComponent=!0;const x6p={toc:[]},v6p="wrapper";function L6p(t){let{components:e,...n}=t;return(0,s.kt)(v6p,(0,p.Z)({},x6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}L6p.isMDXComponent=!0;const Z6p={toc:[]},b6p="wrapper";function N6p(t){let{components:e,...n}=t;return(0,s.kt)(b6p,(0,p.Z)({},Z6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}N6p.isMDXComponent=!0;const z6p={toc:[]},A6p="wrapper";function P6p(t){let{components:e,...n}=t;return(0,s.kt)(A6p,(0,p.Z)({},z6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}P6p.isMDXComponent=!0;const I6p={toc:[]},W6p="wrapper";function R6p(t){let{components:e,...n}=t;return(0,s.kt)(W6p,(0,p.Z)({},I6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}R6p.isMDXComponent=!0;const S6p={toc:[]},B6p="wrapper";function G6p(t){let{components:e,...n}=t;return(0,s.kt)(B6p,(0,p.Z)({},S6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}G6p.isMDXComponent=!0;const E6p={toc:[]},O6p="wrapper";function U6p(t){let{components:e,...n}=t;return(0,s.kt)(O6p,(0,p.Z)({},E6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}U6p.isMDXComponent=!0;const F6p={toc:[]},V6p="wrapper";function q6p(t){let{components:e,...n}=t;return(0,s.kt)(V6p,(0,p.Z)({},F6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q6p.isMDXComponent=!0;const j6p={toc:[]},H6p="wrapper";function Y6p(t){let{components:e,...n}=t;return(0,s.kt)(H6p,(0,p.Z)({},j6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Y6p.isMDXComponent=!0;const Q6p={toc:[]},$6p="wrapper";function K6p(t){let{components:e,...n}=t;return(0,s.kt)($6p,(0,p.Z)({},Q6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K6p.isMDXComponent=!0;const J6p={toc:[]},t5p="wrapper";function e5p(t){let{components:e,...n}=t;return(0,s.kt)(t5p,(0,p.Z)({},J6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}e5p.isMDXComponent=!0;const n5p={toc:[]},o5p="wrapper";function p5p(t){let{components:e,...n}=t;return(0,s.kt)(o5p,(0,p.Z)({},n5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p5p.isMDXComponent=!0;const r5p={toc:[]},s5p="wrapper";function c5p(t){let{components:e,...n}=t;return(0,s.kt)(s5p,(0,p.Z)({},r5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}c5p.isMDXComponent=!0;const a5p={toc:[]},i5p="wrapper";function l5p(t){let{components:e,...n}=t;return(0,s.kt)(i5p,(0,p.Z)({},a5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}l5p.isMDXComponent=!0;const u5p={toc:[]},m5p="wrapper";function d5p(t){let{components:e,...n}=t;return(0,s.kt)(m5p,(0,p.Z)({},u5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}d5p.isMDXComponent=!0;const h5p={toc:[]},f5p="wrapper";function k5p(t){let{components:e,...n}=t;return(0,s.kt)(f5p,(0,p.Z)({},h5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}k5p.isMDXComponent=!0;const y5p={toc:[]},D5p="wrapper";function M5p(t){let{components:e,...n}=t;return(0,s.kt)(D5p,(0,p.Z)({},y5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}M5p.isMDXComponent=!0;const X5p={toc:[]},_5p="wrapper";function w5p(t){let{components:e,...n}=t;return(0,s.kt)(_5p,(0,p.Z)({},X5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}w5p.isMDXComponent=!0;const T5p={toc:[]},C5p="wrapper";function g5p(t){let{components:e,...n}=t;return(0,s.kt)(C5p,(0,p.Z)({},T5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}g5p.isMDXComponent=!0;const x5p={toc:[]},v5p="wrapper";function L5p(t){let{components:e,...n}=t;return(0,s.kt)(v5p,(0,p.Z)({},x5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}L5p.isMDXComponent=!0;const Z5p={toc:[]},b5p="wrapper";function N5p(t){let{components:e,...n}=t;return(0,s.kt)(b5p,(0,p.Z)({},Z5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}N5p.isMDXComponent=!0;const z5p={toc:[]},A5p="wrapper";function P5p(t){let{components:e,...n}=t;return(0,s.kt)(A5p,(0,p.Z)({},z5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}P5p.isMDXComponent=!0;const I5p={toc:[]},W5p="wrapper";function R5p(t){let{components:e,...n}=t;return(0,s.kt)(W5p,(0,p.Z)({},I5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}R5p.isMDXComponent=!0;const S5p={toc:[]},B5p="wrapper";function G5p(t){let{components:e,...n}=t;return(0,s.kt)(B5p,(0,p.Z)({},S5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}G5p.isMDXComponent=!0;const E5p={toc:[]},O5p="wrapper";function U5p(t){let{components:e,...n}=t;return(0,s.kt)(O5p,(0,p.Z)({},E5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}U5p.isMDXComponent=!0;const F5p={toc:[]},V5p="wrapper";function q5p(t){let{components:e,...n}=t;return(0,s.kt)(V5p,(0,p.Z)({},F5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}q5p.isMDXComponent=!0;const j5p={toc:[]},H5p="wrapper";function Y5p(t){let{components:e,...n}=t;return(0,s.kt)(H5p,(0,p.Z)({},j5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Y5p.isMDXComponent=!0;const Q5p={toc:[]},$5p="wrapper";function K5p(t){let{components:e,...n}=t;return(0,s.kt)($5p,(0,p.Z)({},Q5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}K5p.isMDXComponent=!0;const J5p={toc:[]},t7p="wrapper";function e7p(t){let{components:e,...n}=t;return(0,s.kt)(t7p,(0,p.Z)({},J5p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}e7p.isMDXComponent=!0;const n7p={toc:[]},o7p="wrapper";function p7p(t){let{components:e,...n}=t;return(0,s.kt)(o7p,(0,p.Z)({},n7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}p7p.isMDXComponent=!0;const r7p={toc:[]},s7p="wrapper";function c7p(t){let{components:e,...n}=t;return(0,s.kt)(s7p,(0,p.Z)({},r7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}c7p.isMDXComponent=!0;const a7p={toc:[]},i7p="wrapper";function l7p(t){let{components:e,...n}=t;return(0,s.kt)(i7p,(0,p.Z)({},a7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}l7p.isMDXComponent=!0;const u7p={toc:[]},m7p="wrapper";function d7p(t){let{components:e,...n}=t;return(0,s.kt)(m7p,(0,p.Z)({},u7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}d7p.isMDXComponent=!0;const h7p={toc:[]},f7p="wrapper";function k7p(t){let{components:e,...n}=t;return(0,s.kt)(f7p,(0,p.Z)({},h7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}k7p.isMDXComponent=!0;const y7p={toc:[]},D7p="wrapper";function M7p(t){let{components:e,...n}=t;return(0,s.kt)(D7p,(0,p.Z)({},y7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}M7p.isMDXComponent=!0;const X7p={toc:[]},_7p="wrapper";function w7p(t){let{components:e,...n}=t;return(0,s.kt)(_7p,(0,p.Z)({},X7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}w7p.isMDXComponent=!0;const T7p={toc:[]},C7p="wrapper";function g7p(t){let{components:e,...n}=t;return(0,s.kt)(C7p,(0,p.Z)({},T7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}g7p.isMDXComponent=!0;const x7p={toc:[]},v7p="wrapper";function L7p(t){let{components:e,...n}=t;return(0,s.kt)(v7p,(0,p.Z)({},x7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}L7p.isMDXComponent=!0;const Z7p={toc:[]},b7p="wrapper";function N7p(t){let{components:e,...n}=t;return(0,s.kt)(b7p,(0,p.Z)({},Z7p,n,{components:e,mdxType:"MDXLayout"}))}N7p.isMDXComponent=!0;const z7p={toc:[]},A7p="wrapper";function P7p(t){let{components:e,...n}=t;return(0,s.kt)(A7p,(0,p.Z)({},z7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}P7p.isMDXComponent=!0;const I7p={toc:[]},W7p="wrapper";function R7p(t){let{components:e,...n}=t;return(0,s.kt)(W7p,(0,p.Z)({},I7p,n,{components:e,mdxType:"MDXLayout"}))}R7p.isMDXComponent=!0;const S7p={toc:[]},B7p="wrapper";function G7p(t){let{components:e,...n}=t;return(0,s.kt)(B7p,(0,p.Z)({},S7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}G7p.isMDXComponent=!0;const E7p={toc:[]},O7p="wrapper";function U7p(t){let{components:e,...n}=t;return(0,s.kt)(O7p,(0,p.Z)({},E7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}U7p.isMDXComponent=!0;const F7p={toc:[]},V7p="wrapper";function q7p(t){let{components:e,...n}=t;return(0,s.kt)(V7p,(0,p.Z)({},F7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}q7p.isMDXComponent=!0;const j7p={toc:[]},H7p="wrapper";function Y7p(t){let{components:e,...n}=t;return(0,s.kt)(H7p,(0,p.Z)({},j7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Y7p.isMDXComponent=!0;const Q7p={toc:[]},$7p="wrapper";function K7p(t){let{components:e,...n}=t;return(0,s.kt)($7p,(0,p.Z)({},Q7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}K7p.isMDXComponent=!0;const J7p={toc:[]},t9p="wrapper";function e9p(t){let{components:e,...n}=t;return(0,s.kt)(t9p,(0,p.Z)({},J7p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}e9p.isMDXComponent=!0;const n9p={toc:[]},o9p="wrapper";function p9p(t){let{components:e,...n}=t;return(0,s.kt)(o9p,(0,p.Z)({},n9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}p9p.isMDXComponent=!0;const r9p={toc:[]},s9p="wrapper";function c9p(t){let{components:e,...n}=t;return(0,s.kt)(s9p,(0,p.Z)({},r9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}c9p.isMDXComponent=!0;const a9p={toc:[]},i9p="wrapper";function l9p(t){let{components:e,...n}=t;return(0,s.kt)(i9p,(0,p.Z)({},a9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}l9p.isMDXComponent=!0;const u9p={toc:[]},m9p="wrapper";function d9p(t){let{components:e,...n}=t;return(0,s.kt)(m9p,(0,p.Z)({},u9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}d9p.isMDXComponent=!0;const h9p={toc:[]},f9p="wrapper";function k9p(t){let{components:e,...n}=t;return(0,s.kt)(f9p,(0,p.Z)({},h9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}k9p.isMDXComponent=!0;const y9p={toc:[]},D9p="wrapper";function M9p(t){let{components:e,...n}=t;return(0,s.kt)(D9p,(0,p.Z)({},y9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}M9p.isMDXComponent=!0;const X9p={toc:[]},_9p="wrapper";function w9p(t){let{components:e,...n}=t;return(0,s.kt)(_9p,(0,p.Z)({},X9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}w9p.isMDXComponent=!0;const T9p={toc:[]},C9p="wrapper";function g9p(t){let{components:e,...n}=t;return(0,s.kt)(C9p,(0,p.Z)({},T9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}g9p.isMDXComponent=!0;const x9p={toc:[]},v9p="wrapper";function L9p(t){let{components:e,...n}=t;return(0,s.kt)(v9p,(0,p.Z)({},x9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}L9p.isMDXComponent=!0;const Z9p={toc:[]},b9p="wrapper";function N9p(t){let{components:e,...n}=t;return(0,s.kt)(b9p,(0,p.Z)({},Z9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}N9p.isMDXComponent=!0;const z9p={toc:[]},A9p="wrapper";function P9p(t){let{components:e,...n}=t;return(0,s.kt)(A9p,(0,p.Z)({},z9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}P9p.isMDXComponent=!0;const I9p={toc:[]},W9p="wrapper";function R9p(t){let{components:e,...n}=t;return(0,s.kt)(W9p,(0,p.Z)({},I9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}R9p.isMDXComponent=!0;const S9p={toc:[]},B9p="wrapper";function G9p(t){let{components:e,...n}=t;return(0,s.kt)(B9p,(0,p.Z)({},S9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}G9p.isMDXComponent=!0;const E9p={toc:[]},O9p="wrapper";function U9p(t){let{components:e,...n}=t;return(0,s.kt)(O9p,(0,p.Z)({},E9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}U9p.isMDXComponent=!0;const F9p={toc:[]},V9p="wrapper";function q9p(t){let{components:e,...n}=t;return(0,s.kt)(V9p,(0,p.Z)({},F9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}q9p.isMDXComponent=!0;const j9p={toc:[]},H9p="wrapper";function Y9p(t){let{components:e,...n}=t;return(0,s.kt)(H9p,(0,p.Z)({},j9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Y9p.isMDXComponent=!0;const Q9p={toc:[]},$9p="wrapper";function K9p(t){let{components:e,...n}=t;return(0,s.kt)($9p,(0,p.Z)({},Q9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}K9p.isMDXComponent=!0;const J9p={toc:[]},ttr="wrapper";function etr(t){let{components:e,...n}=t;return(0,s.kt)(ttr,(0,p.Z)({},J9p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}etr.isMDXComponent=!0;const ntr={toc:[]},otr="wrapper";function ptr(t){let{components:e,...n}=t;return(0,s.kt)(otr,(0,p.Z)({},ntr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}ptr.isMDXComponent=!0;const rtr={toc:[]},str="wrapper";function ctr(t){let{components:e,...n}=t;return(0,s.kt)(str,(0,p.Z)({},rtr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}ctr.isMDXComponent=!0;const atr={toc:[]},itr="wrapper";function ltr(t){let{components:e,...n}=t;return(0,s.kt)(itr,(0,p.Z)({},atr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}ltr.isMDXComponent=!0;const utr={toc:[]},mtr="wrapper";function dtr(t){let{components:e,...n}=t;return(0,s.kt)(mtr,(0,p.Z)({},utr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}dtr.isMDXComponent=!0;const htr={toc:[]},ftr="wrapper";function ktr(t){let{components:e,...n}=t;return(0,s.kt)(ftr,(0,p.Z)({},htr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}ktr.isMDXComponent=!0;const ytr={toc:[]},Dtr="wrapper";function Mtr(t){let{components:e,...n}=t;return(0,s.kt)(Dtr,(0,p.Z)({},ytr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Mtr.isMDXComponent=!0;const Xtr={toc:[]},_tr="wrapper";function wtr(t){let{components:e,...n}=t;return(0,s.kt)(_tr,(0,p.Z)({},Xtr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wtr.isMDXComponent=!0;const Ttr={toc:[]},Ctr="wrapper";function gtr(t){let{components:e,...n}=t;return(0,s.kt)(Ctr,(0,p.Z)({},Ttr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}gtr.isMDXComponent=!0;const xtr={toc:[]},vtr="wrapper";function Ltr(t){let{components:e,...n}=t;return(0,s.kt)(vtr,(0,p.Z)({},xtr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Ltr.isMDXComponent=!0;const Ztr={toc:[]},btr="wrapper";function Ntr(t){let{components:e,...n}=t;return(0,s.kt)(btr,(0,p.Z)({},Ztr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Ntr.isMDXComponent=!0;const ztr={toc:[]},Atr="wrapper";function Ptr(t){let{components:e,...n}=t;return(0,s.kt)(Atr,(0,p.Z)({},ztr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Ptr.isMDXComponent=!0;const Itr={toc:[]},Wtr="wrapper";function Rtr(t){let{components:e,...n}=t;return(0,s.kt)(Wtr,(0,p.Z)({},Itr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Rtr.isMDXComponent=!0;const Str={toc:[]},Btr="wrapper";function Gtr(t){let{components:e,...n}=t;return(0,s.kt)(Btr,(0,p.Z)({},Str,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Gtr.isMDXComponent=!0;const Etr={toc:[]},Otr="wrapper";function Utr(t){let{components:e,...n}=t;return(0,s.kt)(Otr,(0,p.Z)({},Etr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Utr.isMDXComponent=!0;const Ftr={toc:[]},Vtr="wrapper";function qtr(t){let{components:e,...n}=t;return(0,s.kt)(Vtr,(0,p.Z)({},Ftr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}qtr.isMDXComponent=!0;const jtr={toc:[]},Htr="wrapper";function Ytr(t){let{components:e,...n}=t;return(0,s.kt)(Htr,(0,p.Z)({},jtr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Ytr.isMDXComponent=!0;const Qtr={toc:[]},$tr="wrapper";function Ktr(t){let{components:e,...n}=t;return(0,s.kt)($tr,(0,p.Z)({},Qtr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Ktr.isMDXComponent=!0;const Jtr={toc:[]},ter="wrapper";function eer(t){let{components:e,...n}=t;return(0,s.kt)(ter,(0,p.Z)({},Jtr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eer.isMDXComponent=!0;const ner={toc:[]},oer="wrapper";function per(t){let{components:e,...n}=t;return(0,s.kt)(oer,(0,p.Z)({},ner,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}per.isMDXComponent=!0;const rer={toc:[]},ser="wrapper";function cer(t){let{components:e,...n}=t;return(0,s.kt)(ser,(0,p.Z)({},rer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}cer.isMDXComponent=!0;const aer={toc:[]},ier="wrapper";function ler(t){let{components:e,...n}=t;return(0,s.kt)(ier,(0,p.Z)({},aer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}ler.isMDXComponent=!0;const uer={toc:[]},mer="wrapper";function der(t){let{components:e,...n}=t;return(0,s.kt)(mer,(0,p.Z)({},uer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}der.isMDXComponent=!0;const her={toc:[]},fer="wrapper";function ker(t){let{components:e,...n}=t;return(0,s.kt)(fer,(0,p.Z)({},her,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}ker.isMDXComponent=!0;const yer={toc:[]},Der="wrapper";function Mer(t){let{components:e,...n}=t;return(0,s.kt)(Der,(0,p.Z)({},yer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mer.isMDXComponent=!0;const Xer={toc:[]},_er="wrapper";function wer(t){let{components:e,...n}=t;return(0,s.kt)(_er,(0,p.Z)({},Xer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wer.isMDXComponent=!0;const Ter={toc:[]},Cer="wrapper";function ger(t){let{components:e,...n}=t;return(0,s.kt)(Cer,(0,p.Z)({},Ter,n,{components:e,mdxType:"MDXLayout"}))}ger.isMDXComponent=!0;const xer={toc:[]},ver="wrapper";function Ler(t){let{components:e,...n}=t;return(0,s.kt)(ver,(0,p.Z)({},xer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Ler.isMDXComponent=!0;const Zer={toc:[]},ber="wrapper";function Ner(t){let{components:e,...n}=t;return(0,s.kt)(ber,(0,p.Z)({},Zer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Ner.isMDXComponent=!0;const zer={toc:[]},Aer="wrapper";function Per(t){let{components:e,...n}=t;return(0,s.kt)(Aer,(0,p.Z)({},zer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Per.isMDXComponent=!0;const Ier={toc:[]},Wer="wrapper";function Rer(t){let{components:e,...n}=t;return(0,s.kt)(Wer,(0,p.Z)({},Ier,n,{components:e,mdxType:"MDXLayout"}))}Rer.isMDXComponent=!0;const Ser={toc:[]},Ber="wrapper";function Ger(t){let{components:e,...n}=t;return(0,s.kt)(Ber,(0,p.Z)({},Ser,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ger.isMDXComponent=!0;const Eer={toc:[]},Oer="wrapper";function Uer(t){let{components:e,...n}=t;return(0,s.kt)(Oer,(0,p.Z)({},Eer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Uer.isMDXComponent=!0;const Fer={toc:[]},Ver="wrapper";function qer(t){let{components:e,...n}=t;return(0,s.kt)(Ver,(0,p.Z)({},Fer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qer.isMDXComponent=!0;const jer={toc:[]},Her="wrapper";function Yer(t){let{components:e,...n}=t;return(0,s.kt)(Her,(0,p.Z)({},jer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Yer.isMDXComponent=!0;const Qer={toc:[]},$er="wrapper";function Ker(t){let{components:e,...n}=t;return(0,s.kt)($er,(0,p.Z)({},Qer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ker.isMDXComponent=!0;const Jer={toc:[]},tnr="wrapper";function enr(t){let{components:e,...n}=t;return(0,s.kt)(tnr,(0,p.Z)({},Jer,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}enr.isMDXComponent=!0;const nnr={toc:[]},onr="wrapper";function pnr(t){let{components:e,...n}=t;return(0,s.kt)(onr,(0,p.Z)({},nnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pnr.isMDXComponent=!0;const rnr={toc:[]},snr="wrapper";function cnr(t){let{components:e,...n}=t;return(0,s.kt)(snr,(0,p.Z)({},rnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}cnr.isMDXComponent=!0;const anr={toc:[]},inr="wrapper";function lnr(t){let{components:e,...n}=t;return(0,s.kt)(inr,(0,p.Z)({},anr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lnr.isMDXComponent=!0;const unr={toc:[]},mnr="wrapper";function dnr(t){let{components:e,...n}=t;return(0,s.kt)(mnr,(0,p.Z)({},unr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}dnr.isMDXComponent=!0;const hnr={toc:[]},fnr="wrapper";function knr(t){let{components:e,...n}=t;return(0,s.kt)(fnr,(0,p.Z)({},hnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}knr.isMDXComponent=!0;const ynr={toc:[]},Dnr="wrapper";function Mnr(t){let{components:e,...n}=t;return(0,s.kt)(Dnr,(0,p.Z)({},ynr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Mnr.isMDXComponent=!0;const Xnr={toc:[]},_nr="wrapper";function wnr(t){let{components:e,...n}=t;return(0,s.kt)(_nr,(0,p.Z)({},Xnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG document that contains SVG shapes.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"nodes")," have reference to parent SVG renderer."))}wnr.isMDXComponent=!0;const Tnr={toc:[]},Cnr="wrapper";function gnr(t){let{components:e,...n}=t;return(0,s.kt)(Cnr,(0,p.Z)({},Tnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGDocument.\nThis can used many times because it do not reference parent SVG.\nThis must build into SVGDocument"))}gnr.isMDXComponent=!0;const xnr={toc:[]},vnr="wrapper";function Lnr(t){let{components:e,...n}=t;return(0,s.kt)(vnr,(0,p.Z)({},xnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lnr.isMDXComponent=!0;const Znr={toc:[]},bnr="wrapper";function Nnr(t){let{components:e,...n}=t;return(0,s.kt)(bnr,(0,p.Z)({},Znr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Nnr.isMDXComponent=!0;const znr={toc:[]},Anr="wrapper";function Pnr(t){let{components:e,...n}=t;return(0,s.kt)(Anr,(0,p.Z)({},znr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pnr.isMDXComponent=!0;const Inr={toc:[]},Wnr="wrapper";function Rnr(t){let{components:e,...n}=t;return(0,s.kt)(Wnr,(0,p.Z)({},Inr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Rnr.isMDXComponent=!0;const Snr={toc:[]},Bnr="wrapper";function Gnr(t){let{components:e,...n}=t;return(0,s.kt)(Bnr,(0,p.Z)({},Snr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gnr.isMDXComponent=!0;const Enr={toc:[]},Onr="wrapper";function Unr(t){let{components:e,...n}=t;return(0,s.kt)(Onr,(0,p.Z)({},Enr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Unr.isMDXComponent=!0;const Fnr={toc:[]},Vnr="wrapper";function qnr(t){let{components:e,...n}=t;return(0,s.kt)(Vnr,(0,p.Z)({},Fnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qnr.isMDXComponent=!0;const jnr={toc:[]},Hnr="wrapper";function Ynr(t){let{components:e,...n}=t;return(0,s.kt)(Hnr,(0,p.Z)({},jnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Ynr.isMDXComponent=!0;const Qnr={toc:[]},$nr="wrapper";function Knr(t){let{components:e,...n}=t;return(0,s.kt)($nr,(0,p.Z)({},Qnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Knr.isMDXComponent=!0;const Jnr={toc:[]},tor="wrapper";function eor(t){let{components:e,...n}=t;return(0,s.kt)(tor,(0,p.Z)({},Jnr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}eor.isMDXComponent=!0;const nor={toc:[]},oor="wrapper";function por(t){let{components:e,...n}=t;return(0,s.kt)(oor,(0,p.Z)({},nor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}por.isMDXComponent=!0;const ror={toc:[]},sor="wrapper";function cor(t){let{components:e,...n}=t;return(0,s.kt)(sor,(0,p.Z)({},ror,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cor.isMDXComponent=!0;const aor={toc:[]},ior="wrapper";function lor(t){let{components:e,...n}=t;return(0,s.kt)(ior,(0,p.Z)({},aor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lor.isMDXComponent=!0;const uor={toc:[]},mor="wrapper";function dor(t){let{components:e,...n}=t;return(0,s.kt)(mor,(0,p.Z)({},uor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dor.isMDXComponent=!0;const hor={toc:[]},kor="wrapper";function yor(t){let{components:e,...n}=t;return(0,s.kt)(kor,(0,p.Z)({},hor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}yor.isMDXComponent=!0;const Dor={toc:[]},Mor="wrapper";function Xor(t){let{components:e,...n}=t;return(0,s.kt)(Mor,(0,p.Z)({},Dor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Xor.isMDXComponent=!0;const _or={toc:[]},wor="wrapper";function Tor(t){let{components:e,...n}=t;return(0,s.kt)(wor,(0,p.Z)({},_or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tor.isMDXComponent=!0;const Cor={toc:[]},gor="wrapper";function xor(t){let{components:e,...n}=t;return(0,s.kt)(gor,(0,p.Z)({},Cor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}xor.isMDXComponent=!0;const vor={toc:[]},Lor="wrapper";function Zor(t){let{components:e,...n}=t;return(0,s.kt)(Lor,(0,p.Z)({},vor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Zor.isMDXComponent=!0;const bor={toc:[]},Nor="wrapper";function zor(t){let{components:e,...n}=t;return(0,s.kt)(Nor,(0,p.Z)({},bor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}zor.isMDXComponent=!0;const Aor={toc:[]},Por="wrapper";function Ior(t){let{components:e,...n}=t;return(0,s.kt)(Por,(0,p.Z)({},Aor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ior.isMDXComponent=!0;const Wor={toc:[]},Ror="wrapper";function Sor(t){let{components:e,...n}=t;return(0,s.kt)(Ror,(0,p.Z)({},Wor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Sor.isMDXComponent=!0;const Bor={toc:[]},Gor="wrapper";function Eor(t){let{components:e,...n}=t;return(0,s.kt)(Gor,(0,p.Z)({},Bor,n,{components:e,mdxType:"MDXLayout"}))}Eor.isMDXComponent=!0;const Oor={toc:[]},Uor="wrapper";function For(t){let{components:e,...n}=t;return(0,s.kt)(Uor,(0,p.Z)({},Oor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}For.isMDXComponent=!0;const Vor={toc:[]},qor="wrapper";function jor(t){let{components:e,...n}=t;return(0,s.kt)(qor,(0,p.Z)({},Vor,n,{components:e,mdxType:"MDXLayout"}))}jor.isMDXComponent=!0;const Hor={toc:[]},Yor="wrapper";function Qor(t){let{components:e,...n}=t;return(0,s.kt)(Yor,(0,p.Z)({},Hor,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qor.isMDXComponent=!0;const $or={toc:[]},Kor="wrapper";function Jor(t){let{components:e,...n}=t;return(0,s.kt)(Kor,(0,p.Z)({},$or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Jor.isMDXComponent=!0;const tpr={toc:[]},epr="wrapper";function npr(t){let{components:e,...n}=t;return(0,s.kt)(epr,(0,p.Z)({},tpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}npr.isMDXComponent=!0;const opr={toc:[]},ppr="wrapper";function rpr(t){let{components:e,...n}=t;return(0,s.kt)(ppr,(0,p.Z)({},opr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}rpr.isMDXComponent=!0;const spr={toc:[]},cpr="wrapper";function apr(t){let{components:e,...n}=t;return(0,s.kt)(cpr,(0,p.Z)({},spr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}apr.isMDXComponent=!0;const ipr={toc:[]},lpr="wrapper";function upr(t){let{components:e,...n}=t;return(0,s.kt)(lpr,(0,p.Z)({},ipr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}upr.isMDXComponent=!0;const mpr={toc:[]},dpr="wrapper";function hpr(t){let{components:e,...n}=t;return(0,s.kt)(dpr,(0,p.Z)({},mpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG shape.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"node")," may have reference to parent SVG renderer."))}hpr.isMDXComponent=!0;const fpr={toc:[]},kpr="wrapper";function ypr(t){let{components:e,...n}=t;return(0,s.kt)(kpr,(0,p.Z)({},fpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGShape.\nThis can used many times  because it do not reference parent SVG.\nThis must build into SVGShape"))}ypr.isMDXComponent=!0;const Dpr={toc:[]},Mpr="wrapper";function Xpr(t){let{components:e,...n}=t;return(0,s.kt)(Mpr,(0,p.Z)({},Dpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xpr.isMDXComponent=!0;const _pr={toc:[]},wpr="wrapper";function Tpr(t){let{components:e,...n}=t;return(0,s.kt)(wpr,(0,p.Z)({},_pr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Tpr.isMDXComponent=!0;const Cpr={toc:[]},gpr="wrapper";function xpr(t){let{components:e,...n}=t;return(0,s.kt)(gpr,(0,p.Z)({},Cpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xpr.isMDXComponent=!0;const vpr={toc:[]},Lpr="wrapper";function Zpr(t){let{components:e,...n}=t;return(0,s.kt)(Lpr,(0,p.Z)({},vpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Zpr.isMDXComponent=!0;const bpr={toc:[]},Npr="wrapper";function zpr(t){let{components:e,...n}=t;return(0,s.kt)(Npr,(0,p.Z)({},bpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zpr.isMDXComponent=!0;const Apr={toc:[]},Ppr="wrapper";function Ipr(t){let{components:e,...n}=t;return(0,s.kt)(Ppr,(0,p.Z)({},Apr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ipr.isMDXComponent=!0;const Wpr={toc:[]},Rpr="wrapper";function Spr(t){let{components:e,...n}=t;return(0,s.kt)(Rpr,(0,p.Z)({},Wpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Spr.isMDXComponent=!0;const Bpr={toc:[]},Gpr="wrapper";function Epr(t){let{components:e,...n}=t;return(0,s.kt)(Gpr,(0,p.Z)({},Bpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Epr.isMDXComponent=!0;const Opr={toc:[]},Upr="wrapper";function Fpr(t){let{components:e,...n}=t;return(0,s.kt)(Upr,(0,p.Z)({},Opr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Fpr.isMDXComponent=!0;const Vpr={toc:[]},qpr="wrapper";function jpr(t){let{components:e,...n}=t;return(0,s.kt)(qpr,(0,p.Z)({},Vpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}jpr.isMDXComponent=!0;const Hpr={toc:[]},Ypr="wrapper";function Qpr(t){let{components:e,...n}=t;return(0,s.kt)(Ypr,(0,p.Z)({},Hpr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Qpr.isMDXComponent=!0;const $pr={toc:[]},Kpr="wrapper";function Jpr(t){let{components:e,...n}=t;return(0,s.kt)(Kpr,(0,p.Z)({},$pr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Jpr.isMDXComponent=!0;const trr={toc:[]},err="wrapper";function nrr(t){let{components:e,...n}=t;return(0,s.kt)(err,(0,p.Z)({},trr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}nrr.isMDXComponent=!0;const orr={toc:[]},prr="wrapper";function rrr(t){let{components:e,...n}=t;return(0,s.kt)(prr,(0,p.Z)({},orr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}rrr.isMDXComponent=!0;const srr={toc:[]},crr="wrapper";function arr(t){let{components:e,...n}=t;return(0,s.kt)(crr,(0,p.Z)({},srr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}arr.isMDXComponent=!0;const irr={toc:[]},lrr="wrapper";function urr(t){let{components:e,...n}=t;return(0,s.kt)(lrr,(0,p.Z)({},irr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}urr.isMDXComponent=!0;const mrr={toc:[]},drr="wrapper";function hrr(t){let{components:e,...n}=t;return(0,s.kt)(drr,(0,p.Z)({},mrr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hrr.isMDXComponent=!0;const frr={toc:[]},krr="wrapper";function yrr(t){let{components:e,...n}=t;return(0,s.kt)(krr,(0,p.Z)({},frr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}yrr.isMDXComponent=!0;const Drr={toc:[]},Mrr="wrapper";function Xrr(t){let{components:e,...n}=t;return(0,s.kt)(Mrr,(0,p.Z)({},Drr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Xrr.isMDXComponent=!0;const _rr={toc:[]},wrr="wrapper";function Trr(t){let{components:e,...n}=t;return(0,s.kt)(wrr,(0,p.Z)({},_rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Trr.isMDXComponent=!0;const Crr={toc:[]},grr="wrapper";function xrr(t){let{components:e,...n}=t;return(0,s.kt)(grr,(0,p.Z)({},Crr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xrr.isMDXComponent=!0;const vrr={toc:[]},Lrr="wrapper";function Zrr(t){let{components:e,...n}=t;return(0,s.kt)(Lrr,(0,p.Z)({},vrr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Zrr.isMDXComponent=!0;const brr={toc:[]},Nrr="wrapper";function zrr(t){let{components:e,...n}=t;return(0,s.kt)(Nrr,(0,p.Z)({},brr,n,{components:e,mdxType:"MDXLayout"}))}zrr.isMDXComponent=!0;const Arr={toc:[]},Prr="wrapper";function Irr(t){let{components:e,...n}=t;return(0,s.kt)(Prr,(0,p.Z)({},Arr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Irr.isMDXComponent=!0;const Wrr={toc:[]},Rrr="wrapper";function Srr(t){let{components:e,...n}=t;return(0,s.kt)(Rrr,(0,p.Z)({},Wrr,n,{components:e,mdxType:"MDXLayout"}))}Srr.isMDXComponent=!0;const Brr={toc:[]},Grr="wrapper";function Err(t){let{components:e,...n}=t;return(0,s.kt)(Grr,(0,p.Z)({},Brr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Err.isMDXComponent=!0;const Orr={toc:[]},Urr="wrapper";function Frr(t){let{components:e,...n}=t;return(0,s.kt)(Urr,(0,p.Z)({},Orr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Frr.isMDXComponent=!0;const Vrr={toc:[]},qrr="wrapper";function jrr(t){let{components:e,...n}=t;return(0,s.kt)(qrr,(0,p.Z)({},Vrr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jrr.isMDXComponent=!0;const Hrr={toc:[]},Yrr="wrapper";function Qrr(t){let{components:e,...n}=t;return(0,s.kt)(Yrr,(0,p.Z)({},Hrr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Qrr.isMDXComponent=!0;const $rr={toc:[]},Krr="wrapper";function Jrr(t){let{components:e,...n}=t;return(0,s.kt)(Krr,(0,p.Z)({},$rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Jrr.isMDXComponent=!0;const tsr={toc:[]},esr="wrapper";function nsr(t){let{components:e,...n}=t;return(0,s.kt)(esr,(0,p.Z)({},tsr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}nsr.isMDXComponent=!0;const osr={toc:[]},psr="wrapper";function rsr(t){let{components:e,...n}=t;return(0,s.kt)(psr,(0,p.Z)({},osr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}rsr.isMDXComponent=!0;const ssr={toc:[]},csr="wrapper";function asr(t){let{components:e,...n}=t;return(0,s.kt)(csr,(0,p.Z)({},ssr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}asr.isMDXComponent=!0;const isr={toc:[]},lsr="wrapper";function usr(t){let{components:e,...n}=t;return(0,s.kt)(lsr,(0,p.Z)({},isr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}usr.isMDXComponent=!0;const msr={toc:[]},dsr="wrapper";function hsr(t){let{components:e,...n}=t;return(0,s.kt)(dsr,(0,p.Z)({},msr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}hsr.isMDXComponent=!0;const fsr={toc:[]},ksr="wrapper";function ysr(t){let{components:e,...n}=t;return(0,s.kt)(ksr,(0,p.Z)({},fsr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ysr.isMDXComponent=!0;const Dsr={toc:[]},Msr="wrapper";function Xsr(t){let{components:e,...n}=t;return(0,s.kt)(Msr,(0,p.Z)({},Dsr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Xsr.isMDXComponent=!0;const _sr={toc:[]},wsr="wrapper";function Tsr(t){let{components:e,...n}=t;return(0,s.kt)(wsr,(0,p.Z)({},_sr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tsr.isMDXComponent=!0;const Csr={toc:[]},gsr="wrapper";function xsr(t){let{components:e,...n}=t;return(0,s.kt)(gsr,(0,p.Z)({},Csr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}xsr.isMDXComponent=!0;const vsr={toc:[]},Lsr="wrapper";function Zsr(t){let{components:e,...n}=t;return(0,s.kt)(Lsr,(0,p.Z)({},vsr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Zsr.isMDXComponent=!0;const bsr={toc:[]},Nsr="wrapper";function zsr(t){let{components:e,...n}=t;return(0,s.kt)(Nsr,(0,p.Z)({},bsr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}zsr.isMDXComponent=!0;const Asr={toc:[]},Psr="wrapper";function Isr(t){let{components:e,...n}=t;return(0,s.kt)(Psr,(0,p.Z)({},Asr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Isr.isMDXComponent=!0;const Wsr={toc:[]},Rsr="wrapper";function Ssr(t){let{components:e,...n}=t;return(0,s.kt)(Rsr,(0,p.Z)({},Wsr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Ssr.isMDXComponent=!0;const Bsr={toc:[]},Gsr="wrapper";function Esr(t){let{components:e,...n}=t;return(0,s.kt)(Gsr,(0,p.Z)({},Bsr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Esr.isMDXComponent=!0;const Osr={toc:[]},Usr="wrapper";function Fsr(t){let{components:e,...n}=t;return(0,s.kt)(Usr,(0,p.Z)({},Osr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Fsr.isMDXComponent=!0;const Vsr={toc:[]},qsr="wrapper";function jsr(t){let{components:e,...n}=t;return(0,s.kt)(qsr,(0,p.Z)({},Vsr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}jsr.isMDXComponent=!0;const Hsr={toc:[]},Ysr="wrapper";function Qsr(t){let{components:e,...n}=t;return(0,s.kt)(Ysr,(0,p.Z)({},Hsr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Qsr.isMDXComponent=!0;const $sr={toc:[]},Ksr="wrapper";function Jsr(t){let{components:e,...n}=t;return(0,s.kt)(Ksr,(0,p.Z)({},$sr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Jsr.isMDXComponent=!0;const tcr={toc:[]},ecr="wrapper";function ncr(t){let{components:e,...n}=t;return(0,s.kt)(ecr,(0,p.Z)({},tcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}ncr.isMDXComponent=!0;const ocr={toc:[]},pcr="wrapper";function rcr(t){let{components:e,...n}=t;return(0,s.kt)(pcr,(0,p.Z)({},ocr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}rcr.isMDXComponent=!0;const scr={toc:[]},ccr="wrapper";function acr(t){let{components:e,...n}=t;return(0,s.kt)(ccr,(0,p.Z)({},scr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}acr.isMDXComponent=!0;const icr={toc:[]},lcr="wrapper";function ucr(t){let{components:e,...n}=t;return(0,s.kt)(lcr,(0,p.Z)({},icr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ucr.isMDXComponent=!0;const mcr={toc:[]},dcr="wrapper";function hcr(t){let{components:e,...n}=t;return(0,s.kt)(dcr,(0,p.Z)({},mcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}hcr.isMDXComponent=!0;const fcr={toc:[]},kcr="wrapper";function ycr(t){let{components:e,...n}=t;return(0,s.kt)(kcr,(0,p.Z)({},fcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ycr.isMDXComponent=!0;const Dcr={toc:[]},Mcr="wrapper";function Xcr(t){let{components:e,...n}=t;return(0,s.kt)(Mcr,(0,p.Z)({},Dcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Xcr.isMDXComponent=!0;const _cr={toc:[]},wcr="wrapper";function Tcr(t){let{components:e,...n}=t;return(0,s.kt)(wcr,(0,p.Z)({},_cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Tcr.isMDXComponent=!0;const Ccr={toc:[]},gcr="wrapper";function xcr(t){let{components:e,...n}=t;return(0,s.kt)(gcr,(0,p.Z)({},Ccr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}xcr.isMDXComponent=!0;const vcr={toc:[]},Lcr="wrapper";function Zcr(t){let{components:e,...n}=t;return(0,s.kt)(Lcr,(0,p.Z)({},vcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Zcr.isMDXComponent=!0;const bcr={toc:[]},Ncr="wrapper";function zcr(t){let{components:e,...n}=t;return(0,s.kt)(Ncr,(0,p.Z)({},bcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}zcr.isMDXComponent=!0;const Acr={toc:[]},Pcr="wrapper";function Icr(t){let{components:e,...n}=t;return(0,s.kt)(Pcr,(0,p.Z)({},Acr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Icr.isMDXComponent=!0;const Wcr={toc:[]},Rcr="wrapper";function Scr(t){let{components:e,...n}=t;return(0,s.kt)(Rcr,(0,p.Z)({},Wcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Scr.isMDXComponent=!0;const Bcr={toc:[]},Gcr="wrapper";function Ecr(t){let{components:e,...n}=t;return(0,s.kt)(Gcr,(0,p.Z)({},Bcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."))}Ecr.isMDXComponent=!0;const Ocr={toc:[]},Ucr="wrapper";function Fcr(t){let{components:e,...n}=t;return(0,s.kt)(Ucr,(0,p.Z)({},Ocr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}Fcr.isMDXComponent=!0;const Vcr={toc:[]},qcr="wrapper";function jcr(t){let{components:e,...n}=t;return(0,s.kt)(qcr,(0,p.Z)({},Vcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}jcr.isMDXComponent=!0;const Hcr={toc:[]},Ycr="wrapper";function Qcr(t){let{components:e,...n}=t;return(0,s.kt)(Ycr,(0,p.Z)({},Hcr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Qcr.isMDXComponent=!0;const $cr={toc:[]},Kcr="wrapper";function Jcr(t){let{components:e,...n}=t;return(0,s.kt)(Kcr,(0,p.Z)({},$cr,n,{components:e,mdxType:"MDXLayout"}))}Jcr.isMDXComponent=!0;const tar={toc:[]},ear="wrapper";function nar(t){let{components:e,...n}=t;return(0,s.kt)(ear,(0,p.Z)({},tar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}nar.isMDXComponent=!0;const oar={toc:[]},par="wrapper";function rar(t){let{components:e,...n}=t;return(0,s.kt)(par,(0,p.Z)({},oar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The smoothness of the spline when using auto-calculated handles."))}rar.isMDXComponent=!0;const sar={toc:[]},car="wrapper";function aar(t){let{components:e,...n}=t;return(0,s.kt)(car,(0,p.Z)({},sar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}aar.isMDXComponent=!0;const iar={toc:[]},lar="wrapper";function uar(t){let{components:e,...n}=t;return(0,s.kt)(lar,(0,p.Z)({},iar,n,{components:e,mdxType:"MDXLayout"}))}uar.isMDXComponent=!0;const mar={toc:[]},dar="wrapper";function har(t){let{components:e,...n}=t;return(0,s.kt)(dar,(0,p.Z)({},mar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}har.isMDXComponent=!0;const far={toc:[]},kar="wrapper";function yar(t){let{components:e,...n}=t;return(0,s.kt)(kar,(0,p.Z)({},far,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}yar.isMDXComponent=!0;const Dar={toc:[]},Mar="wrapper";function Xar(t){let{components:e,...n}=t;return(0,s.kt)(Mar,(0,p.Z)({},Dar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Xar.isMDXComponent=!0;const _ar={toc:[]},war="wrapper";function Tar(t){let{components:e,...n}=t;return(0,s.kt)(war,(0,p.Z)({},_ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Tar.isMDXComponent=!0;const Car={toc:[]},gar="wrapper";function xar(t){let{components:e,...n}=t;return(0,s.kt)(gar,(0,p.Z)({},Car,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xar.isMDXComponent=!0;const Lar={toc:[]},Zar="wrapper";function bar(t){let{components:e,...n}=t;return(0,s.kt)(Zar,(0,p.Z)({},Lar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}bar.isMDXComponent=!0;const Nar={toc:[]},zar="wrapper";function Aar(t){let{components:e,...n}=t;return(0,s.kt)(zar,(0,p.Z)({},Nar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Aar.isMDXComponent=!0;const Par={toc:[]},Iar="wrapper";function War(t){let{components:e,...n}=t;return(0,s.kt)(Iar,(0,p.Z)({},Par,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}War.isMDXComponent=!0;const Rar={toc:[]},Sar="wrapper";function Bar(t){let{components:e,...n}=t;return(0,s.kt)(Sar,(0,p.Z)({},Rar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bar.isMDXComponent=!0;const Gar={toc:[]},Ear="wrapper";function Oar(t){let{components:e,...n}=t;return(0,s.kt)(Ear,(0,p.Z)({},Gar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Oar.isMDXComponent=!0;const Uar={toc:[]},Far="wrapper";function Var(t){let{components:e,...n}=t;return(0,s.kt)(Far,(0,p.Z)({},Uar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Var.isMDXComponent=!0;const qar={toc:[]},jar="wrapper";function Har(t){let{components:e,...n}=t;return(0,s.kt)(jar,(0,p.Z)({},qar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Har.isMDXComponent=!0;const Yar={toc:[]},Qar="wrapper";function $ar(t){let{components:e,...n}=t;return(0,s.kt)(Qar,(0,p.Z)({},Yar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$ar.isMDXComponent=!0;const Kar={toc:[]},Jar="wrapper";function tir(t){let{components:e,...n}=t;return(0,s.kt)(Jar,(0,p.Z)({},Kar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}tir.isMDXComponent=!0;const eir={toc:[]},nir="wrapper";function oir(t){let{components:e,...n}=t;return(0,s.kt)(nir,(0,p.Z)({},eir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}oir.isMDXComponent=!0;const pir={toc:[]},rir="wrapper";function sir(t){let{components:e,...n}=t;return(0,s.kt)(rir,(0,p.Z)({},pir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}sir.isMDXComponent=!0;const cir={toc:[]},air="wrapper";function iir(t){let{components:e,...n}=t;return(0,s.kt)(air,(0,p.Z)({},cir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iir.isMDXComponent=!0;const lir={toc:[]},uir="wrapper";function mir(t){let{components:e,...n}=t;return(0,s.kt)(uir,(0,p.Z)({},lir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}mir.isMDXComponent=!0;const dir={toc:[]},hir="wrapper";function fir(t){let{components:e,...n}=t;return(0,s.kt)(hir,(0,p.Z)({},dir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}fir.isMDXComponent=!0;const kir={toc:[]},yir="wrapper";function Dir(t){let{components:e,...n}=t;return(0,s.kt)(yir,(0,p.Z)({},kir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Dir.isMDXComponent=!0;const Mir={toc:[]},Xir="wrapper";function _ir(t){let{components:e,...n}=t;return(0,s.kt)(Xir,(0,p.Z)({},Mir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}_ir.isMDXComponent=!0;const wir={toc:[]},Tir="wrapper";function Cir(t){let{components:e,...n}=t;return(0,s.kt)(Tir,(0,p.Z)({},wir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Cir.isMDXComponent=!0;const gir={toc:[]},xir="wrapper";function vir(t){let{components:e,...n}=t;return(0,s.kt)(xir,(0,p.Z)({},gir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}vir.isMDXComponent=!0;const Lir={toc:[]},Zir="wrapper";function bir(t){let{components:e,...n}=t;return(0,s.kt)(Zir,(0,p.Z)({},Lir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}bir.isMDXComponent=!0;const Nir={toc:[]},zir="wrapper";function Air(t){let{components:e,...n}=t;return(0,s.kt)(zir,(0,p.Z)({},Nir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Air.isMDXComponent=!0;const Pir={toc:[]},Iir="wrapper";function Wir(t){let{components:e,...n}=t;return(0,s.kt)(Iir,(0,p.Z)({},Pir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Wir.isMDXComponent=!0;const Rir={toc:[]},Sir="wrapper";function Bir(t){let{components:e,...n}=t;return(0,s.kt)(Sir,(0,p.Z)({},Rir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Bir.isMDXComponent=!0;const Gir={toc:[]},Eir="wrapper";function Oir(t){let{components:e,...n}=t;return(0,s.kt)(Eir,(0,p.Z)({},Gir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Oir.isMDXComponent=!0;const Uir={toc:[]},Fir="wrapper";function Vir(t){let{components:e,...n}=t;return(0,s.kt)(Fir,(0,p.Z)({},Uir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vir.isMDXComponent=!0;const qir={toc:[]},jir="wrapper";function Hir(t){let{components:e,...n}=t;return(0,s.kt)(jir,(0,p.Z)({},qir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Hir.isMDXComponent=!0;const Yir={toc:[]},Qir="wrapper";function $ir(t){let{components:e,...n}=t;return(0,s.kt)(Qir,(0,p.Z)({},Yir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}$ir.isMDXComponent=!0;const Kir={toc:[]},Jir="wrapper";function tlr(t){let{components:e,...n}=t;return(0,s.kt)(Jir,(0,p.Z)({},Kir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}tlr.isMDXComponent=!0;const elr={toc:[]},nlr="wrapper";function olr(t){let{components:e,...n}=t;return(0,s.kt)(nlr,(0,p.Z)({},elr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}olr.isMDXComponent=!0;const plr={toc:[]},rlr="wrapper";function slr(t){let{components:e,...n}=t;return(0,s.kt)(rlr,(0,p.Z)({},plr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}slr.isMDXComponent=!0;const clr={toc:[]},alr="wrapper";function ilr(t){let{components:e,...n}=t;return(0,s.kt)(alr,(0,p.Z)({},clr,n,{components:e,mdxType:"MDXLayout"}))}ilr.isMDXComponent=!0;const llr={toc:[]},ulr="wrapper";function mlr(t){let{components:e,...n}=t;return(0,s.kt)(ulr,(0,p.Z)({},llr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}mlr.isMDXComponent=!0;const dlr={toc:[]},hlr="wrapper";function flr(t){let{components:e,...n}=t;return(0,s.kt)(hlr,(0,p.Z)({},dlr,n,{components:e,mdxType:"MDXLayout"}))}flr.isMDXComponent=!0;const klr={toc:[]},ylr="wrapper";function Dlr(t){let{components:e,...n}=t;return(0,s.kt)(ylr,(0,p.Z)({},klr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dlr.isMDXComponent=!0;const Mlr={toc:[]},Xlr="wrapper";function _lr(t){let{components:e,...n}=t;return(0,s.kt)(Xlr,(0,p.Z)({},Mlr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}_lr.isMDXComponent=!0;const wlr={toc:[]},Tlr="wrapper";function Clr(t){let{components:e,...n}=t;return(0,s.kt)(Tlr,(0,p.Z)({},wlr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Clr.isMDXComponent=!0;const glr={toc:[]},xlr="wrapper";function vlr(t){let{components:e,...n}=t;return(0,s.kt)(xlr,(0,p.Z)({},glr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}vlr.isMDXComponent=!0;const Llr={toc:[]},Zlr="wrapper";function blr(t){let{components:e,...n}=t;return(0,s.kt)(Zlr,(0,p.Z)({},Llr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}blr.isMDXComponent=!0;const Nlr={toc:[]},zlr="wrapper";function Alr(t){let{components:e,...n}=t;return(0,s.kt)(zlr,(0,p.Z)({},Nlr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Alr.isMDXComponent=!0;const Plr={toc:[]},Ilr="wrapper";function Wlr(t){let{components:e,...n}=t;return(0,s.kt)(Ilr,(0,p.Z)({},Plr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Wlr.isMDXComponent=!0;const Rlr={toc:[]},Slr="wrapper";function Blr(t){let{components:e,...n}=t;return(0,s.kt)(Slr,(0,p.Z)({},Rlr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}Blr.isMDXComponent=!0;const Glr={toc:[]},Elr="wrapper";function Olr(t){let{components:e,...n}=t;return(0,s.kt)(Elr,(0,p.Z)({},Glr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Olr.isMDXComponent=!0;const Ulr={toc:[]},Flr="wrapper";function Vlr(t){let{components:e,...n}=t;return(0,s.kt)(Flr,(0,p.Z)({},Ulr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Vlr.isMDXComponent=!0;const qlr={toc:[]},jlr="wrapper";function Hlr(t){let{components:e,...n}=t;return(0,s.kt)(jlr,(0,p.Z)({},qlr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hlr.isMDXComponent=!0;const Ylr={toc:[]},Qlr="wrapper";function $lr(t){let{components:e,...n}=t;return(0,s.kt)(Qlr,(0,p.Z)({},Ylr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}$lr.isMDXComponent=!0;const Klr={toc:[]},Jlr="wrapper";function tur(t){let{components:e,...n}=t;return(0,s.kt)(Jlr,(0,p.Z)({},Klr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tur.isMDXComponent=!0;const eur={toc:[]},nur="wrapper";function our(t){let{components:e,...n}=t;return(0,s.kt)(nur,(0,p.Z)({},eur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}our.isMDXComponent=!0;const pur={toc:[]},rur="wrapper";function sur(t){let{components:e,...n}=t;return(0,s.kt)(rur,(0,p.Z)({},pur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sur.isMDXComponent=!0;const cur={toc:[]},aur="wrapper";function iur(t){let{components:e,...n}=t;return(0,s.kt)(aur,(0,p.Z)({},cur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}iur.isMDXComponent=!0;const lur={toc:[]},uur="wrapper";function mur(t){let{components:e,...n}=t;return(0,s.kt)(uur,(0,p.Z)({},lur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}mur.isMDXComponent=!0;const dur={toc:[]},hur="wrapper";function fur(t){let{components:e,...n}=t;return(0,s.kt)(hur,(0,p.Z)({},dur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}fur.isMDXComponent=!0;const kur={toc:[]},yur="wrapper";function Dur(t){let{components:e,...n}=t;return(0,s.kt)(yur,(0,p.Z)({},kur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Dur.isMDXComponent=!0;const Mur={toc:[]},Xur="wrapper";function _ur(t){let{components:e,...n}=t;return(0,s.kt)(Xur,(0,p.Z)({},Mur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}_ur.isMDXComponent=!0;const wur={toc:[]},Tur="wrapper";function Cur(t){let{components:e,...n}=t;return(0,s.kt)(Tur,(0,p.Z)({},wur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Cur.isMDXComponent=!0;const gur={toc:[]},xur="wrapper";function vur(t){let{components:e,...n}=t;return(0,s.kt)(xur,(0,p.Z)({},gur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}vur.isMDXComponent=!0;const Lur={toc:[]},Zur="wrapper";function bur(t){let{components:e,...n}=t;return(0,s.kt)(Zur,(0,p.Z)({},Lur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}bur.isMDXComponent=!0;const Nur={toc:[]},zur="wrapper";function Aur(t){let{components:e,...n}=t;return(0,s.kt)(zur,(0,p.Z)({},Nur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Aur.isMDXComponent=!0;const Pur={toc:[]},Iur="wrapper";function Wur(t){let{components:e,...n}=t;return(0,s.kt)(Iur,(0,p.Z)({},Pur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Wur.isMDXComponent=!0;const Rur={toc:[]},Sur="wrapper";function Bur(t){let{components:e,...n}=t;return(0,s.kt)(Sur,(0,p.Z)({},Rur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Bur.isMDXComponent=!0;const Gur={toc:[]},Eur="wrapper";function Our(t){let{components:e,...n}=t;return(0,s.kt)(Eur,(0,p.Z)({},Gur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Our.isMDXComponent=!0;const Uur={toc:[]},Fur="wrapper";function Vur(t){let{components:e,...n}=t;return(0,s.kt)(Fur,(0,p.Z)({},Uur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Vur.isMDXComponent=!0;const qur={toc:[]},jur="wrapper";function Hur(t){let{components:e,...n}=t;return(0,s.kt)(jur,(0,p.Z)({},qur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Hur.isMDXComponent=!0;const Yur={toc:[]},Qur="wrapper";function $ur(t){let{components:e,...n}=t;return(0,s.kt)(Qur,(0,p.Z)({},Yur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}$ur.isMDXComponent=!0;const Kur={toc:[]},Jur="wrapper";function tmr(t){let{components:e,...n}=t;return(0,s.kt)(Jur,(0,p.Z)({},Kur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}tmr.isMDXComponent=!0;const emr={toc:[]},nmr="wrapper";function omr(t){let{components:e,...n}=t;return(0,s.kt)(nmr,(0,p.Z)({},emr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}omr.isMDXComponent=!0;const pmr={toc:[]},rmr="wrapper";function smr(t){let{components:e,...n}=t;return(0,s.kt)(rmr,(0,p.Z)({},pmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}smr.isMDXComponent=!0;const cmr={toc:[]},amr="wrapper";function imr(t){let{components:e,...n}=t;return(0,s.kt)(amr,(0,p.Z)({},cmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}imr.isMDXComponent=!0;const lmr={toc:[]},umr="wrapper";function mmr(t){let{components:e,...n}=t;return(0,s.kt)(umr,(0,p.Z)({},lmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}mmr.isMDXComponent=!0;const dmr={toc:[]},hmr="wrapper";function fmr(t){let{components:e,...n}=t;return(0,s.kt)(hmr,(0,p.Z)({},dmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}fmr.isMDXComponent=!0;const kmr={toc:[]},ymr="wrapper";function Dmr(t){let{components:e,...n}=t;return(0,s.kt)(ymr,(0,p.Z)({},kmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dmr.isMDXComponent=!0;const Mmr={toc:[]},Xmr="wrapper";function _mr(t){let{components:e,...n}=t;return(0,s.kt)(Xmr,(0,p.Z)({},Mmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}_mr.isMDXComponent=!0;const wmr={toc:[]},Tmr="wrapper";function Cmr(t){let{components:e,...n}=t;return(0,s.kt)(Tmr,(0,p.Z)({},wmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}Cmr.isMDXComponent=!0;const gmr={toc:[]},xmr="wrapper";function vmr(t){let{components:e,...n}=t;return(0,s.kt)(xmr,(0,p.Z)({},gmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}vmr.isMDXComponent=!0;const Lmr={toc:[]},Zmr="wrapper";function bmr(t){let{components:e,...n}=t;return(0,s.kt)(Zmr,(0,p.Z)({},Lmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}bmr.isMDXComponent=!0;const Nmr={toc:[]},zmr="wrapper";function Amr(t){let{components:e,...n}=t;return(0,s.kt)(zmr,(0,p.Z)({},Nmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rate at which the video plays, as multiples of the normal speed."))}Amr.isMDXComponent=!0;const Pmr={toc:[]},Imr="wrapper";function Wmr(t){let{components:e,...n}=t;return(0,s.kt)(Imr,(0,p.Z)({},Pmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Wmr.isMDXComponent=!0;const Rmr={toc:[]},Smr="wrapper";function Bmr(t){let{components:e,...n}=t;return(0,s.kt)(Smr,(0,p.Z)({},Rmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Bmr.isMDXComponent=!0;const Gmr={toc:[]},Emr="wrapper";function Omr(t){let{components:e,...n}=t;return(0,s.kt)(Emr,(0,p.Z)({},Gmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Omr.isMDXComponent=!0;const Umr={toc:[]},Fmr="wrapper";function Vmr(t){let{components:e,...n}=t;return(0,s.kt)(Fmr,(0,p.Z)({},Umr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Vmr.isMDXComponent=!0;const qmr={toc:[]},jmr="wrapper";function Hmr(t){let{components:e,...n}=t;return(0,s.kt)(jmr,(0,p.Z)({},qmr,n,{components:e,mdxType:"MDXLayout"}))}Hmr.isMDXComponent=!0;const Ymr={toc:[]},Qmr="wrapper";function $mr(t){let{components:e,...n}=t;return(0,s.kt)(Qmr,(0,p.Z)({},Ymr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}$mr.isMDXComponent=!0;const Kmr={toc:[]},Jmr="wrapper";function tdr(t){let{components:e,...n}=t;return(0,s.kt)(Jmr,(0,p.Z)({},Kmr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}tdr.isMDXComponent=!0;const edr={toc:[]},ndr="wrapper";function odr(t){let{components:e,...n}=t;return(0,s.kt)(ndr,(0,p.Z)({},edr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}odr.isMDXComponent=!0;const pdr={toc:[]},rdr="wrapper";function sdr(t){let{components:e,...n}=t;return(0,s.kt)(rdr,(0,p.Z)({},pdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}sdr.isMDXComponent=!0;const cdr={toc:[]},adr="wrapper";function idr(t){let{components:e,...n}=t;return(0,s.kt)(adr,(0,p.Z)({},cdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}idr.isMDXComponent=!0;const ldr={toc:[]},udr="wrapper";function mdr(t){let{components:e,...n}=t;return(0,s.kt)(udr,(0,p.Z)({},ldr,n,{components:e,mdxType:"MDXLayout"}))}mdr.isMDXComponent=!0;const ddr={toc:[]},hdr="wrapper";function fdr(t){let{components:e,...n}=t;return(0,s.kt)(hdr,(0,p.Z)({},ddr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}fdr.isMDXComponent=!0;const kdr={toc:[]},ydr="wrapper";function Ddr(t){let{components:e,...n}=t;return(0,s.kt)(ydr,(0,p.Z)({},kdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ddr.isMDXComponent=!0;const Mdr={toc:[]},Xdr="wrapper";function _dr(t){let{components:e,...n}=t;return(0,s.kt)(Xdr,(0,p.Z)({},Mdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}_dr.isMDXComponent=!0;const wdr={toc:[]},Tdr="wrapper";function Cdr(t){let{components:e,...n}=t;return(0,s.kt)(Tdr,(0,p.Z)({},wdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Cdr.isMDXComponent=!0;const gdr={toc:[]},xdr="wrapper";function vdr(t){let{components:e,...n}=t;return(0,s.kt)(xdr,(0,p.Z)({},gdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}vdr.isMDXComponent=!0;const Ldr={toc:[]},Zdr="wrapper";function bdr(t){let{components:e,...n}=t;return(0,s.kt)(Zdr,(0,p.Z)({},Ldr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}bdr.isMDXComponent=!0;const Ndr={toc:[]},zdr="wrapper";function Adr(t){let{components:e,...n}=t;return(0,s.kt)(zdr,(0,p.Z)({},Ndr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Adr.isMDXComponent=!0;const Pdr={toc:[]},Idr="wrapper";function Wdr(t){let{components:e,...n}=t;return(0,s.kt)(Idr,(0,p.Z)({},Pdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}Wdr.isMDXComponent=!0;const Rdr={toc:[]},Sdr="wrapper";function Bdr(t){let{components:e,...n}=t;return(0,s.kt)(Sdr,(0,p.Z)({},Rdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bdr.isMDXComponent=!0;const Gdr={toc:[]},Edr="wrapper";function Odr(t){let{components:e,...n}=t;return(0,s.kt)(Edr,(0,p.Z)({},Gdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Odr.isMDXComponent=!0;const Udr={toc:[]},Fdr="wrapper";function Vdr(t){let{components:e,...n}=t;return(0,s.kt)(Fdr,(0,p.Z)({},Udr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vdr.isMDXComponent=!0;const qdr={toc:[]},jdr="wrapper";function Hdr(t){let{components:e,...n}=t;return(0,s.kt)(jdr,(0,p.Z)({},qdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Hdr.isMDXComponent=!0;const Ydr={toc:[]},Qdr="wrapper";function $dr(t){let{components:e,...n}=t;return(0,s.kt)(Qdr,(0,p.Z)({},Ydr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$dr.isMDXComponent=!0;const Kdr={toc:[]},Jdr="wrapper";function thr(t){let{components:e,...n}=t;return(0,s.kt)(Jdr,(0,p.Z)({},Kdr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}thr.isMDXComponent=!0;const ehr={toc:[]},nhr="wrapper";function ohr(t){let{components:e,...n}=t;return(0,s.kt)(nhr,(0,p.Z)({},ehr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}ohr.isMDXComponent=!0;const phr={toc:[]},rhr="wrapper";function shr(t){let{components:e,...n}=t;return(0,s.kt)(rhr,(0,p.Z)({},phr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}shr.isMDXComponent=!0;const chr={toc:[]},ahr="wrapper";function ihr(t){let{components:e,...n}=t;return(0,s.kt)(ahr,(0,p.Z)({},chr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ihr.isMDXComponent=!0;const lhr={toc:[]},uhr="wrapper";function mhr(t){let{components:e,...n}=t;return(0,s.kt)(uhr,(0,p.Z)({},lhr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mhr.isMDXComponent=!0;const dhr={toc:[]},hhr="wrapper";function fhr(t){let{components:e,...n}=t;return(0,s.kt)(hhr,(0,p.Z)({},dhr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fhr.isMDXComponent=!0;const khr={toc:[]},yhr="wrapper";function Dhr(t){let{components:e,...n}=t;return(0,s.kt)(yhr,(0,p.Z)({},khr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Dhr.isMDXComponent=!0;const Mhr={toc:[]},Xhr="wrapper";function _hr(t){let{components:e,...n}=t;return(0,s.kt)(Xhr,(0,p.Z)({},Mhr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_hr.isMDXComponent=!0;const whr={toc:[]},Thr="wrapper";function Chr(t){let{components:e,...n}=t;return(0,s.kt)(Thr,(0,p.Z)({},whr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Chr.isMDXComponent=!0;const ghr={toc:[]},xhr="wrapper";function vhr(t){let{components:e,...n}=t;return(0,s.kt)(xhr,(0,p.Z)({},ghr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}vhr.isMDXComponent=!0;const Lhr={toc:[]},Zhr="wrapper";function bhr(t){let{components:e,...n}=t;return(0,s.kt)(Zhr,(0,p.Z)({},Lhr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}bhr.isMDXComponent=!0;const Nhr={toc:[]},zhr="wrapper";function Ahr(t){let{components:e,...n}=t;return(0,s.kt)(zhr,(0,p.Z)({},Nhr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Ahr.isMDXComponent=!0;const Phr={toc:[]},Ihr="wrapper";function Whr(t){let{components:e,...n}=t;return(0,s.kt)(Ihr,(0,p.Z)({},Phr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Whr.isMDXComponent=!0;const Rhr={toc:[]},Shr="wrapper";function Bhr(t){let{components:e,...n}=t;return(0,s.kt)(Shr,(0,p.Z)({},Rhr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Bhr.isMDXComponent=!0;const Ghr={toc:[]},Ehr="wrapper";function Ohr(t){let{components:e,...n}=t;return(0,s.kt)(Ehr,(0,p.Z)({},Ghr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Ohr.isMDXComponent=!0;const Uhr={toc:[]},Fhr="wrapper";function Vhr(t){let{components:e,...n}=t;return(0,s.kt)(Fhr,(0,p.Z)({},Uhr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Vhr.isMDXComponent=!0;const qhr={toc:[]},jhr="wrapper";function Hhr(t){let{components:e,...n}=t;return(0,s.kt)(jhr,(0,p.Z)({},qhr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Hhr.isMDXComponent=!0;const Yhr={toc:[]},Qhr="wrapper";function $hr(t){let{components:e,...n}=t;return(0,s.kt)(Qhr,(0,p.Z)({},Yhr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$hr.isMDXComponent=!0;const Khr={toc:[]},Jhr="wrapper";function tfr(t){let{components:e,...n}=t;return(0,s.kt)(Jhr,(0,p.Z)({},Khr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}tfr.isMDXComponent=!0;const efr={toc:[]},nfr="wrapper";function ofr(t){let{components:e,...n}=t;return(0,s.kt)(nfr,(0,p.Z)({},efr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ofr.isMDXComponent=!0;const pfr={toc:[]},rfr="wrapper";function sfr(t){let{components:e,...n}=t;return(0,s.kt)(rfr,(0,p.Z)({},pfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}sfr.isMDXComponent=!0;const cfr={toc:[]},afr="wrapper";function ifr(t){let{components:e,...n}=t;return(0,s.kt)(afr,(0,p.Z)({},cfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ifr.isMDXComponent=!0;const lfr={toc:[]},ufr="wrapper";function mfr(t){let{components:e,...n}=t;return(0,s.kt)(ufr,(0,p.Z)({},lfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mfr.isMDXComponent=!0;const dfr={toc:[]},hfr="wrapper";function ffr(t){let{components:e,...n}=t;return(0,s.kt)(hfr,(0,p.Z)({},dfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ffr.isMDXComponent=!0;const kfr={toc:[]},yfr="wrapper";function Dfr(t){let{components:e,...n}=t;return(0,s.kt)(yfr,(0,p.Z)({},kfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Dfr.isMDXComponent=!0;const Mfr={toc:[]},Xfr="wrapper";function _fr(t){let{components:e,...n}=t;return(0,s.kt)(Xfr,(0,p.Z)({},Mfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_fr.isMDXComponent=!0;const wfr={toc:[]},Tfr="wrapper";function Cfr(t){let{components:e,...n}=t;return(0,s.kt)(Tfr,(0,p.Z)({},wfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Cfr.isMDXComponent=!0;const gfr={toc:[]},xfr="wrapper";function vfr(t){let{components:e,...n}=t;return(0,s.kt)(xfr,(0,p.Z)({},gfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}vfr.isMDXComponent=!0;const Lfr={toc:[]},Zfr="wrapper";function bfr(t){let{components:e,...n}=t;return(0,s.kt)(Zfr,(0,p.Z)({},Lfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}bfr.isMDXComponent=!0;const Nfr={toc:[]},zfr="wrapper";function Afr(t){let{components:e,...n}=t;return(0,s.kt)(zfr,(0,p.Z)({},Nfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Afr.isMDXComponent=!0;const Pfr={toc:[]},Ifr="wrapper";function Wfr(t){let{components:e,...n}=t;return(0,s.kt)(Ifr,(0,p.Z)({},Pfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wfr.isMDXComponent=!0;const Rfr={toc:[]},Sfr="wrapper";function Bfr(t){let{components:e,...n}=t;return(0,s.kt)(Sfr,(0,p.Z)({},Rfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Bfr.isMDXComponent=!0;const Gfr={toc:[]},Efr="wrapper";function Ofr(t){let{components:e,...n}=t;return(0,s.kt)(Efr,(0,p.Z)({},Gfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Ofr.isMDXComponent=!0;const Ufr={toc:[]},Ffr="wrapper";function Vfr(t){let{components:e,...n}=t;return(0,s.kt)(Ffr,(0,p.Z)({},Ufr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Vfr.isMDXComponent=!0;const qfr={toc:[]},jfr="wrapper";function Hfr(t){let{components:e,...n}=t;return(0,s.kt)(jfr,(0,p.Z)({},qfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Hfr.isMDXComponent=!0;const Yfr={toc:[]},Qfr="wrapper";function $fr(t){let{components:e,...n}=t;return(0,s.kt)(Qfr,(0,p.Z)({},Yfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$fr.isMDXComponent=!0;const Kfr={toc:[]},Jfr="wrapper";function tkr(t){let{components:e,...n}=t;return(0,s.kt)(Jfr,(0,p.Z)({},Kfr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tkr.isMDXComponent=!0;const ekr={toc:[]},nkr="wrapper";function okr(t){let{components:e,...n}=t;return(0,s.kt)(nkr,(0,p.Z)({},ekr,n,{components:e,mdxType:"MDXLayout"}))}okr.isMDXComponent=!0;const pkr={toc:[]},rkr="wrapper";function skr(t){let{components:e,...n}=t;return(0,s.kt)(rkr,(0,p.Z)({},pkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}skr.isMDXComponent=!0;const ckr={toc:[]},akr="wrapper";function ikr(t){let{components:e,...n}=t;return(0,s.kt)(akr,(0,p.Z)({},ckr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}ikr.isMDXComponent=!0;const lkr={toc:[]},ukr="wrapper";function mkr(t){let{components:e,...n}=t;return(0,s.kt)(ukr,(0,p.Z)({},lkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}mkr.isMDXComponent=!0;const dkr={toc:[]},hkr="wrapper";function fkr(t){let{components:e,...n}=t;return(0,s.kt)(hkr,(0,p.Z)({},dkr,n,{components:e,mdxType:"MDXLayout"}))}fkr.isMDXComponent=!0;const kkr={toc:[]},ykr="wrapper";function Dkr(t){let{components:e,...n}=t;return(0,s.kt)(ykr,(0,p.Z)({},kkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Dkr.isMDXComponent=!0;const Mkr={toc:[]},Xkr="wrapper";function _kr(t){let{components:e,...n}=t;return(0,s.kt)(Xkr,(0,p.Z)({},Mkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}_kr.isMDXComponent=!0;const wkr={toc:[]},Tkr="wrapper";function Ckr(t){let{components:e,...n}=t;return(0,s.kt)(Tkr,(0,p.Z)({},wkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ckr.isMDXComponent=!0;const gkr={toc:[]},xkr="wrapper";function vkr(t){let{components:e,...n}=t;return(0,s.kt)(xkr,(0,p.Z)({},gkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}vkr.isMDXComponent=!0;const Lkr={toc:[]},Zkr="wrapper";function bkr(t){let{components:e,...n}=t;return(0,s.kt)(Zkr,(0,p.Z)({},Lkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}bkr.isMDXComponent=!0;const Nkr={toc:[]},zkr="wrapper";function Akr(t){let{components:e,...n}=t;return(0,s.kt)(zkr,(0,p.Z)({},Nkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Akr.isMDXComponent=!0;const Pkr={toc:[]},Ikr="wrapper";function Wkr(t){let{components:e,...n}=t;return(0,s.kt)(Ikr,(0,p.Z)({},Pkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wkr.isMDXComponent=!0;const Rkr={toc:[]},Skr="wrapper";function Bkr(t){let{components:e,...n}=t;return(0,s.kt)(Skr,(0,p.Z)({},Rkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Bkr.isMDXComponent=!0;const Gkr={toc:[]},Ekr="wrapper";function Okr(t){let{components:e,...n}=t;return(0,s.kt)(Ekr,(0,p.Z)({},Gkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Okr.isMDXComponent=!0;const Ukr={toc:[]},Fkr="wrapper";function Vkr(t){let{components:e,...n}=t;return(0,s.kt)(Fkr,(0,p.Z)({},Ukr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Vkr.isMDXComponent=!0;const qkr={toc:[]},jkr="wrapper";function Hkr(t){let{components:e,...n}=t;return(0,s.kt)(jkr,(0,p.Z)({},qkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hkr.isMDXComponent=!0;const Ykr={toc:[]},Qkr="wrapper";function $kr(t){let{components:e,...n}=t;return(0,s.kt)(Qkr,(0,p.Z)({},Ykr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}$kr.isMDXComponent=!0;const Kkr={toc:[]},Jkr="wrapper";function tyr(t){let{components:e,...n}=t;return(0,s.kt)(Jkr,(0,p.Z)({},Kkr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}tyr.isMDXComponent=!0;const eyr={toc:[]},nyr="wrapper";function oyr(t){let{components:e,...n}=t;return(0,s.kt)(nyr,(0,p.Z)({},eyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}oyr.isMDXComponent=!0;const pyr={toc:[]},ryr="wrapper";function syr(t){let{components:e,...n}=t;return(0,s.kt)(ryr,(0,p.Z)({},pyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}syr.isMDXComponent=!0;const cyr={toc:[]},ayr="wrapper";function iyr(t){let{components:e,...n}=t;return(0,s.kt)(ayr,(0,p.Z)({},cyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}iyr.isMDXComponent=!0;const lyr={toc:[]},uyr="wrapper";function myr(t){let{components:e,...n}=t;return(0,s.kt)(uyr,(0,p.Z)({},lyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}myr.isMDXComponent=!0;const dyr={toc:[]},hyr="wrapper";function fyr(t){let{components:e,...n}=t;return(0,s.kt)(hyr,(0,p.Z)({},dyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}fyr.isMDXComponent=!0;const kyr={toc:[]},yyr="wrapper";function Dyr(t){let{components:e,...n}=t;return(0,s.kt)(yyr,(0,p.Z)({},kyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Dyr.isMDXComponent=!0;const Myr={toc:[]},Xyr="wrapper";function _yr(t){let{components:e,...n}=t;return(0,s.kt)(Xyr,(0,p.Z)({},Myr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}_yr.isMDXComponent=!0;const wyr={toc:[]},Tyr="wrapper";function Cyr(t){let{components:e,...n}=t;return(0,s.kt)(Tyr,(0,p.Z)({},wyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Cyr.isMDXComponent=!0;const gyr={toc:[]},xyr="wrapper";function vyr(t){let{components:e,...n}=t;return(0,s.kt)(xyr,(0,p.Z)({},gyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}vyr.isMDXComponent=!0;const Lyr={toc:[]},Zyr="wrapper";function byr(t){let{components:e,...n}=t;return(0,s.kt)(Zyr,(0,p.Z)({},Lyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}byr.isMDXComponent=!0;const Nyr={toc:[]},zyr="wrapper";function Ayr(t){let{components:e,...n}=t;return(0,s.kt)(zyr,(0,p.Z)({},Nyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Ayr.isMDXComponent=!0;const Pyr={toc:[]},Iyr="wrapper";function Wyr(t){let{components:e,...n}=t;return(0,s.kt)(Iyr,(0,p.Z)({},Pyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Wyr.isMDXComponent=!0;const Ryr={toc:[]},Syr="wrapper";function Byr(t){let{components:e,...n}=t;return(0,s.kt)(Syr,(0,p.Z)({},Ryr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Byr.isMDXComponent=!0;const Gyr={toc:[]},Eyr="wrapper";function Oyr(t){let{components:e,...n}=t;return(0,s.kt)(Eyr,(0,p.Z)({},Gyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Oyr.isMDXComponent=!0;const Uyr={toc:[]},Fyr="wrapper";function Vyr(t){let{components:e,...n}=t;return(0,s.kt)(Fyr,(0,p.Z)({},Uyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}Vyr.isMDXComponent=!0;const qyr={toc:[]},jyr="wrapper";function Hyr(t){let{components:e,...n}=t;return(0,s.kt)(jyr,(0,p.Z)({},qyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}Hyr.isMDXComponent=!0;const Yyr={toc:[]},Qyr="wrapper";function $yr(t){let{components:e,...n}=t;return(0,s.kt)(Qyr,(0,p.Z)({},Yyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}$yr.isMDXComponent=!0;const Kyr={toc:[]},Jyr="wrapper";function tDr(t){let{components:e,...n}=t;return(0,s.kt)(Jyr,(0,p.Z)({},Kyr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}tDr.isMDXComponent=!0;const eDr={toc:[]},nDr="wrapper";function oDr(t){let{components:e,...n}=t;return(0,s.kt)(nDr,(0,p.Z)({},eDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}oDr.isMDXComponent=!0;const pDr={toc:[]},rDr="wrapper";function sDr(t){let{components:e,...n}=t;return(0,s.kt)(rDr,(0,p.Z)({},pDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}sDr.isMDXComponent=!0;const cDr={toc:[]},aDr="wrapper";function iDr(t){let{components:e,...n}=t;return(0,s.kt)(aDr,(0,p.Z)({},cDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}iDr.isMDXComponent=!0;const lDr={toc:[]},uDr="wrapper";function mDr(t){let{components:e,...n}=t;return(0,s.kt)(uDr,(0,p.Z)({},lDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}mDr.isMDXComponent=!0;const dDr={toc:[]},hDr="wrapper";function fDr(t){let{components:e,...n}=t;return(0,s.kt)(hDr,(0,p.Z)({},dDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}fDr.isMDXComponent=!0;const kDr={toc:[]},yDr="wrapper";function DDr(t){let{components:e,...n}=t;return(0,s.kt)(yDr,(0,p.Z)({},kDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}DDr.isMDXComponent=!0;const MDr={toc:[]},XDr="wrapper";function _Dr(t){let{components:e,...n}=t;return(0,s.kt)(XDr,(0,p.Z)({},MDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}_Dr.isMDXComponent=!0;const wDr={toc:[]},TDr="wrapper";function CDr(t){let{components:e,...n}=t;return(0,s.kt)(TDr,(0,p.Z)({},wDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}CDr.isMDXComponent=!0;const gDr={toc:[]},xDr="wrapper";function vDr(t){let{components:e,...n}=t;return(0,s.kt)(xDr,(0,p.Z)({},gDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}vDr.isMDXComponent=!0;const LDr={toc:[]},ZDr="wrapper";function bDr(t){let{components:e,...n}=t;return(0,s.kt)(ZDr,(0,p.Z)({},LDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}bDr.isMDXComponent=!0;const NDr={toc:[]},zDr="wrapper";function ADr(t){let{components:e,...n}=t;return(0,s.kt)(zDr,(0,p.Z)({},NDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}ADr.isMDXComponent=!0;const PDr={toc:[]},IDr="wrapper";function WDr(t){let{components:e,...n}=t;return(0,s.kt)(IDr,(0,p.Z)({},PDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}WDr.isMDXComponent=!0;const RDr={toc:[]},SDr="wrapper";function BDr(t){let{components:e,...n}=t;return(0,s.kt)(SDr,(0,p.Z)({},RDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}BDr.isMDXComponent=!0;const GDr={toc:[]},EDr="wrapper";function ODr(t){let{components:e,...n}=t;return(0,s.kt)(EDr,(0,p.Z)({},GDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}ODr.isMDXComponent=!0;const UDr={toc:[]},FDr="wrapper";function VDr(t){let{components:e,...n}=t;return(0,s.kt)(FDr,(0,p.Z)({},UDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}VDr.isMDXComponent=!0;const qDr={toc:[]},jDr="wrapper";function HDr(t){let{components:e,...n}=t;return(0,s.kt)(jDr,(0,p.Z)({},qDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}HDr.isMDXComponent=!0;const YDr={toc:[]},QDr="wrapper";function $Dr(t){let{components:e,...n}=t;return(0,s.kt)(QDr,(0,p.Z)({},YDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}$Dr.isMDXComponent=!0;const KDr={toc:[]},JDr="wrapper";function tMr(t){let{components:e,...n}=t;return(0,s.kt)(JDr,(0,p.Z)({},KDr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}tMr.isMDXComponent=!0;const eMr={toc:[]},nMr="wrapper";function oMr(t){let{components:e,...n}=t;return(0,s.kt)(nMr,(0,p.Z)({},eMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}oMr.isMDXComponent=!0;const pMr={toc:[]},rMr="wrapper";function sMr(t){let{components:e,...n}=t;return(0,s.kt)(rMr,(0,p.Z)({},pMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}sMr.isMDXComponent=!0;const cMr={toc:[]},aMr="wrapper";function iMr(t){let{components:e,...n}=t;return(0,s.kt)(aMr,(0,p.Z)({},cMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}iMr.isMDXComponent=!0;const lMr={toc:[]},uMr="wrapper";function mMr(t){let{components:e,...n}=t;return(0,s.kt)(uMr,(0,p.Z)({},lMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}mMr.isMDXComponent=!0;const dMr={toc:[]},hMr="wrapper";function fMr(t){let{components:e,...n}=t;return(0,s.kt)(hMr,(0,p.Z)({},dMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}fMr.isMDXComponent=!0;const kMr={toc:[]},yMr="wrapper";function DMr(t){let{components:e,...n}=t;return(0,s.kt)(yMr,(0,p.Z)({},kMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}DMr.isMDXComponent=!0;const MMr={toc:[]},XMr="wrapper";function _Mr(t){let{components:e,...n}=t;return(0,s.kt)(XMr,(0,p.Z)({},MMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}_Mr.isMDXComponent=!0;const wMr={toc:[]},TMr="wrapper";function CMr(t){let{components:e,...n}=t;return(0,s.kt)(TMr,(0,p.Z)({},wMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}CMr.isMDXComponent=!0;const gMr={toc:[]},xMr="wrapper";function vMr(t){let{components:e,...n}=t;return(0,s.kt)(xMr,(0,p.Z)({},gMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}vMr.isMDXComponent=!0;const LMr={toc:[]},ZMr="wrapper";function bMr(t){let{components:e,...n}=t;return(0,s.kt)(ZMr,(0,p.Z)({},LMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}bMr.isMDXComponent=!0;const NMr={toc:[]},zMr="wrapper";function AMr(t){let{components:e,...n}=t;return(0,s.kt)(zMr,(0,p.Z)({},NMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}AMr.isMDXComponent=!0;const PMr={toc:[]},IMr="wrapper";function WMr(t){let{components:e,...n}=t;return(0,s.kt)(IMr,(0,p.Z)({},PMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}WMr.isMDXComponent=!0;const RMr={toc:[]},SMr="wrapper";function BMr(t){let{components:e,...n}=t;return(0,s.kt)(SMr,(0,p.Z)({},RMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}BMr.isMDXComponent=!0;const GMr={toc:[]},EMr="wrapper";function OMr(t){let{components:e,...n}=t;return(0,s.kt)(EMr,(0,p.Z)({},GMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}OMr.isMDXComponent=!0;const UMr={toc:[]},FMr="wrapper";function VMr(t){let{components:e,...n}=t;return(0,s.kt)(FMr,(0,p.Z)({},UMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}VMr.isMDXComponent=!0;const qMr={toc:[]},jMr="wrapper";function HMr(t){let{components:e,...n}=t;return(0,s.kt)(jMr,(0,p.Z)({},qMr,n,{components:e,mdxType:"MDXLayout"}))}HMr.isMDXComponent=!0;const YMr={toc:[]},QMr="wrapper";function $Mr(t){let{components:e,...n}=t;return(0,s.kt)(QMr,(0,p.Z)({},YMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}$Mr.isMDXComponent=!0;const KMr={toc:[]},JMr="wrapper";function tXr(t){let{components:e,...n}=t;return(0,s.kt)(JMr,(0,p.Z)({},KMr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}tXr.isMDXComponent=!0;const eXr={toc:[]},nXr="wrapper";function oXr(t){let{components:e,...n}=t;return(0,s.kt)(nXr,(0,p.Z)({},eXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}oXr.isMDXComponent=!0;const pXr={toc:[]},rXr="wrapper";function sXr(t){let{components:e,...n}=t;return(0,s.kt)(rXr,(0,p.Z)({},pXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}sXr.isMDXComponent=!0;const cXr={toc:[]},aXr="wrapper";function iXr(t){let{components:e,...n}=t;return(0,s.kt)(aXr,(0,p.Z)({},cXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}iXr.isMDXComponent=!0;const lXr={toc:[]},uXr="wrapper";function mXr(t){let{components:e,...n}=t;return(0,s.kt)(uXr,(0,p.Z)({},lXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}mXr.isMDXComponent=!0;const dXr={toc:[]},hXr="wrapper";function fXr(t){let{components:e,...n}=t;return(0,s.kt)(hXr,(0,p.Z)({},dXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}fXr.isMDXComponent=!0;const kXr={toc:[]},yXr="wrapper";function DXr(t){let{components:e,...n}=t;return(0,s.kt)(yXr,(0,p.Z)({},kXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}DXr.isMDXComponent=!0;const MXr={toc:[]},XXr="wrapper";function _Xr(t){let{components:e,...n}=t;return(0,s.kt)(XXr,(0,p.Z)({},MXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}_Xr.isMDXComponent=!0;const wXr={toc:[]},TXr="wrapper";function CXr(t){let{components:e,...n}=t;return(0,s.kt)(TXr,(0,p.Z)({},wXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}CXr.isMDXComponent=!0;const gXr={toc:[]},xXr="wrapper";function vXr(t){let{components:e,...n}=t;return(0,s.kt)(xXr,(0,p.Z)({},gXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}vXr.isMDXComponent=!0;const LXr={toc:[]},ZXr="wrapper";function bXr(t){let{components:e,...n}=t;return(0,s.kt)(ZXr,(0,p.Z)({},LXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}bXr.isMDXComponent=!0;const NXr={toc:[]},zXr="wrapper";function AXr(t){let{components:e,...n}=t;return(0,s.kt)(zXr,(0,p.Z)({},NXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}AXr.isMDXComponent=!0;const PXr={toc:[]},IXr="wrapper";function WXr(t){let{components:e,...n}=t;return(0,s.kt)(IXr,(0,p.Z)({},PXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}WXr.isMDXComponent=!0;const RXr={toc:[]},SXr="wrapper";function BXr(t){let{components:e,...n}=t;return(0,s.kt)(SXr,(0,p.Z)({},RXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}BXr.isMDXComponent=!0;const GXr={toc:[]},EXr="wrapper";function OXr(t){let{components:e,...n}=t;return(0,s.kt)(EXr,(0,p.Z)({},GXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}OXr.isMDXComponent=!0;const UXr={toc:[]},FXr="wrapper";function VXr(t){let{components:e,...n}=t;return(0,s.kt)(FXr,(0,p.Z)({},UXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}VXr.isMDXComponent=!0;const qXr={toc:[]},jXr="wrapper";function HXr(t){let{components:e,...n}=t;return(0,s.kt)(jXr,(0,p.Z)({},qXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}HXr.isMDXComponent=!0;const YXr={toc:[]},QXr="wrapper";function $Xr(t){let{components:e,...n}=t;return(0,s.kt)(QXr,(0,p.Z)({},YXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}$Xr.isMDXComponent=!0;const KXr={toc:[]},JXr="wrapper";function t_r(t){let{components:e,...n}=t;return(0,s.kt)(JXr,(0,p.Z)({},KXr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}t_r.isMDXComponent=!0;const e_r={toc:[]},n_r="wrapper";function o_r(t){let{components:e,...n}=t;return(0,s.kt)(n_r,(0,p.Z)({},e_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}o_r.isMDXComponent=!0;const p_r={toc:[]},r_r="wrapper";function s_r(t){let{components:e,...n}=t;return(0,s.kt)(r_r,(0,p.Z)({},p_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}s_r.isMDXComponent=!0;const c_r={toc:[]},a_r="wrapper";function i_r(t){let{components:e,...n}=t;return(0,s.kt)(a_r,(0,p.Z)({},c_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}i_r.isMDXComponent=!0;const l_r={toc:[]},u_r="wrapper";function m_r(t){let{components:e,...n}=t;return(0,s.kt)(u_r,(0,p.Z)({},l_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}m_r.isMDXComponent=!0;const d_r={toc:[]},h_r="wrapper";function f_r(t){let{components:e,...n}=t;return(0,s.kt)(h_r,(0,p.Z)({},d_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}f_r.isMDXComponent=!0;const k_r={toc:[]},y_r="wrapper";function D_r(t){let{components:e,...n}=t;return(0,s.kt)(y_r,(0,p.Z)({},k_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}D_r.isMDXComponent=!0;const M_r={toc:[]},X_r="wrapper";function __r(t){let{components:e,...n}=t;return(0,s.kt)(X_r,(0,p.Z)({},M_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}__r.isMDXComponent=!0;const w_r={toc:[]},T_r="wrapper";function C_r(t){let{components:e,...n}=t;return(0,s.kt)(T_r,(0,p.Z)({},w_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}C_r.isMDXComponent=!0;const g_r={toc:[]},x_r="wrapper";function v_r(t){let{components:e,...n}=t;return(0,s.kt)(x_r,(0,p.Z)({},g_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}v_r.isMDXComponent=!0;const L_r={toc:[]},Z_r="wrapper";function b_r(t){let{components:e,...n}=t;return(0,s.kt)(Z_r,(0,p.Z)({},L_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}b_r.isMDXComponent=!0;const N_r={toc:[]},z_r="wrapper";function A_r(t){let{components:e,...n}=t;return(0,s.kt)(z_r,(0,p.Z)({},N_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}A_r.isMDXComponent=!0;const P_r={toc:[]},I_r="wrapper";function W_r(t){let{components:e,...n}=t;return(0,s.kt)(I_r,(0,p.Z)({},P_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}W_r.isMDXComponent=!0;const R_r={toc:[]},S_r="wrapper";function B_r(t){let{components:e,...n}=t;return(0,s.kt)(S_r,(0,p.Z)({},R_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}B_r.isMDXComponent=!0;const G_r={toc:[]},E_r="wrapper";function O_r(t){let{components:e,...n}=t;return(0,s.kt)(E_r,(0,p.Z)({},G_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}O_r.isMDXComponent=!0;const U_r={toc:[]},F_r="wrapper";function V_r(t){let{components:e,...n}=t;return(0,s.kt)(F_r,(0,p.Z)({},U_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}V_r.isMDXComponent=!0;const q_r={toc:[]},j_r="wrapper";function H_r(t){let{components:e,...n}=t;return(0,s.kt)(j_r,(0,p.Z)({},q_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}H_r.isMDXComponent=!0;const Y_r={toc:[]},Q_r="wrapper";function $_r(t){let{components:e,...n}=t;return(0,s.kt)(Q_r,(0,p.Z)({},Y_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}$_r.isMDXComponent=!0;const K_r={toc:[]},J_r="wrapper";function twr(t){let{components:e,...n}=t;return(0,s.kt)(J_r,(0,p.Z)({},K_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}twr.isMDXComponent=!0;const ewr={toc:[]},nwr="wrapper";function owr(t){let{components:e,...n}=t;return(0,s.kt)(nwr,(0,p.Z)({},ewr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}owr.isMDXComponent=!0;const pwr={toc:[]},rwr="wrapper";function swr(t){let{components:e,...n}=t;return(0,s.kt)(rwr,(0,p.Z)({},pwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}swr.isMDXComponent=!0;const cwr={toc:[]},awr="wrapper";function iwr(t){let{components:e,...n}=t;return(0,s.kt)(awr,(0,p.Z)({},cwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}iwr.isMDXComponent=!0;const lwr={toc:[]},uwr="wrapper";function mwr(t){let{components:e,...n}=t;return(0,s.kt)(uwr,(0,p.Z)({},lwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}mwr.isMDXComponent=!0;const dwr={toc:[]},hwr="wrapper";function fwr(t){let{components:e,...n}=t;return(0,s.kt)(hwr,(0,p.Z)({},dwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}fwr.isMDXComponent=!0;const kwr={toc:[]},ywr="wrapper";function Dwr(t){let{components:e,...n}=t;return(0,s.kt)(ywr,(0,p.Z)({},kwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Dwr.isMDXComponent=!0;const Mwr={toc:[]},Xwr="wrapper";function _wr(t){let{components:e,...n}=t;return(0,s.kt)(Xwr,(0,p.Z)({},Mwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}_wr.isMDXComponent=!0;const wwr={toc:[]},Twr="wrapper";function Cwr(t){let{components:e,...n}=t;return(0,s.kt)(Twr,(0,p.Z)({},wwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Cwr.isMDXComponent=!0;const gwr={toc:[]},xwr="wrapper";function vwr(t){let{components:e,...n}=t;return(0,s.kt)(xwr,(0,p.Z)({},gwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}vwr.isMDXComponent=!0;const Lwr={toc:[]},Zwr="wrapper";function bwr(t){let{components:e,...n}=t;return(0,s.kt)(Zwr,(0,p.Z)({},Lwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}bwr.isMDXComponent=!0;const Nwr={toc:[]},zwr="wrapper";function Awr(t){let{components:e,...n}=t;return(0,s.kt)(zwr,(0,p.Z)({},Nwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}Awr.isMDXComponent=!0;const Pwr={toc:[]},Iwr="wrapper";function Wwr(t){let{components:e,...n}=t;return(0,s.kt)(Iwr,(0,p.Z)({},Pwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}Wwr.isMDXComponent=!0;const Rwr={toc:[]},Swr="wrapper";function Bwr(t){let{components:e,...n}=t;return(0,s.kt)(Swr,(0,p.Z)({},Rwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}Bwr.isMDXComponent=!0;const Gwr={toc:[]},Ewr="wrapper";function Owr(t){let{components:e,...n}=t;return(0,s.kt)(Ewr,(0,p.Z)({},Gwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}Owr.isMDXComponent=!0;const Uwr={toc:[]},Fwr="wrapper";function Vwr(t){let{components:e,...n}=t;return(0,s.kt)(Fwr,(0,p.Z)({},Uwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}Vwr.isMDXComponent=!0;const qwr={toc:[]},jwr="wrapper";function Hwr(t){let{components:e,...n}=t;return(0,s.kt)(jwr,(0,p.Z)({},qwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}Hwr.isMDXComponent=!0;const Ywr={toc:[]},Qwr="wrapper";function $wr(t){let{components:e,...n}=t;return(0,s.kt)(Qwr,(0,p.Z)({},Ywr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}$wr.isMDXComponent=!0;const Kwr={toc:[]},Jwr="wrapper";function tTr(t){let{components:e,...n}=t;return(0,s.kt)(Jwr,(0,p.Z)({},Kwr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}tTr.isMDXComponent=!0;const eTr={toc:[]},nTr="wrapper";function oTr(t){let{components:e,...n}=t;return(0,s.kt)(nTr,(0,p.Z)({},eTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}oTr.isMDXComponent=!0;const pTr={toc:[]},rTr="wrapper";function sTr(t){let{components:e,...n}=t;return(0,s.kt)(rTr,(0,p.Z)({},pTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}sTr.isMDXComponent=!0;const cTr={toc:[]},aTr="wrapper";function iTr(t){let{components:e,...n}=t;return(0,s.kt)(aTr,(0,p.Z)({},cTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}iTr.isMDXComponent=!0;const lTr={toc:[]},uTr="wrapper";function mTr(t){let{components:e,...n}=t;return(0,s.kt)(uTr,(0,p.Z)({},lTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}mTr.isMDXComponent=!0;const dTr={toc:[]},hTr="wrapper";function fTr(t){let{components:e,...n}=t;return(0,s.kt)(hTr,(0,p.Z)({},dTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}fTr.isMDXComponent=!0;const kTr={toc:[]},yTr="wrapper";function DTr(t){let{components:e,...n}=t;return(0,s.kt)(yTr,(0,p.Z)({},kTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}DTr.isMDXComponent=!0;const MTr={toc:[]},XTr="wrapper";function _Tr(t){let{components:e,...n}=t;return(0,s.kt)(XTr,(0,p.Z)({},MTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}_Tr.isMDXComponent=!0;const wTr={toc:[]},TTr="wrapper";function CTr(t){let{components:e,...n}=t;return(0,s.kt)(TTr,(0,p.Z)({},wTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}CTr.isMDXComponent=!0;const gTr={toc:[]},xTr="wrapper";function vTr(t){let{components:e,...n}=t;return(0,s.kt)(xTr,(0,p.Z)({},gTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}vTr.isMDXComponent=!0;const LTr={toc:[]},ZTr="wrapper";function bTr(t){let{components:e,...n}=t;return(0,s.kt)(ZTr,(0,p.Z)({},LTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}bTr.isMDXComponent=!0;const NTr={toc:[]},zTr="wrapper";function ATr(t){let{components:e,...n}=t;return(0,s.kt)(zTr,(0,p.Z)({},NTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}ATr.isMDXComponent=!0;const PTr={toc:[]},ITr="wrapper";function WTr(t){let{components:e,...n}=t;return(0,s.kt)(ITr,(0,p.Z)({},PTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}WTr.isMDXComponent=!0;const RTr={toc:[]},STr="wrapper";function BTr(t){let{components:e,...n}=t;return(0,s.kt)(STr,(0,p.Z)({},RTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}BTr.isMDXComponent=!0;const GTr={toc:[]},ETr="wrapper";function OTr(t){let{components:e,...n}=t;return(0,s.kt)(ETr,(0,p.Z)({},GTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}OTr.isMDXComponent=!0;const UTr={toc:[]},FTr="wrapper";function VTr(t){let{components:e,...n}=t;return(0,s.kt)(FTr,(0,p.Z)({},UTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}VTr.isMDXComponent=!0;const qTr={toc:[]},jTr="wrapper";function HTr(t){let{components:e,...n}=t;return(0,s.kt)(jTr,(0,p.Z)({},qTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}HTr.isMDXComponent=!0;const YTr={toc:[]},QTr="wrapper";function $Tr(t){let{components:e,...n}=t;return(0,s.kt)(QTr,(0,p.Z)({},YTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}$Tr.isMDXComponent=!0;const KTr={toc:[]},JTr="wrapper";function tCr(t){let{components:e,...n}=t;return(0,s.kt)(JTr,(0,p.Z)({},KTr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}tCr.isMDXComponent=!0;const eCr={toc:[]},nCr="wrapper";function oCr(t){let{components:e,...n}=t;return(0,s.kt)(nCr,(0,p.Z)({},eCr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}oCr.isMDXComponent=!0;const pCr={toc:[]},rCr="wrapper";function sCr(t){let{components:e,...n}=t;return(0,s.kt)(rCr,(0,p.Z)({},pCr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a predicate that checks if the given object is an instance of the\ngiven class."))}sCr.isMDXComponent=!0;const cCr={toc:[]},aCr="wrapper";function iCr(t){let{components:e,...n}=t;return(0,s.kt)(aCr,(0,p.Z)({},cCr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class to check against."))}iCr.isMDXComponent=!0;const lCr={toc:[]},uCr="wrapper";function mCr(t){let{components:e,...n}=t;return(0,s.kt)(uCr,(0,p.Z)({},lCr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const MyTxt = withDefaults(Txt, {\n  fill: '#f3303f',\n});\n\n// ...\n\nview.add(<MyTxt>Hello, World!</MyTxt>);\n")))}mCr.isMDXComponent=!0;const dCr={toc:[]},hCr="wrapper";function fCr(t){let{components:e,...n}=t;return(0,s.kt)(hCr,(0,p.Z)({},dCr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a higher order component with default props."))}fCr.isMDXComponent=!0;const kCr={toc:[]},yCr="wrapper";function DCr(t){let{components:e,...n}=t;return(0,s.kt)(yCr,(0,p.Z)({},kCr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base class or function component to wrap."))}DCr.isMDXComponent=!0;const MCr={toc:[]},XCr="wrapper";function _Cr(t){let{components:e,...n}=t;return(0,s.kt)(XCr,(0,p.Z)({},MCr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default props to apply."))}function wCr(t){let{id:e}=t;const n=o[e]??r.Fragment;return r.createElement(n,null)}_Cr.isMDXComponent=!0},9322:(t,e,n)=>{n.d(e,{Z:()=>i});var o=n(8698),p=n(8588),r=n(8770),s=n(6277),c=n(2784);const a={toggle:"toggle_S_IX",collapsed:"collapsed_wdUB",collapse:"collapse_TjTN",inverse:"inverse_g6vW",clearFix:"clearFix_HQ1T"};function i(t){let{comment:e,full:n=!0}=t;const o=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@remarks"===e}))),[e]);return c.createElement(c.Fragment,null,n&&c.createElement(l,{comment:e}),c.createElement(p.Z,{id:e?.summaryId}),c.createElement(p.Z,{id:o?.contentId}),n&&c.createElement(u,{comment:e}))}function l(t){let{comment:e}=t;return(0,c.useMemo)((()=>e?.modifierTags?.includes("@experimental")),[e])?c.createElement(r.Z,null):null}function u(t){let{comment:e}=t;const[n,r]=(0,c.useState)(!0),i=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@preview"===e}))),[e]),l=(0,c.useMemo)((()=>e?.blockTags?.filter((t=>{let{tag:e}=t;return"@example"===e}))??[]),[e]),u=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))),[e]),m=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@deprecated"===e}))),[e]),d=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@see"===e}))),[e]);return c.createElement(c.Fragment,null,c.createElement(p.Z,{id:i?.contentId}),l.length>0&&c.createElement(c.Fragment,null,c.createElement("h4",null,c.createElement("a",{className:(0,s.Z)(a.toggle,n&&a.collapsed),onClick:t=>{t.preventDefault(),r(!n)},href:"#"},"Examples")),c.createElement(o.z,{lazy:!0,as:"div",collapsed:n},c.createElement("div",{className:a.collapse},l.map((t=>c.createElement(p.Z,{key:t.contentId,id:t.contentId})))),c.createElement("div",{className:a.clearFix})),c.createElement("div",{className:(0,s.Z)(a.clearFix,a.inverse)})),u&&c.createElement(c.Fragment,null,"Default Value:"," ",c.createElement("code",null,u.content.map((t=>t.text)).join(""))),m&&c.createElement(c.Fragment,null,c.createElement("h4",null,"Deprecated"),c.createElement(p.Z,{id:m.contentId})),d&&c.createElement(c.Fragment,null,c.createElement("h4",null,"See also"),c.createElement(p.Z,{id:d.contentId})))}},2830:(t,e,n)=>{n.d(e,{Z:()=>wt});var o=n(8569),p=n(6835),r=n(7896),s=n(2784);function c(t){let{width:e=24,height:n=24,...o}=t;return s.createElement("svg",(0,r.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},o),s.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=n(68),l=n(6277);function u(t){let{children:e,highlight:n,onClick:r,link:u}=t;const m=(0,p.F)(),d=(0,i.s2)();return s.createElement("div",{className:(0,l.Z)(o.Z.codeBlockContent,a.codeBlock,n&&a.highlight,r&&a.pointer)},s.createElement("pre",{onClick:r,onKeyDown:t=>{"Enter"===t.key&&r?.()},tabIndex:0,ref:m.codeBlockRef,className:(0,l.Z)(o.Z.codeBlock,"thin-scrollbar")},s.createElement("code",{className:o.Z.codeBlockLines,style:d},e)),u&&s.createElement("div",{className:o.Z.buttonGroup},s.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(u,"_blank")}},s.createElement(c,{width:18,height:18}))))}var m=n(9318);function d(t){let{children:e}=t;return s.createElement(m.Z,{as:"div",className:(0,l.Z)(a.codeBlockContainer,"language-typescript")},e)}function h(t){let{children:e}=t;const n=(0,s.useRef)();return(0,s.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${a.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(a.wrap)}})),s.createElement(s.Fragment,null,e&&s.createElement("span",{ref:n,className:(0,l.Z)(a.line,"token-line")},e),s.createElement("br",null))}var f=n(9322),k=n(7390);function y(t){let{width:e=24,height:n=24,...o}=t;return s.createElement("svg",(0,r.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},o),s.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}var D=n(7708);const M={header:"header_nSmr",filters:"filters_z1iC",icon:"icon_ROIU"};function X(){const t=(0,s.useRef)(null),[e,n]=(0,s.useState)(!1),[o,p]=(0,D.mN)();return(0,s.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),s.createElement(s.Fragment,null,s.createElement("div",{ref:t,className:(0,l.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},s.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",s.createElement(y,{className:M.icon})),s.createElement("ul",{className:"dropdown__menu"},s.createElement("li",null,s.createElement("label",{htmlFor:"private",className:(0,l.Z)("dropdown__link",o.private&&"dropdown__link--active")},s.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:o.private,onChange:t=>{p({...o,private:t.target.checked})}}),"Protected members")),s.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},s.createElement("label",{htmlFor:"inherited",className:(0,l.Z)("dropdown__link",o.inherited&&"dropdown__link--active")},s.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:o.inherited,onChange:t=>{p({...o,inherited:t.target.checked})}}),"Inherited members")))))}function _(t){let{children:e,kind:n}=t;return n===k.W.Class||n===k.W.Interface?s.createElement("div",{className:(0,l.Z)("row",M.header)},s.createElement("div",{className:(0,l.Z)("col",M.filters)},s.createElement(X,null)),s.createElement("div",{className:"col"},e)):s.createElement(s.Fragment,null,e)}var w=n(3181),T=n(9817);function C(t){let{children:e,type:n,to:o,id:p,tooltip:c}=t;const a=(0,i.Ld)(n);return o?s.createElement(T.Z,(0,r.Z)({id:p,to:o,"data-tooltip":c},a),e):s.createElement("span",(0,r.Z)({id:p},a),e)}let g=function(t){return t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses",t}({}),x=function(t){return t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & ",t}({});const v={[g.None]:a.none,[g.Angle]:a.angle,[g.Curly]:a.curly,[g.Square]:a.square,[g.Parentheses]:a.parentheses};function L(t){let{children:e,type:n,separator:o=x.Comma}=t;return s.createElement("span",{className:(0,l.Z)(a.list,v[n??g.None])},s.createElement("span",{className:(0,l.Z)(a.elements,o!==x.Comma&&a.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>s.createElement("span",{"data-separator":o,key:e,className:a.element},t)))))}function Z(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:e.elementType}),"[]")}function b(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:e.checkType}),s.createElement(C,{type:"keyword"}," extends "),s.createElement(ot,{type:e.extendsType})," ? ",s.createElement(ot,{type:e.trueType})," : ",s.createElement(ot,{type:e.falseType}))}function N(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:e.objectType}),"[",s.createElement(ot,{type:e.indexType}),"]")}function z(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"infer "),s.createElement(C,{type:"constant"},e.name))}function A(t){let{type:e}=t;return s.createElement(L,{type:g.Parentheses,separator:x.Ampersand},e.types.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))}function P(t){let{type:e}=t;return s.createElement(C,{type:"keyword"},e.name)}function I(t){let{type:e}=t;const[n,o]=(0,s.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return s.createElement(C,{type:o},n)}function W(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(L,{type:g.Curly},s.createElement(s.Fragment,null,"[",s.createElement(C,{type:"class"},e.parameter),s.createElement(C,{type:"keyword"}," in "),s.createElement(ot,{type:e.parameterType}),"]: ",s.createElement(ot,{type:e.templateType}))))}function R(t){let{type:e}=t;return s.createElement(s.Fragment,null,e.name,": ",s.createElement(ot,{type:e.element}))}function S(t){let{type:e}=t;return e.asserts?s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"asserts "),s.createElement(C,null,e.name," ")):s.createElement(s.Fragment,null,s.createElement(C,null,e.name," "),s.createElement(C,{type:"keyword"},"is "),s.createElement(ot,{type:e.targetType}))}function B(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"typeof "),s.createElement(ot,{type:e.queryType}))}function G(t){let{flags:e,explicitAccessModifier:n}=t;const o=[];return e?.isAbstract&&o.push("abstract"),e?.isStatic&&o.push("static"),e?.isConst&&o.push("const"),e?.isReadonly&&o.push("readonly"),e?.isPrivate&&o.push("private"),e?.isProtected&&o.push("protected"),(e?.isPublic||n&&!e?.isProtected&&!e?.isPrivate)&&o.push("public"),s.createElement(s.Fragment,null,o.map((t=>s.createElement(C,{key:t,type:"keyword"},t," "))))}function E(t){let{reflection:e}=t;return s.createElement(s.Fragment,null,s.createElement(G,{flags:e.flags}),e.varianceModifier&&s.createElement(C,{type:"keyword"},e.varianceModifier," "),s.createElement(C,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&s.createElement(s.Fragment,null," extends ",s.createElement(ot,{type:e.type})),e.default&&s.createElement(s.Fragment,null," = ",s.createElement(ot,{type:e.default})))}var O=n(8617);const U={[k.W.Namespace]:"namespace",[k.W.Enum]:"enum",[k.W.Class]:"class",[k.W.Interface]:"interface"};function F(t){let{reflection:e}=t;const n=(0,O.in)();return s.createElement(s.Fragment,null,s.createElement(G,{flags:e.flags}),s.createElement(C,{type:"keyword"},U[e.kind]," "),s.createElement(C,{type:"class-name"},e.name),!!e.typeParameters?.length&&s.createElement(L,{type:g.Angle},e.typeParameters.map((t=>s.createElement(E,{key:t.id,reflection:n(t)}))))," ",!!e.extendedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"extends "),s.createElement(L,null,e.extendedTypes.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))),!!e.implementedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"implements "),s.createElement(L,null,e.implementedTypes.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))))}function V(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return s.createElement(s.Fragment,null,s.createElement(G,{flags:e.flags}),e.flags.isRest&&"...",s.createElement(C,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&s.createElement(ot,{type:e.type}),e.defaultValue&&s.createElement(s.Fragment,null," = ",s.createElement(C,{type:"plain"},e.defaultValue)))}function q(t){let{reflection:e,flags:n}=t;const o=(0,O.in)(),p="__type"===e.name;return s.createElement(s.Fragment,null,s.createElement(G,{flags:n??e.flags,explicitAccessModifier:!p}),e.kind===k.W.GetSignature&&s.createElement(C,{type:"keyword"},"get "),e.kind===k.W.SetSignature&&s.createElement(C,{type:"keyword"},"set "),e.overwrites&&s.createElement(s.Fragment,null,s.createElement(C,{to:e.overwrites.externalUrl??(0,O.Gr)(o(e.overwrites.id)),type:"keyword"},"override")," "),e.kind===k.W.ConstructorSignature?s.createElement(s.Fragment,null,s.createElement(C,{to:"#",type:"keyword"},"new")," ",s.createElement(C,{type:"plain"},e.type.name)):p?"":s.createElement(C,{type:"function"},e.name),!!e.typeParameter?.length&&s.createElement(L,{type:g.Angle},e.typeParameter.map((t=>s.createElement(E,{key:t.id,reflection:o(t)})))),e.parameters?.length?s.createElement(L,{type:g.Parentheses},e.parameters.map((t=>s.createElement(V,{key:t,reflection:o(t)})))):"()",e.type&&s.createElement(s.Fragment,null,p?" => ":": ",s.createElement(ot,{type:e.type})))}function j(t){let{reflection:e}=t;const n=e.signatures?.[0]??e.getSignature??e.setSignature??e.indexSignature;return s.createElement(q,{reflection:n})}function H(t){let{reflection:e}=t;return s.createElement(V,{reflection:e})}function Y(t){let{reflection:e}=t;const n=(0,O.in)();return s.createElement(s.Fragment,null,s.createElement(G,{flags:e.flags}),s.createElement(C,{type:"keyword"},"type "),s.createElement(C,{type:"class-name"},e.name),e.typeParameters&&s.createElement(L,{type:g.Angle},e.typeParameters.map((t=>s.createElement(E,{key:t.id,reflection:n(t)}))))," = ",s.createElement(ot,{type:e.type}))}function Q(t){let{reflection:e}=t;const n=(0,O.in)();if(e.signatures){let t=e.signatures[0];if(t?.kind||(t=n(t)),t)return s.createElement(q,{reflection:t})}return e.children?s.createElement(L,{type:g.Curly},e.children.map((t=>s.createElement($,{key:t.id,reflection:n(t)})))):s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"unknown"))}function $(t){let{reflection:e}=t;const n=(0,s.useMemo)((()=>{switch(e.kind){case k.W.Project:case k.W.Module:case k.W.EnumMember:case k.W.Variable:case k.W.Function:break;case k.W.Namespace:case k.W.Enum:case k.W.Class:case k.W.Interface:return F;case k.W.Constructor:return q;case k.W.Property:return H;case k.W.Method:return j;case k.W.CallSignature:case k.W.IndexSignature:case k.W.ConstructorSignature:case k.W.Parameter:break;case k.W.TypeLiteral:return Q;case k.W.TypeParameter:return E;case k.W.Accessor:case k.W.GetSignature:case k.W.SetSignature:case k.W.ObjectLiteral:break;case k.W.TypeAlias:return Y;case k.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return s.createElement(n,{reflection:e})}function K(t){let{type:e}=t;const n=(0,O.in)();return s.createElement($,{reflection:n(e.declaration)})}function J(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,o]=t;return s.createElement(s.Fragment,null,"${",s.createElement(ot,{key:e,type:n}),"}",s.createElement(C,{type:"string"},o))})),s.createElement(C,{type:"string"},"`"))}function tt(t){let{type:e}=t;return e.elements?s.createElement(L,{type:g.Square},e.elements.map(((t,e)=>s.createElement(ot,{key:e,type:t})))):s.createElement(s.Fragment,null,"[]")}function et(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},e.operator," "),s.createElement(ot,{type:e.target}))}function nt(t){let{type:e}=t;return s.createElement(L,{type:g.Parentheses,separator:x.Pipe},e.types.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))}function ot(t){const e=(0,s.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return et;case"conditional":return b;case"reflection":return K;case"query":return B;case"named-tuple-member":return R;case"union":return nt;case"intrinsic":return P;case"literal":return I;case"reference":return pt;case"predicate":return S;case"tuple":return tt;case"array":return Z;case"intersection":return A;case"inferred":return z;case"mapped":return W;case"template-literal":return J;case"indexedAccess":return N}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return s.createElement(e,t)}function pt(t){let{type:e}=t;const n=(0,O.RU)(e.project),o=n?.[e.id],p=e.externalUrl??(0,O.Gr)(o);return s.createElement(s.Fragment,null,s.createElement(C,{to:p,type:p?"class-name":"constant",tooltip:!0},e.name),!!e.typeArguments?.length&&s.createElement(L,{type:g.Angle},e.typeArguments.map(((t,e)=>s.createElement(ot,{key:e,type:t})))))}function rt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?s.createElement(wt,{reflection:e.nested[0]}):s.createElement(s.Fragment,null,e.external.length>0&&s.createElement("ul",null,e.external.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>s.createElement(s.Fragment,{key:t.id},e>0&&s.createElement("hr",null),s.createElement(wt,{reflection:t})))))}var st=n(3851),ct=n(2009),at=n(7336);function it(t){let{group:e,project:n}=t;const o=(0,w.TH)(),p=(0,O.RU)(n),r=o.hash.split("-")[0].slice(1),[c]=(0,D.mN)(),a=(0,s.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],p=[],r=[];for(const s of t.children){const t=e[s];t&&(0,D.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,p,c))).filter((t=>!!t))),[e,p,c]);return(0,s.useEffect)((()=>{if(1===a.length)return;const t=o.hash.split("-")[0].slice(1);for(const e of a)if(e.anchors.includes(t))return}),[o.hash,a]),0===a.length?s.createElement(s.Fragment,null):s.createElement(s.Fragment,null,s.createElement(st.Z,{as:"h2",id:e.title},e.title),a.length>1?s.createElement(at.Z,{groupId:e.title},a.map((t=>s.createElement(ct.Z,{default:t.anchors.includes(r),value:t.title,label:t.title,className:"margin-top--lg"},s.createElement(rt,{group:t}))))):s.createElement(rt,{group:a[0]}))}var lt=n(8588);function ut(t){let{parameters:e}=t;const n=(0,O.in)(),o=(0,s.useMemo)((()=>e?.map(n)),[e]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Parameters"),s.createElement("ul",null,o.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(V,{reflection:t})),s.createElement(lt.Z,{id:t.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function mt(t){let{parameters:e}=t;const n=(0,O.in)(),o=(0,s.useMemo)((()=>e?.map(n)),[e]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Type Parameters"),s.createElement("ul",null,o.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(E,{reflection:t})),s.createElement(lt.Z,{id:t.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function dt(t){let{signatures:e,flags:n,source:o}=t;const p=(0,O.in)(),r=(0,s.useMemo)((()=>e.map(p)),[e]),[c,a]=(0,s.useState)(r[0]);return s.createElement(s.Fragment,null,s.createElement(d,null,r.map((t=>s.createElement(u,{link:o?.url,key:t.id,highlight:e.length>1&&t.id===c.id,onClick:e.length>1?()=>a(t):void 0},s.createElement(h,null,s.createElement(q,{reflection:t,flags:n})))))),s.createElement(f.Z,{comment:c.comment}),s.createElement(mt,{parameters:c.typeParameter}),s.createElement(ut,{parameters:c.parameters}))}function ht(t){let{reflection:e}=t;return s.createElement(s.Fragment,null,s.createElement(d,null,s.createElement(u,{link:e.sources?.[0]?.url},s.createElement(h,null,s.createElement($,{reflection:e})))),s.createElement(_,{kind:e.kind},s.createElement(f.Z,{comment:e.comment})),s.createElement(mt,{parameters:e.typeParameters}),e.implementedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Implemented by"),s.createElement("ul",null,e.implementedBy.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t}))))))),e.extendedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Extended by"),s.createElement("ul",null,e.extendedBy.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t}))))))),e.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(dt,{signatures:e.signatures})),e.groups?.map((t=>s.createElement(it,{group:t,key:t.title,project:e.project}))))}function ft(t){let{reflection:e,headless:n}=t;const o=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return s.createElement(s.Fragment,null,!n&&(e.hasOwnPage?s.createElement("h1",null,e.name):s.createElement(st.Z,{as:"h3",id:e.anchor},s.createElement("code",null,e.name))),s.createElement(dt,{signatures:o,flags:e.flags,source:e.sources?.[0]}),e.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pt,{type:e.inheritedFrom}))),e.overwrites&&s.createElement("small",null,"Overwrites"," ",s.createElement("code",null,s.createElement(pt,{type:e.overwrites}))))}var kt=n(6109);function yt(t){let{reflection:e}=t;return s.createElement(s.Fragment,null,s.createElement(kt.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),s.createElement(_,{kind:e.kind},s.createElement(f.Z,{comment:e.comment})),e.groups?.map((t=>s.createElement(it,{group:t,key:t.title,project:e.project}))))}const Dt={cardContainer:"cardContainer_ybwo",cardTitle:"cardTitle_Ehd1",cardDescription:"cardDescription_b6wr"};function Mt(t){let{reflection:e}=t;const n=(0,O.RU)(e.project),o=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return s.createElement("article",{className:"margin-top--lg"},s.createElement("section",{className:(0,l.Z)("row")},o.map((t=>s.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},s.createElement(T.Z,{href:t.href,className:(0,l.Z)("card padding--lg",Dt.cardContainer)},s.createElement("h2",{className:(0,l.Z)("text--truncate",Dt.cardTitle)},s.createElement("code",null,t.name)),s.createElement("div",{className:(0,l.Z)("text--truncate",Dt.cardDescription)},t.comment?.summaryText??"\xa0")))))))}function Xt(t){let{reflection:e,headless:n}=t;return s.createElement(s.Fragment,null,!n&&(e.hasOwnPage?s.createElement("h1",null,e.name):s.createElement(st.Z,{as:"h3",id:e.anchor},s.createElement("code",null,e.name))),s.createElement(d,null,s.createElement(u,{link:e.sources?.[0]?.url},s.createElement(h,null,s.createElement(H,{reflection:e})))),s.createElement(f.Z,{comment:e.comment}),e.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pt,{type:e.inheritedFrom}))))}function _t(t){let{reflection:e}=t;const n=(0,O.RU)(e.project);return s.createElement(s.Fragment,null,s.createElement(st.Z,{as:"h3",id:e.anchor},s.createElement("code",null,e.name)),s.createElement(d,null,s.createElement(u,{link:e.sources?.[0]?.url},s.createElement(h,null,s.createElement($,{reflection:e})))),s.createElement(f.Z,{comment:e.comment}),s.createElement(mt,{parameters:e.typeParameters}),e.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(dt,{signatures:e.signatures})),e.groups?.map((t=>s.createElement(s.Fragment,{key:t.title},s.createElement("h2",null,t.title),t.children.map((t=>n[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>s.createElement(wt,{key:t.id,reflection:t})))))))}function wt(t){let{reflection:e,headless:n=!1}=t;const o=(0,s.useMemo)((()=>{switch(e.kind){case k.W.Project:return Mt;case k.W.Module:return yt;case k.W.Namespace:case k.W.Enum:case k.W.Class:case k.W.Interface:return ht;case k.W.Function:case k.W.Accessor:case k.W.Constructor:case k.W.Method:return ft;case k.W.Variable:case k.W.Property:case k.W.EnumMember:return Xt;case k.W.CallSignature:case k.W.IndexSignature:case k.W.ConstructorSignature:case k.W.Parameter:case k.W.TypeLiteral:case k.W.TypeParameter:case k.W.GetSignature:case k.W.SetSignature:case k.W.ObjectLiteral:break;case k.W.TypeAlias:return _t;case k.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return s.createElement(o,{reflection:e,headless:n})}},7390:(t,e,n)=>{n.d(e,{W:()=>o});let o=function(t){return t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference",t}({})},8770:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(9817),p=n(6047),r=n(2784);function s(){return r.createElement(p.Z,{type:"experimental"},"This is an ",r.createElement(o.Z,{to:"/docs/experimental"},"experimental feature"),". The behavior and API may change drastically between minor releases.")}},8617:(t,e,n)=>{n.d(e,{Gr:()=>i,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>a});var o=n(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:n,urlLookup:r}},e)}function s(t){const{lookup:e}=(0,o.useContext)(p);return e[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return e=>{if("number"==typeof e?.project)return t[e.project][e.id]}}function a(){const{urlLookup:t,lookup:e}=(0,o.useContext)(p);return n=>{const o=t[n];return o?e[o.projectId]?.[o.id]??null:null}}function i(t){if(t)return t.href}},68:(t,e,n)=>{n.d(e,{Ld:()=>c,Y0:()=>s,s2:()=>a});var o=n(822),p=n(2784);const r=p.createContext(null);function s(t){let{children:e}=t;const n=(0,o.p)(),s=(0,p.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),p=t.styles.reduce(((t,n)=>{const{languages:o,style:p}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...p}})),t}),o);return p.root=n,p.plain={...n,backgroundColor:null},p}(n,"typescript")),[n]);return p.createElement(r.Provider,{value:s},e)}function c(t){void 0===t&&(t="plain");const e=(0,p.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function a(t){void 0===t&&(t="plain");const e=(0,p.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(1263),p=n(9741),r=n(2784);const s="api-filters",c=o.Z.canUseDOM?localStorage.getItem(s):null,a=c?JSON.parse(c):{inherited:!0,private:!1},i=r.createContext([a,()=>{}]);function l(t){let{children:e}=t;const[n,o]=(0,r.useState)(a),c=(0,p.Z)();return r.createElement(i.Provider,{value:[n,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),o(t)}]},e)}function u(){return(0,r.useContext)(i)}function m(t,e){const n=e.flags?.isPrivate||e.flags?.isProtected;if(!t.private&&n)return!1;const o=!!e.inheritedFrom;return!(!t.inherited&&o)}},6047:(t,e,n)=>{n.d(e,{Z:()=>m});var o=n(7896),p=n(8046),r=n(2784);function s(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function c(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function i(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}var l=n(9055);const u={icon:"icon_Fw4I"};function m(t){let{title:e,type:n,...m}=t;const d=(0,r.useMemo)((()=>{switch(n){case"tip":return a;case"caution":return i;case"danger":return s;case"experimental":return p.Z;default:return c}}),[n]);return"experimental"===n&&(e??="Experimental",n="caution"),r.createElement(r.Fragment,null,r.createElement(l.Z,(0,o.Z)({icon:r.createElement(d,{className:u.icon}),title:e,type:n},m)))}},1004:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>u});var o=n(7896),p=(n(2784),n(876)),r=n(2665),s=n(2072);const c={sidebar_position:4,slug:"/positioning"},a="Positioning",i={unversionedId:"getting-started/positioning",id:"getting-started/positioning",title:"Positioning",description:"Motion Canvas uses a Cartesian coordinate system. Its origin is located in the",source:"@site/docs/getting-started/positioning.mdx",sourceDirName:"getting-started",slug:"/positioning",permalink:"/docs/positioning",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/positioning.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:4,frontMatter:{sidebar_position:4,slug:"/positioning"},sidebar:"docs",previous:{title:"Scene hierarchy",permalink:"/docs/hierarchy"},next:{title:"Layouts",permalink:"/docs/layouts"}},l={},u=[{value:"Transform",id:"transform",level:2},{value:"<code>Node.position</code>",id:"nodeposition",level:3},{value:"<code>Node.scale</code>",id:"nodescale",level:3},{value:"<code>Node.rotation</code>",id:"noderotation",level:3},{value:"Absolute transform",id:"absolute-transform",level:2},{value:"<code>Node.absolutePosition</code>",id:"nodeabsoluteposition",level:3},{value:"<code>Node.absoluteScale</code>",id:"nodeabsolutescale",level:3},{value:"<code>Node.absoluteRotation</code>",id:"nodeabsoluterotation",level:3},{value:"Matrices",id:"matrices",level:2},{value:"<code>Node.localToWorld</code>",id:"nodelocaltoworld",level:3},{value:"<code>Node.worldToLocal</code>",id:"nodeworldtolocal",level:3},{value:"<code>Node.localToParent</code>",id:"nodelocaltoparent",level:3},{value:"<code>Node.parentToWorld</code>",id:"nodeparenttoworld",level:3},{value:"<code>Node.worldToParent</code>",id:"nodeworldtoparent",level:3}],m={toc:u},d="wrapper";function h(t){let{components:e,...n}=t;return(0,p.kt)(d,(0,o.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"positioning"},"Positioning"),(0,p.kt)(r.Z,{name:"positioning",banner:!0,mdxType:"AnimationPlayer"}),(0,p.kt)("p",null,"Motion Canvas uses a Cartesian coordinate system. Its origin is located in the\ncenter of the scene, with the x-axis going to the right and the y-axis going\ndown."),(0,p.kt)("h2",{id:"transform"},"Transform"),(0,p.kt)("p",null,"All nodes are positioned relative to their parents. This means that any\ntransformations applied to the parent are also applied to its children. The\ntransform of each node consists of the following properties:"),(0,p.kt)("h3",{id:"nodeposition"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.position")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#position",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodescale"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.scale")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#scale",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"noderotation"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.rotation")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#rotation",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"absolute-transform"},"Absolute transform"),(0,p.kt)("p",null,"Each of the basic transform properties has a dedicated helper method that\noperates in world space."),(0,p.kt)("p",null,"This can be helpful, for instance, when we need to match the transforms of two\nnodes located within different parents. Consider the following example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const circleA = createRef<Node>();\nconst circleB = createRef<Node>();\n\nview.add(\n  <>\n    <Node position={[200, 100]}>\n      <Circle\n        position={[0, 100]}\n        ref={circleA}\n        width={20}\n        height={20}\n        fill={'white'}\n      />\n    </Node>\n    <Circle ref={circleB} width={10} height={10} fill={'red'} />\n  </>,\n);\n\ncircleB().absolutePosition(circleA().absolutePosition());\n")),(0,p.kt)("p",null,"We access the absolute position (position in world space) of ",(0,p.kt)("inlineCode",{parentName:"p"},"circleA")," and\nassign it as the absolute position of ",(0,p.kt)("inlineCode",{parentName:"p"},"circleB"),". This will move the ",(0,p.kt)("inlineCode",{parentName:"p"},"circleB"),"\nright on top of ",(0,p.kt)("inlineCode",{parentName:"p"},"circleA"),"."),(0,p.kt)("admonition",{type:"info"},(0,p.kt)("p",{parentName:"admonition"},"Note that we still need to set the ",(0,p.kt)("inlineCode",{parentName:"p"},"absolutePosition")," of ",(0,p.kt)("inlineCode",{parentName:"p"},"circleB")," and not just\nthe ",(0,p.kt)("inlineCode",{parentName:"p"},"position"),". It may seem redundant since ",(0,p.kt)("inlineCode",{parentName:"p"},"circleB")," is a direct child of the\nscene view. But the local space of the scene view is ",(0,p.kt)("strong",{parentName:"p"},"not")," the same as the\nworld space.")),(0,p.kt)("p",null,"All available world-space properties are listed below:"),(0,p.kt)("h3",{id:"nodeabsoluteposition"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.absolutePosition")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#absolutePosition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodeabsolutescale"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.absoluteScale")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#absoluteScale",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodeabsoluterotation"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.absoluteRotation")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#absoluteRotation",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"matrices"},"Matrices"),(0,p.kt)("p",null,"For more advanced uses, nodes expose all the matrices necessary to map vectors\nfrom one space to another. For example, the helper properties described above\ncould be reimplemented using the ",(0,p.kt)("inlineCode",{parentName:"p"},"worldToParent")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"localToWorld")," matrices:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// getting the absolute position:\nnode.absolutePosition();\n// same as:\nVector2.zero.transformAsPoint(node.localToWorld());\n\n// setting the absolute position:\nnode.absolutePosition(vector);\n// same as:\nnode.position(vector.transformAsPoint(node.worldToParent()));\n")),(0,p.kt)("p",null,"The available matrices include:"),(0,p.kt)("h3",{id:"nodelocaltoworld"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.localToWorld")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#localToWorld",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodeworldtolocal"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.worldToLocal")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#worldToLocal",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodelocaltoparent"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.localToParent")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#localToParent",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodeparenttoworld"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.parentToWorld")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#parentToWorld",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"nodeworldtoparent"},(0,p.kt)("inlineCode",{parentName:"h3"},"Node.worldToParent")),(0,p.kt)(s.Z,{url:"/api/2d/components/Node#worldToParent",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null))}h.isMDXComponent=!0}}]);