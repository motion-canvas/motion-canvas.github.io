"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[2474],{876:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(2784);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),l=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=l(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(t),m=r,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||o;return t?a.createElement(h,i(i({ref:n},p),{},{components:t})):a.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[u]="string"==typeof e?e:r,i[1]=c;for(var l=2;l<o;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},390:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var a=t(7896),r=(t(2784),t(876));const o={sidebar_position:6,slug:"/spawners"},i="Spawners",c={unversionedId:"advanced/spawners",id:"advanced/spawners",title:"Spawners",description:"Sometimes we want the children of a given node to be reactive. In other words,",source:"@site/docs/advanced/spawners.mdx",sourceDirName:"advanced",slug:"/spawners",permalink:"/docs/spawners",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/advanced/spawners.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:6,frontMatter:{sidebar_position:6,slug:"/spawners"},sidebar:"docs",previous:{title:"Shaders",permalink:"/docs/shaders"},next:{title:"Experimental features",permalink:"/docs/experimental"}},s={},l=[],p={toc:l},u="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"spawners"},"Spawners"),(0,r.kt)("p",null,"Sometimes we want the children of a given node to be reactive. In other words,\nwe want them to change according to some external state. Consider the following\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const count = createSignal(10);\n\nview.add(\n  <Layout layout>\n    {range(count()).map(() => (\n      <Circle size={32} fill={'white'} />\n    ))}\n  </Layout>,\n);\n")),(0,r.kt)("p",null,"We first create the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," signal and then use its value to generate N number\nof circles."),(0,r.kt)("p",null,"This example is not reactive - changing the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," signal won't change the\nnumber of circles inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"Layout")," node. We can fix that by using a function\nthat returns the children instead of writing them directly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const count = createSignal(10);\n\nview.add(\n  <Layout layout>\n    {() => range(count()).map(() => <Circle size={32} fill={'white'} />)}\n  </Layout>,\n);\n")),(0,r.kt)("p",null,"Throughout this guide, we will refer to functions that return children as\n",(0,r.kt)("strong",{parentName:"p"},"spawners"),". Like any other signal, this function will keep track of its\ndependencies and recompute its value whenever they change. We can animate our\n",(0,r.kt)("inlineCode",{parentName:"p"},"count")," signal to see if it works:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, Layout, Circle} from '@motion-canvas/2d';\nimport {createSignal, linear, range} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const count = createSignal(10);\n\n  view.add(\n    <Layout layout>\n      {() => range(count()).map(() => <Circle size={32} fill={'white'} />)}\n    </Layout>,\n  );\n\n  yield* count(3, 2, linear).wait(1).back(2);\n});\n")),(0,r.kt)("p",null,"It's important to remember that creating new nodes comes with some overhead. If\nour spawner happens to generate a large number of nodes and its dependencies\nchange every frame, it may drastically reduce the playback's performance. To\ncounteract this, we can use an object pool that will let us reuse the same nodes\ninstead of recreating them each time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const count = createSignal(10);\n\nconst pool = range(64).map(i => (\n  <Circle x={i * 32} width={32} height={32} fill={'lightseagreen'} />\n));\n\nconst layout = createRef<Layout>();\nview.add(\n  <Layout layout ref={layout}>\n    {() => pool.slice(0, count())}\n  </Layout>,\n);\n")),(0,r.kt)("p",null,"Apart from the spawner function, the pool should never be accessed directly. Use\nthe helper methods on the parent object to get references to the spawned\nchildren:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// ... continuing from above ...\nlet spawnedCircles = layout().childrenAs<Circle>();\nyield * all(...spawnedCircles.map(circle => circle.scale(1.5, 1).to(1, 1)));\n")),(0,r.kt)("p",null,"Be aware that the references returned by a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"children()")," may be\ninvalidated when the number of spawned objects changes, and accessing the\ninvalidated objects may cause undefined behavior. Try not to save references to\nspawned objects for too long, and use ",(0,r.kt)("inlineCode",{parentName:"p"},"children()")," wherever possible to get the\nupdated list of spawned objects."))}d.isMDXComponent=!0}}]);