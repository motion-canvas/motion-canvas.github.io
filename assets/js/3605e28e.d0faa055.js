"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3805],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function r(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function s(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?r(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function c(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var i=o.createContext({}),a=function(t){var n=o.useContext(i),e=n;return t&&(e="function"==typeof t?t(n):s(s({},n),t)),e},l=function(t){var n=a(t.components);return o.createElement(i.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,r=t.originalType,i=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=a(e),d=p,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||r;return e?o.createElement(h,s(s({ref:n},l),{},{components:e})):o.createElement(h,s({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var r=e.length,s=new Array(r);s[0]=d;var c={};for(var i in n)hasOwnProperty.call(n,i)&&(c[i]=n[i]);c.originalType=t,c[u]="string"==typeof t?t:p,s[1]=c;for(var a=2;a<r;a++)s[a]=e[a];return o.createElement.apply(null,s)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},3851:(t,n,e)=>{e.d(n,{Z:()=>u});var o=e(7896),p=e(2784),r=e(6277),s=e(1077),c=e(7683),i=e(9817);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:n,id:e,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===n||!e)return p.createElement(n,(0,o.Z)({},u,{id:void 0}));const d=(0,s.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:e});return p.createElement(n,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:a,u.className),id:e}),u.children,p.createElement(i.Z,{className:"hash-link",to:`#${e}`,"aria-label":d,title:d},"\u200b"))}},2665:(t,n,e)=>{e.d(n,{Z:()=>f});var o=e(2784);const p="container_lQCo",r="small_As57",s="banner_A4QS",c="player_tELG",i="link_BTzN",a="icon_wSGd";var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}var m=e(9817),d=e(6277);function h(t){let{name:n}=t;const e=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${n}.tsx`;return o.createElement(m.Z,{to:e,className:(0,d.Z)("padding--sm",i)},o.createElement("span",null,"View source code"),o.createElement(u,{className:a}))}function f(t){let{name:n,banner:e,small:i,link:a}=t;return o.createElement("div",{className:(0,d.Z)(p,e&&s,i&&r)},o.createElement("motion-canvas-player",{class:c,src:`/examples/${n}.js`,auto:e}),o.createElement(h,{name:a||n}))}e(1263).Z.canUseDOM&&e.e(5455).then(e.bind(e,5455))},2072:(t,n,e)=>{e.d(n,{Z:()=>s});var o=e(2784),p=e(8617),r=e(1930);function s(t){let{url:n}=t;const e=(0,p.rG)()(n);return o.createElement(r.Z,{reflection:e,headless:!0})}},3328:(t,n,e)=>{e.d(n,{Z:()=>NGn});var o={};e.r(o),e.d(o,{content_0_0:()=>i,content_0_10:()=>M,content_0_100:()=>tn,content_0_1000:()=>Ey,content_0_1002:()=>Gy,content_0_1004:()=>Uy,content_0_1006:()=>qy,content_0_1008:()=>jy,content_0_1010:()=>Qy,content_0_1012:()=>$y,content_0_1014:()=>Jy,content_0_1016:()=>nM,content_0_1018:()=>oM,content_0_102:()=>en,content_0_1020:()=>rM,content_0_1022:()=>cM,content_0_1024:()=>aM,content_0_1026:()=>uM,content_0_1028:()=>dM,content_0_1030:()=>fM,content_0_1032:()=>yM,content_0_1034:()=>DM,content_0_1036:()=>_M,content_0_1038:()=>gM,content_0_104:()=>pn,content_0_1040:()=>xM,content_0_1042:()=>vM,content_0_1044:()=>ZM,content_0_1046:()=>NM,content_0_1048:()=>AM,content_0_1050:()=>RM,content_0_1052:()=>PM,content_0_1054:()=>EM,content_0_1056:()=>GM,content_0_1058:()=>UM,content_0_106:()=>sn,content_0_1060:()=>qM,content_0_1062:()=>jM,content_0_1064:()=>QM,content_0_1066:()=>$M,content_0_1068:()=>JM,content_0_1070:()=>nD,content_0_1072:()=>oD,content_0_1074:()=>rD,content_0_1076:()=>cD,content_0_1078:()=>aD,content_0_108:()=>an,content_0_1080:()=>uD,content_0_1082:()=>dD,content_0_1084:()=>fD,content_0_1086:()=>yD,content_0_1088:()=>DD,content_0_1090:()=>_D,content_0_1092:()=>gD,content_0_1094:()=>xD,content_0_1096:()=>vD,content_0_1098:()=>ZD,content_0_110:()=>un,content_0_1100:()=>ND,content_0_1102:()=>AD,content_0_1104:()=>RD,content_0_1106:()=>PD,content_0_1108:()=>ED,content_0_1110:()=>GD,content_0_1112:()=>UD,content_0_1114:()=>qD,content_0_1116:()=>jD,content_0_1118:()=>QD,content_0_112:()=>dn,content_0_1120:()=>$D,content_0_1122:()=>JD,content_0_1124:()=>nw,content_0_1126:()=>ow,content_0_1128:()=>rw,content_0_1130:()=>cw,content_0_1132:()=>aw,content_0_1134:()=>uw,content_0_1136:()=>dw,content_0_1138:()=>fw,content_0_114:()=>fn,content_0_1140:()=>yw,content_0_1142:()=>Dw,content_0_1144:()=>_w,content_0_1146:()=>gw,content_0_1148:()=>xw,content_0_1150:()=>vw,content_0_1152:()=>Zw,content_0_1154:()=>Nw,content_0_1156:()=>Aw,content_0_1158:()=>Rw,content_0_116:()=>yn,content_0_1160:()=>Pw,content_0_1162:()=>Ew,content_0_1164:()=>Gw,content_0_1166:()=>Uw,content_0_1168:()=>qw,content_0_1170:()=>jw,content_0_1172:()=>Qw,content_0_1174:()=>$w,content_0_1176:()=>Jw,content_0_1178:()=>n_,content_0_118:()=>Dn,content_0_1180:()=>o_,content_0_1182:()=>r_,content_0_1184:()=>c_,content_0_1186:()=>a_,content_0_1188:()=>u_,content_0_1190:()=>d_,content_0_1192:()=>f_,content_0_1194:()=>y_,content_0_1196:()=>D_,content_0_1198:()=>__,content_0_12:()=>w,content_0_120:()=>_n,content_0_1200:()=>g_,content_0_1202:()=>x_,content_0_1204:()=>v_,content_0_1206:()=>Z_,content_0_1208:()=>N_,content_0_1210:()=>A_,content_0_1212:()=>R_,content_0_1214:()=>P_,content_0_1216:()=>E_,content_0_1218:()=>G_,content_0_122:()=>gn,content_0_1220:()=>U_,content_0_1222:()=>q_,content_0_1224:()=>j_,content_0_1226:()=>Q_,content_0_1228:()=>$_,content_0_1230:()=>J_,content_0_1232:()=>nX,content_0_1234:()=>oX,content_0_1236:()=>rX,content_0_1238:()=>cX,content_0_124:()=>xn,content_0_1240:()=>aX,content_0_1242:()=>uX,content_0_1244:()=>dX,content_0_1246:()=>fX,content_0_1248:()=>yX,content_0_1250:()=>DX,content_0_1252:()=>_X,content_0_1254:()=>gX,content_0_1256:()=>xX,content_0_1258:()=>vX,content_0_126:()=>vn,content_0_1260:()=>ZX,content_0_1262:()=>NX,content_0_1264:()=>AX,content_0_1266:()=>RX,content_0_1268:()=>PX,content_0_1270:()=>EX,content_0_1272:()=>GX,content_0_1274:()=>UX,content_0_1276:()=>qX,content_0_1278:()=>jX,content_0_128:()=>Zn,content_0_1280:()=>QX,content_0_1282:()=>$X,content_0_1284:()=>JX,content_0_1286:()=>ng,content_0_1288:()=>og,content_0_1290:()=>rg,content_0_1292:()=>cg,content_0_1294:()=>ag,content_0_1296:()=>ug,content_0_1298:()=>dg,content_0_130:()=>Nn,content_0_1300:()=>fg,content_0_1302:()=>yg,content_0_1304:()=>Dg,content_0_1306:()=>_g,content_0_1308:()=>gg,content_0_1310:()=>xg,content_0_1312:()=>vg,content_0_1314:()=>Zg,content_0_1316:()=>Ng,content_0_1318:()=>Ag,content_0_132:()=>An,content_0_1320:()=>Rg,content_0_1322:()=>Pg,content_0_1324:()=>Eg,content_0_1326:()=>Gg,content_0_1328:()=>Ug,content_0_1330:()=>qg,content_0_1332:()=>jg,content_0_1334:()=>Qg,content_0_1336:()=>$g,content_0_1338:()=>Jg,content_0_134:()=>Rn,content_0_1340:()=>nT,content_0_1342:()=>oT,content_0_1344:()=>rT,content_0_1346:()=>cT,content_0_1348:()=>aT,content_0_1350:()=>uT,content_0_1352:()=>dT,content_0_1354:()=>fT,content_0_1356:()=>yT,content_0_1358:()=>DT,content_0_136:()=>Pn,content_0_1360:()=>_T,content_0_1362:()=>gT,content_0_1364:()=>xT,content_0_1366:()=>vT,content_0_1368:()=>ZT,content_0_1370:()=>NT,content_0_1372:()=>AT,content_0_1374:()=>RT,content_0_1376:()=>PT,content_0_1378:()=>ET,content_0_138:()=>En,content_0_1380:()=>GT,content_0_1382:()=>UT,content_0_1384:()=>qT,content_0_1386:()=>jT,content_0_1388:()=>QT,content_0_1390:()=>$T,content_0_1392:()=>JT,content_0_1394:()=>nx,content_0_1396:()=>ox,content_0_1398:()=>rx,content_0_14:()=>X,content_0_140:()=>Gn,content_0_1400:()=>cx,content_0_1402:()=>ax,content_0_1404:()=>ux,content_0_1406:()=>dx,content_0_1408:()=>fx,content_0_1410:()=>yx,content_0_1412:()=>Dx,content_0_1414:()=>_x,content_0_1416:()=>gx,content_0_1418:()=>xx,content_0_142:()=>Un,content_0_1420:()=>vx,content_0_1422:()=>Zx,content_0_1424:()=>Nx,content_0_1426:()=>Ax,content_0_1428:()=>Rx,content_0_1430:()=>Px,content_0_1432:()=>Ex,content_0_1434:()=>Gx,content_0_1436:()=>Ux,content_0_1438:()=>qx,content_0_144:()=>qn,content_0_1440:()=>jx,content_0_1442:()=>Qx,content_0_1444:()=>$x,content_0_1446:()=>Jx,content_0_1448:()=>nC,content_0_1450:()=>oC,content_0_1452:()=>rC,content_0_1454:()=>cC,content_0_1456:()=>aC,content_0_1458:()=>uC,content_0_146:()=>jn,content_0_1460:()=>dC,content_0_1462:()=>fC,content_0_1464:()=>yC,content_0_1466:()=>DC,content_0_1468:()=>_C,content_0_1470:()=>gC,content_0_1472:()=>xC,content_0_1474:()=>vC,content_0_1476:()=>ZC,content_0_1478:()=>NC,content_0_148:()=>Qn,content_0_1480:()=>AC,content_0_1482:()=>RC,content_0_1484:()=>PC,content_0_1486:()=>EC,content_0_1488:()=>GC,content_0_1490:()=>UC,content_0_1492:()=>qC,content_0_1494:()=>jC,content_0_1496:()=>QC,content_0_1498:()=>$C,content_0_150:()=>$n,content_0_1500:()=>JC,content_0_1502:()=>nv,content_0_1504:()=>ov,content_0_1506:()=>rv,content_0_1508:()=>cv,content_0_1510:()=>av,content_0_1512:()=>uv,content_0_1514:()=>dv,content_0_1516:()=>fv,content_0_1518:()=>yv,content_0_152:()=>Jn,content_0_1520:()=>Dv,content_0_1522:()=>_v,content_0_1524:()=>gv,content_0_1526:()=>xv,content_0_1528:()=>vv,content_0_1530:()=>Zv,content_0_1532:()=>Nv,content_0_1534:()=>Av,content_0_1536:()=>Rv,content_0_1538:()=>Pv,content_0_154:()=>ne,content_0_1540:()=>Ev,content_0_1542:()=>Gv,content_0_1544:()=>Uv,content_0_1546:()=>qv,content_0_1548:()=>jv,content_0_1550:()=>Qv,content_0_1552:()=>$v,content_0_1554:()=>Jv,content_0_1556:()=>nL,content_0_1558:()=>oL,content_0_156:()=>oe,content_0_1560:()=>rL,content_0_1562:()=>cL,content_0_1564:()=>aL,content_0_1566:()=>uL,content_0_1568:()=>dL,content_0_1570:()=>fL,content_0_1572:()=>yL,content_0_1574:()=>DL,content_0_1576:()=>_L,content_0_1578:()=>gL,content_0_158:()=>re,content_0_1580:()=>xL,content_0_1582:()=>vL,content_0_1584:()=>ZL,content_0_1586:()=>NL,content_0_1588:()=>AL,content_0_1590:()=>RL,content_0_1592:()=>PL,content_0_1594:()=>EL,content_0_1596:()=>GL,content_0_1598:()=>UL,content_0_16:()=>T,content_0_160:()=>ce,content_0_1600:()=>qL,content_0_1602:()=>jL,content_0_1604:()=>QL,content_0_1606:()=>$L,content_0_1608:()=>JL,content_0_1610:()=>nZ,content_0_1612:()=>oZ,content_0_1614:()=>rZ,content_0_1616:()=>cZ,content_0_1618:()=>aZ,content_0_162:()=>ae,content_0_1620:()=>uZ,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>fe,content_0_170:()=>ye,content_0_172:()=>De,content_0_174:()=>_e,content_0_176:()=>ge,content_0_178:()=>xe,content_0_18:()=>C,content_0_180:()=>ve,content_0_182:()=>Ze,content_0_184:()=>Ne,content_0_186:()=>Ae,content_0_188:()=>Re,content_0_190:()=>Pe,content_0_192:()=>Ee,content_0_194:()=>Ge,content_0_196:()=>Ue,content_0_198:()=>qe,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>je,content_0_202:()=>Qe,content_0_204:()=>$e,content_0_206:()=>Je,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>co,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>ko,content_0_224:()=>Mo,content_0_226:()=>wo,content_0_228:()=>Xo,content_0_230:()=>To,content_0_232:()=>Co,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>zo,content_0_24:()=>z,content_0_240:()=>Wo,content_0_242:()=>Io,content_0_244:()=>So,content_0_246:()=>Bo,content_0_248:()=>Oo,content_0_250:()=>Fo,content_0_252:()=>Vo,content_0_254:()=>Ho,content_0_256:()=>Yo,content_0_258:()=>Ko,content_0_26:()=>W,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>sp,content_0_268:()=>ip,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>kp,content_0_278:()=>Mp,content_0_28:()=>I,content_0_280:()=>wp,content_0_282:()=>Xp,content_0_284:()=>Tp,content_0_286:()=>Cp,content_0_288:()=>Lp,content_0_290:()=>bp,content_0_292:()=>zp,content_0_294:()=>Wp,content_0_296:()=>Ip,content_0_298:()=>Sp,content_0_30:()=>S,content_0_300:()=>Bp,content_0_302:()=>Op,content_0_304:()=>Fp,content_0_306:()=>Vp,content_0_308:()=>Hp,content_0_310:()=>Yp,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>er,content_0_318:()=>pr,content_0_32:()=>B,content_0_320:()=>sr,content_0_322:()=>ir,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>kr,content_0_332:()=>Mr,content_0_334:()=>wr,content_0_336:()=>Xr,content_0_338:()=>Tr,content_0_34:()=>O,content_0_340:()=>Cr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>zr,content_0_348:()=>Wr,content_0_350:()=>Ir,content_0_352:()=>Sr,content_0_354:()=>Br,content_0_356:()=>Or,content_0_358:()=>Fr,content_0_36:()=>F,content_0_360:()=>Vr,content_0_362:()=>Hr,content_0_364:()=>Yr,content_0_366:()=>Kr,content_0_368:()=>ts,content_0_370:()=>es,content_0_372:()=>ps,content_0_374:()=>ss,content_0_376:()=>is,content_0_378:()=>ls,content_0_38:()=>V,content_0_380:()=>ms,content_0_382:()=>hs,content_0_384:()=>ks,content_0_386:()=>Ms,content_0_388:()=>ws,content_0_390:()=>Xs,content_0_392:()=>Ts,content_0_394:()=>Cs,content_0_396:()=>Ls,content_0_398:()=>bs,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>zs,content_0_402:()=>Ws,content_0_404:()=>Is,content_0_406:()=>Ss,content_0_408:()=>Bs,content_0_410:()=>Os,content_0_412:()=>Fs,content_0_414:()=>Vs,content_0_416:()=>Hs,content_0_418:()=>Ys,content_0_42:()=>Y,content_0_420:()=>Ks,content_0_422:()=>tc,content_0_424:()=>ec,content_0_426:()=>pc,content_0_428:()=>sc,content_0_430:()=>ic,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>kc,content_0_44:()=>K,content_0_440:()=>Mc,content_0_442:()=>wc,content_0_444:()=>Xc,content_0_446:()=>Tc,content_0_448:()=>Cc,content_0_450:()=>Lc,content_0_452:()=>bc,content_0_454:()=>zc,content_0_456:()=>Wc,content_0_458:()=>Ic,content_0_46:()=>tt,content_0_460:()=>Sc,content_0_462:()=>Bc,content_0_464:()=>Oc,content_0_466:()=>Fc,content_0_468:()=>Vc,content_0_470:()=>Hc,content_0_472:()=>Yc,content_0_474:()=>Kc,content_0_476:()=>ti,content_0_478:()=>ei,content_0_48:()=>et,content_0_480:()=>pi,content_0_482:()=>si,content_0_484:()=>ii,content_0_486:()=>li,content_0_488:()=>mi,content_0_490:()=>hi,content_0_492:()=>ki,content_0_494:()=>Mi,content_0_496:()=>wi,content_0_498:()=>Xi,content_0_50:()=>pt,content_0_500:()=>Ti,content_0_502:()=>Ci,content_0_504:()=>Li,content_0_506:()=>bi,content_0_508:()=>zi,content_0_510:()=>Wi,content_0_512:()=>Ii,content_0_514:()=>Si,content_0_516:()=>Bi,content_0_518:()=>Oi,content_0_52:()=>st,content_0_520:()=>Fi,content_0_522:()=>Vi,content_0_524:()=>Hi,content_0_526:()=>Yi,content_0_528:()=>Ki,content_0_530:()=>ta,content_0_532:()=>ea,content_0_534:()=>pa,content_0_536:()=>sa,content_0_538:()=>ia,content_0_54:()=>it,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ka,content_0_548:()=>Ma,content_0_550:()=>wa,content_0_552:()=>Xa,content_0_554:()=>Ta,content_0_556:()=>Ca,content_0_558:()=>La,content_0_56:()=>lt,content_0_560:()=>ba,content_0_562:()=>za,content_0_564:()=>Wa,content_0_566:()=>Ia,content_0_568:()=>Sa,content_0_570:()=>Ba,content_0_572:()=>Oa,content_0_574:()=>Fa,content_0_576:()=>Va,content_0_578:()=>Ha,content_0_58:()=>mt,content_0_580:()=>Ya,content_0_582:()=>Ka,content_0_584:()=>tl,content_0_586:()=>el,content_0_588:()=>pl,content_0_590:()=>sl,content_0_592:()=>il,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>kl,content_0_602:()=>Ml,content_0_604:()=>wl,content_0_606:()=>Xl,content_0_608:()=>Tl,content_0_610:()=>Cl,content_0_612:()=>Ll,content_0_614:()=>bl,content_0_616:()=>zl,content_0_618:()=>Wl,content_0_62:()=>kt,content_0_620:()=>Il,content_0_622:()=>Sl,content_0_624:()=>Bl,content_0_626:()=>Ol,content_0_628:()=>Fl,content_0_630:()=>Vl,content_0_632:()=>Hl,content_0_634:()=>Yl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>su,content_0_646:()=>iu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>ku,content_0_656:()=>Mu,content_0_658:()=>wu,content_0_66:()=>wt,content_0_660:()=>Xu,content_0_662:()=>Tu,content_0_664:()=>Cu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>zu,content_0_672:()=>Wu,content_0_674:()=>Iu,content_0_676:()=>Su,content_0_678:()=>Bu,content_0_68:()=>Xt,content_0_680:()=>Ou,content_0_682:()=>Fu,content_0_684:()=>Vu,content_0_686:()=>Hu,content_0_688:()=>Yu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>sm,content_0_70:()=>Tt,content_0_700:()=>im,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>km,content_0_710:()=>Mm,content_0_712:()=>wm,content_0_714:()=>Xm,content_0_716:()=>Tm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>zm,content_0_726:()=>Wm,content_0_728:()=>Im,content_0_730:()=>Sm,content_0_732:()=>Bm,content_0_734:()=>Om,content_0_736:()=>Fm,content_0_738:()=>Vm,content_0_74:()=>Lt,content_0_740:()=>Hm,content_0_742:()=>Ym,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>sd,content_0_754:()=>id,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>kd,content_0_764:()=>Md,content_0_766:()=>wd,content_0_768:()=>Xd,content_0_770:()=>Td,content_0_772:()=>Cd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>zd,content_0_78:()=>zt,content_0_780:()=>Wd,content_0_782:()=>Id,content_0_784:()=>Sd,content_0_786:()=>Bd,content_0_788:()=>Od,content_0_790:()=>Fd,content_0_792:()=>Vd,content_0_794:()=>Hd,content_0_796:()=>Yd,content_0_798:()=>Kd,content_0_8:()=>k,content_0_80:()=>Wt,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>sh,content_0_808:()=>ih,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>kh,content_0_818:()=>Mh,content_0_82:()=>It,content_0_820:()=>wh,content_0_822:()=>Xh,content_0_824:()=>Th,content_0_826:()=>Ch,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>zh,content_0_834:()=>Wh,content_0_836:()=>Ih,content_0_838:()=>Sh,content_0_84:()=>St,content_0_840:()=>Bh,content_0_842:()=>Oh,content_0_844:()=>Fh,content_0_846:()=>Vh,content_0_848:()=>Hh,content_0_850:()=>Yh,content_0_852:()=>Kh,content_0_854:()=>tf,content_0_856:()=>ef,content_0_858:()=>pf,content_0_86:()=>Bt,content_0_860:()=>sf,content_0_862:()=>af,content_0_864:()=>uf,content_0_866:()=>df,content_0_868:()=>ff,content_0_870:()=>yf,content_0_872:()=>Df,content_0_874:()=>_f,content_0_876:()=>gf,content_0_878:()=>xf,content_0_88:()=>Ot,content_0_880:()=>vf,content_0_882:()=>Zf,content_0_884:()=>Nf,content_0_886:()=>Af,content_0_888:()=>Rf,content_0_890:()=>Pf,content_0_892:()=>Ef,content_0_894:()=>Gf,content_0_896:()=>Uf,content_0_898:()=>qf,content_0_90:()=>Ft,content_0_900:()=>jf,content_0_902:()=>Qf,content_0_904:()=>$f,content_0_906:()=>Jf,content_0_908:()=>nk,content_0_910:()=>ok,content_0_912:()=>rk,content_0_914:()=>ck,content_0_916:()=>ak,content_0_918:()=>uk,content_0_92:()=>Vt,content_0_920:()=>dk,content_0_922:()=>fk,content_0_924:()=>yk,content_0_926:()=>Dk,content_0_928:()=>_k,content_0_930:()=>gk,content_0_932:()=>xk,content_0_934:()=>vk,content_0_936:()=>Zk,content_0_938:()=>Nk,content_0_94:()=>Ht,content_0_940:()=>Ak,content_0_942:()=>Rk,content_0_944:()=>Pk,content_0_946:()=>Ek,content_0_948:()=>Gk,content_0_950:()=>Uk,content_0_952:()=>qk,content_0_954:()=>jk,content_0_956:()=>Qk,content_0_958:()=>$k,content_0_96:()=>Yt,content_0_960:()=>Jk,content_0_962:()=>ny,content_0_964:()=>oy,content_0_966:()=>ry,content_0_968:()=>cy,content_0_970:()=>ay,content_0_972:()=>uy,content_0_974:()=>dy,content_0_976:()=>fy,content_0_978:()=>yy,content_0_98:()=>Kt,content_0_980:()=>Dy,content_0_982:()=>_y,content_0_984:()=>gy,content_0_986:()=>xy,content_0_988:()=>vy,content_0_990:()=>Zy,content_0_992:()=>Ny,content_0_994:()=>Ay,content_0_996:()=>Ry,content_0_998:()=>Py,content_3504_0:()=>dZ,content_3504_10:()=>gZ,content_3504_100:()=>rN,content_3504_1000:()=>Gj,content_3504_1002:()=>Uj,content_3504_1004:()=>qj,content_3504_1006:()=>jj,content_3504_1008:()=>Qj,content_3504_1010:()=>$j,content_3504_1012:()=>Jj,content_3504_1014:()=>nH,content_3504_1016:()=>oH,content_3504_1018:()=>rH,content_3504_102:()=>cN,content_3504_1020:()=>cH,content_3504_1022:()=>aH,content_3504_1024:()=>uH,content_3504_1026:()=>dH,content_3504_1028:()=>fH,content_3504_1030:()=>yH,content_3504_1032:()=>DH,content_3504_1034:()=>_H,content_3504_1036:()=>gH,content_3504_1038:()=>xH,content_3504_104:()=>aN,content_3504_1040:()=>vH,content_3504_1042:()=>ZH,content_3504_1044:()=>NH,content_3504_1046:()=>AH,content_3504_1048:()=>RH,content_3504_1050:()=>PH,content_3504_1052:()=>EH,content_3504_1054:()=>GH,content_3504_1056:()=>UH,content_3504_1058:()=>qH,content_3504_106:()=>uN,content_3504_1060:()=>jH,content_3504_1062:()=>QH,content_3504_1064:()=>$H,content_3504_1066:()=>JH,content_3504_1068:()=>nQ,content_3504_1070:()=>oQ,content_3504_1072:()=>rQ,content_3504_1074:()=>cQ,content_3504_1076:()=>aQ,content_3504_1078:()=>uQ,content_3504_108:()=>dN,content_3504_1080:()=>dQ,content_3504_1082:()=>fQ,content_3504_1084:()=>yQ,content_3504_1086:()=>DQ,content_3504_1088:()=>_Q,content_3504_1090:()=>gQ,content_3504_1092:()=>xQ,content_3504_1094:()=>vQ,content_3504_1096:()=>ZQ,content_3504_1098:()=>NQ,content_3504_110:()=>fN,content_3504_1100:()=>AQ,content_3504_1102:()=>RQ,content_3504_1104:()=>PQ,content_3504_1106:()=>EQ,content_3504_1108:()=>GQ,content_3504_1110:()=>UQ,content_3504_1112:()=>qQ,content_3504_1114:()=>jQ,content_3504_1116:()=>QQ,content_3504_1118:()=>$Q,content_3504_112:()=>yN,content_3504_1120:()=>JQ,content_3504_1122:()=>nY,content_3504_1124:()=>oY,content_3504_1126:()=>rY,content_3504_1128:()=>cY,content_3504_1130:()=>aY,content_3504_1132:()=>uY,content_3504_1134:()=>dY,content_3504_1136:()=>fY,content_3504_1138:()=>yY,content_3504_114:()=>DN,content_3504_1140:()=>DY,content_3504_1142:()=>_Y,content_3504_1144:()=>gY,content_3504_1146:()=>xY,content_3504_1148:()=>vY,content_3504_1150:()=>ZY,content_3504_1152:()=>NY,content_3504_1154:()=>AY,content_3504_1156:()=>RY,content_3504_1158:()=>PY,content_3504_116:()=>_N,content_3504_1160:()=>EY,content_3504_1162:()=>GY,content_3504_1164:()=>UY,content_3504_1166:()=>qY,content_3504_1168:()=>jY,content_3504_1170:()=>QY,content_3504_1172:()=>$Y,content_3504_1174:()=>JY,content_3504_1176:()=>n$,content_3504_1178:()=>o$,content_3504_118:()=>gN,content_3504_1180:()=>r$,content_3504_1182:()=>c$,content_3504_1184:()=>a$,content_3504_1186:()=>u$,content_3504_1188:()=>d$,content_3504_1190:()=>f$,content_3504_1192:()=>y$,content_3504_1194:()=>D$,content_3504_1196:()=>_$,content_3504_1198:()=>g$,content_3504_12:()=>xZ,content_3504_120:()=>xN,content_3504_1200:()=>x$,content_3504_1202:()=>v$,content_3504_1204:()=>Z$,content_3504_1206:()=>N$,content_3504_1208:()=>A$,content_3504_1210:()=>R$,content_3504_1212:()=>P$,content_3504_1214:()=>E$,content_3504_1216:()=>G$,content_3504_1218:()=>U$,content_3504_122:()=>vN,content_3504_1220:()=>q$,content_3504_1222:()=>j$,content_3504_1224:()=>Q$,content_3504_1226:()=>$$,content_3504_1228:()=>J$,content_3504_1230:()=>nK,content_3504_1232:()=>oK,content_3504_1234:()=>rK,content_3504_1236:()=>cK,content_3504_1238:()=>aK,content_3504_124:()=>ZN,content_3504_1240:()=>uK,content_3504_1242:()=>dK,content_3504_1244:()=>fK,content_3504_1246:()=>yK,content_3504_1248:()=>DK,content_3504_1250:()=>_K,content_3504_1252:()=>gK,content_3504_1254:()=>xK,content_3504_1256:()=>vK,content_3504_1258:()=>ZK,content_3504_126:()=>NN,content_3504_1260:()=>NK,content_3504_1262:()=>AK,content_3504_1264:()=>RK,content_3504_1266:()=>PK,content_3504_1268:()=>EK,content_3504_1270:()=>GK,content_3504_1272:()=>UK,content_3504_1274:()=>qK,content_3504_1276:()=>jK,content_3504_1278:()=>QK,content_3504_128:()=>AN,content_3504_1280:()=>$K,content_3504_1282:()=>JK,content_3504_1284:()=>nJ,content_3504_1286:()=>oJ,content_3504_1288:()=>rJ,content_3504_1290:()=>cJ,content_3504_1292:()=>aJ,content_3504_1294:()=>uJ,content_3504_1296:()=>dJ,content_3504_1298:()=>fJ,content_3504_130:()=>RN,content_3504_1300:()=>yJ,content_3504_1302:()=>DJ,content_3504_1304:()=>_J,content_3504_1306:()=>gJ,content_3504_1308:()=>xJ,content_3504_1310:()=>vJ,content_3504_1312:()=>ZJ,content_3504_1314:()=>NJ,content_3504_1316:()=>AJ,content_3504_1318:()=>RJ,content_3504_132:()=>PN,content_3504_1320:()=>PJ,content_3504_1322:()=>EJ,content_3504_1324:()=>GJ,content_3504_1326:()=>UJ,content_3504_1328:()=>qJ,content_3504_1330:()=>jJ,content_3504_1332:()=>QJ,content_3504_1334:()=>$J,content_3504_1336:()=>JJ,content_3504_1338:()=>n0,content_3504_134:()=>EN,content_3504_1340:()=>o0,content_3504_1342:()=>r0,content_3504_1344:()=>c0,content_3504_1346:()=>a0,content_3504_1348:()=>u0,content_3504_1350:()=>d0,content_3504_1352:()=>f0,content_3504_1354:()=>y0,content_3504_1356:()=>D0,content_3504_1358:()=>_0,content_3504_136:()=>GN,content_3504_1360:()=>g0,content_3504_1362:()=>x0,content_3504_1364:()=>v0,content_3504_1366:()=>Z0,content_3504_1368:()=>N0,content_3504_1370:()=>A0,content_3504_1372:()=>R0,content_3504_1374:()=>P0,content_3504_1376:()=>E0,content_3504_1378:()=>G0,content_3504_138:()=>UN,content_3504_1380:()=>U0,content_3504_1382:()=>q0,content_3504_1384:()=>j0,content_3504_1386:()=>Q0,content_3504_1388:()=>$0,content_3504_1390:()=>J0,content_3504_1392:()=>n4,content_3504_1394:()=>o4,content_3504_1396:()=>r4,content_3504_1398:()=>c4,content_3504_14:()=>vZ,content_3504_140:()=>qN,content_3504_1400:()=>a4,content_3504_1402:()=>u4,content_3504_1404:()=>d4,content_3504_1406:()=>f4,content_3504_1408:()=>y4,content_3504_1410:()=>D4,content_3504_1412:()=>_4,content_3504_1414:()=>g4,content_3504_1416:()=>x4,content_3504_1418:()=>v4,content_3504_142:()=>jN,content_3504_1420:()=>Z4,content_3504_1422:()=>N4,content_3504_1424:()=>A4,content_3504_1426:()=>R4,content_3504_1428:()=>P4,content_3504_1430:()=>E4,content_3504_1432:()=>G4,content_3504_1434:()=>U4,content_3504_1436:()=>q4,content_3504_1438:()=>j4,content_3504_144:()=>QN,content_3504_1440:()=>Q4,content_3504_1442:()=>$4,content_3504_1444:()=>J4,content_3504_1446:()=>n3,content_3504_1448:()=>o3,content_3504_1450:()=>r3,content_3504_1452:()=>c3,content_3504_1454:()=>a3,content_3504_1456:()=>u3,content_3504_1458:()=>d3,content_3504_146:()=>$N,content_3504_1460:()=>f3,content_3504_1462:()=>y3,content_3504_1464:()=>D3,content_3504_1466:()=>_3,content_3504_1468:()=>g3,content_3504_1470:()=>x3,content_3504_1472:()=>v3,content_3504_1474:()=>Z3,content_3504_1476:()=>N3,content_3504_1478:()=>A3,content_3504_148:()=>JN,content_3504_1480:()=>R3,content_3504_1482:()=>P3,content_3504_1484:()=>E3,content_3504_1486:()=>G3,content_3504_1488:()=>U3,content_3504_1490:()=>q3,content_3504_1492:()=>j3,content_3504_1494:()=>Q3,content_3504_1496:()=>$3,content_3504_1498:()=>J3,content_3504_150:()=>nz,content_3504_1500:()=>n5,content_3504_1502:()=>o5,content_3504_1504:()=>r5,content_3504_1506:()=>c5,content_3504_1508:()=>a5,content_3504_1510:()=>u5,content_3504_1512:()=>d5,content_3504_1514:()=>f5,content_3504_1516:()=>y5,content_3504_1518:()=>D5,content_3504_152:()=>oz,content_3504_1520:()=>_5,content_3504_1522:()=>g5,content_3504_1524:()=>x5,content_3504_1526:()=>v5,content_3504_1528:()=>Z5,content_3504_1530:()=>N5,content_3504_1532:()=>A5,content_3504_1534:()=>R5,content_3504_1536:()=>P5,content_3504_1538:()=>E5,content_3504_154:()=>rz,content_3504_1540:()=>G5,content_3504_1542:()=>U5,content_3504_1544:()=>q5,content_3504_1546:()=>j5,content_3504_1548:()=>Q5,content_3504_1550:()=>$5,content_3504_1552:()=>J5,content_3504_1554:()=>n2,content_3504_1556:()=>o2,content_3504_1558:()=>r2,content_3504_156:()=>cz,content_3504_1560:()=>c2,content_3504_1562:()=>a2,content_3504_1564:()=>u2,content_3504_1566:()=>d2,content_3504_1568:()=>f2,content_3504_1570:()=>y2,content_3504_1572:()=>D2,content_3504_1574:()=>_2,content_3504_1576:()=>g2,content_3504_1578:()=>x2,content_3504_158:()=>az,content_3504_1580:()=>v2,content_3504_1582:()=>Z2,content_3504_1584:()=>N2,content_3504_1586:()=>A2,content_3504_1588:()=>R2,content_3504_1590:()=>P2,content_3504_1592:()=>E2,content_3504_1594:()=>G2,content_3504_1596:()=>U2,content_3504_1598:()=>q2,content_3504_16:()=>ZZ,content_3504_160:()=>uz,content_3504_1600:()=>j2,content_3504_1602:()=>Q2,content_3504_1604:()=>$2,content_3504_1606:()=>J2,content_3504_1608:()=>n1,content_3504_1610:()=>o1,content_3504_1612:()=>r1,content_3504_1614:()=>c1,content_3504_1616:()=>a1,content_3504_1618:()=>u1,content_3504_162:()=>dz,content_3504_1620:()=>d1,content_3504_1622:()=>f1,content_3504_1624:()=>y1,content_3504_1626:()=>D1,content_3504_1628:()=>_1,content_3504_1630:()=>g1,content_3504_1632:()=>x1,content_3504_1634:()=>v1,content_3504_1636:()=>Z1,content_3504_1638:()=>N1,content_3504_164:()=>fz,content_3504_1640:()=>A1,content_3504_1642:()=>R1,content_3504_1644:()=>P1,content_3504_1646:()=>E1,content_3504_1648:()=>G1,content_3504_1650:()=>U1,content_3504_1652:()=>q1,content_3504_1654:()=>j1,content_3504_1656:()=>Q1,content_3504_1658:()=>$1,content_3504_166:()=>yz,content_3504_1660:()=>J1,content_3504_1662:()=>n6,content_3504_1664:()=>o6,content_3504_1666:()=>r6,content_3504_1668:()=>c6,content_3504_1670:()=>a6,content_3504_1672:()=>u6,content_3504_1674:()=>d6,content_3504_1676:()=>f6,content_3504_1678:()=>y6,content_3504_168:()=>Dz,content_3504_1680:()=>D6,content_3504_1682:()=>_6,content_3504_1684:()=>g6,content_3504_1686:()=>x6,content_3504_1688:()=>v6,content_3504_1690:()=>Z6,content_3504_1692:()=>N6,content_3504_1694:()=>A6,content_3504_1696:()=>R6,content_3504_1698:()=>P6,content_3504_170:()=>_z,content_3504_1700:()=>E6,content_3504_1702:()=>G6,content_3504_1704:()=>U6,content_3504_1706:()=>q6,content_3504_1708:()=>j6,content_3504_1710:()=>Q6,content_3504_1712:()=>$6,content_3504_1714:()=>J6,content_3504_1716:()=>n8,content_3504_1718:()=>o8,content_3504_172:()=>gz,content_3504_1720:()=>r8,content_3504_1722:()=>c8,content_3504_1724:()=>a8,content_3504_1726:()=>u8,content_3504_1728:()=>d8,content_3504_1730:()=>f8,content_3504_1732:()=>y8,content_3504_1734:()=>D8,content_3504_1736:()=>_8,content_3504_1738:()=>g8,content_3504_174:()=>xz,content_3504_1740:()=>x8,content_3504_1742:()=>v8,content_3504_1744:()=>Z8,content_3504_1746:()=>N8,content_3504_1748:()=>A8,content_3504_1750:()=>R8,content_3504_1752:()=>P8,content_3504_1754:()=>E8,content_3504_1756:()=>G8,content_3504_1758:()=>U8,content_3504_176:()=>vz,content_3504_1760:()=>q8,content_3504_1762:()=>j8,content_3504_1764:()=>Q8,content_3504_1766:()=>$8,content_3504_1768:()=>J8,content_3504_1770:()=>n7,content_3504_1772:()=>o7,content_3504_1774:()=>r7,content_3504_1776:()=>c7,content_3504_1778:()=>a7,content_3504_178:()=>Zz,content_3504_1780:()=>u7,content_3504_1782:()=>d7,content_3504_1784:()=>f7,content_3504_1786:()=>y7,content_3504_1788:()=>D7,content_3504_1790:()=>_7,content_3504_1792:()=>g7,content_3504_1794:()=>x7,content_3504_1796:()=>v7,content_3504_1798:()=>Z7,content_3504_18:()=>NZ,content_3504_180:()=>Nz,content_3504_1800:()=>N7,content_3504_1802:()=>A7,content_3504_1804:()=>R7,content_3504_1806:()=>P7,content_3504_1808:()=>E7,content_3504_1810:()=>G7,content_3504_1812:()=>U7,content_3504_1814:()=>q7,content_3504_1816:()=>j7,content_3504_1818:()=>Q7,content_3504_182:()=>Az,content_3504_1820:()=>$7,content_3504_1822:()=>J7,content_3504_1824:()=>n9,content_3504_1826:()=>o9,content_3504_1828:()=>r9,content_3504_1830:()=>c9,content_3504_1832:()=>a9,content_3504_1834:()=>u9,content_3504_1836:()=>d9,content_3504_1838:()=>f9,content_3504_184:()=>Rz,content_3504_1840:()=>y9,content_3504_1842:()=>D9,content_3504_1844:()=>_9,content_3504_1846:()=>g9,content_3504_1848:()=>x9,content_3504_1850:()=>v9,content_3504_1852:()=>Z9,content_3504_1854:()=>N9,content_3504_1856:()=>A9,content_3504_1858:()=>R9,content_3504_186:()=>Pz,content_3504_1860:()=>P9,content_3504_1862:()=>E9,content_3504_1864:()=>G9,content_3504_1866:()=>U9,content_3504_1868:()=>q9,content_3504_1870:()=>j9,content_3504_1872:()=>Q9,content_3504_1874:()=>$9,content_3504_1876:()=>J9,content_3504_1878:()=>ntt,content_3504_188:()=>Ez,content_3504_1880:()=>ott,content_3504_1882:()=>rtt,content_3504_1884:()=>ctt,content_3504_1886:()=>att,content_3504_1888:()=>utt,content_3504_1890:()=>dtt,content_3504_1892:()=>ftt,content_3504_1894:()=>ytt,content_3504_1896:()=>Dtt,content_3504_1898:()=>_tt,content_3504_190:()=>Gz,content_3504_1900:()=>gtt,content_3504_1902:()=>xtt,content_3504_1904:()=>vtt,content_3504_1906:()=>Ztt,content_3504_1908:()=>Ntt,content_3504_1910:()=>Att,content_3504_1912:()=>Rtt,content_3504_1914:()=>Ptt,content_3504_1916:()=>Ett,content_3504_1918:()=>Gtt,content_3504_192:()=>Uz,content_3504_1920:()=>Utt,content_3504_1922:()=>qtt,content_3504_1924:()=>jtt,content_3504_1926:()=>Qtt,content_3504_1928:()=>$tt,content_3504_1930:()=>Jtt,content_3504_1932:()=>nnt,content_3504_1934:()=>ont,content_3504_1936:()=>rnt,content_3504_1938:()=>cnt,content_3504_194:()=>qz,content_3504_1940:()=>ant,content_3504_1942:()=>unt,content_3504_1944:()=>dnt,content_3504_1946:()=>fnt,content_3504_1948:()=>ynt,content_3504_1950:()=>Dnt,content_3504_1952:()=>_nt,content_3504_1954:()=>gnt,content_3504_1956:()=>xnt,content_3504_1958:()=>vnt,content_3504_196:()=>jz,content_3504_1960:()=>Znt,content_3504_1962:()=>Nnt,content_3504_1964:()=>Ant,content_3504_1966:()=>Rnt,content_3504_1968:()=>Pnt,content_3504_1970:()=>Ent,content_3504_1972:()=>Gnt,content_3504_1974:()=>Unt,content_3504_1976:()=>qnt,content_3504_1978:()=>jnt,content_3504_198:()=>Qz,content_3504_1980:()=>Qnt,content_3504_1982:()=>$nt,content_3504_1984:()=>Jnt,content_3504_1986:()=>net,content_3504_1988:()=>oet,content_3504_1990:()=>ret,content_3504_1992:()=>cet,content_3504_1994:()=>aet,content_3504_1996:()=>met,content_3504_1998:()=>het,content_3504_2:()=>fZ,content_3504_20:()=>AZ,content_3504_200:()=>$z,content_3504_2000:()=>ket,content_3504_2002:()=>Met,content_3504_2004:()=>wet,content_3504_2006:()=>Xet,content_3504_2008:()=>Tet,content_3504_2010:()=>Cet,content_3504_2012:()=>Let,content_3504_2014:()=>bet,content_3504_2016:()=>zet,content_3504_2018:()=>Wet,content_3504_202:()=>Jz,content_3504_2020:()=>Iet,content_3504_2022:()=>Set,content_3504_2024:()=>Bet,content_3504_2026:()=>Oet,content_3504_2028:()=>Fet,content_3504_2030:()=>Vet,content_3504_2032:()=>Het,content_3504_2034:()=>Yet,content_3504_2036:()=>Ket,content_3504_2038:()=>tot,content_3504_204:()=>nA,content_3504_2040:()=>eot,content_3504_2042:()=>pot,content_3504_2044:()=>sot,content_3504_2046:()=>iot,content_3504_2048:()=>lot,content_3504_2050:()=>mot,content_3504_2052:()=>hot,content_3504_2054:()=>kot,content_3504_2056:()=>Mot,content_3504_2058:()=>wot,content_3504_206:()=>oA,content_3504_2060:()=>Xot,content_3504_2062:()=>Tot,content_3504_2064:()=>Cot,content_3504_2066:()=>Lot,content_3504_2068:()=>bot,content_3504_2070:()=>zot,content_3504_2072:()=>Wot,content_3504_2074:()=>Iot,content_3504_2076:()=>Sot,content_3504_2078:()=>Bot,content_3504_208:()=>rA,content_3504_2080:()=>Oot,content_3504_2082:()=>Fot,content_3504_2084:()=>Vot,content_3504_2086:()=>Hot,content_3504_2088:()=>Yot,content_3504_2090:()=>Kot,content_3504_2092:()=>tpt,content_3504_2094:()=>ept,content_3504_2096:()=>ppt,content_3504_2098:()=>spt,content_3504_210:()=>cA,content_3504_2100:()=>ipt,content_3504_2102:()=>lpt,content_3504_2104:()=>mpt,content_3504_2106:()=>hpt,content_3504_2108:()=>kpt,content_3504_2110:()=>Mpt,content_3504_2112:()=>wpt,content_3504_2114:()=>Xpt,content_3504_2116:()=>Tpt,content_3504_2118:()=>Cpt,content_3504_212:()=>aA,content_3504_2120:()=>Lpt,content_3504_2122:()=>bpt,content_3504_2124:()=>zpt,content_3504_2126:()=>Wpt,content_3504_2128:()=>Ipt,content_3504_2130:()=>Spt,content_3504_2132:()=>Bpt,content_3504_2134:()=>Opt,content_3504_2136:()=>Fpt,content_3504_2138:()=>Vpt,content_3504_214:()=>uA,content_3504_2140:()=>Hpt,content_3504_2142:()=>Ypt,content_3504_2144:()=>Kpt,content_3504_2146:()=>trt,content_3504_2148:()=>ert,content_3504_2150:()=>prt,content_3504_2152:()=>srt,content_3504_2154:()=>irt,content_3504_2156:()=>lrt,content_3504_2158:()=>mrt,content_3504_216:()=>dA,content_3504_2160:()=>hrt,content_3504_2162:()=>krt,content_3504_2164:()=>Mrt,content_3504_2166:()=>wrt,content_3504_2168:()=>Xrt,content_3504_2170:()=>Trt,content_3504_2172:()=>Crt,content_3504_2174:()=>Lrt,content_3504_2176:()=>brt,content_3504_2178:()=>zrt,content_3504_218:()=>fA,content_3504_2180:()=>Wrt,content_3504_2182:()=>Irt,content_3504_2184:()=>Srt,content_3504_2186:()=>Brt,content_3504_2188:()=>Ort,content_3504_2190:()=>Frt,content_3504_2192:()=>Vrt,content_3504_2194:()=>Hrt,content_3504_2196:()=>Yrt,content_3504_2198:()=>Krt,content_3504_22:()=>RZ,content_3504_220:()=>yA,content_3504_2200:()=>tst,content_3504_2202:()=>est,content_3504_2204:()=>pst,content_3504_2206:()=>sst,content_3504_2208:()=>ist,content_3504_2210:()=>lst,content_3504_2212:()=>mst,content_3504_2214:()=>hst,content_3504_2216:()=>kst,content_3504_2218:()=>Mst,content_3504_222:()=>DA,content_3504_2220:()=>wst,content_3504_2222:()=>Xst,content_3504_2224:()=>Tst,content_3504_2226:()=>Cst,content_3504_2228:()=>Lst,content_3504_2230:()=>bst,content_3504_2232:()=>zst,content_3504_2234:()=>Wst,content_3504_2236:()=>Ist,content_3504_2238:()=>Sst,content_3504_224:()=>_A,content_3504_2240:()=>Bst,content_3504_2242:()=>Ost,content_3504_2244:()=>Fst,content_3504_2246:()=>Vst,content_3504_2248:()=>Hst,content_3504_2250:()=>Yst,content_3504_2252:()=>Kst,content_3504_2254:()=>tct,content_3504_2256:()=>ect,content_3504_2258:()=>pct,content_3504_226:()=>gA,content_3504_2260:()=>sct,content_3504_2262:()=>ict,content_3504_2264:()=>lct,content_3504_2266:()=>mct,content_3504_2268:()=>hct,content_3504_2270:()=>kct,content_3504_2272:()=>Mct,content_3504_2274:()=>wct,content_3504_2276:()=>Xct,content_3504_2278:()=>Tct,content_3504_228:()=>xA,content_3504_2280:()=>Cct,content_3504_2282:()=>Lct,content_3504_2284:()=>bct,content_3504_2286:()=>zct,content_3504_2288:()=>Wct,content_3504_2290:()=>Ict,content_3504_2292:()=>Sct,content_3504_2294:()=>Bct,content_3504_2296:()=>Oct,content_3504_2298:()=>Fct,content_3504_230:()=>vA,content_3504_2300:()=>Vct,content_3504_2302:()=>Hct,content_3504_2304:()=>Yct,content_3504_2306:()=>Kct,content_3504_2308:()=>tit,content_3504_2310:()=>eit,content_3504_2312:()=>pit,content_3504_2314:()=>sit,content_3504_2316:()=>iit,content_3504_2318:()=>lit,content_3504_232:()=>ZA,content_3504_2320:()=>mit,content_3504_2322:()=>hit,content_3504_2324:()=>kit,content_3504_2326:()=>Mit,content_3504_2328:()=>wit,content_3504_2330:()=>Xit,content_3504_2332:()=>Tit,content_3504_2334:()=>Cit,content_3504_2336:()=>Lit,content_3504_2338:()=>bit,content_3504_234:()=>NA,content_3504_2340:()=>zit,content_3504_2342:()=>Wit,content_3504_2344:()=>Iit,content_3504_2346:()=>Sit,content_3504_2348:()=>Bit,content_3504_2350:()=>Oit,content_3504_2352:()=>Fit,content_3504_2354:()=>Vit,content_3504_2356:()=>Hit,content_3504_2358:()=>Yit,content_3504_236:()=>AA,content_3504_2360:()=>Kit,content_3504_2362:()=>tat,content_3504_2364:()=>eat,content_3504_2366:()=>pat,content_3504_2368:()=>sat,content_3504_2370:()=>iat,content_3504_2372:()=>lat,content_3504_2374:()=>mat,content_3504_2376:()=>hat,content_3504_2378:()=>kat,content_3504_238:()=>RA,content_3504_2380:()=>Mat,content_3504_2382:()=>wat,content_3504_2384:()=>Xat,content_3504_2386:()=>Tat,content_3504_2388:()=>Cat,content_3504_2390:()=>Lat,content_3504_2392:()=>bat,content_3504_2394:()=>zat,content_3504_2396:()=>Wat,content_3504_2398:()=>Iat,content_3504_24:()=>PZ,content_3504_240:()=>PA,content_3504_2400:()=>Sat,content_3504_2402:()=>Bat,content_3504_2404:()=>Oat,content_3504_2406:()=>Fat,content_3504_2408:()=>Vat,content_3504_2410:()=>Hat,content_3504_2412:()=>Yat,content_3504_2414:()=>Kat,content_3504_2416:()=>tlt,content_3504_2418:()=>elt,content_3504_242:()=>EA,content_3504_2420:()=>plt,content_3504_2422:()=>slt,content_3504_2424:()=>ilt,content_3504_2426:()=>llt,content_3504_2428:()=>mlt,content_3504_2430:()=>hlt,content_3504_2432:()=>klt,content_3504_2434:()=>Mlt,content_3504_2436:()=>wlt,content_3504_2438:()=>Xlt,content_3504_244:()=>GA,content_3504_2440:()=>Tlt,content_3504_2442:()=>Clt,content_3504_2444:()=>Llt,content_3504_2446:()=>blt,content_3504_2448:()=>zlt,content_3504_2450:()=>Wlt,content_3504_2452:()=>Ilt,content_3504_2454:()=>Slt,content_3504_2456:()=>Blt,content_3504_2458:()=>Olt,content_3504_246:()=>UA,content_3504_2460:()=>Flt,content_3504_2462:()=>Vlt,content_3504_2464:()=>Hlt,content_3504_2466:()=>Ylt,content_3504_2468:()=>Klt,content_3504_2470:()=>tut,content_3504_2472:()=>eut,content_3504_2474:()=>put,content_3504_2476:()=>sut,content_3504_2478:()=>iut,content_3504_248:()=>qA,content_3504_2480:()=>lut,content_3504_2482:()=>mut,content_3504_2484:()=>hut,content_3504_2486:()=>kut,content_3504_2488:()=>Mut,content_3504_2490:()=>wut,content_3504_2492:()=>Xut,content_3504_2494:()=>Tut,content_3504_2496:()=>Cut,content_3504_2498:()=>Lut,content_3504_250:()=>jA,content_3504_2500:()=>but,content_3504_2502:()=>zut,content_3504_2504:()=>Wut,content_3504_2506:()=>Iut,content_3504_2508:()=>Sut,content_3504_2510:()=>But,content_3504_2512:()=>Out,content_3504_2514:()=>Fut,content_3504_2516:()=>Vut,content_3504_2518:()=>Hut,content_3504_252:()=>QA,content_3504_2520:()=>Yut,content_3504_2522:()=>Kut,content_3504_2524:()=>tmt,content_3504_2526:()=>emt,content_3504_2528:()=>pmt,content_3504_2530:()=>smt,content_3504_2532:()=>imt,content_3504_2534:()=>lmt,content_3504_2536:()=>mmt,content_3504_2538:()=>hmt,content_3504_254:()=>$A,content_3504_2540:()=>kmt,content_3504_2542:()=>Mmt,content_3504_2544:()=>wmt,content_3504_2546:()=>Xmt,content_3504_2548:()=>Tmt,content_3504_2550:()=>Cmt,content_3504_2552:()=>Lmt,content_3504_2554:()=>bmt,content_3504_2556:()=>zmt,content_3504_2558:()=>Wmt,content_3504_256:()=>JA,content_3504_2560:()=>Imt,content_3504_2562:()=>Smt,content_3504_2564:()=>Bmt,content_3504_2566:()=>Omt,content_3504_2568:()=>Fmt,content_3504_2570:()=>Vmt,content_3504_2572:()=>Hmt,content_3504_2574:()=>Ymt,content_3504_2576:()=>Kmt,content_3504_2578:()=>tdt,content_3504_258:()=>nW,content_3504_2580:()=>edt,content_3504_2582:()=>pdt,content_3504_2584:()=>sdt,content_3504_2586:()=>idt,content_3504_2588:()=>ldt,content_3504_2590:()=>mdt,content_3504_2592:()=>hdt,content_3504_2594:()=>kdt,content_3504_2596:()=>Mdt,content_3504_2598:()=>wdt,content_3504_26:()=>EZ,content_3504_260:()=>oW,content_3504_2600:()=>Xdt,content_3504_2602:()=>Tdt,content_3504_2604:()=>Cdt,content_3504_2606:()=>Ldt,content_3504_2608:()=>bdt,content_3504_2610:()=>zdt,content_3504_2612:()=>Wdt,content_3504_2614:()=>Idt,content_3504_2616:()=>Sdt,content_3504_2618:()=>Bdt,content_3504_262:()=>rW,content_3504_2620:()=>Odt,content_3504_2622:()=>Fdt,content_3504_2624:()=>Vdt,content_3504_2626:()=>Hdt,content_3504_2628:()=>Ydt,content_3504_2630:()=>Kdt,content_3504_2632:()=>tht,content_3504_2634:()=>eht,content_3504_2636:()=>pht,content_3504_2638:()=>sht,content_3504_264:()=>cW,content_3504_2640:()=>iht,content_3504_2642:()=>lht,content_3504_2644:()=>mht,content_3504_2646:()=>hht,content_3504_2648:()=>kht,content_3504_2650:()=>Mht,content_3504_2652:()=>wht,content_3504_2654:()=>Xht,content_3504_2656:()=>Tht,content_3504_2658:()=>Cht,content_3504_266:()=>aW,content_3504_2660:()=>Lht,content_3504_2662:()=>bht,content_3504_2664:()=>zht,content_3504_2666:()=>Wht,content_3504_2668:()=>Iht,content_3504_2670:()=>Sht,content_3504_2672:()=>Bht,content_3504_2674:()=>Oht,content_3504_2676:()=>Fht,content_3504_2678:()=>Vht,content_3504_268:()=>uW,content_3504_2680:()=>Hht,content_3504_2682:()=>Yht,content_3504_2684:()=>Kht,content_3504_2686:()=>tft,content_3504_2688:()=>eft,content_3504_2690:()=>pft,content_3504_2692:()=>sft,content_3504_2694:()=>ift,content_3504_2696:()=>lft,content_3504_2698:()=>mft,content_3504_270:()=>dW,content_3504_2700:()=>hft,content_3504_2702:()=>kft,content_3504_2704:()=>Mft,content_3504_2706:()=>wft,content_3504_2708:()=>Xft,content_3504_2710:()=>Tft,content_3504_2712:()=>Cft,content_3504_2714:()=>Lft,content_3504_2716:()=>bft,content_3504_2718:()=>zft,content_3504_272:()=>fW,content_3504_2720:()=>Wft,content_3504_2722:()=>Ift,content_3504_2724:()=>Sft,content_3504_2726:()=>Bft,content_3504_2728:()=>Oft,content_3504_2730:()=>Fft,content_3504_2732:()=>Vft,content_3504_2734:()=>Hft,content_3504_2736:()=>Yft,content_3504_2738:()=>Kft,content_3504_274:()=>yW,content_3504_2740:()=>tkt,content_3504_2742:()=>ekt,content_3504_2744:()=>pkt,content_3504_2746:()=>skt,content_3504_2748:()=>ikt,content_3504_2750:()=>lkt,content_3504_2752:()=>mkt,content_3504_2754:()=>hkt,content_3504_2756:()=>kkt,content_3504_2758:()=>Mkt,content_3504_276:()=>DW,content_3504_2760:()=>wkt,content_3504_2762:()=>Xkt,content_3504_2764:()=>Tkt,content_3504_2766:()=>Ckt,content_3504_2768:()=>Lkt,content_3504_2770:()=>bkt,content_3504_2772:()=>zkt,content_3504_2774:()=>Wkt,content_3504_2776:()=>Ikt,content_3504_2778:()=>Skt,content_3504_278:()=>_W,content_3504_2780:()=>Bkt,content_3504_2782:()=>Okt,content_3504_2784:()=>Fkt,content_3504_2786:()=>Vkt,content_3504_2788:()=>Hkt,content_3504_2790:()=>Ykt,content_3504_2792:()=>Kkt,content_3504_2794:()=>tyt,content_3504_2796:()=>eyt,content_3504_2798:()=>pyt,content_3504_28:()=>GZ,content_3504_280:()=>gW,content_3504_2800:()=>syt,content_3504_2802:()=>iyt,content_3504_2804:()=>lyt,content_3504_2806:()=>myt,content_3504_2808:()=>hyt,content_3504_2810:()=>kyt,content_3504_2812:()=>Myt,content_3504_2814:()=>wyt,content_3504_2816:()=>Xyt,content_3504_2818:()=>Tyt,content_3504_282:()=>xW,content_3504_2820:()=>Cyt,content_3504_2822:()=>Lyt,content_3504_2824:()=>byt,content_3504_2826:()=>zyt,content_3504_2828:()=>Wyt,content_3504_2830:()=>Iyt,content_3504_2832:()=>Syt,content_3504_2834:()=>Byt,content_3504_2836:()=>Oyt,content_3504_2838:()=>Fyt,content_3504_284:()=>vW,content_3504_2840:()=>Vyt,content_3504_2842:()=>Hyt,content_3504_2844:()=>Yyt,content_3504_2846:()=>Kyt,content_3504_2848:()=>tMt,content_3504_2850:()=>eMt,content_3504_2852:()=>pMt,content_3504_2854:()=>sMt,content_3504_2856:()=>iMt,content_3504_2858:()=>lMt,content_3504_286:()=>ZW,content_3504_2860:()=>mMt,content_3504_2862:()=>hMt,content_3504_2864:()=>kMt,content_3504_2866:()=>MMt,content_3504_2868:()=>wMt,content_3504_2870:()=>XMt,content_3504_2872:()=>TMt,content_3504_2874:()=>CMt,content_3504_2876:()=>LMt,content_3504_2878:()=>bMt,content_3504_288:()=>NW,content_3504_2880:()=>zMt,content_3504_2882:()=>WMt,content_3504_2884:()=>IMt,content_3504_2886:()=>SMt,content_3504_2888:()=>BMt,content_3504_2890:()=>OMt,content_3504_2892:()=>FMt,content_3504_2894:()=>VMt,content_3504_2896:()=>HMt,content_3504_2898:()=>YMt,content_3504_290:()=>AW,content_3504_2900:()=>KMt,content_3504_2902:()=>tDt,content_3504_2904:()=>eDt,content_3504_2906:()=>pDt,content_3504_2908:()=>sDt,content_3504_2910:()=>iDt,content_3504_2912:()=>lDt,content_3504_2914:()=>mDt,content_3504_2916:()=>hDt,content_3504_2918:()=>kDt,content_3504_292:()=>RW,content_3504_2920:()=>MDt,content_3504_2922:()=>wDt,content_3504_2924:()=>XDt,content_3504_2926:()=>TDt,content_3504_2928:()=>CDt,content_3504_2930:()=>LDt,content_3504_2932:()=>bDt,content_3504_2934:()=>zDt,content_3504_2936:()=>WDt,content_3504_2938:()=>IDt,content_3504_294:()=>PW,content_3504_2940:()=>SDt,content_3504_2942:()=>BDt,content_3504_2944:()=>ODt,content_3504_2946:()=>FDt,content_3504_2948:()=>VDt,content_3504_2950:()=>HDt,content_3504_2952:()=>YDt,content_3504_2954:()=>KDt,content_3504_2956:()=>twt,content_3504_2958:()=>ewt,content_3504_296:()=>EW,content_3504_2960:()=>pwt,content_3504_2962:()=>swt,content_3504_2964:()=>iwt,content_3504_2966:()=>lwt,content_3504_2968:()=>mwt,content_3504_2970:()=>hwt,content_3504_2972:()=>kwt,content_3504_2974:()=>Mwt,content_3504_2976:()=>wwt,content_3504_2978:()=>Xwt,content_3504_298:()=>GW,content_3504_2980:()=>Twt,content_3504_2982:()=>Cwt,content_3504_2984:()=>Lwt,content_3504_2986:()=>bwt,content_3504_2988:()=>zwt,content_3504_2990:()=>Wwt,content_3504_2992:()=>Iwt,content_3504_2994:()=>Swt,content_3504_2996:()=>Bwt,content_3504_2998:()=>Owt,content_3504_30:()=>UZ,content_3504_300:()=>UW,content_3504_3000:()=>Fwt,content_3504_3002:()=>Vwt,content_3504_3004:()=>Hwt,content_3504_3006:()=>Ywt,content_3504_3008:()=>Kwt,content_3504_3010:()=>t_t,content_3504_3012:()=>e_t,content_3504_3014:()=>p_t,content_3504_3016:()=>s_t,content_3504_3018:()=>i_t,content_3504_302:()=>qW,content_3504_3020:()=>l_t,content_3504_3022:()=>m_t,content_3504_3024:()=>h_t,content_3504_3026:()=>k_t,content_3504_3028:()=>M_t,content_3504_3030:()=>w_t,content_3504_3032:()=>X_t,content_3504_3034:()=>T_t,content_3504_3036:()=>C_t,content_3504_3038:()=>L_t,content_3504_304:()=>jW,content_3504_3040:()=>b_t,content_3504_3042:()=>z_t,content_3504_3044:()=>W_t,content_3504_3046:()=>I_t,content_3504_3048:()=>S_t,content_3504_3050:()=>B_t,content_3504_3052:()=>O_t,content_3504_3054:()=>F_t,content_3504_3056:()=>V_t,content_3504_3058:()=>H_t,content_3504_306:()=>QW,content_3504_3060:()=>Y_t,content_3504_3062:()=>K_t,content_3504_3064:()=>tXt,content_3504_3066:()=>eXt,content_3504_3068:()=>pXt,content_3504_3070:()=>sXt,content_3504_3072:()=>iXt,content_3504_3074:()=>lXt,content_3504_3076:()=>mXt,content_3504_3078:()=>hXt,content_3504_308:()=>$W,content_3504_3080:()=>kXt,content_3504_3082:()=>MXt,content_3504_3084:()=>wXt,content_3504_3086:()=>XXt,content_3504_3088:()=>TXt,content_3504_3090:()=>CXt,content_3504_3092:()=>LXt,content_3504_3094:()=>bXt,content_3504_3096:()=>zXt,content_3504_3098:()=>WXt,content_3504_310:()=>JW,content_3504_3100:()=>IXt,content_3504_3102:()=>SXt,content_3504_3104:()=>BXt,content_3504_3106:()=>OXt,content_3504_3108:()=>FXt,content_3504_3110:()=>VXt,content_3504_3112:()=>HXt,content_3504_3114:()=>YXt,content_3504_3116:()=>KXt,content_3504_3118:()=>tgt,content_3504_312:()=>nR,content_3504_3120:()=>egt,content_3504_3122:()=>pgt,content_3504_3124:()=>sgt,content_3504_3126:()=>igt,content_3504_3128:()=>lgt,content_3504_3130:()=>mgt,content_3504_3132:()=>hgt,content_3504_3134:()=>kgt,content_3504_3136:()=>Mgt,content_3504_3138:()=>wgt,content_3504_314:()=>oR,content_3504_3140:()=>Xgt,content_3504_3142:()=>Tgt,content_3504_3144:()=>Cgt,content_3504_3146:()=>Lgt,content_3504_3148:()=>bgt,content_3504_3150:()=>zgt,content_3504_3152:()=>Wgt,content_3504_3154:()=>Igt,content_3504_3156:()=>Sgt,content_3504_3158:()=>Bgt,content_3504_316:()=>rR,content_3504_3160:()=>Ogt,content_3504_3162:()=>Fgt,content_3504_3164:()=>Vgt,content_3504_3166:()=>Hgt,content_3504_3168:()=>Ygt,content_3504_3170:()=>Kgt,content_3504_3172:()=>tTt,content_3504_3174:()=>eTt,content_3504_3176:()=>pTt,content_3504_3178:()=>sTt,content_3504_318:()=>cR,content_3504_3180:()=>iTt,content_3504_3182:()=>lTt,content_3504_3184:()=>mTt,content_3504_3186:()=>hTt,content_3504_3188:()=>kTt,content_3504_3190:()=>MTt,content_3504_3192:()=>wTt,content_3504_3194:()=>XTt,content_3504_3196:()=>TTt,content_3504_3198:()=>CTt,content_3504_32:()=>qZ,content_3504_320:()=>aR,content_3504_3200:()=>LTt,content_3504_3202:()=>bTt,content_3504_3204:()=>zTt,content_3504_3206:()=>WTt,content_3504_3208:()=>ITt,content_3504_3210:()=>STt,content_3504_3212:()=>BTt,content_3504_3214:()=>OTt,content_3504_3216:()=>FTt,content_3504_3218:()=>VTt,content_3504_322:()=>uR,content_3504_3220:()=>HTt,content_3504_3222:()=>YTt,content_3504_3224:()=>KTt,content_3504_3226:()=>txt,content_3504_3228:()=>ext,content_3504_3230:()=>pxt,content_3504_3232:()=>sxt,content_3504_3234:()=>ixt,content_3504_3236:()=>lxt,content_3504_3238:()=>mxt,content_3504_324:()=>dR,content_3504_3240:()=>hxt,content_3504_3242:()=>kxt,content_3504_3244:()=>Mxt,content_3504_3246:()=>wxt,content_3504_3248:()=>Xxt,content_3504_3250:()=>Txt,content_3504_3252:()=>Cxt,content_3504_3254:()=>Lxt,content_3504_3256:()=>bxt,content_3504_3258:()=>zxt,content_3504_326:()=>fR,content_3504_3260:()=>Wxt,content_3504_3262:()=>Ixt,content_3504_3264:()=>Sxt,content_3504_3266:()=>Bxt,content_3504_3268:()=>Oxt,content_3504_3270:()=>Fxt,content_3504_3272:()=>Vxt,content_3504_3274:()=>Hxt,content_3504_3276:()=>Yxt,content_3504_3278:()=>Kxt,content_3504_328:()=>yR,content_3504_3280:()=>tCt,content_3504_3282:()=>eCt,content_3504_3284:()=>pCt,content_3504_3286:()=>sCt,content_3504_3288:()=>iCt,content_3504_3290:()=>lCt,content_3504_3292:()=>mCt,content_3504_3294:()=>hCt,content_3504_3296:()=>kCt,content_3504_3298:()=>MCt,content_3504_330:()=>DR,content_3504_3300:()=>wCt,content_3504_3302:()=>XCt,content_3504_3304:()=>TCt,content_3504_3306:()=>CCt,content_3504_3308:()=>LCt,content_3504_3310:()=>bCt,content_3504_3312:()=>zCt,content_3504_3314:()=>WCt,content_3504_3316:()=>ICt,content_3504_3318:()=>SCt,content_3504_332:()=>_R,content_3504_3320:()=>BCt,content_3504_3322:()=>OCt,content_3504_3324:()=>FCt,content_3504_3326:()=>VCt,content_3504_3328:()=>HCt,content_3504_3330:()=>YCt,content_3504_3332:()=>KCt,content_3504_3334:()=>tvt,content_3504_3336:()=>evt,content_3504_3338:()=>pvt,content_3504_334:()=>gR,content_3504_3340:()=>svt,content_3504_3342:()=>ivt,content_3504_3344:()=>lvt,content_3504_3346:()=>mvt,content_3504_3348:()=>hvt,content_3504_3350:()=>kvt,content_3504_3352:()=>Mvt,content_3504_3354:()=>wvt,content_3504_3356:()=>Xvt,content_3504_3358:()=>Tvt,content_3504_336:()=>xR,content_3504_3360:()=>Cvt,content_3504_3362:()=>Lvt,content_3504_3364:()=>bvt,content_3504_3366:()=>zvt,content_3504_3368:()=>Wvt,content_3504_3370:()=>Ivt,content_3504_3372:()=>Svt,content_3504_3374:()=>Bvt,content_3504_3376:()=>Ovt,content_3504_3378:()=>Fvt,content_3504_338:()=>vR,content_3504_3380:()=>Vvt,content_3504_3382:()=>Hvt,content_3504_3384:()=>Yvt,content_3504_3386:()=>Kvt,content_3504_3388:()=>tLt,content_3504_3390:()=>eLt,content_3504_3392:()=>pLt,content_3504_3394:()=>sLt,content_3504_3396:()=>iLt,content_3504_3398:()=>lLt,content_3504_34:()=>jZ,content_3504_340:()=>ZR,content_3504_3400:()=>mLt,content_3504_3402:()=>hLt,content_3504_3404:()=>kLt,content_3504_3406:()=>MLt,content_3504_3408:()=>wLt,content_3504_3410:()=>XLt,content_3504_3412:()=>TLt,content_3504_3414:()=>CLt,content_3504_3416:()=>LLt,content_3504_3418:()=>bLt,content_3504_342:()=>NR,content_3504_3420:()=>zLt,content_3504_3422:()=>WLt,content_3504_3424:()=>ILt,content_3504_3426:()=>SLt,content_3504_3428:()=>BLt,content_3504_3430:()=>OLt,content_3504_3432:()=>FLt,content_3504_3434:()=>VLt,content_3504_3436:()=>HLt,content_3504_3438:()=>YLt,content_3504_344:()=>AR,content_3504_3440:()=>KLt,content_3504_3442:()=>tZt,content_3504_3444:()=>eZt,content_3504_3446:()=>pZt,content_3504_3448:()=>sZt,content_3504_3450:()=>iZt,content_3504_3452:()=>lZt,content_3504_3454:()=>mZt,content_3504_3456:()=>hZt,content_3504_3458:()=>kZt,content_3504_346:()=>RR,content_3504_3460:()=>MZt,content_3504_3462:()=>wZt,content_3504_3464:()=>XZt,content_3504_3466:()=>TZt,content_3504_3468:()=>CZt,content_3504_3470:()=>LZt,content_3504_3472:()=>bZt,content_3504_3474:()=>zZt,content_3504_3476:()=>WZt,content_3504_3478:()=>IZt,content_3504_348:()=>PR,content_3504_3480:()=>SZt,content_3504_3482:()=>BZt,content_3504_3484:()=>OZt,content_3504_3486:()=>FZt,content_3504_3488:()=>VZt,content_3504_3490:()=>HZt,content_3504_3492:()=>YZt,content_3504_3494:()=>KZt,content_3504_3496:()=>tbt,content_3504_3498:()=>ebt,content_3504_350:()=>ER,content_3504_3500:()=>pbt,content_3504_3502:()=>sbt,content_3504_3504:()=>ibt,content_3504_3506:()=>lbt,content_3504_3508:()=>mbt,content_3504_3510:()=>hbt,content_3504_3512:()=>kbt,content_3504_3514:()=>Mbt,content_3504_3516:()=>wbt,content_3504_3518:()=>Xbt,content_3504_352:()=>GR,content_3504_3520:()=>Tbt,content_3504_3522:()=>Cbt,content_3504_3524:()=>Lbt,content_3504_3526:()=>bbt,content_3504_3528:()=>zbt,content_3504_3530:()=>Wbt,content_3504_3532:()=>Ibt,content_3504_3534:()=>Sbt,content_3504_3536:()=>Bbt,content_3504_3538:()=>Obt,content_3504_354:()=>UR,content_3504_3540:()=>Fbt,content_3504_3542:()=>Vbt,content_3504_3544:()=>Hbt,content_3504_3546:()=>Ybt,content_3504_3548:()=>Kbt,content_3504_3550:()=>tNt,content_3504_3552:()=>eNt,content_3504_3554:()=>pNt,content_3504_3556:()=>sNt,content_3504_3558:()=>iNt,content_3504_356:()=>qR,content_3504_3560:()=>lNt,content_3504_3562:()=>mNt,content_3504_3564:()=>hNt,content_3504_3566:()=>kNt,content_3504_3568:()=>MNt,content_3504_3570:()=>wNt,content_3504_3572:()=>XNt,content_3504_3574:()=>TNt,content_3504_3576:()=>CNt,content_3504_3578:()=>LNt,content_3504_358:()=>jR,content_3504_3580:()=>bNt,content_3504_3582:()=>zNt,content_3504_3584:()=>WNt,content_3504_3586:()=>INt,content_3504_3588:()=>SNt,content_3504_3590:()=>BNt,content_3504_3592:()=>ONt,content_3504_3594:()=>FNt,content_3504_3596:()=>VNt,content_3504_3598:()=>HNt,content_3504_36:()=>QZ,content_3504_360:()=>QR,content_3504_3600:()=>YNt,content_3504_3602:()=>KNt,content_3504_3604:()=>tzt,content_3504_3606:()=>ezt,content_3504_3608:()=>pzt,content_3504_3610:()=>szt,content_3504_3612:()=>izt,content_3504_3614:()=>lzt,content_3504_3616:()=>mzt,content_3504_3618:()=>hzt,content_3504_362:()=>$R,content_3504_3620:()=>kzt,content_3504_3622:()=>Mzt,content_3504_3624:()=>wzt,content_3504_3626:()=>Xzt,content_3504_3628:()=>Tzt,content_3504_3630:()=>Czt,content_3504_3632:()=>Lzt,content_3504_3634:()=>bzt,content_3504_3636:()=>zzt,content_3504_3638:()=>Wzt,content_3504_364:()=>JR,content_3504_3640:()=>Izt,content_3504_3642:()=>Szt,content_3504_3644:()=>Bzt,content_3504_3646:()=>Ozt,content_3504_3648:()=>Fzt,content_3504_3650:()=>Vzt,content_3504_3652:()=>Hzt,content_3504_3654:()=>Yzt,content_3504_3656:()=>Kzt,content_3504_3658:()=>tAt,content_3504_366:()=>nI,content_3504_3660:()=>eAt,content_3504_3662:()=>pAt,content_3504_3664:()=>sAt,content_3504_3666:()=>iAt,content_3504_3668:()=>lAt,content_3504_3670:()=>mAt,content_3504_3672:()=>hAt,content_3504_3674:()=>kAt,content_3504_3676:()=>MAt,content_3504_3678:()=>wAt,content_3504_368:()=>oI,content_3504_3680:()=>XAt,content_3504_3682:()=>TAt,content_3504_3684:()=>CAt,content_3504_3686:()=>LAt,content_3504_3688:()=>bAt,content_3504_3690:()=>zAt,content_3504_3692:()=>WAt,content_3504_3694:()=>IAt,content_3504_3696:()=>SAt,content_3504_3698:()=>BAt,content_3504_370:()=>rI,content_3504_3700:()=>OAt,content_3504_3702:()=>FAt,content_3504_3704:()=>VAt,content_3504_3706:()=>HAt,content_3504_3708:()=>YAt,content_3504_3710:()=>KAt,content_3504_3712:()=>tWt,content_3504_3714:()=>eWt,content_3504_3716:()=>pWt,content_3504_3718:()=>sWt,content_3504_372:()=>cI,content_3504_3720:()=>iWt,content_3504_3722:()=>lWt,content_3504_3724:()=>mWt,content_3504_3726:()=>hWt,content_3504_3728:()=>kWt,content_3504_3730:()=>MWt,content_3504_3732:()=>wWt,content_3504_3734:()=>XWt,content_3504_3736:()=>TWt,content_3504_3738:()=>CWt,content_3504_374:()=>aI,content_3504_3740:()=>LWt,content_3504_3742:()=>bWt,content_3504_3744:()=>zWt,content_3504_3746:()=>WWt,content_3504_3748:()=>IWt,content_3504_3750:()=>SWt,content_3504_3752:()=>BWt,content_3504_3754:()=>OWt,content_3504_3756:()=>FWt,content_3504_3758:()=>VWt,content_3504_376:()=>uI,content_3504_3760:()=>HWt,content_3504_3762:()=>YWt,content_3504_3764:()=>KWt,content_3504_3766:()=>tRt,content_3504_3768:()=>eRt,content_3504_3770:()=>pRt,content_3504_3772:()=>sRt,content_3504_3774:()=>iRt,content_3504_3776:()=>lRt,content_3504_3778:()=>mRt,content_3504_378:()=>dI,content_3504_3780:()=>hRt,content_3504_3782:()=>kRt,content_3504_3784:()=>MRt,content_3504_3786:()=>wRt,content_3504_3788:()=>XRt,content_3504_3790:()=>TRt,content_3504_3792:()=>CRt,content_3504_3794:()=>LRt,content_3504_3796:()=>bRt,content_3504_3798:()=>zRt,content_3504_38:()=>$Z,content_3504_380:()=>fI,content_3504_3800:()=>WRt,content_3504_3802:()=>IRt,content_3504_3804:()=>SRt,content_3504_3806:()=>BRt,content_3504_3808:()=>ORt,content_3504_3810:()=>FRt,content_3504_3812:()=>VRt,content_3504_3814:()=>HRt,content_3504_3816:()=>YRt,content_3504_3818:()=>KRt,content_3504_382:()=>yI,content_3504_3820:()=>tIt,content_3504_3822:()=>eIt,content_3504_3824:()=>pIt,content_3504_3826:()=>sIt,content_3504_3828:()=>iIt,content_3504_3830:()=>lIt,content_3504_3832:()=>mIt,content_3504_3834:()=>hIt,content_3504_3836:()=>kIt,content_3504_3838:()=>MIt,content_3504_384:()=>DI,content_3504_3840:()=>wIt,content_3504_3842:()=>XIt,content_3504_3844:()=>TIt,content_3504_3846:()=>CIt,content_3504_3848:()=>LIt,content_3504_3850:()=>bIt,content_3504_3852:()=>zIt,content_3504_3854:()=>WIt,content_3504_3856:()=>IIt,content_3504_3858:()=>SIt,content_3504_386:()=>_I,content_3504_3860:()=>BIt,content_3504_3862:()=>OIt,content_3504_3864:()=>FIt,content_3504_3866:()=>VIt,content_3504_3868:()=>HIt,content_3504_3870:()=>YIt,content_3504_3872:()=>KIt,content_3504_3874:()=>tPt,content_3504_3876:()=>ePt,content_3504_3878:()=>pPt,content_3504_388:()=>gI,content_3504_3880:()=>sPt,content_3504_3882:()=>iPt,content_3504_3884:()=>lPt,content_3504_3886:()=>mPt,content_3504_3888:()=>hPt,content_3504_3890:()=>kPt,content_3504_3892:()=>MPt,content_3504_3894:()=>wPt,content_3504_3896:()=>XPt,content_3504_3898:()=>TPt,content_3504_390:()=>xI,content_3504_3900:()=>CPt,content_3504_3902:()=>LPt,content_3504_3904:()=>bPt,content_3504_3906:()=>zPt,content_3504_3908:()=>WPt,content_3504_3910:()=>IPt,content_3504_3912:()=>SPt,content_3504_3914:()=>BPt,content_3504_3916:()=>OPt,content_3504_3918:()=>FPt,content_3504_392:()=>vI,content_3504_3920:()=>VPt,content_3504_3922:()=>HPt,content_3504_3924:()=>YPt,content_3504_3926:()=>KPt,content_3504_3928:()=>tSt,content_3504_3930:()=>eSt,content_3504_3932:()=>pSt,content_3504_3934:()=>sSt,content_3504_3936:()=>iSt,content_3504_3938:()=>lSt,content_3504_394:()=>ZI,content_3504_3940:()=>mSt,content_3504_3942:()=>hSt,content_3504_3944:()=>kSt,content_3504_3946:()=>MSt,content_3504_3948:()=>wSt,content_3504_3950:()=>XSt,content_3504_3952:()=>TSt,content_3504_3954:()=>CSt,content_3504_3956:()=>LSt,content_3504_3958:()=>bSt,content_3504_396:()=>NI,content_3504_3960:()=>zSt,content_3504_3962:()=>WSt,content_3504_3964:()=>ISt,content_3504_3966:()=>SSt,content_3504_3968:()=>BSt,content_3504_3970:()=>OSt,content_3504_3972:()=>FSt,content_3504_3974:()=>VSt,content_3504_3976:()=>HSt,content_3504_3978:()=>YSt,content_3504_398:()=>AI,content_3504_3980:()=>KSt,content_3504_3982:()=>tEt,content_3504_3984:()=>eEt,content_3504_3986:()=>pEt,content_3504_3988:()=>sEt,content_3504_3990:()=>iEt,content_3504_3992:()=>lEt,content_3504_3994:()=>mEt,content_3504_3996:()=>hEt,content_3504_3998:()=>kEt,content_3504_4:()=>yZ,content_3504_40:()=>JZ,content_3504_400:()=>RI,content_3504_4000:()=>MEt,content_3504_4002:()=>wEt,content_3504_4004:()=>XEt,content_3504_4006:()=>TEt,content_3504_4008:()=>CEt,content_3504_4010:()=>LEt,content_3504_4012:()=>bEt,content_3504_4014:()=>zEt,content_3504_4016:()=>WEt,content_3504_4018:()=>IEt,content_3504_402:()=>PI,content_3504_4020:()=>SEt,content_3504_4022:()=>BEt,content_3504_4024:()=>OEt,content_3504_4026:()=>FEt,content_3504_4028:()=>VEt,content_3504_4030:()=>HEt,content_3504_4032:()=>YEt,content_3504_4034:()=>KEt,content_3504_4036:()=>tBt,content_3504_4038:()=>eBt,content_3504_404:()=>EI,content_3504_4040:()=>pBt,content_3504_4042:()=>sBt,content_3504_4044:()=>iBt,content_3504_4046:()=>lBt,content_3504_4048:()=>mBt,content_3504_4050:()=>hBt,content_3504_4052:()=>kBt,content_3504_4054:()=>MBt,content_3504_4056:()=>wBt,content_3504_4058:()=>XBt,content_3504_406:()=>GI,content_3504_4060:()=>TBt,content_3504_4062:()=>CBt,content_3504_4064:()=>LBt,content_3504_4066:()=>bBt,content_3504_4068:()=>zBt,content_3504_4070:()=>WBt,content_3504_4072:()=>IBt,content_3504_4074:()=>SBt,content_3504_4076:()=>BBt,content_3504_4078:()=>OBt,content_3504_408:()=>UI,content_3504_4080:()=>FBt,content_3504_4082:()=>VBt,content_3504_4084:()=>HBt,content_3504_4086:()=>YBt,content_3504_4088:()=>KBt,content_3504_4090:()=>tGt,content_3504_4092:()=>eGt,content_3504_4094:()=>pGt,content_3504_4096:()=>sGt,content_3504_4098:()=>iGt,content_3504_410:()=>qI,content_3504_4100:()=>lGt,content_3504_4102:()=>mGt,content_3504_4104:()=>hGt,content_3504_4106:()=>kGt,content_3504_4108:()=>MGt,content_3504_4110:()=>wGt,content_3504_4112:()=>XGt,content_3504_4114:()=>TGt,content_3504_4116:()=>CGt,content_3504_4118:()=>LGt,content_3504_412:()=>jI,content_3504_4120:()=>bGt,content_3504_4122:()=>zGt,content_3504_4124:()=>WGt,content_3504_4126:()=>IGt,content_3504_4128:()=>SGt,content_3504_4130:()=>BGt,content_3504_4132:()=>OGt,content_3504_4134:()=>FGt,content_3504_4136:()=>VGt,content_3504_4138:()=>HGt,content_3504_414:()=>QI,content_3504_4140:()=>YGt,content_3504_4142:()=>KGt,content_3504_4144:()=>tOt,content_3504_4146:()=>eOt,content_3504_4148:()=>pOt,content_3504_4150:()=>sOt,content_3504_4152:()=>iOt,content_3504_4154:()=>lOt,content_3504_4156:()=>mOt,content_3504_4158:()=>hOt,content_3504_416:()=>$I,content_3504_4160:()=>kOt,content_3504_4162:()=>MOt,content_3504_4164:()=>wOt,content_3504_4166:()=>XOt,content_3504_4168:()=>TOt,content_3504_4170:()=>COt,content_3504_4172:()=>LOt,content_3504_4174:()=>bOt,content_3504_4176:()=>zOt,content_3504_4178:()=>WOt,content_3504_418:()=>JI,content_3504_4180:()=>IOt,content_3504_4182:()=>SOt,content_3504_4184:()=>BOt,content_3504_4186:()=>OOt,content_3504_4188:()=>FOt,content_3504_4190:()=>VOt,content_3504_4192:()=>HOt,content_3504_4194:()=>YOt,content_3504_4196:()=>KOt,content_3504_4198:()=>tUt,content_3504_42:()=>nb,content_3504_420:()=>nP,content_3504_4200:()=>eUt,content_3504_4202:()=>pUt,content_3504_4204:()=>sUt,content_3504_4206:()=>iUt,content_3504_4208:()=>lUt,content_3504_4210:()=>mUt,content_3504_4212:()=>hUt,content_3504_4214:()=>kUt,content_3504_4216:()=>MUt,content_3504_4218:()=>wUt,content_3504_422:()=>oP,content_3504_4220:()=>XUt,content_3504_4222:()=>TUt,content_3504_4224:()=>CUt,content_3504_4226:()=>LUt,content_3504_4228:()=>bUt,content_3504_4230:()=>zUt,content_3504_4232:()=>WUt,content_3504_4234:()=>IUt,content_3504_4236:()=>SUt,content_3504_4238:()=>BUt,content_3504_424:()=>rP,content_3504_4240:()=>OUt,content_3504_4242:()=>FUt,content_3504_4244:()=>VUt,content_3504_4246:()=>HUt,content_3504_4248:()=>YUt,content_3504_4250:()=>KUt,content_3504_4252:()=>tFt,content_3504_4254:()=>eFt,content_3504_4256:()=>pFt,content_3504_4258:()=>sFt,content_3504_426:()=>cP,content_3504_4260:()=>iFt,content_3504_4262:()=>lFt,content_3504_4264:()=>mFt,content_3504_4266:()=>hFt,content_3504_4268:()=>kFt,content_3504_4270:()=>MFt,content_3504_4272:()=>wFt,content_3504_4274:()=>XFt,content_3504_4276:()=>TFt,content_3504_4278:()=>CFt,content_3504_428:()=>aP,content_3504_4280:()=>LFt,content_3504_4282:()=>bFt,content_3504_4284:()=>zFt,content_3504_4286:()=>WFt,content_3504_4288:()=>IFt,content_3504_4290:()=>SFt,content_3504_4292:()=>BFt,content_3504_4294:()=>OFt,content_3504_4296:()=>FFt,content_3504_4298:()=>VFt,content_3504_430:()=>uP,content_3504_4300:()=>HFt,content_3504_4302:()=>YFt,content_3504_4304:()=>KFt,content_3504_4306:()=>tqt,content_3504_4308:()=>eqt,content_3504_4310:()=>pqt,content_3504_4312:()=>sqt,content_3504_4314:()=>iqt,content_3504_4316:()=>lqt,content_3504_4318:()=>mqt,content_3504_432:()=>dP,content_3504_4320:()=>hqt,content_3504_4322:()=>kqt,content_3504_4324:()=>Mqt,content_3504_4326:()=>wqt,content_3504_4328:()=>Xqt,content_3504_4330:()=>Tqt,content_3504_4332:()=>Cqt,content_3504_4334:()=>Lqt,content_3504_4336:()=>bqt,content_3504_4338:()=>zqt,content_3504_434:()=>fP,content_3504_4340:()=>Wqt,content_3504_4342:()=>Iqt,content_3504_4344:()=>Sqt,content_3504_4346:()=>Bqt,content_3504_4348:()=>Oqt,content_3504_4350:()=>Fqt,content_3504_4352:()=>Vqt,content_3504_4354:()=>Hqt,content_3504_4356:()=>Yqt,content_3504_4358:()=>Kqt,content_3504_436:()=>yP,content_3504_4360:()=>tVt,content_3504_4362:()=>eVt,content_3504_4364:()=>pVt,content_3504_4366:()=>sVt,content_3504_4368:()=>iVt,content_3504_4370:()=>lVt,content_3504_4372:()=>mVt,content_3504_4374:()=>hVt,content_3504_4376:()=>kVt,content_3504_4378:()=>MVt,content_3504_438:()=>DP,content_3504_4380:()=>wVt,content_3504_4382:()=>XVt,content_3504_4384:()=>TVt,content_3504_4386:()=>CVt,content_3504_4388:()=>LVt,content_3504_4390:()=>bVt,content_3504_4392:()=>zVt,content_3504_4394:()=>WVt,content_3504_4396:()=>IVt,content_3504_4398:()=>SVt,content_3504_44:()=>ob,content_3504_440:()=>_P,content_3504_4400:()=>BVt,content_3504_4402:()=>OVt,content_3504_4404:()=>FVt,content_3504_4406:()=>VVt,content_3504_4408:()=>HVt,content_3504_4410:()=>YVt,content_3504_4412:()=>KVt,content_3504_4414:()=>tjt,content_3504_4416:()=>ejt,content_3504_4418:()=>pjt,content_3504_442:()=>gP,content_3504_4420:()=>sjt,content_3504_4422:()=>ijt,content_3504_4424:()=>ljt,content_3504_4426:()=>mjt,content_3504_4428:()=>hjt,content_3504_4430:()=>kjt,content_3504_4432:()=>Mjt,content_3504_4434:()=>wjt,content_3504_4436:()=>Xjt,content_3504_4438:()=>Tjt,content_3504_444:()=>xP,content_3504_4440:()=>Cjt,content_3504_4442:()=>Ljt,content_3504_4444:()=>bjt,content_3504_4446:()=>zjt,content_3504_4448:()=>Wjt,content_3504_4450:()=>Ijt,content_3504_4452:()=>Sjt,content_3504_4454:()=>Bjt,content_3504_4456:()=>Ojt,content_3504_4458:()=>Fjt,content_3504_446:()=>vP,content_3504_4460:()=>Vjt,content_3504_4462:()=>Hjt,content_3504_4464:()=>Yjt,content_3504_4466:()=>Kjt,content_3504_4468:()=>tHt,content_3504_4470:()=>eHt,content_3504_4472:()=>pHt,content_3504_4474:()=>sHt,content_3504_4476:()=>iHt,content_3504_4478:()=>lHt,content_3504_448:()=>ZP,content_3504_4480:()=>mHt,content_3504_4482:()=>hHt,content_3504_4484:()=>kHt,content_3504_4486:()=>MHt,content_3504_4488:()=>wHt,content_3504_4490:()=>XHt,content_3504_4492:()=>THt,content_3504_4494:()=>CHt,content_3504_4496:()=>LHt,content_3504_4498:()=>bHt,content_3504_450:()=>NP,content_3504_4500:()=>zHt,content_3504_4502:()=>WHt,content_3504_4504:()=>IHt,content_3504_4506:()=>SHt,content_3504_4508:()=>BHt,content_3504_4510:()=>OHt,content_3504_4512:()=>FHt,content_3504_4514:()=>VHt,content_3504_4516:()=>HHt,content_3504_4518:()=>YHt,content_3504_452:()=>AP,content_3504_4520:()=>KHt,content_3504_4522:()=>tQt,content_3504_4524:()=>eQt,content_3504_4526:()=>pQt,content_3504_4528:()=>sQt,content_3504_4530:()=>iQt,content_3504_4532:()=>lQt,content_3504_4534:()=>mQt,content_3504_4536:()=>hQt,content_3504_4538:()=>kQt,content_3504_454:()=>RP,content_3504_4540:()=>MQt,content_3504_4542:()=>wQt,content_3504_4544:()=>XQt,content_3504_4546:()=>TQt,content_3504_4548:()=>CQt,content_3504_4550:()=>LQt,content_3504_4552:()=>bQt,content_3504_4554:()=>zQt,content_3504_4556:()=>WQt,content_3504_4558:()=>IQt,content_3504_456:()=>PP,content_3504_4560:()=>SQt,content_3504_4562:()=>BQt,content_3504_4564:()=>OQt,content_3504_4566:()=>FQt,content_3504_4568:()=>VQt,content_3504_4570:()=>HQt,content_3504_4572:()=>YQt,content_3504_4574:()=>KQt,content_3504_4576:()=>tYt,content_3504_4578:()=>eYt,content_3504_458:()=>EP,content_3504_4580:()=>pYt,content_3504_4582:()=>sYt,content_3504_4584:()=>iYt,content_3504_4586:()=>lYt,content_3504_4588:()=>mYt,content_3504_4590:()=>hYt,content_3504_4592:()=>kYt,content_3504_4594:()=>MYt,content_3504_4596:()=>wYt,content_3504_4598:()=>XYt,content_3504_46:()=>rb,content_3504_460:()=>GP,content_3504_4600:()=>TYt,content_3504_4602:()=>CYt,content_3504_4604:()=>LYt,content_3504_4606:()=>bYt,content_3504_4608:()=>zYt,content_3504_4610:()=>WYt,content_3504_4612:()=>IYt,content_3504_4614:()=>SYt,content_3504_4616:()=>BYt,content_3504_4618:()=>OYt,content_3504_462:()=>UP,content_3504_4620:()=>FYt,content_3504_4622:()=>VYt,content_3504_4624:()=>HYt,content_3504_4626:()=>YYt,content_3504_4628:()=>KYt,content_3504_4630:()=>t$t,content_3504_4632:()=>e$t,content_3504_4634:()=>p$t,content_3504_4636:()=>s$t,content_3504_4638:()=>i$t,content_3504_464:()=>qP,content_3504_4640:()=>l$t,content_3504_4642:()=>m$t,content_3504_4644:()=>h$t,content_3504_4646:()=>k$t,content_3504_4648:()=>M$t,content_3504_4650:()=>w$t,content_3504_4652:()=>X$t,content_3504_4654:()=>T$t,content_3504_4656:()=>C$t,content_3504_4658:()=>L$t,content_3504_466:()=>jP,content_3504_4660:()=>b$t,content_3504_4662:()=>z$t,content_3504_4664:()=>W$t,content_3504_4666:()=>I$t,content_3504_4668:()=>S$t,content_3504_4670:()=>B$t,content_3504_4672:()=>O$t,content_3504_4674:()=>F$t,content_3504_4676:()=>V$t,content_3504_4678:()=>H$t,content_3504_468:()=>QP,content_3504_4680:()=>Y$t,content_3504_4682:()=>K$t,content_3504_4684:()=>tKt,content_3504_4686:()=>eKt,content_3504_4688:()=>pKt,content_3504_4690:()=>sKt,content_3504_4692:()=>iKt,content_3504_4694:()=>lKt,content_3504_4696:()=>mKt,content_3504_4698:()=>hKt,content_3504_470:()=>$P,content_3504_4700:()=>kKt,content_3504_4702:()=>MKt,content_3504_4704:()=>wKt,content_3504_4706:()=>XKt,content_3504_4708:()=>TKt,content_3504_4710:()=>CKt,content_3504_4712:()=>LKt,content_3504_4714:()=>bKt,content_3504_4716:()=>zKt,content_3504_4718:()=>WKt,content_3504_472:()=>JP,content_3504_4720:()=>IKt,content_3504_4722:()=>SKt,content_3504_4724:()=>BKt,content_3504_4726:()=>OKt,content_3504_4728:()=>FKt,content_3504_4730:()=>VKt,content_3504_4732:()=>HKt,content_3504_4734:()=>YKt,content_3504_4736:()=>KKt,content_3504_4738:()=>tJt,content_3504_474:()=>nS,content_3504_4740:()=>eJt,content_3504_4742:()=>pJt,content_3504_4744:()=>sJt,content_3504_4746:()=>iJt,content_3504_4748:()=>lJt,content_3504_4750:()=>mJt,content_3504_4752:()=>hJt,content_3504_4754:()=>kJt,content_3504_4756:()=>MJt,content_3504_4758:()=>wJt,content_3504_476:()=>oS,content_3504_4760:()=>XJt,content_3504_4762:()=>TJt,content_3504_4764:()=>CJt,content_3504_4766:()=>LJt,content_3504_4768:()=>bJt,content_3504_4770:()=>zJt,content_3504_4772:()=>WJt,content_3504_4774:()=>IJt,content_3504_4776:()=>SJt,content_3504_4778:()=>BJt,content_3504_478:()=>rS,content_3504_4780:()=>OJt,content_3504_4782:()=>FJt,content_3504_4784:()=>VJt,content_3504_4786:()=>HJt,content_3504_4788:()=>YJt,content_3504_4790:()=>KJt,content_3504_4792:()=>t0t,content_3504_4794:()=>e0t,content_3504_4796:()=>p0t,content_3504_4798:()=>s0t,content_3504_48:()=>cb,content_3504_480:()=>cS,content_3504_4800:()=>i0t,content_3504_4802:()=>l0t,content_3504_4804:()=>m0t,content_3504_4806:()=>h0t,content_3504_4808:()=>k0t,content_3504_4810:()=>M0t,content_3504_4812:()=>w0t,content_3504_4814:()=>X0t,content_3504_4816:()=>T0t,content_3504_4818:()=>C0t,content_3504_482:()=>aS,content_3504_4820:()=>L0t,content_3504_4822:()=>b0t,content_3504_4824:()=>z0t,content_3504_4826:()=>W0t,content_3504_4828:()=>I0t,content_3504_4830:()=>S0t,content_3504_4832:()=>B0t,content_3504_4834:()=>O0t,content_3504_4836:()=>F0t,content_3504_4838:()=>V0t,content_3504_484:()=>uS,content_3504_4840:()=>H0t,content_3504_4842:()=>Y0t,content_3504_4844:()=>K0t,content_3504_4846:()=>t4t,content_3504_4848:()=>e4t,content_3504_4850:()=>p4t,content_3504_4852:()=>s4t,content_3504_4854:()=>i4t,content_3504_4856:()=>l4t,content_3504_4858:()=>m4t,content_3504_486:()=>dS,content_3504_4860:()=>h4t,content_3504_4862:()=>k4t,content_3504_4864:()=>M4t,content_3504_4866:()=>w4t,content_3504_4868:()=>X4t,content_3504_4870:()=>T4t,content_3504_4872:()=>C4t,content_3504_4874:()=>L4t,content_3504_4876:()=>b4t,content_3504_4878:()=>z4t,content_3504_488:()=>fS,content_3504_4880:()=>W4t,content_3504_4882:()=>I4t,content_3504_4884:()=>S4t,content_3504_4886:()=>B4t,content_3504_4888:()=>O4t,content_3504_4890:()=>F4t,content_3504_4892:()=>V4t,content_3504_4894:()=>H4t,content_3504_4896:()=>Y4t,content_3504_4898:()=>K4t,content_3504_490:()=>yS,content_3504_4900:()=>t3t,content_3504_4902:()=>e3t,content_3504_4904:()=>p3t,content_3504_4906:()=>s3t,content_3504_4908:()=>i3t,content_3504_4910:()=>l3t,content_3504_4912:()=>m3t,content_3504_4914:()=>h3t,content_3504_4916:()=>k3t,content_3504_4918:()=>M3t,content_3504_492:()=>DS,content_3504_4920:()=>w3t,content_3504_4922:()=>X3t,content_3504_4924:()=>T3t,content_3504_4926:()=>C3t,content_3504_4928:()=>L3t,content_3504_4930:()=>b3t,content_3504_4932:()=>z3t,content_3504_4934:()=>W3t,content_3504_4936:()=>I3t,content_3504_4938:()=>S3t,content_3504_494:()=>_S,content_3504_4940:()=>B3t,content_3504_4942:()=>O3t,content_3504_4944:()=>F3t,content_3504_4946:()=>V3t,content_3504_4948:()=>H3t,content_3504_4950:()=>Y3t,content_3504_4952:()=>K3t,content_3504_4954:()=>t5t,content_3504_4956:()=>e5t,content_3504_4958:()=>p5t,content_3504_496:()=>gS,content_3504_4960:()=>s5t,content_3504_4962:()=>i5t,content_3504_4964:()=>l5t,content_3504_4966:()=>m5t,content_3504_4968:()=>h5t,content_3504_4970:()=>k5t,content_3504_4972:()=>M5t,content_3504_4974:()=>w5t,content_3504_4976:()=>X5t,content_3504_4978:()=>T5t,content_3504_498:()=>xS,content_3504_4980:()=>C5t,content_3504_4982:()=>L5t,content_3504_4984:()=>b5t,content_3504_4986:()=>z5t,content_3504_4988:()=>W5t,content_3504_4990:()=>I5t,content_3504_4992:()=>S5t,content_3504_4994:()=>B5t,content_3504_4996:()=>O5t,content_3504_4998:()=>F5t,content_3504_50:()=>ab,content_3504_500:()=>vS,content_3504_5000:()=>V5t,content_3504_5002:()=>H5t,content_3504_5004:()=>Y5t,content_3504_5006:()=>K5t,content_3504_5008:()=>t2t,content_3504_5010:()=>e2t,content_3504_5012:()=>p2t,content_3504_5014:()=>s2t,content_3504_5016:()=>i2t,content_3504_5018:()=>l2t,content_3504_502:()=>ZS,content_3504_5020:()=>m2t,content_3504_5022:()=>h2t,content_3504_5024:()=>k2t,content_3504_5026:()=>M2t,content_3504_5028:()=>w2t,content_3504_5030:()=>X2t,content_3504_5032:()=>T2t,content_3504_5034:()=>C2t,content_3504_5036:()=>L2t,content_3504_5038:()=>b2t,content_3504_504:()=>NS,content_3504_5040:()=>z2t,content_3504_5042:()=>W2t,content_3504_5044:()=>I2t,content_3504_5046:()=>S2t,content_3504_5048:()=>B2t,content_3504_5050:()=>O2t,content_3504_5052:()=>F2t,content_3504_5054:()=>V2t,content_3504_5056:()=>H2t,content_3504_5058:()=>Y2t,content_3504_506:()=>AS,content_3504_5060:()=>K2t,content_3504_5062:()=>t1t,content_3504_5064:()=>e1t,content_3504_5066:()=>p1t,content_3504_5068:()=>s1t,content_3504_5070:()=>i1t,content_3504_5072:()=>l1t,content_3504_5074:()=>m1t,content_3504_5076:()=>h1t,content_3504_5078:()=>k1t,content_3504_508:()=>RS,content_3504_5080:()=>M1t,content_3504_5082:()=>w1t,content_3504_5084:()=>X1t,content_3504_5086:()=>T1t,content_3504_5088:()=>C1t,content_3504_5090:()=>L1t,content_3504_5092:()=>b1t,content_3504_5094:()=>z1t,content_3504_5096:()=>W1t,content_3504_5098:()=>I1t,content_3504_510:()=>PS,content_3504_5100:()=>S1t,content_3504_5102:()=>B1t,content_3504_5104:()=>O1t,content_3504_5106:()=>F1t,content_3504_5108:()=>V1t,content_3504_5110:()=>H1t,content_3504_5112:()=>Y1t,content_3504_5114:()=>K1t,content_3504_5116:()=>t6t,content_3504_5118:()=>e6t,content_3504_512:()=>ES,content_3504_5120:()=>p6t,content_3504_5122:()=>s6t,content_3504_5124:()=>i6t,content_3504_5126:()=>l6t,content_3504_5128:()=>m6t,content_3504_5130:()=>h6t,content_3504_5132:()=>k6t,content_3504_5134:()=>M6t,content_3504_5136:()=>w6t,content_3504_5138:()=>X6t,content_3504_514:()=>GS,content_3504_5140:()=>T6t,content_3504_5142:()=>C6t,content_3504_5144:()=>L6t,content_3504_5146:()=>b6t,content_3504_5148:()=>z6t,content_3504_5150:()=>W6t,content_3504_5152:()=>I6t,content_3504_5154:()=>S6t,content_3504_5156:()=>B6t,content_3504_5158:()=>O6t,content_3504_516:()=>US,content_3504_5160:()=>F6t,content_3504_5162:()=>V6t,content_3504_5164:()=>H6t,content_3504_5166:()=>Y6t,content_3504_5168:()=>K6t,content_3504_5170:()=>t8t,content_3504_5172:()=>e8t,content_3504_5174:()=>p8t,content_3504_5176:()=>s8t,content_3504_5178:()=>i8t,content_3504_518:()=>qS,content_3504_5180:()=>l8t,content_3504_5182:()=>m8t,content_3504_5184:()=>h8t,content_3504_5186:()=>k8t,content_3504_5188:()=>M8t,content_3504_5190:()=>w8t,content_3504_5192:()=>X8t,content_3504_5194:()=>T8t,content_3504_5196:()=>C8t,content_3504_5198:()=>L8t,content_3504_52:()=>ub,content_3504_520:()=>jS,content_3504_5200:()=>b8t,content_3504_5202:()=>z8t,content_3504_5204:()=>W8t,content_3504_5206:()=>I8t,content_3504_5208:()=>S8t,content_3504_5210:()=>B8t,content_3504_5212:()=>O8t,content_3504_5214:()=>F8t,content_3504_5216:()=>V8t,content_3504_5218:()=>H8t,content_3504_522:()=>QS,content_3504_5220:()=>Y8t,content_3504_5222:()=>K8t,content_3504_5224:()=>t7t,content_3504_5226:()=>e7t,content_3504_5228:()=>p7t,content_3504_5230:()=>s7t,content_3504_5232:()=>i7t,content_3504_5234:()=>l7t,content_3504_5236:()=>m7t,content_3504_5238:()=>h7t,content_3504_524:()=>$S,content_3504_5240:()=>k7t,content_3504_5242:()=>M7t,content_3504_5244:()=>w7t,content_3504_5246:()=>X7t,content_3504_5248:()=>T7t,content_3504_5250:()=>C7t,content_3504_5252:()=>L7t,content_3504_5254:()=>b7t,content_3504_5256:()=>z7t,content_3504_5258:()=>W7t,content_3504_526:()=>JS,content_3504_5260:()=>I7t,content_3504_5262:()=>S7t,content_3504_5264:()=>B7t,content_3504_5266:()=>O7t,content_3504_5268:()=>F7t,content_3504_5270:()=>V7t,content_3504_5272:()=>H7t,content_3504_5274:()=>Y7t,content_3504_5276:()=>K7t,content_3504_5278:()=>t9t,content_3504_528:()=>nE,content_3504_5280:()=>e9t,content_3504_5282:()=>p9t,content_3504_5284:()=>s9t,content_3504_5286:()=>i9t,content_3504_5288:()=>l9t,content_3504_5290:()=>m9t,content_3504_5292:()=>h9t,content_3504_5294:()=>k9t,content_3504_5296:()=>M9t,content_3504_5298:()=>w9t,content_3504_530:()=>oE,content_3504_5300:()=>X9t,content_3504_5302:()=>T9t,content_3504_5304:()=>C9t,content_3504_5306:()=>L9t,content_3504_5308:()=>b9t,content_3504_5310:()=>z9t,content_3504_5312:()=>W9t,content_3504_5314:()=>I9t,content_3504_5316:()=>S9t,content_3504_5318:()=>B9t,content_3504_532:()=>rE,content_3504_5320:()=>O9t,content_3504_5322:()=>F9t,content_3504_5324:()=>V9t,content_3504_5326:()=>H9t,content_3504_5328:()=>Y9t,content_3504_5330:()=>K9t,content_3504_5332:()=>ttn,content_3504_5334:()=>etn,content_3504_5336:()=>ptn,content_3504_5338:()=>stn,content_3504_534:()=>cE,content_3504_5340:()=>itn,content_3504_5342:()=>ltn,content_3504_5344:()=>mtn,content_3504_5346:()=>htn,content_3504_5348:()=>ktn,content_3504_5350:()=>Mtn,content_3504_5352:()=>wtn,content_3504_5354:()=>Xtn,content_3504_5356:()=>Ttn,content_3504_5358:()=>Ctn,content_3504_536:()=>aE,content_3504_5360:()=>Ltn,content_3504_5362:()=>btn,content_3504_5364:()=>ztn,content_3504_5366:()=>Wtn,content_3504_5368:()=>Itn,content_3504_5370:()=>Stn,content_3504_5372:()=>Btn,content_3504_5374:()=>Otn,content_3504_5376:()=>Ftn,content_3504_5378:()=>Vtn,content_3504_538:()=>uE,content_3504_5380:()=>Htn,content_3504_5382:()=>Ytn,content_3504_5384:()=>Ktn,content_3504_5386:()=>tnn,content_3504_5388:()=>enn,content_3504_5390:()=>pnn,content_3504_5392:()=>snn,content_3504_5394:()=>inn,content_3504_5396:()=>lnn,content_3504_5398:()=>mnn,content_3504_54:()=>db,content_3504_540:()=>dE,content_3504_5400:()=>hnn,content_3504_5402:()=>knn,content_3504_5404:()=>Mnn,content_3504_5406:()=>wnn,content_3504_5408:()=>Xnn,content_3504_5410:()=>Tnn,content_3504_5412:()=>Cnn,content_3504_5414:()=>Lnn,content_3504_5416:()=>bnn,content_3504_5418:()=>znn,content_3504_542:()=>fE,content_3504_5420:()=>Wnn,content_3504_5422:()=>Inn,content_3504_5424:()=>Snn,content_3504_5426:()=>Bnn,content_3504_5428:()=>Onn,content_3504_5430:()=>Fnn,content_3504_5432:()=>Vnn,content_3504_5434:()=>Hnn,content_3504_5436:()=>Ynn,content_3504_5438:()=>Knn,content_3504_544:()=>yE,content_3504_5440:()=>ten,content_3504_5442:()=>een,content_3504_5444:()=>pen,content_3504_5446:()=>sen,content_3504_5448:()=>ien,content_3504_5450:()=>len,content_3504_5452:()=>men,content_3504_5454:()=>hen,content_3504_5456:()=>ken,content_3504_5458:()=>Men,content_3504_546:()=>DE,content_3504_5460:()=>wen,content_3504_5462:()=>Xen,content_3504_5464:()=>Ten,content_3504_5466:()=>Cen,content_3504_5468:()=>Len,content_3504_5470:()=>ben,content_3504_5472:()=>zen,content_3504_5474:()=>Wen,content_3504_5476:()=>Ien,content_3504_5478:()=>Sen,content_3504_548:()=>_E,content_3504_5480:()=>Ben,content_3504_5482:()=>Oen,content_3504_5484:()=>Fen,content_3504_5486:()=>Ven,content_3504_5488:()=>Hen,content_3504_5490:()=>Yen,content_3504_5492:()=>Ken,content_3504_5494:()=>ton,content_3504_5496:()=>eon,content_3504_5498:()=>pon,content_3504_550:()=>gE,content_3504_5500:()=>son,content_3504_5502:()=>ion,content_3504_5504:()=>lon,content_3504_5506:()=>mon,content_3504_5508:()=>hon,content_3504_5510:()=>kon,content_3504_5512:()=>Mon,content_3504_5514:()=>won,content_3504_5516:()=>Xon,content_3504_5518:()=>Ton,content_3504_552:()=>xE,content_3504_5520:()=>Con,content_3504_5522:()=>Lon,content_3504_5524:()=>bon,content_3504_5526:()=>zon,content_3504_5528:()=>Won,content_3504_5530:()=>Ion,content_3504_5532:()=>Son,content_3504_5534:()=>Bon,content_3504_5536:()=>Oon,content_3504_5538:()=>Fon,content_3504_554:()=>vE,content_3504_5540:()=>Von,content_3504_5542:()=>Hon,content_3504_5544:()=>Yon,content_3504_5546:()=>Kon,content_3504_5548:()=>tpn,content_3504_5550:()=>epn,content_3504_5552:()=>ppn,content_3504_5554:()=>spn,content_3504_5556:()=>ipn,content_3504_5558:()=>lpn,content_3504_556:()=>ZE,content_3504_5560:()=>mpn,content_3504_5562:()=>hpn,content_3504_5564:()=>kpn,content_3504_5566:()=>Mpn,content_3504_5568:()=>wpn,content_3504_5570:()=>Xpn,content_3504_5572:()=>Tpn,content_3504_5574:()=>Cpn,content_3504_5576:()=>Lpn,content_3504_5578:()=>bpn,content_3504_558:()=>NE,content_3504_5580:()=>zpn,content_3504_5582:()=>Wpn,content_3504_5584:()=>Ipn,content_3504_5586:()=>Spn,content_3504_5588:()=>Bpn,content_3504_5590:()=>Opn,content_3504_5592:()=>Fpn,content_3504_5594:()=>Vpn,content_3504_5596:()=>Hpn,content_3504_5598:()=>Ypn,content_3504_56:()=>fb,content_3504_560:()=>AE,content_3504_5600:()=>Kpn,content_3504_5602:()=>trn,content_3504_5604:()=>ern,content_3504_5606:()=>prn,content_3504_5608:()=>srn,content_3504_5610:()=>irn,content_3504_5612:()=>lrn,content_3504_5614:()=>mrn,content_3504_5616:()=>hrn,content_3504_5618:()=>krn,content_3504_562:()=>RE,content_3504_5620:()=>Mrn,content_3504_5622:()=>wrn,content_3504_5624:()=>Xrn,content_3504_5626:()=>Trn,content_3504_5628:()=>Crn,content_3504_5630:()=>Lrn,content_3504_5632:()=>brn,content_3504_5634:()=>zrn,content_3504_5636:()=>Wrn,content_3504_5638:()=>Irn,content_3504_564:()=>PE,content_3504_5640:()=>Srn,content_3504_5642:()=>Brn,content_3504_5644:()=>Orn,content_3504_5646:()=>Frn,content_3504_5648:()=>Vrn,content_3504_5650:()=>Hrn,content_3504_5652:()=>Yrn,content_3504_5654:()=>Krn,content_3504_5656:()=>tsn,content_3504_5658:()=>esn,content_3504_566:()=>EE,content_3504_5660:()=>psn,content_3504_5662:()=>ssn,content_3504_5664:()=>isn,content_3504_5666:()=>lsn,content_3504_5668:()=>msn,content_3504_5670:()=>hsn,content_3504_5672:()=>ksn,content_3504_5674:()=>Msn,content_3504_5676:()=>wsn,content_3504_5678:()=>Xsn,content_3504_568:()=>GE,content_3504_5680:()=>Tsn,content_3504_5682:()=>Csn,content_3504_5684:()=>Lsn,content_3504_5686:()=>bsn,content_3504_5688:()=>zsn,content_3504_5690:()=>Wsn,content_3504_5692:()=>Isn,content_3504_5694:()=>Ssn,content_3504_5696:()=>Bsn,content_3504_5698:()=>Osn,content_3504_570:()=>UE,content_3504_5700:()=>Fsn,content_3504_5702:()=>Vsn,content_3504_5704:()=>Hsn,content_3504_5706:()=>Ysn,content_3504_5708:()=>Ksn,content_3504_5710:()=>tcn,content_3504_5712:()=>ecn,content_3504_5714:()=>pcn,content_3504_5716:()=>scn,content_3504_5718:()=>icn,content_3504_572:()=>qE,content_3504_5720:()=>lcn,content_3504_5722:()=>mcn,content_3504_5724:()=>hcn,content_3504_5726:()=>kcn,content_3504_5728:()=>Mcn,content_3504_5730:()=>wcn,content_3504_5732:()=>Xcn,content_3504_5734:()=>Tcn,content_3504_5736:()=>Ccn,content_3504_5738:()=>Lcn,content_3504_574:()=>jE,content_3504_5740:()=>bcn,content_3504_5742:()=>zcn,content_3504_5744:()=>Wcn,content_3504_5746:()=>Icn,content_3504_5748:()=>Scn,content_3504_5750:()=>Bcn,content_3504_5752:()=>Ocn,content_3504_5754:()=>Fcn,content_3504_5756:()=>Vcn,content_3504_5758:()=>Hcn,content_3504_576:()=>QE,content_3504_5760:()=>Ycn,content_3504_5762:()=>Kcn,content_3504_5764:()=>tin,content_3504_5766:()=>ein,content_3504_5768:()=>pin,content_3504_5770:()=>sin,content_3504_5772:()=>iin,content_3504_5774:()=>lin,content_3504_5776:()=>min,content_3504_5778:()=>hin,content_3504_578:()=>$E,content_3504_5780:()=>kin,content_3504_5782:()=>Min,content_3504_5784:()=>win,content_3504_5786:()=>Xin,content_3504_5788:()=>Tin,content_3504_5790:()=>Cin,content_3504_5792:()=>Lin,content_3504_5794:()=>bin,content_3504_5796:()=>zin,content_3504_5798:()=>Win,content_3504_58:()=>yb,content_3504_580:()=>JE,content_3504_5800:()=>Iin,content_3504_5802:()=>Sin,content_3504_5804:()=>Bin,content_3504_5806:()=>Oin,content_3504_5808:()=>Fin,content_3504_5810:()=>Vin,content_3504_5812:()=>Hin,content_3504_5814:()=>Yin,content_3504_5816:()=>Kin,content_3504_5818:()=>tan,content_3504_582:()=>nB,content_3504_5820:()=>ean,content_3504_5822:()=>pan,content_3504_5824:()=>san,content_3504_5826:()=>ian,content_3504_5828:()=>lan,content_3504_5830:()=>man,content_3504_5832:()=>han,content_3504_5834:()=>kan,content_3504_5836:()=>Man,content_3504_5838:()=>wan,content_3504_584:()=>oB,content_3504_5840:()=>Xan,content_3504_5842:()=>Tan,content_3504_5844:()=>Can,content_3504_5846:()=>Lan,content_3504_5848:()=>ban,content_3504_5850:()=>zan,content_3504_5852:()=>Wan,content_3504_5854:()=>Ian,content_3504_5856:()=>San,content_3504_5858:()=>Ban,content_3504_586:()=>rB,content_3504_5860:()=>Oan,content_3504_5862:()=>Fan,content_3504_5864:()=>Van,content_3504_5866:()=>Han,content_3504_5868:()=>Yan,content_3504_5870:()=>Kan,content_3504_5872:()=>tln,content_3504_5874:()=>eln,content_3504_5876:()=>pln,content_3504_5878:()=>sln,content_3504_588:()=>cB,content_3504_5880:()=>iln,content_3504_5882:()=>lln,content_3504_5884:()=>mln,content_3504_5886:()=>hln,content_3504_5888:()=>kln,content_3504_5890:()=>Mln,content_3504_5892:()=>wln,content_3504_5894:()=>Xln,content_3504_5896:()=>Tln,content_3504_5898:()=>Cln,content_3504_590:()=>aB,content_3504_5900:()=>Lln,content_3504_5902:()=>bln,content_3504_5904:()=>zln,content_3504_5906:()=>Wln,content_3504_5908:()=>Iln,content_3504_5910:()=>Sln,content_3504_5912:()=>Bln,content_3504_5914:()=>Oln,content_3504_5916:()=>Fln,content_3504_5918:()=>Vln,content_3504_592:()=>uB,content_3504_5920:()=>Hln,content_3504_5922:()=>Yln,content_3504_5924:()=>Kln,content_3504_5926:()=>tun,content_3504_5928:()=>eun,content_3504_5930:()=>pun,content_3504_5932:()=>sun,content_3504_5934:()=>iun,content_3504_5936:()=>lun,content_3504_5938:()=>mun,content_3504_594:()=>dB,content_3504_5940:()=>hun,content_3504_5942:()=>kun,content_3504_5944:()=>Mun,content_3504_5946:()=>wun,content_3504_5948:()=>Xun,content_3504_5950:()=>Tun,content_3504_5952:()=>Cun,content_3504_5954:()=>Lun,content_3504_5956:()=>bun,content_3504_5958:()=>zun,content_3504_596:()=>fB,content_3504_5960:()=>Wun,content_3504_5962:()=>Iun,content_3504_5964:()=>Sun,content_3504_5966:()=>Bun,content_3504_5968:()=>Oun,content_3504_5970:()=>Fun,content_3504_5972:()=>Vun,content_3504_5974:()=>Hun,content_3504_5976:()=>Yun,content_3504_5978:()=>Kun,content_3504_598:()=>yB,content_3504_5980:()=>tmn,content_3504_5982:()=>emn,content_3504_5984:()=>pmn,content_3504_5986:()=>smn,content_3504_5988:()=>imn,content_3504_5990:()=>lmn,content_3504_5992:()=>mmn,content_3504_5994:()=>hmn,content_3504_5996:()=>kmn,content_3504_5998:()=>Mmn,content_3504_6:()=>DZ,content_3504_60:()=>Db,content_3504_600:()=>DB,content_3504_6000:()=>wmn,content_3504_6002:()=>Xmn,content_3504_6004:()=>Tmn,content_3504_6006:()=>Cmn,content_3504_6008:()=>Lmn,content_3504_6010:()=>bmn,content_3504_6012:()=>zmn,content_3504_6014:()=>Wmn,content_3504_6016:()=>Imn,content_3504_6018:()=>Smn,content_3504_602:()=>_B,content_3504_6020:()=>Bmn,content_3504_6022:()=>Omn,content_3504_6024:()=>Fmn,content_3504_6026:()=>Vmn,content_3504_6028:()=>Hmn,content_3504_6030:()=>Ymn,content_3504_6032:()=>Kmn,content_3504_6034:()=>tdn,content_3504_6036:()=>edn,content_3504_6038:()=>pdn,content_3504_604:()=>gB,content_3504_6040:()=>sdn,content_3504_6042:()=>idn,content_3504_6044:()=>ldn,content_3504_6046:()=>mdn,content_3504_6048:()=>hdn,content_3504_6050:()=>kdn,content_3504_6052:()=>Mdn,content_3504_6054:()=>wdn,content_3504_6056:()=>Xdn,content_3504_6058:()=>Tdn,content_3504_606:()=>xB,content_3504_6060:()=>Cdn,content_3504_6062:()=>Ldn,content_3504_6064:()=>bdn,content_3504_6066:()=>zdn,content_3504_6068:()=>Wdn,content_3504_6070:()=>Idn,content_3504_6072:()=>Sdn,content_3504_6074:()=>Bdn,content_3504_6076:()=>Odn,content_3504_6078:()=>Fdn,content_3504_608:()=>vB,content_3504_6080:()=>Vdn,content_3504_6082:()=>Hdn,content_3504_6084:()=>Ydn,content_3504_6086:()=>Kdn,content_3504_6088:()=>thn,content_3504_6090:()=>ehn,content_3504_6092:()=>phn,content_3504_6094:()=>shn,content_3504_6096:()=>ihn,content_3504_6098:()=>lhn,content_3504_610:()=>ZB,content_3504_6100:()=>mhn,content_3504_6102:()=>hhn,content_3504_6104:()=>khn,content_3504_6106:()=>Mhn,content_3504_6108:()=>whn,content_3504_6110:()=>Xhn,content_3504_6112:()=>Thn,content_3504_6114:()=>Chn,content_3504_6116:()=>Lhn,content_3504_6118:()=>bhn,content_3504_612:()=>NB,content_3504_6120:()=>zhn,content_3504_6122:()=>Whn,content_3504_6124:()=>Ihn,content_3504_6126:()=>Shn,content_3504_6128:()=>Bhn,content_3504_6130:()=>Ohn,content_3504_6132:()=>Fhn,content_3504_6134:()=>Vhn,content_3504_6136:()=>Hhn,content_3504_6138:()=>Yhn,content_3504_614:()=>AB,content_3504_6140:()=>Khn,content_3504_6142:()=>tfn,content_3504_6144:()=>efn,content_3504_6146:()=>pfn,content_3504_6148:()=>sfn,content_3504_6150:()=>ifn,content_3504_6152:()=>lfn,content_3504_6154:()=>mfn,content_3504_6156:()=>hfn,content_3504_6158:()=>kfn,content_3504_616:()=>RB,content_3504_6160:()=>Mfn,content_3504_6162:()=>wfn,content_3504_6164:()=>Xfn,content_3504_6166:()=>Tfn,content_3504_6168:()=>Cfn,content_3504_6170:()=>Lfn,content_3504_6172:()=>bfn,content_3504_6174:()=>zfn,content_3504_6176:()=>Wfn,content_3504_6178:()=>Ifn,content_3504_618:()=>PB,content_3504_6180:()=>Sfn,content_3504_6182:()=>Bfn,content_3504_6184:()=>Ofn,content_3504_6186:()=>Ffn,content_3504_6188:()=>Vfn,content_3504_6190:()=>Hfn,content_3504_6192:()=>Yfn,content_3504_6194:()=>Kfn,content_3504_6196:()=>tkn,content_3504_6198:()=>ekn,content_3504_62:()=>_b,content_3504_620:()=>EB,content_3504_6200:()=>pkn,content_3504_6202:()=>skn,content_3504_6204:()=>ikn,content_3504_6206:()=>lkn,content_3504_6208:()=>mkn,content_3504_6210:()=>hkn,content_3504_6212:()=>kkn,content_3504_6214:()=>Mkn,content_3504_6216:()=>wkn,content_3504_6218:()=>Xkn,content_3504_622:()=>GB,content_3504_6220:()=>Tkn,content_3504_6222:()=>Ckn,content_3504_6224:()=>Lkn,content_3504_6226:()=>bkn,content_3504_6228:()=>zkn,content_3504_6230:()=>Wkn,content_3504_6232:()=>Ikn,content_3504_6234:()=>Skn,content_3504_6236:()=>Bkn,content_3504_6238:()=>Okn,content_3504_624:()=>UB,content_3504_6240:()=>Fkn,content_3504_6242:()=>Vkn,content_3504_6244:()=>Hkn,content_3504_6246:()=>Ykn,content_3504_6248:()=>Kkn,content_3504_6250:()=>tyn,content_3504_6252:()=>eyn,content_3504_6254:()=>pyn,content_3504_6256:()=>syn,content_3504_6258:()=>iyn,content_3504_626:()=>qB,content_3504_6260:()=>lyn,content_3504_6262:()=>myn,content_3504_6264:()=>hyn,content_3504_6266:()=>kyn,content_3504_6268:()=>Myn,content_3504_6270:()=>wyn,content_3504_6272:()=>Xyn,content_3504_6274:()=>Tyn,content_3504_6276:()=>Cyn,content_3504_6278:()=>Lyn,content_3504_628:()=>jB,content_3504_6280:()=>byn,content_3504_6282:()=>zyn,content_3504_6284:()=>Wyn,content_3504_6286:()=>Iyn,content_3504_6288:()=>Syn,content_3504_6290:()=>Byn,content_3504_6292:()=>Oyn,content_3504_6294:()=>Fyn,content_3504_6296:()=>Vyn,content_3504_6298:()=>Hyn,content_3504_630:()=>QB,content_3504_6300:()=>Yyn,content_3504_6302:()=>Kyn,content_3504_6304:()=>tMn,content_3504_6306:()=>eMn,content_3504_6308:()=>pMn,content_3504_6310:()=>sMn,content_3504_6312:()=>iMn,content_3504_6314:()=>lMn,content_3504_6316:()=>mMn,content_3504_6318:()=>hMn,content_3504_632:()=>$B,content_3504_6320:()=>kMn,content_3504_6322:()=>MMn,content_3504_6324:()=>wMn,content_3504_6326:()=>XMn,content_3504_6328:()=>TMn,content_3504_6330:()=>CMn,content_3504_6332:()=>LMn,content_3504_6334:()=>bMn,content_3504_6336:()=>zMn,content_3504_6338:()=>WMn,content_3504_634:()=>JB,content_3504_6340:()=>IMn,content_3504_6342:()=>SMn,content_3504_6344:()=>BMn,content_3504_6346:()=>OMn,content_3504_6348:()=>FMn,content_3504_6350:()=>VMn,content_3504_6352:()=>HMn,content_3504_6354:()=>YMn,content_3504_6356:()=>KMn,content_3504_6358:()=>tDn,content_3504_636:()=>nG,content_3504_6360:()=>eDn,content_3504_6362:()=>pDn,content_3504_6364:()=>sDn,content_3504_6366:()=>iDn,content_3504_6368:()=>lDn,content_3504_6370:()=>mDn,content_3504_6372:()=>hDn,content_3504_6374:()=>kDn,content_3504_6376:()=>MDn,content_3504_6378:()=>wDn,content_3504_638:()=>oG,content_3504_6380:()=>XDn,content_3504_6382:()=>TDn,content_3504_6384:()=>CDn,content_3504_6386:()=>LDn,content_3504_6388:()=>bDn,content_3504_6390:()=>zDn,content_3504_6392:()=>WDn,content_3504_6394:()=>IDn,content_3504_6396:()=>SDn,content_3504_6398:()=>BDn,content_3504_64:()=>gb,content_3504_640:()=>rG,content_3504_6400:()=>ODn,content_3504_6402:()=>FDn,content_3504_6404:()=>VDn,content_3504_6406:()=>HDn,content_3504_6408:()=>YDn,content_3504_6410:()=>KDn,content_3504_6412:()=>twn,content_3504_6414:()=>ewn,content_3504_6416:()=>pwn,content_3504_6418:()=>swn,content_3504_642:()=>cG,content_3504_6420:()=>iwn,content_3504_6422:()=>lwn,content_3504_6424:()=>mwn,content_3504_6426:()=>hwn,content_3504_6428:()=>kwn,content_3504_6430:()=>Mwn,content_3504_6432:()=>wwn,content_3504_6434:()=>Xwn,content_3504_6436:()=>Twn,content_3504_6438:()=>Cwn,content_3504_644:()=>aG,content_3504_6440:()=>Lwn,content_3504_6442:()=>bwn,content_3504_6444:()=>zwn,content_3504_6446:()=>Wwn,content_3504_6448:()=>Iwn,content_3504_6450:()=>Swn,content_3504_6452:()=>Bwn,content_3504_6454:()=>Own,content_3504_6456:()=>Fwn,content_3504_6458:()=>Vwn,content_3504_646:()=>uG,content_3504_6460:()=>Hwn,content_3504_6462:()=>Ywn,content_3504_6464:()=>Kwn,content_3504_6466:()=>t_n,content_3504_6468:()=>e_n,content_3504_6470:()=>p_n,content_3504_6472:()=>s_n,content_3504_6474:()=>i_n,content_3504_6476:()=>l_n,content_3504_6478:()=>m_n,content_3504_648:()=>dG,content_3504_6480:()=>h_n,content_3504_6482:()=>k_n,content_3504_6484:()=>M_n,content_3504_6486:()=>w_n,content_3504_6488:()=>X_n,content_3504_6490:()=>T_n,content_3504_6492:()=>C_n,content_3504_6494:()=>L_n,content_3504_6496:()=>b_n,content_3504_6498:()=>z_n,content_3504_650:()=>fG,content_3504_6500:()=>W_n,content_3504_6502:()=>I_n,content_3504_6504:()=>S_n,content_3504_6506:()=>B_n,content_3504_6508:()=>O_n,content_3504_6510:()=>F_n,content_3504_6512:()=>V_n,content_3504_6514:()=>H_n,content_3504_6516:()=>Y_n,content_3504_6518:()=>K_n,content_3504_652:()=>yG,content_3504_6520:()=>tXn,content_3504_6522:()=>eXn,content_3504_6524:()=>pXn,content_3504_6526:()=>sXn,content_3504_6528:()=>iXn,content_3504_6530:()=>lXn,content_3504_6532:()=>mXn,content_3504_6534:()=>hXn,content_3504_6536:()=>kXn,content_3504_6538:()=>MXn,content_3504_654:()=>DG,content_3504_6540:()=>wXn,content_3504_6542:()=>XXn,content_3504_6544:()=>TXn,content_3504_6546:()=>CXn,content_3504_6548:()=>LXn,content_3504_6550:()=>bXn,content_3504_6552:()=>zXn,content_3504_6554:()=>WXn,content_3504_6556:()=>IXn,content_3504_6558:()=>SXn,content_3504_656:()=>_G,content_3504_6560:()=>BXn,content_3504_6562:()=>OXn,content_3504_6564:()=>FXn,content_3504_6566:()=>VXn,content_3504_6568:()=>HXn,content_3504_6570:()=>YXn,content_3504_6572:()=>KXn,content_3504_6574:()=>tgn,content_3504_6576:()=>egn,content_3504_6578:()=>pgn,content_3504_658:()=>gG,content_3504_6580:()=>sgn,content_3504_6582:()=>ign,content_3504_6584:()=>lgn,content_3504_6586:()=>mgn,content_3504_6588:()=>hgn,content_3504_6590:()=>kgn,content_3504_6592:()=>Mgn,content_3504_6594:()=>wgn,content_3504_6596:()=>Xgn,content_3504_6598:()=>Tgn,content_3504_66:()=>xb,content_3504_660:()=>xG,content_3504_6600:()=>Cgn,content_3504_6602:()=>Lgn,content_3504_6604:()=>bgn,content_3504_6606:()=>zgn,content_3504_6608:()=>Wgn,content_3504_6610:()=>Ign,content_3504_6612:()=>Sgn,content_3504_6614:()=>Bgn,content_3504_6616:()=>Ogn,content_3504_6618:()=>Fgn,content_3504_662:()=>vG,content_3504_6620:()=>Vgn,content_3504_6622:()=>Hgn,content_3504_6624:()=>Ygn,content_3504_6626:()=>Kgn,content_3504_6628:()=>tTn,content_3504_6630:()=>eTn,content_3504_6632:()=>pTn,content_3504_6634:()=>sTn,content_3504_6636:()=>iTn,content_3504_6638:()=>lTn,content_3504_664:()=>ZG,content_3504_6640:()=>mTn,content_3504_6642:()=>hTn,content_3504_6644:()=>kTn,content_3504_6646:()=>MTn,content_3504_6648:()=>wTn,content_3504_6650:()=>XTn,content_3504_6652:()=>TTn,content_3504_6654:()=>CTn,content_3504_6656:()=>LTn,content_3504_6658:()=>bTn,content_3504_666:()=>NG,content_3504_6660:()=>zTn,content_3504_6662:()=>WTn,content_3504_6664:()=>ITn,content_3504_6666:()=>STn,content_3504_6668:()=>BTn,content_3504_6670:()=>OTn,content_3504_6672:()=>FTn,content_3504_6674:()=>VTn,content_3504_6676:()=>HTn,content_3504_6678:()=>YTn,content_3504_668:()=>AG,content_3504_6680:()=>KTn,content_3504_6682:()=>txn,content_3504_6684:()=>exn,content_3504_6686:()=>pxn,content_3504_6688:()=>sxn,content_3504_6690:()=>ixn,content_3504_6692:()=>lxn,content_3504_6694:()=>mxn,content_3504_6696:()=>hxn,content_3504_6698:()=>kxn,content_3504_670:()=>RG,content_3504_6700:()=>Mxn,content_3504_6702:()=>wxn,content_3504_6704:()=>Xxn,content_3504_6706:()=>Txn,content_3504_6708:()=>Cxn,content_3504_6710:()=>Lxn,content_3504_6712:()=>bxn,content_3504_6714:()=>zxn,content_3504_6716:()=>Wxn,content_3504_6718:()=>Ixn,content_3504_672:()=>PG,content_3504_6720:()=>Sxn,content_3504_6722:()=>Bxn,content_3504_6724:()=>Oxn,content_3504_6726:()=>Fxn,content_3504_6728:()=>Vxn,content_3504_6730:()=>Hxn,content_3504_6732:()=>Yxn,content_3504_6734:()=>Kxn,content_3504_6736:()=>tCn,content_3504_6738:()=>eCn,content_3504_674:()=>EG,content_3504_6740:()=>pCn,content_3504_6742:()=>sCn,content_3504_6744:()=>iCn,content_3504_6746:()=>lCn,content_3504_6748:()=>mCn,content_3504_6750:()=>hCn,content_3504_6752:()=>kCn,content_3504_6754:()=>MCn,content_3504_6756:()=>wCn,content_3504_6758:()=>XCn,content_3504_676:()=>GG,content_3504_6760:()=>TCn,content_3504_6762:()=>CCn,content_3504_6764:()=>LCn,content_3504_6766:()=>bCn,content_3504_6768:()=>zCn,content_3504_6770:()=>WCn,content_3504_6772:()=>ICn,content_3504_6774:()=>SCn,content_3504_6776:()=>BCn,content_3504_6778:()=>OCn,content_3504_678:()=>UG,content_3504_6780:()=>FCn,content_3504_6782:()=>VCn,content_3504_6784:()=>HCn,content_3504_6786:()=>YCn,content_3504_6788:()=>KCn,content_3504_6790:()=>tvn,content_3504_6792:()=>evn,content_3504_6794:()=>pvn,content_3504_6796:()=>svn,content_3504_6798:()=>ivn,content_3504_68:()=>vb,content_3504_680:()=>qG,content_3504_6800:()=>lvn,content_3504_6802:()=>mvn,content_3504_6804:()=>hvn,content_3504_6806:()=>kvn,content_3504_6808:()=>Mvn,content_3504_6810:()=>wvn,content_3504_6812:()=>Xvn,content_3504_6814:()=>Tvn,content_3504_6816:()=>Cvn,content_3504_6818:()=>Lvn,content_3504_682:()=>jG,content_3504_6820:()=>bvn,content_3504_6822:()=>zvn,content_3504_6824:()=>Wvn,content_3504_6826:()=>Ivn,content_3504_6828:()=>Svn,content_3504_6830:()=>Bvn,content_3504_6832:()=>Ovn,content_3504_6834:()=>Fvn,content_3504_6836:()=>Vvn,content_3504_6838:()=>Hvn,content_3504_684:()=>QG,content_3504_6840:()=>Yvn,content_3504_6842:()=>Kvn,content_3504_6844:()=>tLn,content_3504_6846:()=>eLn,content_3504_6848:()=>pLn,content_3504_6850:()=>sLn,content_3504_6852:()=>iLn,content_3504_6854:()=>lLn,content_3504_6856:()=>mLn,content_3504_6858:()=>hLn,content_3504_686:()=>$G,content_3504_6860:()=>kLn,content_3504_6862:()=>MLn,content_3504_6864:()=>wLn,content_3504_6866:()=>XLn,content_3504_6868:()=>TLn,content_3504_6870:()=>CLn,content_3504_6872:()=>LLn,content_3504_6874:()=>bLn,content_3504_6876:()=>zLn,content_3504_6878:()=>WLn,content_3504_688:()=>JG,content_3504_6880:()=>ILn,content_3504_6882:()=>SLn,content_3504_6884:()=>BLn,content_3504_6886:()=>OLn,content_3504_6888:()=>FLn,content_3504_6890:()=>VLn,content_3504_6892:()=>HLn,content_3504_6894:()=>YLn,content_3504_6896:()=>KLn,content_3504_6898:()=>tZn,content_3504_690:()=>nO,content_3504_6900:()=>eZn,content_3504_6902:()=>pZn,content_3504_6904:()=>sZn,content_3504_6906:()=>iZn,content_3504_6908:()=>lZn,content_3504_6910:()=>mZn,content_3504_6912:()=>hZn,content_3504_6914:()=>kZn,content_3504_6916:()=>MZn,content_3504_6918:()=>wZn,content_3504_692:()=>oO,content_3504_6920:()=>XZn,content_3504_6922:()=>TZn,content_3504_6924:()=>CZn,content_3504_6926:()=>LZn,content_3504_6928:()=>bZn,content_3504_6930:()=>zZn,content_3504_6932:()=>WZn,content_3504_6934:()=>IZn,content_3504_6936:()=>SZn,content_3504_6938:()=>BZn,content_3504_694:()=>rO,content_3504_6940:()=>OZn,content_3504_6942:()=>FZn,content_3504_6944:()=>VZn,content_3504_6946:()=>HZn,content_3504_6948:()=>YZn,content_3504_6950:()=>KZn,content_3504_6952:()=>tbn,content_3504_6954:()=>ebn,content_3504_6956:()=>pbn,content_3504_6958:()=>sbn,content_3504_696:()=>cO,content_3504_6960:()=>ibn,content_3504_6962:()=>lbn,content_3504_6964:()=>mbn,content_3504_6966:()=>hbn,content_3504_6968:()=>kbn,content_3504_6970:()=>Mbn,content_3504_6972:()=>wbn,content_3504_6974:()=>Xbn,content_3504_6976:()=>Tbn,content_3504_6978:()=>Cbn,content_3504_698:()=>aO,content_3504_6980:()=>Lbn,content_3504_6982:()=>bbn,content_3504_6984:()=>zbn,content_3504_6986:()=>Wbn,content_3504_6988:()=>Ibn,content_3504_6990:()=>Sbn,content_3504_6992:()=>Bbn,content_3504_6994:()=>Obn,content_3504_6996:()=>Fbn,content_3504_6998:()=>Vbn,content_3504_70:()=>Zb,content_3504_700:()=>uO,content_3504_7000:()=>Hbn,content_3504_7002:()=>Ybn,content_3504_7004:()=>Kbn,content_3504_7006:()=>tNn,content_3504_7008:()=>eNn,content_3504_7010:()=>pNn,content_3504_7012:()=>sNn,content_3504_7014:()=>iNn,content_3504_7016:()=>lNn,content_3504_7018:()=>mNn,content_3504_702:()=>dO,content_3504_7020:()=>hNn,content_3504_7022:()=>kNn,content_3504_7024:()=>MNn,content_3504_7026:()=>wNn,content_3504_7028:()=>XNn,content_3504_7030:()=>TNn,content_3504_7032:()=>CNn,content_3504_7034:()=>LNn,content_3504_7036:()=>bNn,content_3504_7038:()=>zNn,content_3504_704:()=>fO,content_3504_7040:()=>WNn,content_3504_7042:()=>INn,content_3504_7044:()=>SNn,content_3504_7046:()=>BNn,content_3504_7048:()=>ONn,content_3504_7050:()=>FNn,content_3504_7052:()=>VNn,content_3504_7054:()=>HNn,content_3504_7056:()=>YNn,content_3504_7058:()=>KNn,content_3504_706:()=>yO,content_3504_7060:()=>tzn,content_3504_7062:()=>ezn,content_3504_7064:()=>pzn,content_3504_7066:()=>szn,content_3504_7068:()=>izn,content_3504_7070:()=>lzn,content_3504_7072:()=>mzn,content_3504_7074:()=>hzn,content_3504_7076:()=>kzn,content_3504_7078:()=>Mzn,content_3504_708:()=>DO,content_3504_7080:()=>wzn,content_3504_7082:()=>Xzn,content_3504_7084:()=>Tzn,content_3504_7086:()=>Czn,content_3504_7088:()=>Lzn,content_3504_7090:()=>bzn,content_3504_7092:()=>zzn,content_3504_7094:()=>Wzn,content_3504_7096:()=>Izn,content_3504_7098:()=>Szn,content_3504_710:()=>_O,content_3504_7100:()=>Bzn,content_3504_7102:()=>Ozn,content_3504_7104:()=>Fzn,content_3504_7106:()=>Vzn,content_3504_7108:()=>Hzn,content_3504_7110:()=>Yzn,content_3504_7112:()=>Kzn,content_3504_7114:()=>tAn,content_3504_7116:()=>eAn,content_3504_7118:()=>pAn,content_3504_712:()=>gO,content_3504_7120:()=>sAn,content_3504_7122:()=>iAn,content_3504_7124:()=>lAn,content_3504_7126:()=>mAn,content_3504_7128:()=>hAn,content_3504_7130:()=>kAn,content_3504_7132:()=>MAn,content_3504_7134:()=>wAn,content_3504_7136:()=>XAn,content_3504_7138:()=>TAn,content_3504_714:()=>xO,content_3504_7140:()=>CAn,content_3504_7142:()=>LAn,content_3504_7144:()=>bAn,content_3504_7146:()=>zAn,content_3504_7148:()=>WAn,content_3504_7150:()=>IAn,content_3504_7152:()=>SAn,content_3504_7154:()=>BAn,content_3504_7156:()=>OAn,content_3504_7158:()=>FAn,content_3504_716:()=>vO,content_3504_7160:()=>VAn,content_3504_7162:()=>HAn,content_3504_7164:()=>YAn,content_3504_7166:()=>KAn,content_3504_7168:()=>tWn,content_3504_7170:()=>eWn,content_3504_7172:()=>pWn,content_3504_7174:()=>sWn,content_3504_7176:()=>iWn,content_3504_7178:()=>lWn,content_3504_718:()=>ZO,content_3504_7180:()=>mWn,content_3504_7182:()=>hWn,content_3504_7184:()=>kWn,content_3504_7186:()=>MWn,content_3504_7188:()=>wWn,content_3504_7190:()=>XWn,content_3504_7192:()=>TWn,content_3504_7194:()=>CWn,content_3504_7196:()=>LWn,content_3504_7198:()=>bWn,content_3504_72:()=>Nb,content_3504_720:()=>NO,content_3504_7200:()=>zWn,content_3504_7202:()=>WWn,content_3504_7204:()=>IWn,content_3504_7206:()=>SWn,content_3504_7208:()=>BWn,content_3504_7210:()=>OWn,content_3504_7212:()=>FWn,content_3504_7214:()=>VWn,content_3504_7216:()=>HWn,content_3504_7218:()=>YWn,content_3504_722:()=>AO,content_3504_7220:()=>KWn,content_3504_7222:()=>tRn,content_3504_7224:()=>eRn,content_3504_7226:()=>pRn,content_3504_7228:()=>sRn,content_3504_7230:()=>iRn,content_3504_7232:()=>lRn,content_3504_7234:()=>mRn,content_3504_7236:()=>hRn,content_3504_7238:()=>kRn,content_3504_724:()=>RO,content_3504_7240:()=>MRn,content_3504_7242:()=>wRn,content_3504_7244:()=>XRn,content_3504_7246:()=>TRn,content_3504_7248:()=>CRn,content_3504_7250:()=>LRn,content_3504_7252:()=>bRn,content_3504_7254:()=>zRn,content_3504_7256:()=>WRn,content_3504_7258:()=>IRn,content_3504_726:()=>PO,content_3504_7260:()=>SRn,content_3504_7262:()=>BRn,content_3504_7264:()=>ORn,content_3504_7266:()=>FRn,content_3504_7268:()=>VRn,content_3504_7270:()=>HRn,content_3504_7272:()=>YRn,content_3504_7274:()=>KRn,content_3504_7276:()=>tIn,content_3504_7278:()=>eIn,content_3504_728:()=>EO,content_3504_7280:()=>pIn,content_3504_7282:()=>sIn,content_3504_7284:()=>iIn,content_3504_7286:()=>lIn,content_3504_7288:()=>mIn,content_3504_7290:()=>hIn,content_3504_7292:()=>kIn,content_3504_7294:()=>MIn,content_3504_7296:()=>wIn,content_3504_7298:()=>XIn,content_3504_730:()=>GO,content_3504_7300:()=>TIn,content_3504_7302:()=>CIn,content_3504_7304:()=>LIn,content_3504_7306:()=>bIn,content_3504_7308:()=>zIn,content_3504_7310:()=>WIn,content_3504_7312:()=>IIn,content_3504_7314:()=>SIn,content_3504_7316:()=>BIn,content_3504_7318:()=>OIn,content_3504_732:()=>UO,content_3504_7320:()=>FIn,content_3504_7322:()=>VIn,content_3504_7324:()=>HIn,content_3504_7326:()=>YIn,content_3504_7328:()=>KIn,content_3504_7330:()=>tPn,content_3504_7332:()=>ePn,content_3504_7334:()=>pPn,content_3504_7336:()=>sPn,content_3504_7338:()=>iPn,content_3504_734:()=>qO,content_3504_7340:()=>lPn,content_3504_7342:()=>mPn,content_3504_7344:()=>hPn,content_3504_7346:()=>kPn,content_3504_7348:()=>MPn,content_3504_7350:()=>wPn,content_3504_7352:()=>XPn,content_3504_7354:()=>TPn,content_3504_7356:()=>CPn,content_3504_7358:()=>LPn,content_3504_736:()=>jO,content_3504_7360:()=>bPn,content_3504_7362:()=>zPn,content_3504_7364:()=>WPn,content_3504_7366:()=>IPn,content_3504_7368:()=>SPn,content_3504_7370:()=>BPn,content_3504_7372:()=>OPn,content_3504_7374:()=>FPn,content_3504_7376:()=>VPn,content_3504_7378:()=>HPn,content_3504_738:()=>QO,content_3504_7380:()=>YPn,content_3504_7382:()=>KPn,content_3504_7384:()=>tSn,content_3504_7386:()=>eSn,content_3504_7388:()=>pSn,content_3504_7390:()=>sSn,content_3504_7392:()=>iSn,content_3504_7394:()=>lSn,content_3504_7396:()=>mSn,content_3504_7398:()=>hSn,content_3504_74:()=>Ab,content_3504_740:()=>$O,content_3504_7400:()=>kSn,content_3504_7402:()=>MSn,content_3504_7404:()=>wSn,content_3504_7406:()=>XSn,content_3504_7408:()=>TSn,content_3504_7410:()=>CSn,content_3504_7412:()=>LSn,content_3504_7414:()=>bSn,content_3504_7416:()=>zSn,content_3504_7418:()=>WSn,content_3504_742:()=>JO,content_3504_7420:()=>ISn,content_3504_7422:()=>SSn,content_3504_7424:()=>BSn,content_3504_7426:()=>OSn,content_3504_7428:()=>FSn,content_3504_7430:()=>VSn,content_3504_7432:()=>HSn,content_3504_7434:()=>YSn,content_3504_7436:()=>KSn,content_3504_7438:()=>tEn,content_3504_744:()=>nU,content_3504_7440:()=>eEn,content_3504_7442:()=>pEn,content_3504_7444:()=>sEn,content_3504_7446:()=>iEn,content_3504_7448:()=>lEn,content_3504_7450:()=>mEn,content_3504_7452:()=>hEn,content_3504_7454:()=>kEn,content_3504_7456:()=>MEn,content_3504_7458:()=>wEn,content_3504_746:()=>oU,content_3504_7460:()=>XEn,content_3504_7462:()=>TEn,content_3504_7464:()=>CEn,content_3504_7466:()=>LEn,content_3504_7468:()=>bEn,content_3504_7470:()=>zEn,content_3504_7472:()=>WEn,content_3504_7474:()=>IEn,content_3504_7476:()=>SEn,content_3504_7478:()=>BEn,content_3504_748:()=>rU,content_3504_7480:()=>OEn,content_3504_7482:()=>FEn,content_3504_7484:()=>VEn,content_3504_7486:()=>HEn,content_3504_7488:()=>YEn,content_3504_7490:()=>KEn,content_3504_7492:()=>tBn,content_3504_7494:()=>eBn,content_3504_7496:()=>pBn,content_3504_7498:()=>sBn,content_3504_750:()=>cU,content_3504_7500:()=>iBn,content_3504_7502:()=>lBn,content_3504_7504:()=>mBn,content_3504_7506:()=>hBn,content_3504_7508:()=>kBn,content_3504_7510:()=>MBn,content_3504_7512:()=>wBn,content_3504_7514:()=>XBn,content_3504_7516:()=>TBn,content_3504_7518:()=>CBn,content_3504_752:()=>aU,content_3504_7520:()=>LBn,content_3504_7522:()=>bBn,content_3504_7524:()=>zBn,content_3504_7526:()=>WBn,content_3504_7528:()=>IBn,content_3504_7530:()=>SBn,content_3504_7532:()=>BBn,content_3504_7534:()=>OBn,content_3504_7536:()=>FBn,content_3504_7538:()=>VBn,content_3504_754:()=>uU,content_3504_7540:()=>HBn,content_3504_7542:()=>YBn,content_3504_7544:()=>KBn,content_3504_7546:()=>tGn,content_3504_7548:()=>eGn,content_3504_7550:()=>pGn,content_3504_7552:()=>sGn,content_3504_7554:()=>iGn,content_3504_7556:()=>lGn,content_3504_7558:()=>mGn,content_3504_756:()=>dU,content_3504_7560:()=>hGn,content_3504_7562:()=>kGn,content_3504_7564:()=>MGn,content_3504_7566:()=>wGn,content_3504_7568:()=>XGn,content_3504_7570:()=>TGn,content_3504_7572:()=>CGn,content_3504_7574:()=>LGn,content_3504_7576:()=>bGn,content_3504_758:()=>fU,content_3504_76:()=>Rb,content_3504_760:()=>yU,content_3504_762:()=>DU,content_3504_764:()=>_U,content_3504_766:()=>gU,content_3504_768:()=>xU,content_3504_770:()=>vU,content_3504_772:()=>ZU,content_3504_774:()=>NU,content_3504_776:()=>AU,content_3504_778:()=>RU,content_3504_78:()=>Pb,content_3504_780:()=>PU,content_3504_782:()=>EU,content_3504_784:()=>GU,content_3504_786:()=>UU,content_3504_788:()=>qU,content_3504_790:()=>jU,content_3504_792:()=>QU,content_3504_794:()=>$U,content_3504_796:()=>JU,content_3504_798:()=>nF,content_3504_8:()=>_Z,content_3504_80:()=>Eb,content_3504_800:()=>oF,content_3504_802:()=>rF,content_3504_804:()=>cF,content_3504_806:()=>aF,content_3504_808:()=>uF,content_3504_810:()=>dF,content_3504_812:()=>fF,content_3504_814:()=>yF,content_3504_816:()=>DF,content_3504_818:()=>_F,content_3504_82:()=>Gb,content_3504_820:()=>gF,content_3504_822:()=>xF,content_3504_824:()=>vF,content_3504_826:()=>ZF,content_3504_828:()=>NF,content_3504_830:()=>AF,content_3504_832:()=>RF,content_3504_834:()=>PF,content_3504_836:()=>EF,content_3504_838:()=>GF,content_3504_84:()=>Ub,content_3504_840:()=>UF,content_3504_842:()=>qF,content_3504_844:()=>jF,content_3504_846:()=>QF,content_3504_848:()=>$F,content_3504_850:()=>JF,content_3504_852:()=>nq,content_3504_854:()=>oq,content_3504_856:()=>rq,content_3504_858:()=>cq,content_3504_86:()=>qb,content_3504_860:()=>aq,content_3504_862:()=>uq,content_3504_864:()=>dq,content_3504_866:()=>fq,content_3504_868:()=>yq,content_3504_870:()=>Dq,content_3504_872:()=>_q,content_3504_874:()=>gq,content_3504_876:()=>xq,content_3504_878:()=>vq,content_3504_88:()=>jb,content_3504_880:()=>Zq,content_3504_882:()=>Nq,content_3504_884:()=>Aq,content_3504_886:()=>Rq,content_3504_888:()=>Pq,content_3504_890:()=>Eq,content_3504_892:()=>Gq,content_3504_894:()=>Uq,content_3504_896:()=>qq,content_3504_898:()=>jq,content_3504_90:()=>Qb,content_3504_900:()=>Qq,content_3504_902:()=>$q,content_3504_904:()=>Jq,content_3504_906:()=>nV,content_3504_908:()=>oV,content_3504_910:()=>rV,content_3504_912:()=>cV,content_3504_914:()=>aV,content_3504_916:()=>uV,content_3504_918:()=>dV,content_3504_92:()=>$b,content_3504_920:()=>fV,content_3504_922:()=>yV,content_3504_924:()=>DV,content_3504_926:()=>_V,content_3504_928:()=>gV,content_3504_930:()=>xV,content_3504_932:()=>vV,content_3504_934:()=>ZV,content_3504_936:()=>NV,content_3504_938:()=>AV,content_3504_94:()=>Jb,content_3504_940:()=>RV,content_3504_942:()=>PV,content_3504_944:()=>EV,content_3504_946:()=>GV,content_3504_948:()=>UV,content_3504_950:()=>qV,content_3504_952:()=>jV,content_3504_954:()=>QV,content_3504_956:()=>$V,content_3504_958:()=>JV,content_3504_96:()=>nN,content_3504_960:()=>nj,content_3504_962:()=>oj,content_3504_964:()=>rj,content_3504_966:()=>cj,content_3504_968:()=>aj,content_3504_970:()=>uj,content_3504_972:()=>dj,content_3504_974:()=>fj,content_3504_976:()=>yj,content_3504_978:()=>Dj,content_3504_98:()=>oN,content_3504_980:()=>_j,content_3504_982:()=>gj,content_3504_984:()=>xj,content_3504_986:()=>vj,content_3504_988:()=>Zj,content_3504_990:()=>Nj,content_3504_992:()=>Aj,content_3504_994:()=>Rj,content_3504_996:()=>Pj,content_3504_998:()=>Ej});var p=e(2784),r=e(7896),s=e(876);const c={toc:[]};function i(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}h.isMDXComponent=!0;const f={toc:[]};function k(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}k.isMDXComponent=!0;const y={toc:[]};function M(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}M.isMDXComponent=!0;const D={toc:[]};function w(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}w.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}X.isMDXComponent=!0;const g={toc:[]};function T(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}T.isMDXComponent=!0;const x={toc:[]};function C(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}C.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}L.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}b.isMDXComponent=!0;const N={toc:[]};function z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}z.isMDXComponent=!0;const A={toc:[]};function W(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}W.isMDXComponent=!0;const R={toc:[]};function I(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}I.isMDXComponent=!0;const P={toc:[]};function S(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}S.isMDXComponent=!0;const E={toc:[]};function B(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}B.isMDXComponent=!0;const G={toc:[]};function O(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}O.isMDXComponent=!0;const U={toc:[]};function F(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}F.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}V.isMDXComponent=!0;const j={toc:[]};function H(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}H.isMDXComponent=!0;const Q={toc:[]};function Y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Y.isMDXComponent=!0;const $={toc:[]};function K(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}K.isMDXComponent=!0;const J={toc:[]};function tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}pt.isMDXComponent=!0;const rt={toc:[]};function st(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}st.isMDXComponent=!0;const ct={toc:[]};function it(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}it.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},at,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ht.isMDXComponent=!0;const ft={toc:[]};function kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}kt.isMDXComponent=!0;const yt={toc:[]};function Mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}wt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Xt.isMDXComponent=!0;const gt={toc:[]};function Tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}Tt.isMDXComponent=!0;const xt={toc:[]};function Ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}Ct.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}Lt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}bt.isMDXComponent=!0;const Nt={toc:[]};function zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}zt.isMDXComponent=!0;const At={toc:[]};function Wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}Wt.isMDXComponent=!0;const Rt={toc:[]};function It(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}It.isMDXComponent=!0;const Pt={toc:[]};function St(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}St.isMDXComponent=!0;const Et={toc:[]};function Bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Bt.isMDXComponent=!0;const Gt={toc:[]};function Ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}Ot.isMDXComponent=!0;const Ut={toc:[]};function Ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}Ft.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}Vt.isMDXComponent=!0;const jt={toc:[]};function Ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}Ht.isMDXComponent=!0;const Qt={toc:[]};function Yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}Yt.isMDXComponent=!0;const $t={toc:[]};function Kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}Kt.isMDXComponent=!0;const Jt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}pn.isMDXComponent=!0;const rn={toc:[]};function sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}sn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}dn.isMDXComponent=!0;const hn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}fn.isMDXComponent=!0;const kn={toc:[]};function yn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}yn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}Dn.isMDXComponent=!0;const wn={toc:[]};function _n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}gn.isMDXComponent=!0;const Tn={toc:[]};function xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}xn.isMDXComponent=!0;const Cn={toc:[]};function vn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}vn.isMDXComponent=!0;const Ln={toc:[]};function Zn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}Nn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}An.isMDXComponent=!0;const Wn={toc:[]};function Rn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}Rn.isMDXComponent=!0;const In={toc:[]};function Pn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},In,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Pn.isMDXComponent=!0;const Sn={toc:[]};function En(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}En.isMDXComponent=!0;const Bn={toc:[]};function Gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Gn.isMDXComponent=!0;const On={toc:[]};function Un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},On,e,{components:n,mdxType:"MDXLayout"}))}Un.isMDXComponent=!0;const Fn={toc:[]};function qn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}qn.isMDXComponent=!0;const Vn={toc:[]};function jn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}jn.isMDXComponent=!0;const Hn={toc:[]};function Qn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}Qn.isMDXComponent=!0;const Yn={toc:[]};function $n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}$n.isMDXComponent=!0;const Kn={toc:[]};function Jn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}Jn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}oe.isMDXComponent=!0;const pe={toc:[]};function re(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}re.isMDXComponent=!0;const se={toc:[]};function ce(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},se,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}ce.isMDXComponent=!0;const ie={toc:[]};function ae(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}ae.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}de.isMDXComponent=!0;const he={toc:[]};function fe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}fe.isMDXComponent=!0;const ke={toc:[]};function ye(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}ye.isMDXComponent=!0;const Me={toc:[]};function De(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Me,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}De.isMDXComponent=!0;const we={toc:[]};function _e(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}_e.isMDXComponent=!0;const Xe={toc:[]};function ge(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ge.isMDXComponent=!0;const Te={toc:[]};function xe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}xe.isMDXComponent=!0;const Ce={toc:[]};function ve(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}ve.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Le,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ze.isMDXComponent=!0;const be={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},be,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Ne.isMDXComponent=!0;const ze={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Ae.isMDXComponent=!0;const We={toc:[]};function Re(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},We,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Re.isMDXComponent=!0;const Ie={toc:[]};function Pe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Pe.isMDXComponent=!0;const Se={toc:[]};function Ee(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Se,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ee.isMDXComponent=!0;const Be={toc:[]};function Ge(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Be,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}Ge.isMDXComponent=!0;const Oe={toc:[]};function Ue(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Ue.isMDXComponent=!0;const Fe={toc:[]};function qe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}qe.isMDXComponent=!0;const Ve={toc:[]};function je(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}je.isMDXComponent=!0;const He={toc:[]};function Qe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Qe.isMDXComponent=!0;const Ye={toc:[]};function $e(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}$e.isMDXComponent=!0;const Ke={toc:[]};function Je(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Je.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}ro.isMDXComponent=!0;const so={toc:[]};function co(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},so,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}co.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},io,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ho.isMDXComponent=!0;const fo={toc:[]};function ko(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}ko.isMDXComponent=!0;const yo={toc:[]};function Mo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}Mo.isMDXComponent=!0;const Do={toc:[]};function wo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Do,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}wo.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Xo.isMDXComponent=!0;const go={toc:[]};function To(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}To.isMDXComponent=!0;const xo={toc:[]};function Co(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Co.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Lo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}bo.isMDXComponent=!0;const No={toc:[]};function zo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Wo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Wo.isMDXComponent=!0;const Ro={toc:[]};function Io(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Io.isMDXComponent=!0;const Po={toc:[]};function So(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Po,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}So.isMDXComponent=!0;const Eo={toc:[]};function Bo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Bo.isMDXComponent=!0;const Go={toc:[]};function Oo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Go,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Oo.isMDXComponent=!0;const Uo={toc:[]};function Fo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Fo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Vo.isMDXComponent=!0;const jo={toc:[]};function Ho(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Ho.isMDXComponent=!0;const Qo={toc:[]};function Yo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Yo.isMDXComponent=!0;const $o={toc:[]};function Ko(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Ko.isMDXComponent=!0;const Jo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}pp.isMDXComponent=!0;const rp={toc:[]};function sp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}sp.isMDXComponent=!0;const cp={toc:[]};function ip(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}ip.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}hp.isMDXComponent=!0;const fp={toc:[]};function kp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}kp.isMDXComponent=!0;const yp={toc:[]};function Mp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}wp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Xp.isMDXComponent=!0;const gp={toc:[]};function Tp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Tp.isMDXComponent=!0;const xp={toc:[]};function Cp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}Cp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Lp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}bp.isMDXComponent=!0;const Np={toc:[]};function zp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Wp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Wp.isMDXComponent=!0;const Rp={toc:[]};function Ip(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ip.isMDXComponent=!0;const Pp={toc:[]};function Sp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Sp.isMDXComponent=!0;const Ep={toc:[]};function Bp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Bp.isMDXComponent=!0;const Gp={toc:[]};function Op(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Op.isMDXComponent=!0;const Up={toc:[]};function Fp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Up,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Fp.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Vp.isMDXComponent=!0;const jp={toc:[]};function Hp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Hp.isMDXComponent=!0;const Qp={toc:[]};function Yp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Yp.isMDXComponent=!0;const $p={toc:[]};function Kp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Kp.isMDXComponent=!0;const Jp={toc:[]};function tr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}pr.isMDXComponent=!0;const rr={toc:[]};function sr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}sr.isMDXComponent=!0;const cr={toc:[]};function ir(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ir.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ar,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}hr.isMDXComponent=!0;const fr={toc:[]};function kr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}kr.isMDXComponent=!0;const yr={toc:[]};function Mr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}wr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_r,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}Xr.isMDXComponent=!0;const gr={toc:[]};function Tr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Tr.isMDXComponent=!0;const xr={toc:[]};function Cr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Cr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Lr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}br.isMDXComponent=!0;const Nr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Wr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Wr.isMDXComponent=!0;const Rr={toc:[]};function Ir(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Ir.isMDXComponent=!0;const Pr={toc:[]};function Sr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Sr.isMDXComponent=!0;const Er={toc:[]};function Br(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Er,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Br.isMDXComponent=!0;const Gr={toc:[]};function Or(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Or.isMDXComponent=!0;const Ur={toc:[]};function Fr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ur,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Fr.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}Vr.isMDXComponent=!0;const jr={toc:[]};function Hr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}Hr.isMDXComponent=!0;const Qr={toc:[]};function Yr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}Yr.isMDXComponent=!0;const $r={toc:[]};function Kr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}Kr.isMDXComponent=!0;const Jr={toc:[]};function ts(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}ps.isMDXComponent=!0;const rs={toc:[]};function ss(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}ss.isMDXComponent=!0;const cs={toc:[]};function is(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}is.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},as,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}hs.isMDXComponent=!0;const fs={toc:[]};function ks(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}ks.isMDXComponent=!0;const ys={toc:[]};function Ms(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ys,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function ws(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ds,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}ws.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_s,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Xs.isMDXComponent=!0;const gs={toc:[]};function Ts(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Ts.isMDXComponent=!0;const xs={toc:[]};function Cs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Cs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Ls.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function zs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}zs.isMDXComponent=!0;const As={toc:[]};function Ws(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}Ws.isMDXComponent=!0;const Rs={toc:[]};function Is(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Is.isMDXComponent=!0;const Ps={toc:[]};function Ss(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ps,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ss.isMDXComponent=!0;const Es={toc:[]};function Bs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Es,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Bs.isMDXComponent=!0;const Gs={toc:[]};function Os(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Os.isMDXComponent=!0;const Us={toc:[]};function Fs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Us,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Fs.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Vs.isMDXComponent=!0;const js={toc:[]};function Hs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Hs.isMDXComponent=!0;const Qs={toc:[]};function Ys(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ys.isMDXComponent=!0;const $s={toc:[]};function Ks(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ks.isMDXComponent=!0;const Js={toc:[]};function tc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Js,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}pc.isMDXComponent=!0;const rc={toc:[]};function sc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}sc.isMDXComponent=!0;const cc={toc:[]};function ic(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}ic.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ac,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}hc.isMDXComponent=!0;const fc={toc:[]};function kc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}kc.isMDXComponent=!0;const yc={toc:[]};function Mc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}wc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}Xc.isMDXComponent=!0;const gc={toc:[]};function Tc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Tc.isMDXComponent=!0;const xc={toc:[]};function Cc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Cc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}Lc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}bc.isMDXComponent=!0;const Nc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Wc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Wc.isMDXComponent=!0;const Rc={toc:[]};function Ic(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Ic.isMDXComponent=!0;const Pc={toc:[]};function Sc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Sc.isMDXComponent=!0;const Ec={toc:[]};function Bc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ec,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Bc.isMDXComponent=!0;const Gc={toc:[]};function Oc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}Oc.isMDXComponent=!0;const Uc={toc:[]};function Fc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Fc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vc.isMDXComponent=!0;const jc={toc:[]};function Hc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Hc.isMDXComponent=!0;const Qc={toc:[]};function Yc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yc.isMDXComponent=!0;const $c={toc:[]};function Kc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kc.isMDXComponent=!0;const Jc={toc:[]};function ti(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pi.isMDXComponent=!0;const ri={toc:[]};function si(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ri,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}si.isMDXComponent=!0;const ci={toc:[]};function ii(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}ii.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ai,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hi.isMDXComponent=!0;const fi={toc:[]};function ki(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ki.isMDXComponent=!0;const yi={toc:[]};function Mi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mi.isMDXComponent=!0;const Di={toc:[]};function wi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Di,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}wi.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_i,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Xi.isMDXComponent=!0;const gi={toc:[]};function Ti(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ti.isMDXComponent=!0;const xi={toc:[]};function Ci(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ci.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Li.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}bi.isMDXComponent=!0;const Ni={toc:[]};function zi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Wi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Wi.isMDXComponent=!0;const Ri={toc:[]};function Ii(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ri,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ii.isMDXComponent=!0;const Pi={toc:[]};function Si(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Si.isMDXComponent=!0;const Ei={toc:[]};function Bi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ei,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Bi.isMDXComponent=!0;const Gi={toc:[]};function Oi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Oi.isMDXComponent=!0;const Ui={toc:[]};function Fi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ui,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Fi.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Vi.isMDXComponent=!0;const ji={toc:[]};function Hi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Hi.isMDXComponent=!0;const Qi={toc:[]};function Yi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Yi.isMDXComponent=!0;const $i={toc:[]};function Ki(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ki.isMDXComponent=!0;const Ji={toc:[]};function ta(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ji,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}pa.isMDXComponent=!0;const ra={toc:[]};function sa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ra,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}sa.isMDXComponent=!0;const ca={toc:[]};function ia(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ia.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ha.isMDXComponent=!0;const fa={toc:[]};function ka(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ka.isMDXComponent=!0;const ya={toc:[]};function Ma(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ya,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}Ma.isMDXComponent=!0;const Da={toc:[]};function wa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Da,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}wa.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Xa.isMDXComponent=!0;const ga={toc:[]};function Ta(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ta.isMDXComponent=!0;const xa={toc:[]};function Ca(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Ca.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}La.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Za,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}ba.isMDXComponent=!0;const Na={toc:[]};function za(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}za.isMDXComponent=!0;const Aa={toc:[]};function Wa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Wa.isMDXComponent=!0;const Ra={toc:[]};function Ia(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ra,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ia.isMDXComponent=!0;const Pa={toc:[]};function Sa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Sa.isMDXComponent=!0;const Ea={toc:[]};function Ba(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ea,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ba.isMDXComponent=!0;const Ga={toc:[]};function Oa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ga,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Oa.isMDXComponent=!0;const Ua={toc:[]};function Fa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ua,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Fa.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Va.isMDXComponent=!0;const ja={toc:[]};function Ha(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Ha.isMDXComponent=!0;const Qa={toc:[]};function Ya(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ya.isMDXComponent=!0;const $a={toc:[]};function Ka(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ka.isMDXComponent=!0;const Ja={toc:[]};function tl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ja,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}pl.isMDXComponent=!0;const rl={toc:[]};function sl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}sl.isMDXComponent=!0;const cl={toc:[]};function il(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}il.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},al,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}hl.isMDXComponent=!0;const fl={toc:[]};function kl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}kl.isMDXComponent=!0;const yl={toc:[]};function Ml(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}wl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_l,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Xl.isMDXComponent=!0;const gl={toc:[]};function Tl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Tl.isMDXComponent=!0;const xl={toc:[]};function Cl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Cl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ll.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}bl.isMDXComponent=!0;const Nl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}zl.isMDXComponent=!0;const Al={toc:[]};function Wl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Wl.isMDXComponent=!0;const Rl={toc:[]};function Il(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Il.isMDXComponent=!0;const Pl={toc:[]};function Sl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Sl.isMDXComponent=!0;const El={toc:[]};function Bl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},El,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Bl.isMDXComponent=!0;const Gl={toc:[]};function Ol(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}Ol.isMDXComponent=!0;const Ul={toc:[]};function Fl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ul,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Fl.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vl.isMDXComponent=!0;const jl={toc:[]};function Hl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Hl.isMDXComponent=!0;const Ql={toc:[]};function Yl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ql,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yl.isMDXComponent=!0;const $l={toc:[]};function Kl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kl.isMDXComponent=!0;const Jl={toc:[]};function tu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pu.isMDXComponent=!0;const ru={toc:[]};function su(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ru,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}su.isMDXComponent=!0;const cu={toc:[]};function iu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}iu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},au,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hu.isMDXComponent=!0;const fu={toc:[]};function ku(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ku.isMDXComponent=!0;const yu={toc:[]};function Mu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mu.isMDXComponent=!0;const Du={toc:[]};function wu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Du,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}wu.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Xu.isMDXComponent=!0;const gu={toc:[]};function Tu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Tu.isMDXComponent=!0;const xu={toc:[]};function Cu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Cu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Lu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}bu.isMDXComponent=!0;const Nu={toc:[]};function zu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}zu.isMDXComponent=!0;const Au={toc:[]};function Wu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}Wu.isMDXComponent=!0;const Ru={toc:[]};function Iu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ru,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Iu.isMDXComponent=!0;const Pu={toc:[]};function Su(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Su.isMDXComponent=!0;const Eu={toc:[]};function Bu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Bu.isMDXComponent=!0;const Gu={toc:[]};function Ou(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ou.isMDXComponent=!0;const Uu={toc:[]};function Fu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Fu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Vu.isMDXComponent=!0;const ju={toc:[]};function Hu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Hu.isMDXComponent=!0;const Qu={toc:[]};function Yu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Yu.isMDXComponent=!0;const $u={toc:[]};function Ku(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ku.isMDXComponent=!0;const Ju={toc:[]};function tm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ju,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}pm.isMDXComponent=!0;const rm={toc:[]};function sm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sm.isMDXComponent=!0;const cm={toc:[]};function im(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}im.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},am,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}hm.isMDXComponent=!0;const fm={toc:[]};function km(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}km.isMDXComponent=!0;const ym={toc:[]};function Mm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ym,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}wm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_m,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}Xm.isMDXComponent=!0;const gm={toc:[]};function Tm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}Tm.isMDXComponent=!0;const xm={toc:[]};function Cm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Lm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bm.isMDXComponent=!0;const Nm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zm.isMDXComponent=!0;const Am={toc:[]};function Wm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wm.isMDXComponent=!0;const Rm={toc:[]};function Im(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Im.isMDXComponent=!0;const Pm={toc:[]};function Sm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Sm.isMDXComponent=!0;const Em={toc:[]};function Bm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Em,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bm.isMDXComponent=!0;const Gm={toc:[]};function Om(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Om.isMDXComponent=!0;const Um={toc:[]};function Fm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Um,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fm.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vm.isMDXComponent=!0;const jm={toc:[]};function Hm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Hm.isMDXComponent=!0;const Qm={toc:[]};function Ym(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ym.isMDXComponent=!0;const $m={toc:[]};function Km(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Km.isMDXComponent=!0;const Jm={toc:[]};function td(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}pd.isMDXComponent=!0;const rd={toc:[]};function sd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sd.isMDXComponent=!0;const cd={toc:[]};function id(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}id.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ad,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}hd.isMDXComponent=!0;const fd={toc:[]};function kd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}kd.isMDXComponent=!0;const yd={toc:[]};function Md(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Md.isMDXComponent=!0;const Dd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}wd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}Xd.isMDXComponent=!0;const gd={toc:[]};function Td(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}Td.isMDXComponent=!0;const xd={toc:[]};function Cd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ld.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bd.isMDXComponent=!0;const Nd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Wd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wd.isMDXComponent=!0;const Rd={toc:[]};function Id(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Id.isMDXComponent=!0;const Pd={toc:[]};function Sd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Sd.isMDXComponent=!0;const Ed={toc:[]};function Bd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ed,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bd.isMDXComponent=!0;const Gd={toc:[]};function Od(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Od.isMDXComponent=!0;const Ud={toc:[]};function Fd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ud,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fd.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vd.isMDXComponent=!0;const jd={toc:[]};function Hd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Hd.isMDXComponent=!0;const Qd={toc:[]};function Yd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Yd.isMDXComponent=!0;const $d={toc:[]};function Kd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Kd.isMDXComponent=!0;const Jd={toc:[]};function th(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}ph.isMDXComponent=!0;const rh={toc:[]};function sh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sh.isMDXComponent=!0;const ch={toc:[]};function ih(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ih.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ah,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}hh.isMDXComponent=!0;const fh={toc:[]};function kh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}kh.isMDXComponent=!0;const yh={toc:[]};function Mh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}wh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_h,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Xh.isMDXComponent=!0;const gh={toc:[]};function Th(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Th.isMDXComponent=!0;const xh={toc:[]};function Ch(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ch.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Lh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}bh.isMDXComponent=!0;const Nh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Wh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Wh.isMDXComponent=!0;const Rh={toc:[]};function Ih(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Ih.isMDXComponent=!0;const Ph={toc:[]};function Sh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ph,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Sh.isMDXComponent=!0;const Eh={toc:[]};function Bh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Bh.isMDXComponent=!0;const Gh={toc:[]};function Oh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Oh.isMDXComponent=!0;const Uh={toc:[]};function Fh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Fh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Vh.isMDXComponent=!0;const jh={toc:[]};function Hh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Hh.isMDXComponent=!0;const Qh={toc:[]};function Yh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Yh.isMDXComponent=!0;const $h={toc:[]};function Kh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Kh.isMDXComponent=!0;const Jh={toc:[]};function tf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}pf.isMDXComponent=!0;const rf={toc:[]};function sf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}sf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}df.isMDXComponent=!0;const hf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}ff.isMDXComponent=!0;const kf={toc:[]};function yf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}yf.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Df.isMDXComponent=!0;const wf={toc:[]};function _f(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}gf.isMDXComponent=!0;const Tf={toc:[]};function xf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}xf.isMDXComponent=!0;const Cf={toc:[]};function vf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}vf.isMDXComponent=!0;const Lf={toc:[]};function Zf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}Nf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}Af.isMDXComponent=!0;const Wf={toc:[]};function Rf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}Rf.isMDXComponent=!0;const If={toc:[]};function Pf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},If,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}Pf.isMDXComponent=!0;const Sf={toc:[]};function Ef(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Ef.isMDXComponent=!0;const Bf={toc:[]};function Gf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}Gf.isMDXComponent=!0;const Of={toc:[]};function Uf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Of,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Uf.isMDXComponent=!0;const Ff={toc:[]};function qf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ff,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}qf.isMDXComponent=!0;const Vf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}jf.isMDXComponent=!0;const Hf={toc:[]};function Qf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}Qf.isMDXComponent=!0;const Yf={toc:[]};function $f(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}$f.isMDXComponent=!0;const Kf={toc:[]};function Jf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}Jf.isMDXComponent=!0;const tk={toc:[]};function nk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}nk.isMDXComponent=!0;const ek={toc:[]};function ok(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ek,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}ok.isMDXComponent=!0;const pk={toc:[]};function rk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}rk.isMDXComponent=!0;const sk={toc:[]};function ck(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}ck.isMDXComponent=!0;const ik={toc:[]};function ak(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}ak.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}dk.isMDXComponent=!0;const hk={toc:[]};function fk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}fk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}yk.isMDXComponent=!0;const Mk={toc:[]};function Dk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Dk.isMDXComponent=!0;const wk={toc:[]};function _k(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_k.isMDXComponent=!0;const Xk={toc:[]};function gk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}gk.isMDXComponent=!0;const Tk={toc:[]};function xk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}xk.isMDXComponent=!0;const Ck={toc:[]};function vk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ck,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}vk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Zk.isMDXComponent=!0;const bk={toc:[]};function Nk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Nk.isMDXComponent=!0;const zk={toc:[]};function Ak(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ak.isMDXComponent=!0;const Wk={toc:[]};function Rk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Rk.isMDXComponent=!0;const Ik={toc:[]};function Pk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ik,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}Pk.isMDXComponent=!0;const Sk={toc:[]};function Ek(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Ek.isMDXComponent=!0;const Bk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Gk.isMDXComponent=!0;const Ok={toc:[]};function Uk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ok,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Uk.isMDXComponent=!0;const Fk={toc:[]};function qk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}qk.isMDXComponent=!0;const Vk={toc:[]};function jk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}jk.isMDXComponent=!0;const Hk={toc:[]};function Qk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Qk.isMDXComponent=!0;const Yk={toc:[]};function $k(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}$k.isMDXComponent=!0;const Kk={toc:[]};function Jk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Jk.isMDXComponent=!0;const ty={toc:[]};function ny(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ty,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ny.isMDXComponent=!0;const ey={toc:[]};function oy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ey,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}oy.isMDXComponent=!0;const py={toc:[]};function ry(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},py,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}ry.isMDXComponent=!0;const sy={toc:[]};function cy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}cy.isMDXComponent=!0;const iy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}ay.isMDXComponent=!0;const ly={toc:[]};function uy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ly,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}uy.isMDXComponent=!0;const my={toc:[]};function dy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},my,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}dy.isMDXComponent=!0;const hy={toc:[]};function fy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}fy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ky,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}yy.isMDXComponent=!0;const My={toc:[]};function Dy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},My,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Dy.isMDXComponent=!0;const wy={toc:[]};function _y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}_y.isMDXComponent=!0;const Xy={toc:[]};function gy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}gy.isMDXComponent=!0;const Ty={toc:[]};function xy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ty,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}xy.isMDXComponent=!0;const Cy={toc:[]};function vy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}vy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}Zy.isMDXComponent=!0;const by={toc:[]};function Ny(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},by,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Ny.isMDXComponent=!0;const zy={toc:[]};function Ay(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Ay.isMDXComponent=!0;const Wy={toc:[]};function Ry(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}Ry.isMDXComponent=!0;const Iy={toc:[]};function Py(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}Py.isMDXComponent=!0;const Sy={toc:[]};function Ey(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Ey.isMDXComponent=!0;const By={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Gy.isMDXComponent=!0;const Oy={toc:[]};function Uy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}Uy.isMDXComponent=!0;const Fy={toc:[]};function qy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}qy.isMDXComponent=!0;const Vy={toc:[]};function jy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}jy.isMDXComponent=!0;const Hy={toc:[]};function Qy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}Qy.isMDXComponent=!0;const Yy={toc:[]};function $y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}$y.isMDXComponent=!0;const Ky={toc:[]};function Jy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ky,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Jy.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}rM.isMDXComponent=!0;const sM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}cM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}dM.isMDXComponent=!0;const hM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}fM.isMDXComponent=!0;const kM={toc:[]};function yM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}yM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}DM.isMDXComponent=!0;const wM={toc:[]};function _M(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}gM.isMDXComponent=!0;const TM={toc:[]};function xM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}xM.isMDXComponent=!0;const CM={toc:[]};function vM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}vM.isMDXComponent=!0;const LM={toc:[]};function ZM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}NM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}AM.isMDXComponent=!0;const WM={toc:[]};function RM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}RM.isMDXComponent=!0;const IM={toc:[]};function PM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}PM.isMDXComponent=!0;const SM={toc:[]};function EM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}EM.isMDXComponent=!0;const BM={toc:[]};function GM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}GM.isMDXComponent=!0;const OM={toc:[]};function UM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}UM.isMDXComponent=!0;const FM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}qM.isMDXComponent=!0;const VM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}jM.isMDXComponent=!0;const HM={toc:[]};function QM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}QM.isMDXComponent=!0;const YM={toc:[]};function $M(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$M.isMDXComponent=!0;const KM={toc:[]};function JM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}JM.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}rD.isMDXComponent=!0;const sD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}cD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}dD.isMDXComponent=!0;const hD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}fD.isMDXComponent=!0;const kD={toc:[]};function yD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}yD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}DD.isMDXComponent=!0;const wD={toc:[]};function _D(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}gD.isMDXComponent=!0;const TD={toc:[]};function xD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}xD.isMDXComponent=!0;const CD={toc:[]};function vD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}vD.isMDXComponent=!0;const LD={toc:[]};function ZD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}ND.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}AD.isMDXComponent=!0;const WD={toc:[]};function RD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}RD.isMDXComponent=!0;const ID={toc:[]};function PD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ID,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}PD.isMDXComponent=!0;const SD={toc:[]};function ED(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}ED.isMDXComponent=!0;const BD={toc:[]};function GD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}GD.isMDXComponent=!0;const OD={toc:[]};function UD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}UD.isMDXComponent=!0;const FD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}qD.isMDXComponent=!0;const VD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}jD.isMDXComponent=!0;const HD={toc:[]};function QD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}QD.isMDXComponent=!0;const YD={toc:[]};function $D(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}$D.isMDXComponent=!0;const KD={toc:[]};function JD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}JD.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}rw.isMDXComponent=!0;const sw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}cw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}dw.isMDXComponent=!0;const hw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}fw.isMDXComponent=!0;const kw={toc:[]};function yw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}yw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Dw.isMDXComponent=!0;const ww={toc:[]};function _w(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}gw.isMDXComponent=!0;const Tw={toc:[]};function xw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}xw.isMDXComponent=!0;const Cw={toc:[]};function vw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}vw.isMDXComponent=!0;const Lw={toc:[]};function Zw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Nw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Aw.isMDXComponent=!0;const Ww={toc:[]};function Rw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Rw.isMDXComponent=!0;const Iw={toc:[]};function Pw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Pw.isMDXComponent=!0;const Sw={toc:[]};function Ew(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Ew.isMDXComponent=!0;const Bw={toc:[]};function Gw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}Gw.isMDXComponent=!0;const Ow={toc:[]};function Uw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ow,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}Uw.isMDXComponent=!0;const Fw={toc:[]};function qw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}qw.isMDXComponent=!0;const Vw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}jw.isMDXComponent=!0;const Hw={toc:[]};function Qw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}Qw.isMDXComponent=!0;const Yw={toc:[]};function $w(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}$w.isMDXComponent=!0;const Kw={toc:[]};function Jw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Jw.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}r_.isMDXComponent=!0;const s_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}c_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}d_.isMDXComponent=!0;const h_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}f_.isMDXComponent=!0;const k_={toc:[]};function y_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}y_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}D_.isMDXComponent=!0;const w_={toc:[]};function __(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}g_.isMDXComponent=!0;const T_={toc:[]};function x_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}x_.isMDXComponent=!0;const C_={toc:[]};function v_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}v_.isMDXComponent=!0;const L_={toc:[]};function Z_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}N_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}A_.isMDXComponent=!0;const W_={toc:[]};function R_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}R_.isMDXComponent=!0;const I_={toc:[]};function P_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}P_.isMDXComponent=!0;const S_={toc:[]};function E_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}E_.isMDXComponent=!0;const B_={toc:[]};function G_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}G_.isMDXComponent=!0;const O_={toc:[]};function U_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}U_.isMDXComponent=!0;const F_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}q_.isMDXComponent=!0;const V_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}j_.isMDXComponent=!0;const H_={toc:[]};function Q_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Q_.isMDXComponent=!0;const Y_={toc:[]};function $_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}$_.isMDXComponent=!0;const K_={toc:[]};function J_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}J_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}rX.isMDXComponent=!0;const sX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}cX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}dX.isMDXComponent=!0;const hX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}fX.isMDXComponent=!0;const kX={toc:[]};function yX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}yX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}DX.isMDXComponent=!0;const wX={toc:[]};function _X(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}gX.isMDXComponent=!0;const TX={toc:[]};function xX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}xX.isMDXComponent=!0;const CX={toc:[]};function vX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}vX.isMDXComponent=!0;const LX={toc:[]};function ZX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}NX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}AX.isMDXComponent=!0;const WX={toc:[]};function RX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}RX.isMDXComponent=!0;const IX={toc:[]};function PX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}PX.isMDXComponent=!0;const SX={toc:[]};function EX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}EX.isMDXComponent=!0;const BX={toc:[]};function GX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}GX.isMDXComponent=!0;const OX={toc:[]};function UX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}UX.isMDXComponent=!0;const FX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}qX.isMDXComponent=!0;const VX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}jX.isMDXComponent=!0;const HX={toc:[]};function QX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}QX.isMDXComponent=!0;const YX={toc:[]};function $X(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}$X.isMDXComponent=!0;const KX={toc:[]};function JX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}JX.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}rg.isMDXComponent=!0;const sg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}cg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ig,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}dg.isMDXComponent=!0;const hg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}fg.isMDXComponent=!0;const kg={toc:[]};function yg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}yg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Dg.isMDXComponent=!0;const wg={toc:[]};function _g(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}gg.isMDXComponent=!0;const Tg={toc:[]};function xg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}xg.isMDXComponent=!0;const Cg={toc:[]};function vg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}vg.isMDXComponent=!0;const Lg={toc:[]};function Zg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Ng.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Ag.isMDXComponent=!0;const Wg={toc:[]};function Rg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Rg.isMDXComponent=!0;const Ig={toc:[]};function Pg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ig,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Pg.isMDXComponent=!0;const Sg={toc:[]};function Eg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Eg.isMDXComponent=!0;const Bg={toc:[]};function Gg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Gg.isMDXComponent=!0;const Og={toc:[]};function Ug(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Og,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Ug.isMDXComponent=!0;const Fg={toc:[]};function qg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}qg.isMDXComponent=!0;const Vg={toc:[]};function jg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}jg.isMDXComponent=!0;const Hg={toc:[]};function Qg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}Qg.isMDXComponent=!0;const Yg={toc:[]};function $g(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}$g.isMDXComponent=!0;const Kg={toc:[]};function Jg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}Jg.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}rT.isMDXComponent=!0;const sT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}cT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}dT.isMDXComponent=!0;const hT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}fT.isMDXComponent=!0;const kT={toc:[]};function yT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}yT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}DT.isMDXComponent=!0;const wT={toc:[]};function _T(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gT.isMDXComponent=!0;const TT={toc:[]};function xT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}xT.isMDXComponent=!0;const CT={toc:[]};function vT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}vT.isMDXComponent=!0;const LT={toc:[]};function ZT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}NT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}AT.isMDXComponent=!0;const WT={toc:[]};function RT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}RT.isMDXComponent=!0;const IT={toc:[]};function PT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}PT.isMDXComponent=!0;const ST={toc:[]};function ET(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ST,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}ET.isMDXComponent=!0;const BT={toc:[]};function GT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}GT.isMDXComponent=!0;const OT={toc:[]};function UT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}UT.isMDXComponent=!0;const FT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}qT.isMDXComponent=!0;const VT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}jT.isMDXComponent=!0;const HT={toc:[]};function QT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}QT.isMDXComponent=!0;const YT={toc:[]};function $T(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}$T.isMDXComponent=!0;const KT={toc:[]};function JT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}JT.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}rx.isMDXComponent=!0;const sx={toc:[]};function cx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}cx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ix,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}dx.isMDXComponent=!0;const hx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}fx.isMDXComponent=!0;const kx={toc:[]};function yx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}yx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}Dx.isMDXComponent=!0;const wx={toc:[]};function _x(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}gx.isMDXComponent=!0;const Tx={toc:[]};function xx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}xx.isMDXComponent=!0;const Cx={toc:[]};function vx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}vx.isMDXComponent=!0;const Lx={toc:[]};function Zx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}Nx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}Ax.isMDXComponent=!0;const Wx={toc:[]};function Rx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Rx.isMDXComponent=!0;const Ix={toc:[]};function Px(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ix,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Px.isMDXComponent=!0;const Sx={toc:[]};function Ex(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}Ex.isMDXComponent=!0;const Bx={toc:[]};function Gx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Gx.isMDXComponent=!0;const Ox={toc:[]};function Ux(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ox,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Ux.isMDXComponent=!0;const Fx={toc:[]};function qx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}qx.isMDXComponent=!0;const Vx={toc:[]};function jx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}jx.isMDXComponent=!0;const Hx={toc:[]};function Qx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}Qx.isMDXComponent=!0;const Yx={toc:[]};function $x(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}$x.isMDXComponent=!0;const Kx={toc:[]};function Jx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}Jx.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}rC.isMDXComponent=!0;const sC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}cC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}dC.isMDXComponent=!0;const hC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}fC.isMDXComponent=!0;const kC={toc:[]};function yC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}yC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}DC.isMDXComponent=!0;const wC={toc:[]};function _C(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}gC.isMDXComponent=!0;const TC={toc:[]};function xC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}xC.isMDXComponent=!0;const CC={toc:[]};function vC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}vC.isMDXComponent=!0;const LC={toc:[]};function ZC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}NC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}AC.isMDXComponent=!0;const WC={toc:[]};function RC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}RC.isMDXComponent=!0;const IC={toc:[]};function PC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}PC.isMDXComponent=!0;const SC={toc:[]};function EC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}EC.isMDXComponent=!0;const BC={toc:[]};function GC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}GC.isMDXComponent=!0;const OC={toc:[]};function UC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}UC.isMDXComponent=!0;const FC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}qC.isMDXComponent=!0;const VC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}jC.isMDXComponent=!0;const HC={toc:[]};function QC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}QC.isMDXComponent=!0;const YC={toc:[]};function $C(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}$C.isMDXComponent=!0;const KC={toc:[]};function JC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}JC.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}rv.isMDXComponent=!0;const sv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}cv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}dv.isMDXComponent=!0;const hv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}fv.isMDXComponent=!0;const kv={toc:[]};function yv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}yv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}Dv.isMDXComponent=!0;const wv={toc:[]};function _v(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}gv.isMDXComponent=!0;const Tv={toc:[]};function xv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}xv.isMDXComponent=!0;const Cv={toc:[]};function vv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}vv.isMDXComponent=!0;const Lv={toc:[]};function Zv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}Nv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}Av.isMDXComponent=!0;const Wv={toc:[]};function Rv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}Rv.isMDXComponent=!0;const Iv={toc:[]};function Pv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}Pv.isMDXComponent=!0;const Sv={toc:[]};function Ev(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}Ev.isMDXComponent=!0;const Bv={toc:[]};function Gv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}Gv.isMDXComponent=!0;const Ov={toc:[]};function Uv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ov,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}Uv.isMDXComponent=!0;const Fv={toc:[]};function qv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}qv.isMDXComponent=!0;const Vv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}jv.isMDXComponent=!0;const Hv={toc:[]};function Qv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}Qv.isMDXComponent=!0;const Yv={toc:[]};function $v(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}$v.isMDXComponent=!0;const Kv={toc:[]};function Jv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}Jv.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}rL.isMDXComponent=!0;const sL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}cL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}dL.isMDXComponent=!0;const hL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}fL.isMDXComponent=!0;const kL={toc:[]};function yL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}yL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ML,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}DL.isMDXComponent=!0;const wL={toc:[]};function _L(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}gL.isMDXComponent=!0;const TL={toc:[]};function xL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}xL.isMDXComponent=!0;const CL={toc:[]};function vL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}vL.isMDXComponent=!0;const LL={toc:[]};function ZL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}NL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}AL.isMDXComponent=!0;const WL={toc:[]};function RL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}RL.isMDXComponent=!0;const IL={toc:[]};function PL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}PL.isMDXComponent=!0;const SL={toc:[]};function EL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}EL.isMDXComponent=!0;const BL={toc:[]};function GL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}GL.isMDXComponent=!0;const OL={toc:[]};function UL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}UL.isMDXComponent=!0;const FL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}qL.isMDXComponent=!0;const VL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}jL.isMDXComponent=!0;const HL={toc:[]};function QL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}QL.isMDXComponent=!0;const YL={toc:[]};function $L(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}$L.isMDXComponent=!0;const KL={toc:[]};function JL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}JL.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}rZ.isMDXComponent=!0;const sZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}cZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}fZ.isMDXComponent=!0;const kZ={toc:[]};function yZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}yZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}DZ.isMDXComponent=!0;const wZ={toc:[]};function _Z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}gZ.isMDXComponent=!0;const TZ={toc:[]};function xZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xZ.isMDXComponent=!0;const CZ={toc:[]};function vZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function ZZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}NZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}AZ.isMDXComponent=!0;const WZ={toc:[]};function RZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}RZ.isMDXComponent=!0;const IZ={toc:[]};function PZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}PZ.isMDXComponent=!0;const SZ={toc:[]};function EZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}EZ.isMDXComponent=!0;const BZ={toc:[]};function GZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}GZ.isMDXComponent=!0;const OZ={toc:[]};function UZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}UZ.isMDXComponent=!0;const FZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}jZ.isMDXComponent=!0;const HZ={toc:[]};function QZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QZ.isMDXComponent=!0;const YZ={toc:[]};function $Z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}$Z.isMDXComponent=!0;const KZ={toc:[]};function JZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}JZ.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}rb.isMDXComponent=!0;const sb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ib,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}db.isMDXComponent=!0;const hb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}fb.isMDXComponent=!0;const kb={toc:[]};function yb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}yb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Db.isMDXComponent=!0;const wb={toc:[]};function _b(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}gb.isMDXComponent=!0;const Tb={toc:[]};function xb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xb.isMDXComponent=!0;const Cb={toc:[]};function vb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}vb.isMDXComponent=!0;const Lb={toc:[]};function Zb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Ab.isMDXComponent=!0;const Wb={toc:[]};function Rb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Rb.isMDXComponent=!0;const Ib={toc:[]};function Pb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ib,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Pb.isMDXComponent=!0;const Sb={toc:[]};function Eb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Eb.isMDXComponent=!0;const Bb={toc:[]};function Gb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Gb.isMDXComponent=!0;const Ob={toc:[]};function Ub(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ob,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ub.isMDXComponent=!0;const Fb={toc:[]};function qb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}qb.isMDXComponent=!0;const Vb={toc:[]};function jb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}jb.isMDXComponent=!0;const Hb={toc:[]};function Qb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Qb.isMDXComponent=!0;const Yb={toc:[]};function $b(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}$b.isMDXComponent=!0;const Kb={toc:[]};function Jb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Jb.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}rN.isMDXComponent=!0;const sN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}cN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}dN.isMDXComponent=!0;const hN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}fN.isMDXComponent=!0;const kN={toc:[]};function yN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}yN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}DN.isMDXComponent=!0;const wN={toc:[]};function _N(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gN.isMDXComponent=!0;const TN={toc:[]};function xN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xN.isMDXComponent=!0;const CN={toc:[]};function vN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}vN.isMDXComponent=!0;const LN={toc:[]};function ZN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}NN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}AN.isMDXComponent=!0;const WN={toc:[]};function RN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}RN.isMDXComponent=!0;const IN={toc:[]};function PN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}PN.isMDXComponent=!0;const SN={toc:[]};function EN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}EN.isMDXComponent=!0;const BN={toc:[]};function GN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}GN.isMDXComponent=!0;const ON={toc:[]};function UN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ON,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}UN.isMDXComponent=!0;const FN={toc:[]};function qN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}qN.isMDXComponent=!0;const VN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}jN.isMDXComponent=!0;const HN={toc:[]};function QN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}QN.isMDXComponent=!0;const YN={toc:[]};function $N(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}$N.isMDXComponent=!0;const KN={toc:[]};function JN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}JN.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}rz.isMDXComponent=!0;const sz={toc:[]};function cz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}cz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}dz.isMDXComponent=!0;const hz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}fz.isMDXComponent=!0;const kz={toc:[]};function yz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}yz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Dz.isMDXComponent=!0;const wz={toc:[]};function _z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}gz.isMDXComponent=!0;const Tz={toc:[]};function xz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}xz.isMDXComponent=!0;const Cz={toc:[]};function vz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}vz.isMDXComponent=!0;const Lz={toc:[]};function Zz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Nz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Az.isMDXComponent=!0;const Wz={toc:[]};function Rz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Rz.isMDXComponent=!0;const Iz={toc:[]};function Pz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Pz.isMDXComponent=!0;const Sz={toc:[]};function Ez(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Ez.isMDXComponent=!0;const Bz={toc:[]};function Gz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Gz.isMDXComponent=!0;const Oz={toc:[]};function Uz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Uz.isMDXComponent=!0;const Fz={toc:[]};function qz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qz.isMDXComponent=!0;const Vz={toc:[]};function jz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}jz.isMDXComponent=!0;const Hz={toc:[]};function Qz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Qz.isMDXComponent=!0;const Yz={toc:[]};function $z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$z.isMDXComponent=!0;const Kz={toc:[]};function Jz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Jz.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}rA.isMDXComponent=!0;const sA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}cA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}dA.isMDXComponent=!0;const hA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}fA.isMDXComponent=!0;const kA={toc:[]};function yA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}yA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}DA.isMDXComponent=!0;const wA={toc:[]};function _A(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gA.isMDXComponent=!0;const TA={toc:[]};function xA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}xA.isMDXComponent=!0;const CA={toc:[]};function vA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}vA.isMDXComponent=!0;const LA={toc:[]};function ZA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}NA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}AA.isMDXComponent=!0;const WA={toc:[]};function RA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}RA.isMDXComponent=!0;const IA={toc:[]};function PA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}PA.isMDXComponent=!0;const SA={toc:[]};function EA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}EA.isMDXComponent=!0;const BA={toc:[]};function GA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}GA.isMDXComponent=!0;const OA={toc:[]};function UA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}UA.isMDXComponent=!0;const FA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qA.isMDXComponent=!0;const VA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}jA.isMDXComponent=!0;const HA={toc:[]};function QA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}QA.isMDXComponent=!0;const YA={toc:[]};function $A(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}$A.isMDXComponent=!0;const KA={toc:[]};function JA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}JA.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}rW.isMDXComponent=!0;const sW={toc:[]};function cW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}cW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}dW.isMDXComponent=!0;const hW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}fW.isMDXComponent=!0;const kW={toc:[]};function yW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}yW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}DW.isMDXComponent=!0;const wW={toc:[]};function _W(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}gW.isMDXComponent=!0;const TW={toc:[]};function xW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xW.isMDXComponent=!0;const CW={toc:[]};function vW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}vW.isMDXComponent=!0;const LW={toc:[]};function ZW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}NW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}AW.isMDXComponent=!0;const WW={toc:[]};function RW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}RW.isMDXComponent=!0;const IW={toc:[]};function PW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}PW.isMDXComponent=!0;const SW={toc:[]};function EW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}EW.isMDXComponent=!0;const BW={toc:[]};function GW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}GW.isMDXComponent=!0;const OW={toc:[]};function UW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}UW.isMDXComponent=!0;const FW={toc:[]};function qW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qW.isMDXComponent=!0;const VW={toc:[]};function jW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}jW.isMDXComponent=!0;const HW={toc:[]};function QW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}QW.isMDXComponent=!0;const YW={toc:[]};function $W(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$W.isMDXComponent=!0;const KW={toc:[]};function JW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}JW.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}rR.isMDXComponent=!0;const sR={toc:[]};function cR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}cR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dR.isMDXComponent=!0;const hR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fR.isMDXComponent=!0;const kR={toc:[]};function yR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}yR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}DR.isMDXComponent=!0;const wR={toc:[]};function _R(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}gR.isMDXComponent=!0;const TR={toc:[]};function xR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}xR.isMDXComponent=!0;const CR={toc:[]};function vR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}vR.isMDXComponent=!0;const LR={toc:[]};function ZR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}NR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}AR.isMDXComponent=!0;const WR={toc:[]};function RR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}RR.isMDXComponent=!0;const IR={toc:[]};function PR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}PR.isMDXComponent=!0;const SR={toc:[]};function ER(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}ER.isMDXComponent=!0;const BR={toc:[]};function GR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}GR.isMDXComponent=!0;const OR={toc:[]};function UR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}UR.isMDXComponent=!0;const FR={toc:[]};function qR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qR.isMDXComponent=!0;const VR={toc:[]};function jR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}jR.isMDXComponent=!0;const HR={toc:[]};function QR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}QR.isMDXComponent=!0;const YR={toc:[]};function $R(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$R.isMDXComponent=!0;const KR={toc:[]};function JR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}JR.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}rI.isMDXComponent=!0;const sI={toc:[]};function cI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}cI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}dI.isMDXComponent=!0;const hI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}fI.isMDXComponent=!0;const kI={toc:[]};function yI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}yI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}DI.isMDXComponent=!0;const wI={toc:[]};function _I(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}gI.isMDXComponent=!0;const TI={toc:[]};function xI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}xI.isMDXComponent=!0;const CI={toc:[]};function vI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}vI.isMDXComponent=!0;const LI={toc:[]};function ZI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}AI.isMDXComponent=!0;const WI={toc:[]};function RI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}RI.isMDXComponent=!0;const II={toc:[]};function PI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},II,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}PI.isMDXComponent=!0;const SI={toc:[]};function EI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}EI.isMDXComponent=!0;const BI={toc:[]};function GI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}GI.isMDXComponent=!0;const OI={toc:[]};function UI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}UI.isMDXComponent=!0;const FI={toc:[]};function qI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}qI.isMDXComponent=!0;const VI={toc:[]};function jI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}jI.isMDXComponent=!0;const HI={toc:[]};function QI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}QI.isMDXComponent=!0;const YI={toc:[]};function $I(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}$I.isMDXComponent=!0;const KI={toc:[]};function JI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}JI.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}rP.isMDXComponent=!0;const sP={toc:[]};function cP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}cP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}dP.isMDXComponent=!0;const hP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}fP.isMDXComponent=!0;const kP={toc:[]};function yP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}yP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DP.isMDXComponent=!0;const wP={toc:[]};function _P(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gP.isMDXComponent=!0;const TP={toc:[]};function xP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}xP.isMDXComponent=!0;const CP={toc:[]};function vP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}vP.isMDXComponent=!0;const LP={toc:[]};function ZP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}NP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}AP.isMDXComponent=!0;const WP={toc:[]};function RP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}RP.isMDXComponent=!0;const IP={toc:[]};function PP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}PP.isMDXComponent=!0;const SP={toc:[]};function EP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}EP.isMDXComponent=!0;const BP={toc:[]};function GP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}GP.isMDXComponent=!0;const OP={toc:[]};function UP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}UP.isMDXComponent=!0;const FP={toc:[]};function qP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qP.isMDXComponent=!0;const VP={toc:[]};function jP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}jP.isMDXComponent=!0;const HP={toc:[]};function QP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}QP.isMDXComponent=!0;const YP={toc:[]};function $P(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}$P.isMDXComponent=!0;const KP={toc:[]};function JP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}JP.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}rS.isMDXComponent=!0;const sS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}cS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}dS.isMDXComponent=!0;const hS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fS.isMDXComponent=!0;const kS={toc:[]};function yS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}yS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}DS.isMDXComponent=!0;const wS={toc:[]};function _S(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}gS.isMDXComponent=!0;const TS={toc:[]};function xS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}xS.isMDXComponent=!0;const CS={toc:[]};function vS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}vS.isMDXComponent=!0;const LS={toc:[]};function ZS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}AS.isMDXComponent=!0;const WS={toc:[]};function RS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}RS.isMDXComponent=!0;const IS={toc:[]};function PS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PS.isMDXComponent=!0;const SS={toc:[]};function ES(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}ES.isMDXComponent=!0;const BS={toc:[]};function GS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}GS.isMDXComponent=!0;const OS={toc:[]};function US(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}US.isMDXComponent=!0;const FS={toc:[]};function qS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}qS.isMDXComponent=!0;const VS={toc:[]};function jS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}jS.isMDXComponent=!0;const HS={toc:[]};function QS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}QS.isMDXComponent=!0;const YS={toc:[]};function $S(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}$S.isMDXComponent=!0;const KS={toc:[]};function JS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}JS.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}rE.isMDXComponent=!0;const sE={toc:[]};function cE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dE.isMDXComponent=!0;const hE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}fE.isMDXComponent=!0;const kE={toc:[]};function yE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}yE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ME,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}DE.isMDXComponent=!0;const wE={toc:[]};function _E(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gE.isMDXComponent=!0;const TE={toc:[]};function xE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}xE.isMDXComponent=!0;const CE={toc:[]};function vE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vE.isMDXComponent=!0;const LE={toc:[]};function ZE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}AE.isMDXComponent=!0;const WE={toc:[]};function RE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}RE.isMDXComponent=!0;const IE={toc:[]};function PE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}PE.isMDXComponent=!0;const SE={toc:[]};function EE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}EE.isMDXComponent=!0;const BE={toc:[]};function GE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}GE.isMDXComponent=!0;const OE={toc:[]};function UE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}UE.isMDXComponent=!0;const FE={toc:[]};function qE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}qE.isMDXComponent=!0;const VE={toc:[]};function jE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}jE.isMDXComponent=!0;const HE={toc:[]};function QE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}QE.isMDXComponent=!0;const YE={toc:[]};function $E(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}$E.isMDXComponent=!0;const KE={toc:[]};function JE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}JE.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}rB.isMDXComponent=!0;const sB={toc:[]};function cB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}cB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dB.isMDXComponent=!0;const hB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}fB.isMDXComponent=!0;const kB={toc:[]};function yB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}DB.isMDXComponent=!0;const wB={toc:[]};function _B(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gB.isMDXComponent=!0;const TB={toc:[]};function xB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}xB.isMDXComponent=!0;const CB={toc:[]};function vB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}vB.isMDXComponent=!0;const LB={toc:[]};function ZB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}NB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}AB.isMDXComponent=!0;const WB={toc:[]};function RB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}RB.isMDXComponent=!0;const IB={toc:[]};function PB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}PB.isMDXComponent=!0;const SB={toc:[]};function EB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}EB.isMDXComponent=!0;const BB={toc:[]};function GB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}GB.isMDXComponent=!0;const OB={toc:[]};function UB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}UB.isMDXComponent=!0;const FB={toc:[]};function qB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qB.isMDXComponent=!0;const VB={toc:[]};function jB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}jB.isMDXComponent=!0;const HB={toc:[]};function QB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}QB.isMDXComponent=!0;const YB={toc:[]};function $B(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}$B.isMDXComponent=!0;const KB={toc:[]};function JB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}JB.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}rG.isMDXComponent=!0;const sG={toc:[]};function cG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}dG.isMDXComponent=!0;const hG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}fG.isMDXComponent=!0;const kG={toc:[]};function yG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}yG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}DG.isMDXComponent=!0;const wG={toc:[]};function _G(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}gG.isMDXComponent=!0;const TG={toc:[]};function xG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}xG.isMDXComponent=!0;const CG={toc:[]};function vG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}vG.isMDXComponent=!0;const LG={toc:[]};function ZG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}NG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}AG.isMDXComponent=!0;const WG={toc:[]};function RG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}RG.isMDXComponent=!0;const IG={toc:[]};function PG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}PG.isMDXComponent=!0;const SG={toc:[]};function EG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}EG.isMDXComponent=!0;const BG={toc:[]};function GG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}GG.isMDXComponent=!0;const OG={toc:[]};function UG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}UG.isMDXComponent=!0;const FG={toc:[]};function qG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qG.isMDXComponent=!0;const VG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}jG.isMDXComponent=!0;const HG={toc:[]};function QG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}QG.isMDXComponent=!0;const YG={toc:[]};function $G(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}$G.isMDXComponent=!0;const KG={toc:[]};function JG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}JG.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}rO.isMDXComponent=!0;const sO={toc:[]};function cO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}cO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}dO.isMDXComponent=!0;const hO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}fO.isMDXComponent=!0;const kO={toc:[]};function yO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}yO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DO.isMDXComponent=!0;const wO={toc:[]};function _O(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gO.isMDXComponent=!0;const TO={toc:[]};function xO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}xO.isMDXComponent=!0;const CO={toc:[]};function vO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}vO.isMDXComponent=!0;const LO={toc:[]};function ZO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}NO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}AO.isMDXComponent=!0;const WO={toc:[]};function RO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}RO.isMDXComponent=!0;const IO={toc:[]};function PO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}PO.isMDXComponent=!0;const SO={toc:[]};function EO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}EO.isMDXComponent=!0;const BO={toc:[]};function GO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}GO.isMDXComponent=!0;const OO={toc:[]};function UO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}UO.isMDXComponent=!0;const FO={toc:[]};function qO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}qO.isMDXComponent=!0;const VO={toc:[]};function jO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}jO.isMDXComponent=!0;const HO={toc:[]};function QO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}QO.isMDXComponent=!0;const YO={toc:[]};function $O(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}$O.isMDXComponent=!0;const KO={toc:[]};function JO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}JO.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}rU.isMDXComponent=!0;const sU={toc:[]};function cU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}dU.isMDXComponent=!0;const hU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}fU.isMDXComponent=!0;const kU={toc:[]};function yU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}yU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}DU.isMDXComponent=!0;const wU={toc:[]};function _U(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}gU.isMDXComponent=!0;const TU={toc:[]};function xU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xU.isMDXComponent=!0;const CU={toc:[]};function vU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}vU.isMDXComponent=!0;const LU={toc:[]};function ZU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}NU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}AU.isMDXComponent=!0;const WU={toc:[]};function RU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}RU.isMDXComponent=!0;const IU={toc:[]};function PU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}PU.isMDXComponent=!0;const SU={toc:[]};function EU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}EU.isMDXComponent=!0;const BU={toc:[]};function GU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}GU.isMDXComponent=!0;const OU={toc:[]};function UU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}UU.isMDXComponent=!0;const FU={toc:[]};function qU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qU.isMDXComponent=!0;const VU={toc:[]};function jU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}jU.isMDXComponent=!0;const HU={toc:[]};function QU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}QU.isMDXComponent=!0;const YU={toc:[]};function $U(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}$U.isMDXComponent=!0;const KU={toc:[]};function JU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}JU.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}rF.isMDXComponent=!0;const sF={toc:[]};function cF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}dF.isMDXComponent=!0;const hF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}fF.isMDXComponent=!0;const kF={toc:[]};function yF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}yF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}DF.isMDXComponent=!0;const wF={toc:[]};function _F(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}gF.isMDXComponent=!0;const TF={toc:[]};function xF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}xF.isMDXComponent=!0;const CF={toc:[]};function vF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}vF.isMDXComponent=!0;const LF={toc:[]};function ZF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}NF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}AF.isMDXComponent=!0;const WF={toc:[]};function RF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}RF.isMDXComponent=!0;const IF={toc:[]};function PF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}PF.isMDXComponent=!0;const SF={toc:[]};function EF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}EF.isMDXComponent=!0;const BF={toc:[]};function GF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}GF.isMDXComponent=!0;const OF={toc:[]};function UF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}UF.isMDXComponent=!0;const FF={toc:[]};function qF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}qF.isMDXComponent=!0;const VF={toc:[]};function jF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}jF.isMDXComponent=!0;const HF={toc:[]};function QF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}QF.isMDXComponent=!0;const YF={toc:[]};function $F(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}$F.isMDXComponent=!0;const KF={toc:[]};function JF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}JF.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}rq.isMDXComponent=!0;const sq={toc:[]};function cq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}dq.isMDXComponent=!0;const hq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}fq.isMDXComponent=!0;const kq={toc:[]};function yq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}yq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Dq.isMDXComponent=!0;const wq={toc:[]};function _q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}gq.isMDXComponent=!0;const Tq={toc:[]};function xq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xq.isMDXComponent=!0;const Cq={toc:[]};function vq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}vq.isMDXComponent=!0;const Lq={toc:[]};function Zq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Nq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Aq.isMDXComponent=!0;const Wq={toc:[]};function Rq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Rq.isMDXComponent=!0;const Iq={toc:[]};function Pq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Pq.isMDXComponent=!0;const Sq={toc:[]};function Eq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Eq.isMDXComponent=!0;const Bq={toc:[]};function Gq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Gq.isMDXComponent=!0;const Oq={toc:[]};function Uq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Uq.isMDXComponent=!0;const Fq={toc:[]};function qq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}qq.isMDXComponent=!0;const Vq={toc:[]};function jq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}jq.isMDXComponent=!0;const Hq={toc:[]};function Qq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Qq.isMDXComponent=!0;const Yq={toc:[]};function $q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}$q.isMDXComponent=!0;const Kq={toc:[]};function Jq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Jq.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}rV.isMDXComponent=!0;const sV={toc:[]};function cV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}dV.isMDXComponent=!0;const hV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}fV.isMDXComponent=!0;const kV={toc:[]};function yV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}yV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}DV.isMDXComponent=!0;const wV={toc:[]};function _V(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gV.isMDXComponent=!0;const TV={toc:[]};function xV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}xV.isMDXComponent=!0;const CV={toc:[]};function vV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}vV.isMDXComponent=!0;const LV={toc:[]};function ZV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}NV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}AV.isMDXComponent=!0;const WV={toc:[]};function RV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}RV.isMDXComponent=!0;const IV={toc:[]};function PV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}PV.isMDXComponent=!0;const SV={toc:[]};function EV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}EV.isMDXComponent=!0;const BV={toc:[]};function GV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}GV.isMDXComponent=!0;const OV={toc:[]};function UV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}UV.isMDXComponent=!0;const FV={toc:[]};function qV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qV.isMDXComponent=!0;const VV={toc:[]};function jV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}jV.isMDXComponent=!0;const HV={toc:[]};function QV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QV.isMDXComponent=!0;const YV={toc:[]};function $V(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}$V.isMDXComponent=!0;const KV={toc:[]};function JV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}JV.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}rj.isMDXComponent=!0;const sj={toc:[]};function cj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ij,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}dj.isMDXComponent=!0;const hj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}fj.isMDXComponent=!0;const kj={toc:[]};function yj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Dj.isMDXComponent=!0;const wj={toc:[]};function _j(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}gj.isMDXComponent=!0;const Tj={toc:[]};function xj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xj.isMDXComponent=!0;const Cj={toc:[]};function vj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}vj.isMDXComponent=!0;const Lj={toc:[]};function Zj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Nj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Aj.isMDXComponent=!0;const Wj={toc:[]};function Rj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Rj.isMDXComponent=!0;const Ij={toc:[]};function Pj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ij,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Pj.isMDXComponent=!0;const Sj={toc:[]};function Ej(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ej.isMDXComponent=!0;const Bj={toc:[]};function Gj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Gj.isMDXComponent=!0;const Oj={toc:[]};function Uj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Uj.isMDXComponent=!0;const Fj={toc:[]};function qj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}qj.isMDXComponent=!0;const Vj={toc:[]};function jj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}jj.isMDXComponent=!0;const Hj={toc:[]};function Qj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Qj.isMDXComponent=!0;const Yj={toc:[]};function $j(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}$j.isMDXComponent=!0;const Kj={toc:[]};function Jj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Jj.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}rH.isMDXComponent=!0;const sH={toc:[]};function cH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}cH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}dH.isMDXComponent=!0;const hH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}fH.isMDXComponent=!0;const kH={toc:[]};function yH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}yH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}DH.isMDXComponent=!0;const wH={toc:[]};function _H(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}gH.isMDXComponent=!0;const TH={toc:[]};function xH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}xH.isMDXComponent=!0;const CH={toc:[]};function vH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vH.isMDXComponent=!0;const LH={toc:[]};function ZH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}AH.isMDXComponent=!0;const WH={toc:[]};function RH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}RH.isMDXComponent=!0;const IH={toc:[]};function PH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}PH.isMDXComponent=!0;const SH={toc:[]};function EH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}EH.isMDXComponent=!0;const BH={toc:[]};function GH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}GH.isMDXComponent=!0;const OH={toc:[]};function UH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}UH.isMDXComponent=!0;const FH={toc:[]};function qH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qH.isMDXComponent=!0;const VH={toc:[]};function jH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jH.isMDXComponent=!0;const HH={toc:[]};function QH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}QH.isMDXComponent=!0;const YH={toc:[]};function $H(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}$H.isMDXComponent=!0;const KH={toc:[]};function JH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}JH.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}rQ.isMDXComponent=!0;const sQ={toc:[]};function cQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}cQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}fQ.isMDXComponent=!0;const kQ={toc:[]};function yQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}yQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}DQ.isMDXComponent=!0;const wQ={toc:[]};function _Q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}gQ.isMDXComponent=!0;const TQ={toc:[]};function xQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}xQ.isMDXComponent=!0;const CQ={toc:[]};function vQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}vQ.isMDXComponent=!0;const LQ={toc:[]};function ZQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}NQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}AQ.isMDXComponent=!0;const WQ={toc:[]};function RQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}RQ.isMDXComponent=!0;const IQ={toc:[]};function PQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}PQ.isMDXComponent=!0;const SQ={toc:[]};function EQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}EQ.isMDXComponent=!0;const BQ={toc:[]};function GQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}GQ.isMDXComponent=!0;const OQ={toc:[]};function UQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}UQ.isMDXComponent=!0;const FQ={toc:[]};function qQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}qQ.isMDXComponent=!0;const VQ={toc:[]};function jQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}jQ.isMDXComponent=!0;const HQ={toc:[]};function QQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}QQ.isMDXComponent=!0;const YQ={toc:[]};function $Q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}$Q.isMDXComponent=!0;const KQ={toc:[]};function JQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}JQ.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}rY.isMDXComponent=!0;const sY={toc:[]};function cY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dY.isMDXComponent=!0;const hY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}fY.isMDXComponent=!0;const kY={toc:[]};function yY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}yY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}DY.isMDXComponent=!0;const wY={toc:[]};function _Y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}gY.isMDXComponent=!0;const TY={toc:[]};function xY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xY.isMDXComponent=!0;const CY={toc:[]};function vY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}vY.isMDXComponent=!0;const LY={toc:[]};function ZY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}NY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}AY.isMDXComponent=!0;const WY={toc:[]};function RY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}RY.isMDXComponent=!0;const IY={toc:[]};function PY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}PY.isMDXComponent=!0;const SY={toc:[]};function EY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}EY.isMDXComponent=!0;const BY={toc:[]};function GY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}GY.isMDXComponent=!0;const OY={toc:[]};function UY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}UY.isMDXComponent=!0;const FY={toc:[]};function qY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}qY.isMDXComponent=!0;const VY={toc:[]};function jY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}jY.isMDXComponent=!0;const HY={toc:[]};function QY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QY.isMDXComponent=!0;const YY={toc:[]};function $Y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}$Y.isMDXComponent=!0;const KY={toc:[]};function JY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}JY.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}r$.isMDXComponent=!0;const s$={toc:[]};function c$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}c$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}d$.isMDXComponent=!0;const h$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}f$.isMDXComponent=!0;const k$={toc:[]};function y$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}y$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}D$.isMDXComponent=!0;const w$={toc:[]};function _$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}g$.isMDXComponent=!0;const T$={toc:[]};function x$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}x$.isMDXComponent=!0;const C$={toc:[]};function v$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}v$.isMDXComponent=!0;const L$={toc:[]};function Z$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}N$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}A$.isMDXComponent=!0;const W$={toc:[]};function R$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}R$.isMDXComponent=!0;const I$={toc:[]};function P$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}P$.isMDXComponent=!0;const S$={toc:[]};function E$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}E$.isMDXComponent=!0;const B$={toc:[]};function G$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}G$.isMDXComponent=!0;const O$={toc:[]};function U$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}U$.isMDXComponent=!0;const F$={toc:[]};function q$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}q$.isMDXComponent=!0;const V$={toc:[]};function j$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}j$.isMDXComponent=!0;const H$={toc:[]};function Q$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Q$.isMDXComponent=!0;const Y$={toc:[]};function $$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}$$.isMDXComponent=!0;const K$={toc:[]};function J$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}J$.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}rK.isMDXComponent=!0;const sK={toc:[]};function cK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}cK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dK.isMDXComponent=!0;const hK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}fK.isMDXComponent=!0;const kK={toc:[]};function yK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}yK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}DK.isMDXComponent=!0;const wK={toc:[]};function _K(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}gK.isMDXComponent=!0;const TK={toc:[]};function xK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xK.isMDXComponent=!0;const CK={toc:[]};function vK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}vK.isMDXComponent=!0;const LK={toc:[]};function ZK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}AK.isMDXComponent=!0;const WK={toc:[]};function RK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}RK.isMDXComponent=!0;const IK={toc:[]};function PK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}PK.isMDXComponent=!0;const SK={toc:[]};function EK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}EK.isMDXComponent=!0;const BK={toc:[]};function GK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GK.isMDXComponent=!0;const OK={toc:[]};function UK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}UK.isMDXComponent=!0;const FK={toc:[]};function qK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qK.isMDXComponent=!0;const VK={toc:[]};function jK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}jK.isMDXComponent=!0;const HK={toc:[]};function QK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QK.isMDXComponent=!0;const YK={toc:[]};function $K(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}$K.isMDXComponent=!0;const KK={toc:[]};function JK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}JK.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}rJ.isMDXComponent=!0;const sJ={toc:[]};function cJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}fJ.isMDXComponent=!0;const kJ={toc:[]};function yJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}yJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}DJ.isMDXComponent=!0;const wJ={toc:[]};function _J(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gJ.isMDXComponent=!0;const TJ={toc:[]};function xJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}xJ.isMDXComponent=!0;const CJ={toc:[]};function vJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function ZJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}NJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}AJ.isMDXComponent=!0;const WJ={toc:[]};function RJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}RJ.isMDXComponent=!0;const IJ={toc:[]};function PJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PJ.isMDXComponent=!0;const SJ={toc:[]};function EJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}EJ.isMDXComponent=!0;const BJ={toc:[]};function GJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}GJ.isMDXComponent=!0;const OJ={toc:[]};function UJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}UJ.isMDXComponent=!0;const FJ={toc:[]};function qJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qJ.isMDXComponent=!0;const VJ={toc:[]};function jJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}jJ.isMDXComponent=!0;const HJ={toc:[]};function QJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}QJ.isMDXComponent=!0;const YJ={toc:[]};function $J(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}$J.isMDXComponent=!0;const KJ={toc:[]};function JJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}JJ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}r0.isMDXComponent=!0;const s0={toc:[]};function c0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}c0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}d0.isMDXComponent=!0;const h0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}f0.isMDXComponent=!0;const k0={toc:[]};function y0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}y0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}D0.isMDXComponent=!0;const w0={toc:[]};function _0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}g0.isMDXComponent=!0;const T0={toc:[]};function x0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}x0.isMDXComponent=!0;const C0={toc:[]};function v0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}v0.isMDXComponent=!0;const L0={toc:[]};function Z0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}N0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}A0.isMDXComponent=!0;const W0={toc:[]};function R0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}R0.isMDXComponent=!0;const I0={toc:[]};function P0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}P0.isMDXComponent=!0;const S0={toc:[]};function E0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}E0.isMDXComponent=!0;const B0={toc:[]};function G0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}G0.isMDXComponent=!0;const O0={toc:[]};function U0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}U0.isMDXComponent=!0;const F0={toc:[]};function q0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}q0.isMDXComponent=!0;const V0={toc:[]};function j0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}j0.isMDXComponent=!0;const H0={toc:[]};function Q0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Q0.isMDXComponent=!0;const Y0={toc:[]};function $0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}$0.isMDXComponent=!0;const K0={toc:[]};function J0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}J0.isMDXComponent=!0;const t4={toc:[]};function n4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}n4.isMDXComponent=!0;const e4={toc:[]};function o4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}r4.isMDXComponent=!0;const s4={toc:[]};function c4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}c4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d4.isMDXComponent=!0;const h4={toc:[]};function f4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}f4.isMDXComponent=!0;const k4={toc:[]};function y4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}y4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}D4.isMDXComponent=!0;const w4={toc:[]};function _4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}g4.isMDXComponent=!0;const T4={toc:[]};function x4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}x4.isMDXComponent=!0;const C4={toc:[]};function v4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}v4.isMDXComponent=!0;const L4={toc:[]};function Z4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Z4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}A4.isMDXComponent=!0;const W4={toc:[]};function R4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}R4.isMDXComponent=!0;const I4={toc:[]};function P4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}P4.isMDXComponent=!0;const S4={toc:[]};function E4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}E4.isMDXComponent=!0;const B4={toc:[]};function G4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}G4.isMDXComponent=!0;const O4={toc:[]};function U4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}U4.isMDXComponent=!0;const F4={toc:[]};function q4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}q4.isMDXComponent=!0;const V4={toc:[]};function j4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}j4.isMDXComponent=!0;const H4={toc:[]};function Q4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Q4.isMDXComponent=!0;const Y4={toc:[]};function $4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}$4.isMDXComponent=!0;const K4={toc:[]};function J4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}J4.isMDXComponent=!0;const t3={toc:[]};function n3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}n3.isMDXComponent=!0;const e3={toc:[]};function o3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}r3.isMDXComponent=!0;const s3={toc:[]};function c3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}c3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}d3.isMDXComponent=!0;const h3={toc:[]};function f3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}f3.isMDXComponent=!0;const k3={toc:[]};function y3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}y3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}D3.isMDXComponent=!0;const w3={toc:[]};function _3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}g3.isMDXComponent=!0;const T3={toc:[]};function x3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}x3.isMDXComponent=!0;const C3={toc:[]};function v3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}v3.isMDXComponent=!0;const L3={toc:[]};function Z3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Z3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}N3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}A3.isMDXComponent=!0;const W3={toc:[]};function R3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}R3.isMDXComponent=!0;const I3={toc:[]};function P3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}P3.isMDXComponent=!0;const S3={toc:[]};function E3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}E3.isMDXComponent=!0;const B3={toc:[]};function G3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}G3.isMDXComponent=!0;const O3={toc:[]};function U3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}U3.isMDXComponent=!0;const F3={toc:[]};function q3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}q3.isMDXComponent=!0;const V3={toc:[]};function j3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}j3.isMDXComponent=!0;const H3={toc:[]};function Q3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Q3.isMDXComponent=!0;const Y3={toc:[]};function $3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}$3.isMDXComponent=!0;const K3={toc:[]};function J3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}J3.isMDXComponent=!0;const t5={toc:[]};function n5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}n5.isMDXComponent=!0;const e5={toc:[]};function o5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}r5.isMDXComponent=!0;const s5={toc:[]};function c5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}c5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}d5.isMDXComponent=!0;const h5={toc:[]};function f5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}f5.isMDXComponent=!0;const k5={toc:[]};function y5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}y5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}D5.isMDXComponent=!0;const w5={toc:[]};function _5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_5.isMDXComponent=!0;const X5={toc:[]};function g5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}g5.isMDXComponent=!0;const T5={toc:[]};function x5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}x5.isMDXComponent=!0;const C5={toc:[]};function v5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}v5.isMDXComponent=!0;const L5={toc:[]};function Z5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Z5.isMDXComponent=!0;const b5={toc:[]};function N5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}N5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}A5.isMDXComponent=!0;const W5={toc:[]};function R5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}R5.isMDXComponent=!0;const I5={toc:[]};function P5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}P5.isMDXComponent=!0;const S5={toc:[]};function E5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}E5.isMDXComponent=!0;const B5={toc:[]};function G5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}G5.isMDXComponent=!0;const O5={toc:[]};function U5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}U5.isMDXComponent=!0;const F5={toc:[]};function q5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}q5.isMDXComponent=!0;const V5={toc:[]};function j5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}j5.isMDXComponent=!0;const H5={toc:[]};function Q5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Q5.isMDXComponent=!0;const Y5={toc:[]};function $5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}$5.isMDXComponent=!0;const K5={toc:[]};function J5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}J5.isMDXComponent=!0;const t2={toc:[]};function n2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}n2.isMDXComponent=!0;const e2={toc:[]};function o2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}r2.isMDXComponent=!0;const s2={toc:[]};function c2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}c2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}d2.isMDXComponent=!0;const h2={toc:[]};function f2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}f2.isMDXComponent=!0;const k2={toc:[]};function y2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}y2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}D2.isMDXComponent=!0;const w2={toc:[]};function _2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}g2.isMDXComponent=!0;const T2={toc:[]};function x2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}x2.isMDXComponent=!0;const C2={toc:[]};function v2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}v2.isMDXComponent=!0;const L2={toc:[]};function Z2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}N2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}A2.isMDXComponent=!0;const W2={toc:[]};function R2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}R2.isMDXComponent=!0;const I2={toc:[]};function P2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}P2.isMDXComponent=!0;const S2={toc:[]};function E2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}E2.isMDXComponent=!0;const B2={toc:[]};function G2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}G2.isMDXComponent=!0;const O2={toc:[]};function U2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}U2.isMDXComponent=!0;const F2={toc:[]};function q2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}q2.isMDXComponent=!0;const V2={toc:[]};function j2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}j2.isMDXComponent=!0;const H2={toc:[]};function Q2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Q2.isMDXComponent=!0;const Y2={toc:[]};function $2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}$2.isMDXComponent=!0;const K2={toc:[]};function J2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}J2.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}r1.isMDXComponent=!0;const s1={toc:[]};function c1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}c1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}d1.isMDXComponent=!0;const h1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}f1.isMDXComponent=!0;const k1={toc:[]};function y1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}y1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}D1.isMDXComponent=!0;const w1={toc:[]};function _1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}g1.isMDXComponent=!0;const T1={toc:[]};function x1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}x1.isMDXComponent=!0;const C1={toc:[]};function v1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}v1.isMDXComponent=!0;const L1={toc:[]};function Z1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}N1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}A1.isMDXComponent=!0;const W1={toc:[]};function R1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}R1.isMDXComponent=!0;const I1={toc:[]};function P1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}P1.isMDXComponent=!0;const S1={toc:[]};function E1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}E1.isMDXComponent=!0;const B1={toc:[]};function G1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}G1.isMDXComponent=!0;const O1={toc:[]};function U1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}U1.isMDXComponent=!0;const F1={toc:[]};function q1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}q1.isMDXComponent=!0;const V1={toc:[]};function j1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}j1.isMDXComponent=!0;const H1={toc:[]};function Q1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Q1.isMDXComponent=!0;const Y1={toc:[]};function $1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}$1.isMDXComponent=!0;const K1={toc:[]};function J1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}J1.isMDXComponent=!0;const t6={toc:[]};function n6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}n6.isMDXComponent=!0;const e6={toc:[]};function o6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}r6.isMDXComponent=!0;const s6={toc:[]};function c6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}c6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}d6.isMDXComponent=!0;const h6={toc:[]};function f6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}f6.isMDXComponent=!0;const k6={toc:[]};function y6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}y6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}D6.isMDXComponent=!0;const w6={toc:[]};function _6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}g6.isMDXComponent=!0;const T6={toc:[]};function x6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}x6.isMDXComponent=!0;const C6={toc:[]};function v6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}v6.isMDXComponent=!0;const L6={toc:[]};function Z6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Z6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}N6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}A6.isMDXComponent=!0;const W6={toc:[]};function R6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}R6.isMDXComponent=!0;const I6={toc:[]};function P6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}P6.isMDXComponent=!0;const S6={toc:[]};function E6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}E6.isMDXComponent=!0;const B6={toc:[]};function G6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}G6.isMDXComponent=!0;const O6={toc:[]};function U6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}U6.isMDXComponent=!0;const F6={toc:[]};function q6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}q6.isMDXComponent=!0;const V6={toc:[]};function j6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}j6.isMDXComponent=!0;const H6={toc:[]};function Q6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Q6.isMDXComponent=!0;const Y6={toc:[]};function $6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$6.isMDXComponent=!0;const K6={toc:[]};function J6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}J6.isMDXComponent=!0;const t8={toc:[]};function n8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}n8.isMDXComponent=!0;const e8={toc:[]};function o8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}r8.isMDXComponent=!0;const s8={toc:[]};function c8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}c8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}d8.isMDXComponent=!0;const h8={toc:[]};function f8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}f8.isMDXComponent=!0;const k8={toc:[]};function y8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}y8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}D8.isMDXComponent=!0;const w8={toc:[]};function _8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}g8.isMDXComponent=!0;const T8={toc:[]};function x8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}x8.isMDXComponent=!0;const C8={toc:[]};function v8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}v8.isMDXComponent=!0;const L8={toc:[]};function Z8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Z8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}N8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}A8.isMDXComponent=!0;const W8={toc:[]};function R8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}R8.isMDXComponent=!0;const I8={toc:[]};function P8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}P8.isMDXComponent=!0;const S8={toc:[]};function E8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}E8.isMDXComponent=!0;const B8={toc:[]};function G8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}G8.isMDXComponent=!0;const O8={toc:[]};function U8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}U8.isMDXComponent=!0;const F8={toc:[]};function q8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}q8.isMDXComponent=!0;const V8={toc:[]};function j8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}j8.isMDXComponent=!0;const H8={toc:[]};function Q8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Q8.isMDXComponent=!0;const Y8={toc:[]};function $8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}$8.isMDXComponent=!0;const K8={toc:[]};function J8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}J8.isMDXComponent=!0;const t7={toc:[]};function n7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}n7.isMDXComponent=!0;const e7={toc:[]};function o7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}r7.isMDXComponent=!0;const s7={toc:[]};function c7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}c7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}d7.isMDXComponent=!0;const h7={toc:[]};function f7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}f7.isMDXComponent=!0;const k7={toc:[]};function y7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}y7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}D7.isMDXComponent=!0;const w7={toc:[]};function _7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}g7.isMDXComponent=!0;const T7={toc:[]};function x7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}x7.isMDXComponent=!0;const C7={toc:[]};function v7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}v7.isMDXComponent=!0;const L7={toc:[]};function Z7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Z7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}N7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}A7.isMDXComponent=!0;const W7={toc:[]};function R7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}R7.isMDXComponent=!0;const I7={toc:[]};function P7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}P7.isMDXComponent=!0;const S7={toc:[]};function E7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}E7.isMDXComponent=!0;const B7={toc:[]};function G7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}G7.isMDXComponent=!0;const O7={toc:[]};function U7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}U7.isMDXComponent=!0;const F7={toc:[]};function q7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}q7.isMDXComponent=!0;const V7={toc:[]};function j7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}j7.isMDXComponent=!0;const H7={toc:[]};function Q7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Q7.isMDXComponent=!0;const Y7={toc:[]};function $7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}$7.isMDXComponent=!0;const K7={toc:[]};function J7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}J7.isMDXComponent=!0;const t9={toc:[]};function n9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}n9.isMDXComponent=!0;const e9={toc:[]};function o9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}r9.isMDXComponent=!0;const s9={toc:[]};function c9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}c9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}d9.isMDXComponent=!0;const h9={toc:[]};function f9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}f9.isMDXComponent=!0;const k9={toc:[]};function y9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}y9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}D9.isMDXComponent=!0;const w9={toc:[]};function _9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}_9.isMDXComponent=!0;const X9={toc:[]};function g9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}g9.isMDXComponent=!0;const T9={toc:[]};function x9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}x9.isMDXComponent=!0;const C9={toc:[]};function v9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}v9.isMDXComponent=!0;const L9={toc:[]};function Z9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Z9.isMDXComponent=!0;const b9={toc:[]};function N9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}N9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}A9.isMDXComponent=!0;const W9={toc:[]};function R9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}R9.isMDXComponent=!0;const I9={toc:[]};function P9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}P9.isMDXComponent=!0;const S9={toc:[]};function E9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}E9.isMDXComponent=!0;const B9={toc:[]};function G9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}G9.isMDXComponent=!0;const O9={toc:[]};function U9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}U9.isMDXComponent=!0;const F9={toc:[]};function q9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}q9.isMDXComponent=!0;const V9={toc:[]};function j9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}j9.isMDXComponent=!0;const H9={toc:[]};function Q9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Q9.isMDXComponent=!0;const Y9={toc:[]};function $9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}$9.isMDXComponent=!0;const K9={toc:[]};function J9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}J9.isMDXComponent=!0;const ttt={toc:[]};function ntt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ttt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ntt.isMDXComponent=!0;const ett={toc:[]};function ott(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ett,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ptt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}rtt.isMDXComponent=!0;const stt={toc:[]};function ctt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},stt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}ctt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},itt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}dtt.isMDXComponent=!0;const htt={toc:[]};function ftt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},htt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ftt.isMDXComponent=!0;const ktt={toc:[]};function ytt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ktt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ytt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Dtt.isMDXComponent=!0;const wtt={toc:[]};function _tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_tt.isMDXComponent=!0;const Xtt={toc:[]};function gtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}gtt.isMDXComponent=!0;const Ttt={toc:[]};function xtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ttt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xtt.isMDXComponent=!0;const Ctt={toc:[]};function vtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ctt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function Ztt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}Ztt.isMDXComponent=!0;const btt={toc:[]};function Ntt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},btt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ntt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ztt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Att.isMDXComponent=!0;const Wtt={toc:[]};function Rtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Rtt.isMDXComponent=!0;const Itt={toc:[]};function Ptt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Itt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Ptt.isMDXComponent=!0;const Stt={toc:[]};function Ett(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Stt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ett.isMDXComponent=!0;const Btt={toc:[]};function Gtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Btt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Gtt.isMDXComponent=!0;const Ott={toc:[]};function Utt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ott,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Utt.isMDXComponent=!0;const Ftt={toc:[]};function qtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ftt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}qtt.isMDXComponent=!0;const Vtt={toc:[]};function jtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jtt.isMDXComponent=!0;const Htt={toc:[]};function Qtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Htt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Qtt.isMDXComponent=!0;const Ytt={toc:[]};function $tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ytt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}$tt.isMDXComponent=!0;const Ktt={toc:[]};function Jtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ktt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}Jtt.isMDXComponent=!0;const tnt={toc:[]};function nnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}nnt.isMDXComponent=!0;const ent={toc:[]};function ont(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ent,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}ont.isMDXComponent=!0;const pnt={toc:[]};function rnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}rnt.isMDXComponent=!0;const snt={toc:[]};function cnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},snt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cnt.isMDXComponent=!0;const int={toc:[]};function ant(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},int,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ant.isMDXComponent=!0;const lnt={toc:[]};function unt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}unt.isMDXComponent=!0;const mnt={toc:[]};function dnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}dnt.isMDXComponent=!0;const hnt={toc:[]};function fnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}fnt.isMDXComponent=!0;const knt={toc:[]};function ynt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},knt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}ynt.isMDXComponent=!0;const Mnt={toc:[]};function Dnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Dnt.isMDXComponent=!0;const wnt={toc:[]};function _nt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}_nt.isMDXComponent=!0;const Xnt={toc:[]};function gnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}gnt.isMDXComponent=!0;const Tnt={toc:[]};function xnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}xnt.isMDXComponent=!0;const Cnt={toc:[]};function vnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}vnt.isMDXComponent=!0;const Lnt={toc:[]};function Znt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Znt.isMDXComponent=!0;const bnt={toc:[]};function Nnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Nnt.isMDXComponent=!0;const znt={toc:[]};function Ant(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},znt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Ant.isMDXComponent=!0;const Wnt={toc:[]};function Rnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Rnt.isMDXComponent=!0;const Int={toc:[]};function Pnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Int,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Pnt.isMDXComponent=!0;const Snt={toc:[]};function Ent(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Snt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ent.isMDXComponent=!0;const Bnt={toc:[]};function Gnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Gnt.isMDXComponent=!0;const Ont={toc:[]};function Unt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ont,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Unt.isMDXComponent=!0;const Fnt={toc:[]};function qnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}qnt.isMDXComponent=!0;const Vnt={toc:[]};function jnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}jnt.isMDXComponent=!0;const Hnt={toc:[]};function Qnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Qnt.isMDXComponent=!0;const Ynt={toc:[]};function $nt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ynt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}$nt.isMDXComponent=!0;const Knt={toc:[]};function Jnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Knt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Jnt.isMDXComponent=!0;const tet={toc:[]};function net(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}net.isMDXComponent=!0;const eet={toc:[]};function oet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ret.isMDXComponent=!0;const set={toc:[]};function cet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},set,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cet.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},det,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}het.isMDXComponent=!0;const fet={toc:[]};function ket(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}ket.isMDXComponent=!0;const yet={toc:[]};function Met(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Met.isMDXComponent=!0;const Det={toc:[]};function wet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Det,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}wet.isMDXComponent=!0;const _et={toc:[]};function Xet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Xet.isMDXComponent=!0;const get={toc:[]};function Tet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},get,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Tet.isMDXComponent=!0;const xet={toc:[]};function Cet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Cet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Let.isMDXComponent=!0;const Zet={toc:[]};function bet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}bet.isMDXComponent=!0;const Net={toc:[]};function zet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Net,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}zet.isMDXComponent=!0;const Aet={toc:[]};function Wet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Wet.isMDXComponent=!0;const Ret={toc:[]};function Iet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ret,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Iet.isMDXComponent=!0;const Pet={toc:[]};function Set(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Set.isMDXComponent=!0;const Eet={toc:[]};function Bet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Bet.isMDXComponent=!0;const Get={toc:[]};function Oet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Get,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Oet.isMDXComponent=!0;const Uet={toc:[]};function Fet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Fet.isMDXComponent=!0;const qet={toc:[]};function Vet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Vet.isMDXComponent=!0;const jet={toc:[]};function Het(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Het.isMDXComponent=!0;const Qet={toc:[]};function Yet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Yet.isMDXComponent=!0;const $et={toc:[]};function Ket(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Ket.isMDXComponent=!0;const Jet={toc:[]};function tot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}tot.isMDXComponent=!0;const not={toc:[]};function eot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},not,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}eot.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}pot.isMDXComponent=!0;const rot={toc:[]};function sot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sot.isMDXComponent=!0;const cot={toc:[]};function iot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}iot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}hot.isMDXComponent=!0;const fot={toc:[]};function kot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}kot.isMDXComponent=!0;const yot={toc:[]};function Mot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function wot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}wot.isMDXComponent=!0;const _ot={toc:[]};function Xot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Xot.isMDXComponent=!0;const got={toc:[]};function Tot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},got,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Tot.isMDXComponent=!0;const xot={toc:[]};function Cot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Cot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Lot.isMDXComponent=!0;const Zot={toc:[]};function bot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bot.isMDXComponent=!0;const Not={toc:[]};function zot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Not,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}zot.isMDXComponent=!0;const Aot={toc:[]};function Wot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Wot.isMDXComponent=!0;const Rot={toc:[]};function Iot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Iot.isMDXComponent=!0;const Pot={toc:[]};function Sot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Sot.isMDXComponent=!0;const Eot={toc:[]};function Bot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Bot.isMDXComponent=!0;const Got={toc:[]};function Oot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Got,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Oot.isMDXComponent=!0;const Uot={toc:[]};function Fot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Fot.isMDXComponent=!0;const qot={toc:[]};function Vot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Vot.isMDXComponent=!0;const jot={toc:[]};function Hot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Hot.isMDXComponent=!0;const Qot={toc:[]};function Yot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Yot.isMDXComponent=!0;const $ot={toc:[]};function Kot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}Kot.isMDXComponent=!0;const Jot={toc:[]};function tpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}tpt.isMDXComponent=!0;const npt={toc:[]};function ept(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},npt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}ept.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}ppt.isMDXComponent=!0;const rpt={toc:[]};function spt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}spt.isMDXComponent=!0;const cpt={toc:[]};function ipt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}ipt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}hpt.isMDXComponent=!0;const fpt={toc:[]};function kpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}kpt.isMDXComponent=!0;const ypt={toc:[]};function Mpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ypt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function wpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}wpt.isMDXComponent=!0;const _pt={toc:[]};function Xpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Xpt.isMDXComponent=!0;const gpt={toc:[]};function Tpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Tpt.isMDXComponent=!0;const xpt={toc:[]};function Cpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Cpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]};function bpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}bpt.isMDXComponent=!0;const Npt={toc:[]};function zpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Wpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Wpt.isMDXComponent=!0;const Rpt={toc:[]};function Ipt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Ipt.isMDXComponent=!0;const Ppt={toc:[]};function Spt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ppt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Spt.isMDXComponent=!0;const Ept={toc:[]};function Bpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ept,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Bpt.isMDXComponent=!0;const Gpt={toc:[]};function Opt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Opt.isMDXComponent=!0;const Upt={toc:[]};function Fpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Fpt.isMDXComponent=!0;const qpt={toc:[]};function Vpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Vpt.isMDXComponent=!0;const jpt={toc:[]};function Hpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Hpt.isMDXComponent=!0;const Qpt={toc:[]};function Ypt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ypt.isMDXComponent=!0;const $pt={toc:[]};function Kpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]};function trt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}trt.isMDXComponent=!0;const nrt={toc:[]};function ert(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}ert.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ort,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}prt.isMDXComponent=!0;const rrt={toc:[]};function srt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}srt.isMDXComponent=!0;const crt={toc:[]};function irt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}irt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},art,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}hrt.isMDXComponent=!0;const frt={toc:[]};function krt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}krt.isMDXComponent=!0;const yrt={toc:[]};function Mrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function wrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}wrt.isMDXComponent=!0;const _rt={toc:[]};function Xrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Xrt.isMDXComponent=!0;const grt={toc:[]};function Trt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Trt.isMDXComponent=!0;const xrt={toc:[]};function Crt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Crt.isMDXComponent=!0;const vrt={toc:[]};function Lrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]};function brt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}brt.isMDXComponent=!0;const Nrt={toc:[]};function zrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Wrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Art,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wrt.isMDXComponent=!0;const Rrt={toc:[]};function Irt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Irt.isMDXComponent=!0;const Prt={toc:[]};function Srt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Prt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Srt.isMDXComponent=!0;const Ert={toc:[]};function Brt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ert,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Brt.isMDXComponent=!0;const Grt={toc:[]};function Ort(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Ort.isMDXComponent=!0;const Urt={toc:[]};function Frt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Urt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Frt.isMDXComponent=!0;const qrt={toc:[]};function Vrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Vrt.isMDXComponent=!0;const jrt={toc:[]};function Hrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Hrt.isMDXComponent=!0;const Qrt={toc:[]};function Yrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Yrt.isMDXComponent=!0;const $rt={toc:[]};function Krt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Krt.isMDXComponent=!0;const Jrt={toc:[]};function tst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tst.isMDXComponent=!0;const nst={toc:[]};function est(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}est.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ost,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pst.isMDXComponent=!0;const rst={toc:[]};function sst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}sst.isMDXComponent=!0;const cst={toc:[]};function ist(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ist.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ast,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ust,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}hst.isMDXComponent=!0;const fst={toc:[]};function kst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kst.isMDXComponent=!0;const yst={toc:[]};function Mst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function wst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wst.isMDXComponent=!0;const _st={toc:[]};function Xst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_st,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Xst.isMDXComponent=!0;const gst={toc:[]};function Tst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Tst.isMDXComponent=!0;const xst={toc:[]};function Cst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Cst.isMDXComponent=!0;const vst={toc:[]};function Lst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lst.isMDXComponent=!0;const Zst={toc:[]};function bst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bst.isMDXComponent=!0;const Nst={toc:[]};function zst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zst.isMDXComponent=!0;const Ast={toc:[]};function Wst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ast,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wst.isMDXComponent=!0;const Rst={toc:[]};function Ist(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ist.isMDXComponent=!0;const Pst={toc:[]};function Sst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Sst.isMDXComponent=!0;const Est={toc:[]};function Bst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Est,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Bst.isMDXComponent=!0;const Gst={toc:[]};function Ost(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Ost.isMDXComponent=!0;const Ust={toc:[]};function Fst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ust,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Fst.isMDXComponent=!0;const qst={toc:[]};function Vst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Vst.isMDXComponent=!0;const jst={toc:[]};function Hst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Hst.isMDXComponent=!0;const Qst={toc:[]};function Yst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Yst.isMDXComponent=!0;const $st={toc:[]};function Kst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$st,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}Kst.isMDXComponent=!0;const Jst={toc:[]};function tct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}tct.isMDXComponent=!0;const nct={toc:[]};function ect(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}ect.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pct.isMDXComponent=!0;const rct={toc:[]};function sct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}sct.isMDXComponent=!0;const cct={toc:[]};function ict(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ict.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},act,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}hct.isMDXComponent=!0;const fct={toc:[]};function kct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}kct.isMDXComponent=!0;const yct={toc:[]};function Mct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function wct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}wct.isMDXComponent=!0;const _ct={toc:[]};function Xct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Xct.isMDXComponent=!0;const gct={toc:[]};function Tct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Tct.isMDXComponent=!0;const xct={toc:[]};function Cct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Cct.isMDXComponent=!0;const vct={toc:[]};function Lct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Lct.isMDXComponent=!0;const Zct={toc:[]};function bct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}bct.isMDXComponent=!0;const Nct={toc:[]};function zct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}zct.isMDXComponent=!0;const Act={toc:[]};function Wct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Act,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Wct.isMDXComponent=!0;const Rct={toc:[]};function Ict(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}Ict.isMDXComponent=!0;const Pct={toc:[]};function Sct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}Sct.isMDXComponent=!0;const Ect={toc:[]};function Bct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ect,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Bct.isMDXComponent=!0;const Gct={toc:[]};function Oct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Oct.isMDXComponent=!0;const Uct={toc:[]};function Fct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Fct.isMDXComponent=!0;const qct={toc:[]};function Vct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Vct.isMDXComponent=!0;const jct={toc:[]};function Hct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Hct.isMDXComponent=!0;const Qct={toc:[]};function Yct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Yct.isMDXComponent=!0;const $ct={toc:[]};function Kct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Kct.isMDXComponent=!0;const Jct={toc:[]};function tit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}tit.isMDXComponent=!0;const nit={toc:[]};function eit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}eit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pit.isMDXComponent=!0;const rit={toc:[]};function sit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}sit.isMDXComponent=!0;const cit={toc:[]};function iit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}iit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ait,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}hit.isMDXComponent=!0;const fit={toc:[]};function kit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}kit.isMDXComponent=!0;const yit={toc:[]};function Mit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Mit.isMDXComponent=!0;const Dit={toc:[]};function wit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wit.isMDXComponent=!0;const _it={toc:[]};function Xit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_it,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Xit.isMDXComponent=!0;const git={toc:[]};function Tit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},git,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Tit.isMDXComponent=!0;const xit={toc:[]};function Cit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Cit.isMDXComponent=!0;const vit={toc:[]};function Lit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Lit.isMDXComponent=!0;const Zit={toc:[]};function bit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}bit.isMDXComponent=!0;const Nit={toc:[]};function zit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Wit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ait,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Wit.isMDXComponent=!0;const Rit={toc:[]};function Iit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Iit.isMDXComponent=!0;const Pit={toc:[]};function Sit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Sit.isMDXComponent=!0;const Eit={toc:[]};function Bit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Bit.isMDXComponent=!0;const Git={toc:[]};function Oit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Git,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Oit.isMDXComponent=!0;const Uit={toc:[]};function Fit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Fit.isMDXComponent=!0;const qit={toc:[]};function Vit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Vit.isMDXComponent=!0;const jit={toc:[]};function Hit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Hit.isMDXComponent=!0;const Qit={toc:[]};function Yit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Yit.isMDXComponent=!0;const $it={toc:[]};function Kit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$it,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Kit.isMDXComponent=!0;const Jit={toc:[]};function tat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}tat.isMDXComponent=!0;const nat={toc:[]};function eat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}eat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}pat.isMDXComponent=!0;const rat={toc:[]};function sat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}sat.isMDXComponent=!0;const cat={toc:[]};function iat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}iat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}hat.isMDXComponent=!0;const fat={toc:[]};function kat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kat.isMDXComponent=!0;const yat={toc:[]};function Mat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function wat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wat.isMDXComponent=!0;const _at={toc:[]};function Xat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_at,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Xat.isMDXComponent=!0;const gat={toc:[]};function Tat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Tat.isMDXComponent=!0;const xat={toc:[]};function Cat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Cat.isMDXComponent=!0;const vat={toc:[]};function Lat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Lat.isMDXComponent=!0;const Zat={toc:[]};function bat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}bat.isMDXComponent=!0;const Nat={toc:[]};function zat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}zat.isMDXComponent=!0;const Aat={toc:[]};function Wat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Wat.isMDXComponent=!0;const Rat={toc:[]};function Iat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Iat.isMDXComponent=!0;const Pat={toc:[]};function Sat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Sat.isMDXComponent=!0;const Eat={toc:[]};function Bat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Bat.isMDXComponent=!0;const Gat={toc:[]};function Oat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Oat.isMDXComponent=!0;const Uat={toc:[]};function Fat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Fat.isMDXComponent=!0;const qat={toc:[]};function Vat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Vat.isMDXComponent=!0;const jat={toc:[]};function Hat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Hat.isMDXComponent=!0;const Qat={toc:[]};function Yat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Yat.isMDXComponent=!0;const $at={toc:[]};function Kat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$at,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Kat.isMDXComponent=!0;const Jat={toc:[]};function tlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}tlt.isMDXComponent=!0;const nlt={toc:[]};function elt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}elt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},olt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}plt.isMDXComponent=!0;const rlt={toc:[]};function slt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}slt.isMDXComponent=!0;const clt={toc:[]};function ilt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},clt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ilt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},alt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ult,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}hlt.isMDXComponent=!0;const flt={toc:[]};function klt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},flt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}klt.isMDXComponent=!0;const ylt={toc:[]};function Mlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ylt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function wlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wlt.isMDXComponent=!0;const _lt={toc:[]};function Xlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Xlt.isMDXComponent=!0;const glt={toc:[]};function Tlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},glt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Tlt.isMDXComponent=!0;const xlt={toc:[]};function Clt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Clt.isMDXComponent=!0;const vlt={toc:[]};function Llt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Llt.isMDXComponent=!0;const Zlt={toc:[]};function blt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}blt.isMDXComponent=!0;const Nlt={toc:[]};function zlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Wlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Alt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Wlt.isMDXComponent=!0;const Rlt={toc:[]};function Ilt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Ilt.isMDXComponent=!0;const Plt={toc:[]};function Slt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Plt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Slt.isMDXComponent=!0;const Elt={toc:[]};function Blt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Elt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Blt.isMDXComponent=!0;const Glt={toc:[]};function Olt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Glt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Olt.isMDXComponent=!0;const Ult={toc:[]};function Flt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ult,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Flt.isMDXComponent=!0;const qlt={toc:[]};function Vlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Vlt.isMDXComponent=!0;const jlt={toc:[]};function Hlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Hlt.isMDXComponent=!0;const Qlt={toc:[]};function Ylt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ylt.isMDXComponent=!0;const $lt={toc:[]};function Klt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Klt.isMDXComponent=!0;const Jlt={toc:[]};function tut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}tut.isMDXComponent=!0;const nut={toc:[]};function eut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},out,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}put.isMDXComponent=!0;const rut={toc:[]};function sut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}sut.isMDXComponent=!0;const cut={toc:[]};function iut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}iut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}hut.isMDXComponent=!0;const fut={toc:[]};function kut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}kut.isMDXComponent=!0;const yut={toc:[]};function Mut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function wut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wut.isMDXComponent=!0;const _ut={toc:[]};function Xut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Xut.isMDXComponent=!0;const gut={toc:[]};function Tut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Tut.isMDXComponent=!0;const xut={toc:[]};function Cut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Cut.isMDXComponent=!0;const vut={toc:[]};function Lut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lut.isMDXComponent=!0;const Zut={toc:[]};function but(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}but.isMDXComponent=!0;const Nut={toc:[]};function zut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}zut.isMDXComponent=!0;const Aut={toc:[]};function Wut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Wut.isMDXComponent=!0;const Rut={toc:[]};function Iut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Iut.isMDXComponent=!0;const Put={toc:[]};function Sut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Put,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Sut.isMDXComponent=!0;const Eut={toc:[]};function But(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}But.isMDXComponent=!0;const Gut={toc:[]};function Out(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Out.isMDXComponent=!0;const Uut={toc:[]};function Fut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Fut.isMDXComponent=!0;const qut={toc:[]};function Vut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Vut.isMDXComponent=!0;const jut={toc:[]};function Hut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Hut.isMDXComponent=!0;const Qut={toc:[]};function Yut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Yut.isMDXComponent=!0;const $ut={toc:[]};function Kut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Kut.isMDXComponent=!0;const Jut={toc:[]};function tmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}tmt.isMDXComponent=!0;const nmt={toc:[]};function emt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}emt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pmt.isMDXComponent=!0;const rmt={toc:[]};function smt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}smt.isMDXComponent=!0;const cmt={toc:[]};function imt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}imt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}hmt.isMDXComponent=!0;const fmt={toc:[]};function kmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}kmt.isMDXComponent=!0;const ymt={toc:[]};function Mmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ymt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function wmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wmt.isMDXComponent=!0;const _mt={toc:[]};function Xmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_mt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Xmt.isMDXComponent=!0;const gmt={toc:[]};function Tmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Tmt.isMDXComponent=!0;const xmt={toc:[]};function Cmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Cmt.isMDXComponent=!0;const vmt={toc:[]};function Lmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]};function bmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}bmt.isMDXComponent=!0;const Nmt={toc:[]};function zmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Wmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Wmt.isMDXComponent=!0;const Rmt={toc:[]};function Imt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Imt.isMDXComponent=!0;const Pmt={toc:[]};function Smt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Smt.isMDXComponent=!0;const Emt={toc:[]};function Bmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Bmt.isMDXComponent=!0;const Gmt={toc:[]};function Omt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Omt.isMDXComponent=!0;const Umt={toc:[]};function Fmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Umt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Fmt.isMDXComponent=!0;const qmt={toc:[]};function Vmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Vmt.isMDXComponent=!0;const jmt={toc:[]};function Hmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Hmt.isMDXComponent=!0;const Qmt={toc:[]};function Ymt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Ymt.isMDXComponent=!0;const $mt={toc:[]};function Kmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$mt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]};function tdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}tdt.isMDXComponent=!0;const ndt={toc:[]};function edt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ndt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}edt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pdt.isMDXComponent=!0;const rdt={toc:[]};function sdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}sdt.isMDXComponent=!0;const cdt={toc:[]};function idt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}idt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}hdt.isMDXComponent=!0;const fdt={toc:[]};function kdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}kdt.isMDXComponent=!0;const ydt={toc:[]};function Mdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ydt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function wdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}wdt.isMDXComponent=!0;const _dt={toc:[]};function Xdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Xdt.isMDXComponent=!0;const gdt={toc:[]};function Tdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Tdt.isMDXComponent=!0;const xdt={toc:[]};function Cdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Cdt.isMDXComponent=!0;const vdt={toc:[]};function Ldt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]};function bdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}bdt.isMDXComponent=!0;const Ndt={toc:[]};function zdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Wdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Wdt.isMDXComponent=!0;const Rdt={toc:[]};function Idt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Idt.isMDXComponent=!0;const Pdt={toc:[]};function Sdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Sdt.isMDXComponent=!0;const Edt={toc:[]};function Bdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Bdt.isMDXComponent=!0;const Gdt={toc:[]};function Odt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Odt.isMDXComponent=!0;const Udt={toc:[]};function Fdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Udt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Fdt.isMDXComponent=!0;const qdt={toc:[]};function Vdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Vdt.isMDXComponent=!0;const jdt={toc:[]};function Hdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Hdt.isMDXComponent=!0;const Qdt={toc:[]};function Ydt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Ydt.isMDXComponent=!0;const $dt={toc:[]};function Kdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]};function tht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}tht.isMDXComponent=!0;const nht={toc:[]};function eht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}eht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pht.isMDXComponent=!0;const rht={toc:[]};function sht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}sht.isMDXComponent=!0;const cht={toc:[]};function iht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}iht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}hht.isMDXComponent=!0;const fht={toc:[]};function kht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}kht.isMDXComponent=!0;const yht={toc:[]};function Mht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function wht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}wht.isMDXComponent=!0;const _ht={toc:[]};function Xht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Xht.isMDXComponent=!0;const ght={toc:[]};function Tht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ght,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Tht.isMDXComponent=!0;const xht={toc:[]};function Cht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Cht.isMDXComponent=!0;const vht={toc:[]};function Lht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lht.isMDXComponent=!0;const Zht={toc:[]};function bht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}bht.isMDXComponent=!0;const Nht={toc:[]};function zht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Wht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Wht.isMDXComponent=!0;const Rht={toc:[]};function Iht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Iht.isMDXComponent=!0;const Pht={toc:[]};function Sht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Sht.isMDXComponent=!0;const Eht={toc:[]};function Bht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Bht.isMDXComponent=!0;const Ght={toc:[]};function Oht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ght,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Oht.isMDXComponent=!0;const Uht={toc:[]};function Fht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Fht.isMDXComponent=!0;const qht={toc:[]};function Vht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Vht.isMDXComponent=!0;const jht={toc:[]};function Hht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Hht.isMDXComponent=!0;const Qht={toc:[]};function Yht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Yht.isMDXComponent=!0;const $ht={toc:[]};function Kht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Kht.isMDXComponent=!0;const Jht={toc:[]};function tft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}tft.isMDXComponent=!0;const nft={toc:[]};function eft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}eft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}pft.isMDXComponent=!0;const rft={toc:[]};function sft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}sft.isMDXComponent=!0;const cft={toc:[]};function ift(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}ift.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hft.isMDXComponent=!0;const fft={toc:[]};function kft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}kft.isMDXComponent=!0;const yft={toc:[]};function Mft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function wft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wft.isMDXComponent=!0;const _ft={toc:[]};function Xft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Xft.isMDXComponent=!0;const gft={toc:[]};function Tft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Tft.isMDXComponent=!0;const xft={toc:[]};function Cft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Cft.isMDXComponent=!0;const vft={toc:[]};function Lft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Lft.isMDXComponent=!0;const Zft={toc:[]};function bft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}bft.isMDXComponent=!0;const Nft={toc:[]};function zft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Wft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Wft.isMDXComponent=!0;const Rft={toc:[]};function Ift(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ift.isMDXComponent=!0;const Pft={toc:[]};function Sft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Sft.isMDXComponent=!0;const Eft={toc:[]};function Bft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Bft.isMDXComponent=!0;const Gft={toc:[]};function Oft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Oft.isMDXComponent=!0;const Uft={toc:[]};function Fft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Fft.isMDXComponent=!0;const qft={toc:[]};function Vft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Vft.isMDXComponent=!0;const jft={toc:[]};function Hft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Hft.isMDXComponent=!0;const Qft={toc:[]};function Yft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Yft.isMDXComponent=!0;const $ft={toc:[]};function Kft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Kft.isMDXComponent=!0;const Jft={toc:[]};function tkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}tkt.isMDXComponent=!0;const nkt={toc:[]};function ekt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ekt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pkt.isMDXComponent=!0;const rkt={toc:[]};function skt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}skt.isMDXComponent=!0;const ckt={toc:[]};function ikt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ikt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}hkt.isMDXComponent=!0;const fkt={toc:[]};function kkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}kkt.isMDXComponent=!0;const ykt={toc:[]};function Mkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ykt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function wkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wkt.isMDXComponent=!0;const _kt={toc:[]};function Xkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Xkt.isMDXComponent=!0;const gkt={toc:[]};function Tkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Tkt.isMDXComponent=!0;const xkt={toc:[]};function Ckt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ckt.isMDXComponent=!0;const vkt={toc:[]};function Lkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]};function bkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}bkt.isMDXComponent=!0;const Nkt={toc:[]};function zkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Wkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Wkt.isMDXComponent=!0;const Rkt={toc:[]};function Ikt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ikt.isMDXComponent=!0;const Pkt={toc:[]};function Skt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Skt.isMDXComponent=!0;const Ekt={toc:[]};function Bkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Bkt.isMDXComponent=!0;const Gkt={toc:[]};function Okt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Okt.isMDXComponent=!0;const Ukt={toc:[]};function Fkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ukt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Fkt.isMDXComponent=!0;const qkt={toc:[]};function Vkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Vkt.isMDXComponent=!0;const jkt={toc:[]};function Hkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Hkt.isMDXComponent=!0;const Qkt={toc:[]};function Ykt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ykt.isMDXComponent=!0;const $kt={toc:[]};function Kkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Kkt.isMDXComponent=!0;const Jkt={toc:[]};function tyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}tyt.isMDXComponent=!0;const nyt={toc:[]};function eyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pyt.isMDXComponent=!0;const ryt={toc:[]};function syt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}syt.isMDXComponent=!0;const cyt={toc:[]};function iyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}iyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}hyt.isMDXComponent=!0;const fyt={toc:[]};function kyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kyt.isMDXComponent=!0;const yyt={toc:[]};function Myt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function wyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wyt.isMDXComponent=!0;const _yt={toc:[]};function Xyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Xyt.isMDXComponent=!0;const gyt={toc:[]};function Tyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Tyt.isMDXComponent=!0;const xyt={toc:[]};function Cyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Cyt.isMDXComponent=!0;const vyt={toc:[]};function Lyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]};function byt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}byt.isMDXComponent=!0;const Nyt={toc:[]};function zyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Wyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Wyt.isMDXComponent=!0;const Ryt={toc:[]};function Iyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Iyt.isMDXComponent=!0;const Pyt={toc:[]};function Syt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Syt.isMDXComponent=!0;const Eyt={toc:[]};function Byt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Byt.isMDXComponent=!0;const Gyt={toc:[]};function Oyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Oyt.isMDXComponent=!0;const Uyt={toc:[]};function Fyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Fyt.isMDXComponent=!0;const qyt={toc:[]};function Vyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Vyt.isMDXComponent=!0;const jyt={toc:[]};function Hyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Hyt.isMDXComponent=!0;const Qyt={toc:[]};function Yyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Yyt.isMDXComponent=!0;const $yt={toc:[]};function Kyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]};function tMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tMt.isMDXComponent=!0;const nMt={toc:[]};function eMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}eMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pMt.isMDXComponent=!0;const rMt={toc:[]};function sMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sMt.isMDXComponent=!0;const cMt={toc:[]};function iMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}hMt.isMDXComponent=!0;const fMt={toc:[]};function kMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kMt.isMDXComponent=!0;const yMt={toc:[]};function MMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function wMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wMt.isMDXComponent=!0;const _Mt={toc:[]};function XMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Mt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}XMt.isMDXComponent=!0;const gMt={toc:[]};function TMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}TMt.isMDXComponent=!0;const xMt={toc:[]};function CMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}CMt.isMDXComponent=!0;const vMt={toc:[]};function LMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}LMt.isMDXComponent=!0;const ZMt={toc:[]};function bMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}bMt.isMDXComponent=!0;const NMt={toc:[]};function zMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function WMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}WMt.isMDXComponent=!0;const RMt={toc:[]};function IMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}IMt.isMDXComponent=!0;const PMt={toc:[]};function SMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}SMt.isMDXComponent=!0;const EMt={toc:[]};function BMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}BMt.isMDXComponent=!0;const GMt={toc:[]};function OMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}OMt.isMDXComponent=!0;const UMt={toc:[]};function FMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}FMt.isMDXComponent=!0;const qMt={toc:[]};function VMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}VMt.isMDXComponent=!0;const jMt={toc:[]};function HMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}HMt.isMDXComponent=!0;const QMt={toc:[]};function YMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}YMt.isMDXComponent=!0;const $Mt={toc:[]};function KMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Mt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}KMt.isMDXComponent=!0;const JMt={toc:[]};function tDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}tDt.isMDXComponent=!0;const nDt={toc:[]};function eDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}eDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}pDt.isMDXComponent=!0;const rDt={toc:[]};function sDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sDt.isMDXComponent=!0;const cDt={toc:[]};function iDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}iDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}hDt.isMDXComponent=!0;const fDt={toc:[]};function kDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kDt.isMDXComponent=!0;const yDt={toc:[]};function MDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}MDt.isMDXComponent=!0;const DDt={toc:[]};function wDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wDt.isMDXComponent=!0;const _Dt={toc:[]};function XDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}XDt.isMDXComponent=!0;const gDt={toc:[]};function TDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}TDt.isMDXComponent=!0;const xDt={toc:[]};function CDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}CDt.isMDXComponent=!0;const vDt={toc:[]};function LDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}LDt.isMDXComponent=!0;const ZDt={toc:[]};function bDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}bDt.isMDXComponent=!0;const NDt={toc:[]};function zDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}zDt.isMDXComponent=!0;const ADt={toc:[]};function WDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}WDt.isMDXComponent=!0;const RDt={toc:[]};function IDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}IDt.isMDXComponent=!0;const PDt={toc:[]};function SDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}SDt.isMDXComponent=!0;const EDt={toc:[]};function BDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}BDt.isMDXComponent=!0;const GDt={toc:[]};function ODt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}ODt.isMDXComponent=!0;const UDt={toc:[]};function FDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}FDt.isMDXComponent=!0;const qDt={toc:[]};function VDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}VDt.isMDXComponent=!0;const jDt={toc:[]};function HDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}HDt.isMDXComponent=!0;const QDt={toc:[]};function YDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}YDt.isMDXComponent=!0;const $Dt={toc:[]};function KDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}KDt.isMDXComponent=!0;const JDt={toc:[]};function twt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}twt.isMDXComponent=!0;const nwt={toc:[]};function ewt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ewt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pwt.isMDXComponent=!0;const rwt={toc:[]};function swt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}swt.isMDXComponent=!0;const cwt={toc:[]};function iwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}hwt.isMDXComponent=!0;const fwt={toc:[]};function kwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}kwt.isMDXComponent=!0;const ywt={toc:[]};function Mwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function wwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wwt.isMDXComponent=!0;const _wt={toc:[]};function Xwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Xwt.isMDXComponent=!0;const gwt={toc:[]};function Twt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Twt.isMDXComponent=!0;const xwt={toc:[]};function Cwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Cwt.isMDXComponent=!0;const vwt={toc:[]};function Lwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]};function bwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}bwt.isMDXComponent=!0;const Nwt={toc:[]};function zwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Wwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Wwt.isMDXComponent=!0;const Rwt={toc:[]};function Iwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Iwt.isMDXComponent=!0;const Pwt={toc:[]};function Swt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Swt.isMDXComponent=!0;const Ewt={toc:[]};function Bwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Bwt.isMDXComponent=!0;const Gwt={toc:[]};function Owt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Owt.isMDXComponent=!0;const Uwt={toc:[]};function Fwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Fwt.isMDXComponent=!0;const qwt={toc:[]};function Vwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Vwt.isMDXComponent=!0;const jwt={toc:[]};function Hwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Hwt.isMDXComponent=!0;const Qwt={toc:[]};function Ywt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ywt.isMDXComponent=!0;const $wt={toc:[]};function Kwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]};function t_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}t_t.isMDXComponent=!0;const n_t={toc:[]};function e_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}e_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}p_t.isMDXComponent=!0;const r_t={toc:[]};function s_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}s_t.isMDXComponent=!0;const c_t={toc:[]};function i_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}h_t.isMDXComponent=!0;const f_t={toc:[]};function k_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}k_t.isMDXComponent=!0;const y_t={toc:[]};function M_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}M_t.isMDXComponent=!0;const D_t={toc:[]};function w_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}w_t.isMDXComponent=!0;const __t={toc:[]};function X_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}X_t.isMDXComponent=!0;const g_t={toc:[]};function T_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}T_t.isMDXComponent=!0;const x_t={toc:[]};function C_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}C_t.isMDXComponent=!0;const v_t={toc:[]};function L_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}L_t.isMDXComponent=!0;const Z_t={toc:[]};function b_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}b_t.isMDXComponent=!0;const N_t={toc:[]};function z_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function W_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}W_t.isMDXComponent=!0;const R_t={toc:[]};function I_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}I_t.isMDXComponent=!0;const P_t={toc:[]};function S_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}S_t.isMDXComponent=!0;const E_t={toc:[]};function B_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}B_t.isMDXComponent=!0;const G_t={toc:[]};function O_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}O_t.isMDXComponent=!0;const U_t={toc:[]};function F_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}F_t.isMDXComponent=!0;const q_t={toc:[]};function V_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}V_t.isMDXComponent=!0;const j_t={toc:[]};function H_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}H_t.isMDXComponent=!0;const Q_t={toc:[]};function Y_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Y_t.isMDXComponent=!0;const $_t={toc:[]};function K_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}K_t.isMDXComponent=!0;const J_t={toc:[]};function tXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}tXt.isMDXComponent=!0;const nXt={toc:[]};function eXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}eXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}pXt.isMDXComponent=!0;const rXt={toc:[]};function sXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}sXt.isMDXComponent=!0;const cXt={toc:[]};function iXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}iXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}hXt.isMDXComponent=!0;const fXt={toc:[]};function kXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kXt.isMDXComponent=!0;const yXt={toc:[]};function MXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}MXt.isMDXComponent=!0;const DXt={toc:[]};function wXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wXt.isMDXComponent=!0;const _Xt={toc:[]};function XXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}XXt.isMDXComponent=!0;const gXt={toc:[]};function TXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}TXt.isMDXComponent=!0;const xXt={toc:[]};function CXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}CXt.isMDXComponent=!0;const vXt={toc:[]};function LXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LXt.isMDXComponent=!0;const ZXt={toc:[]};function bXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}bXt.isMDXComponent=!0;const NXt={toc:[]};function zXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}zXt.isMDXComponent=!0;const AXt={toc:[]};function WXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}WXt.isMDXComponent=!0;const RXt={toc:[]};function IXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}IXt.isMDXComponent=!0;const PXt={toc:[]};function SXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}SXt.isMDXComponent=!0;const EXt={toc:[]};function BXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}BXt.isMDXComponent=!0;const GXt={toc:[]};function OXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}OXt.isMDXComponent=!0;const UXt={toc:[]};function FXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}FXt.isMDXComponent=!0;const qXt={toc:[]};function VXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}VXt.isMDXComponent=!0;const jXt={toc:[]};function HXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}HXt.isMDXComponent=!0;const QXt={toc:[]};function YXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}YXt.isMDXComponent=!0;const $Xt={toc:[]};function KXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KXt.isMDXComponent=!0;const JXt={toc:[]};function tgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}tgt.isMDXComponent=!0;const ngt={toc:[]};function egt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ngt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}egt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}pgt.isMDXComponent=!0;const rgt={toc:[]};function sgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}sgt.isMDXComponent=!0;const cgt={toc:[]};function igt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}igt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}hgt.isMDXComponent=!0;const fgt={toc:[]};function kgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}kgt.isMDXComponent=!0;const ygt={toc:[]};function Mgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ygt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function wgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wgt.isMDXComponent=!0;const _gt={toc:[]};function Xgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Xgt.isMDXComponent=!0;const ggt={toc:[]};function Tgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Tgt.isMDXComponent=!0;const xgt={toc:[]};function Cgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Cgt.isMDXComponent=!0;const vgt={toc:[]};function Lgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Lgt.isMDXComponent=!0;const Zgt={toc:[]};function bgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}bgt.isMDXComponent=!0;const Ngt={toc:[]};function zgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Wgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Wgt.isMDXComponent=!0;const Rgt={toc:[]};function Igt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Igt.isMDXComponent=!0;const Pgt={toc:[]};function Sgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Sgt.isMDXComponent=!0;const Egt={toc:[]};function Bgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Bgt.isMDXComponent=!0;const Ggt={toc:[]};function Ogt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ogt.isMDXComponent=!0;const Ugt={toc:[]};function Fgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ugt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Fgt.isMDXComponent=!0;const qgt={toc:[]};function Vgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Vgt.isMDXComponent=!0;const jgt={toc:[]};function Hgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Hgt.isMDXComponent=!0;const Qgt={toc:[]};function Ygt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ygt.isMDXComponent=!0;const $gt={toc:[]};function Kgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]};function tTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}tTt.isMDXComponent=!0;const nTt={toc:[]};function eTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}eTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}pTt.isMDXComponent=!0;const rTt={toc:[]};function sTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}sTt.isMDXComponent=!0;const cTt={toc:[]};function iTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}iTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}hTt.isMDXComponent=!0;const fTt={toc:[]};function kTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}kTt.isMDXComponent=!0;const yTt={toc:[]};function MTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}MTt.isMDXComponent=!0;const DTt={toc:[]};function wTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}wTt.isMDXComponent=!0;const _Tt={toc:[]};function XTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Tt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}XTt.isMDXComponent=!0;const gTt={toc:[]};function TTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}TTt.isMDXComponent=!0;const xTt={toc:[]};function CTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}CTt.isMDXComponent=!0;const vTt={toc:[]};function LTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}LTt.isMDXComponent=!0;const ZTt={toc:[]};function bTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}bTt.isMDXComponent=!0;const NTt={toc:[]};function zTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}zTt.isMDXComponent=!0;const ATt={toc:[]};function WTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WTt.isMDXComponent=!0;const RTt={toc:[]};function ITt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}ITt.isMDXComponent=!0;const PTt={toc:[]};function STt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}STt.isMDXComponent=!0;const ETt={toc:[]};function BTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}BTt.isMDXComponent=!0;const GTt={toc:[]};function OTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}OTt.isMDXComponent=!0;const UTt={toc:[]};function FTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}FTt.isMDXComponent=!0;const qTt={toc:[]};function VTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}VTt.isMDXComponent=!0;const jTt={toc:[]};function HTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}HTt.isMDXComponent=!0;const QTt={toc:[]};function YTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}YTt.isMDXComponent=!0;const $Tt={toc:[]};function KTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Tt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}KTt.isMDXComponent=!0;const JTt={toc:[]};function txt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}txt.isMDXComponent=!0;const nxt={toc:[]};function ext(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}ext.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}pxt.isMDXComponent=!0;const rxt={toc:[]};function sxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sxt.isMDXComponent=!0;const cxt={toc:[]};function ixt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}ixt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}hxt.isMDXComponent=!0;const fxt={toc:[]};function kxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kxt.isMDXComponent=!0;const yxt={toc:[]};function Mxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Mxt.isMDXComponent=!0;const Dxt={toc:[]};function wxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wxt.isMDXComponent=!0;const _xt={toc:[]};function Xxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Xxt.isMDXComponent=!0;const gxt={toc:[]};function Txt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Txt.isMDXComponent=!0;const xxt={toc:[]};function Cxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Cxt.isMDXComponent=!0;const vxt={toc:[]};function Lxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]};function bxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}bxt.isMDXComponent=!0;const Nxt={toc:[]};function zxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Wxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Wxt.isMDXComponent=!0;const Rxt={toc:[]};function Ixt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Ixt.isMDXComponent=!0;const Pxt={toc:[]};function Sxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Sxt.isMDXComponent=!0;const Ext={toc:[]};function Bxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ext,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Bxt.isMDXComponent=!0;const Gxt={toc:[]};function Oxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Oxt.isMDXComponent=!0;const Uxt={toc:[]};function Fxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Fxt.isMDXComponent=!0;const qxt={toc:[]};function Vxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Vxt.isMDXComponent=!0;const jxt={toc:[]};function Hxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Hxt.isMDXComponent=!0;const Qxt={toc:[]};function Yxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Yxt.isMDXComponent=!0;const $xt={toc:[]};function Kxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]};function tCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}tCt.isMDXComponent=!0;const nCt={toc:[]};function eCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}eCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pCt.isMDXComponent=!0;const rCt={toc:[]};function sCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}sCt.isMDXComponent=!0;const cCt={toc:[]};function iCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}hCt.isMDXComponent=!0;const fCt={toc:[]};function kCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}kCt.isMDXComponent=!0;const yCt={toc:[]};function MCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}MCt.isMDXComponent=!0;const DCt={toc:[]};function wCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wCt.isMDXComponent=!0;const _Ct={toc:[]};function XCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}XCt.isMDXComponent=!0;const gCt={toc:[]};function TCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}TCt.isMDXComponent=!0;const xCt={toc:[]};function CCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}CCt.isMDXComponent=!0;const vCt={toc:[]};function LCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}LCt.isMDXComponent=!0;const ZCt={toc:[]};function bCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}bCt.isMDXComponent=!0;const NCt={toc:[]};function zCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}zCt.isMDXComponent=!0;const ACt={toc:[]};function WCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}WCt.isMDXComponent=!0;const RCt={toc:[]};function ICt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ICt.isMDXComponent=!0;const PCt={toc:[]};function SCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}SCt.isMDXComponent=!0;const ECt={toc:[]};function BCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}BCt.isMDXComponent=!0;const GCt={toc:[]};function OCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}OCt.isMDXComponent=!0;const UCt={toc:[]};function FCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}FCt.isMDXComponent=!0;const qCt={toc:[]};function VCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}VCt.isMDXComponent=!0;const jCt={toc:[]};function HCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}HCt.isMDXComponent=!0;const QCt={toc:[]};function YCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}YCt.isMDXComponent=!0;const $Ct={toc:[]};function KCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}KCt.isMDXComponent=!0;const JCt={toc:[]};function tvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}tvt.isMDXComponent=!0;const nvt={toc:[]};function evt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}evt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}pvt.isMDXComponent=!0;const rvt={toc:[]};function svt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}svt.isMDXComponent=!0;const cvt={toc:[]};function ivt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}ivt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}hvt.isMDXComponent=!0;const fvt={toc:[]};function kvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kvt.isMDXComponent=!0;const yvt={toc:[]};function Mvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Mvt.isMDXComponent=!0;const Dvt={toc:[]};function wvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}wvt.isMDXComponent=!0;const _vt={toc:[]};function Xvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Xvt.isMDXComponent=!0;const gvt={toc:[]};function Tvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Tvt.isMDXComponent=!0;const xvt={toc:[]};function Cvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Cvt.isMDXComponent=!0;const vvt={toc:[]};function Lvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]};function bvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}bvt.isMDXComponent=!0;const Nvt={toc:[]};function zvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Wvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Wvt.isMDXComponent=!0;const Rvt={toc:[]};function Ivt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ivt.isMDXComponent=!0;const Pvt={toc:[]};function Svt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Svt.isMDXComponent=!0;const Evt={toc:[]};function Bvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Bvt.isMDXComponent=!0;const Gvt={toc:[]};function Ovt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Ovt.isMDXComponent=!0;const Uvt={toc:[]};function Fvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Fvt.isMDXComponent=!0;const qvt={toc:[]};function Vvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Vvt.isMDXComponent=!0;const jvt={toc:[]};function Hvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Hvt.isMDXComponent=!0;const Qvt={toc:[]};function Yvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Yvt.isMDXComponent=!0;const $vt={toc:[]};function Kvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]};function tLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}tLt.isMDXComponent=!0;const nLt={toc:[]};function eLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}eLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pLt.isMDXComponent=!0;const rLt={toc:[]};function sLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}sLt.isMDXComponent=!0;const cLt={toc:[]};function iLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}iLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}hLt.isMDXComponent=!0;const fLt={toc:[]};function kLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kLt.isMDXComponent=!0;const yLt={toc:[]};function MLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}MLt.isMDXComponent=!0;const DLt={toc:[]};function wLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wLt.isMDXComponent=!0;const _Lt={toc:[]};function XLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}XLt.isMDXComponent=!0;const gLt={toc:[]};function TLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}TLt.isMDXComponent=!0;const xLt={toc:[]};function CLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}CLt.isMDXComponent=!0;const vLt={toc:[]};function LLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}LLt.isMDXComponent=!0;const ZLt={toc:[]};function bLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bLt.isMDXComponent=!0;const NLt={toc:[]};function zLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}zLt.isMDXComponent=!0;const ALt={toc:[]};function WLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WLt.isMDXComponent=!0;const RLt={toc:[]};function ILt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ILt.isMDXComponent=!0;const PLt={toc:[]};function SLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}SLt.isMDXComponent=!0;const ELt={toc:[]};function BLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}BLt.isMDXComponent=!0;const GLt={toc:[]};function OLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}OLt.isMDXComponent=!0;const ULt={toc:[]};function FLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ULt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}FLt.isMDXComponent=!0;const qLt={toc:[]};function VLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}VLt.isMDXComponent=!0;const jLt={toc:[]};function HLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}HLt.isMDXComponent=!0;const QLt={toc:[]};function YLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}YLt.isMDXComponent=!0;const $Lt={toc:[]};function KLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}KLt.isMDXComponent=!0;const JLt={toc:[]};function tZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}tZt.isMDXComponent=!0;const nZt={toc:[]};function eZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}eZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}pZt.isMDXComponent=!0;const rZt={toc:[]};function sZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}sZt.isMDXComponent=!0;const cZt={toc:[]};function iZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}iZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}hZt.isMDXComponent=!0;const fZt={toc:[]};function kZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kZt.isMDXComponent=!0;const yZt={toc:[]};function MZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}MZt.isMDXComponent=!0;const DZt={toc:[]};function wZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}wZt.isMDXComponent=!0;const _Zt={toc:[]};function XZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}XZt.isMDXComponent=!0;const gZt={toc:[]};function TZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}TZt.isMDXComponent=!0;const xZt={toc:[]};function CZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}CZt.isMDXComponent=!0;const vZt={toc:[]};function LZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}LZt.isMDXComponent=!0;const ZZt={toc:[]};function bZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}bZt.isMDXComponent=!0;const NZt={toc:[]};function zZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zZt.isMDXComponent=!0;const AZt={toc:[]};function WZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}WZt.isMDXComponent=!0;const RZt={toc:[]};function IZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}IZt.isMDXComponent=!0;const PZt={toc:[]};function SZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}SZt.isMDXComponent=!0;const EZt={toc:[]};function BZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}BZt.isMDXComponent=!0;const GZt={toc:[]};function OZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}OZt.isMDXComponent=!0;const UZt={toc:[]};function FZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}FZt.isMDXComponent=!0;const qZt={toc:[]};function VZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}VZt.isMDXComponent=!0;const jZt={toc:[]};function HZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}HZt.isMDXComponent=!0;const QZt={toc:[]};function YZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}YZt.isMDXComponent=!0;const $Zt={toc:[]};function KZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}KZt.isMDXComponent=!0;const JZt={toc:[]};function tbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}tbt.isMDXComponent=!0;const nbt={toc:[]};function ebt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}ebt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}pbt.isMDXComponent=!0;const rbt={toc:[]};function sbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sbt.isMDXComponent=!0;const cbt={toc:[]};function ibt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}ibt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}hbt.isMDXComponent=!0;const fbt={toc:[]};function kbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kbt.isMDXComponent=!0;const ybt={toc:[]};function Mbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Mbt.isMDXComponent=!0;const Dbt={toc:[]};function wbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wbt.isMDXComponent=!0;const _bt={toc:[]};function Xbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_bt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Xbt.isMDXComponent=!0;const gbt={toc:[]};function Tbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Tbt.isMDXComponent=!0;const xbt={toc:[]};function Cbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Cbt.isMDXComponent=!0;const vbt={toc:[]};function Lbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]};function bbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}bbt.isMDXComponent=!0;const Nbt={toc:[]};function zbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Wbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wbt.isMDXComponent=!0;const Rbt={toc:[]};function Ibt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Ibt.isMDXComponent=!0;const Pbt={toc:[]};function Sbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Sbt.isMDXComponent=!0;const Ebt={toc:[]};function Bbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Bbt.isMDXComponent=!0;const Gbt={toc:[]};function Obt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Obt.isMDXComponent=!0;const Ubt={toc:[]};function Fbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ubt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Fbt.isMDXComponent=!0;const qbt={toc:[]};function Vbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Vbt.isMDXComponent=!0;const jbt={toc:[]};function Hbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Hbt.isMDXComponent=!0;const Qbt={toc:[]};function Ybt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Ybt.isMDXComponent=!0;const $bt={toc:[]};function Kbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$bt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]};function tNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}tNt.isMDXComponent=!0;const nNt={toc:[]};function eNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}eNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pNt.isMDXComponent=!0;const rNt={toc:[]};function sNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}sNt.isMDXComponent=!0;const cNt={toc:[]};function iNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}iNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}hNt.isMDXComponent=!0;const fNt={toc:[]};function kNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kNt.isMDXComponent=!0;const yNt={toc:[]};function MNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}MNt.isMDXComponent=!0;const DNt={toc:[]};function wNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wNt.isMDXComponent=!0;const _Nt={toc:[]};function XNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}XNt.isMDXComponent=!0;const gNt={toc:[]};function TNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}TNt.isMDXComponent=!0;const xNt={toc:[]};function CNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}CNt.isMDXComponent=!0;const vNt={toc:[]};function LNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}LNt.isMDXComponent=!0;const ZNt={toc:[]};function bNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}bNt.isMDXComponent=!0;const NNt={toc:[]};function zNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zNt.isMDXComponent=!0;const ANt={toc:[]};function WNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}WNt.isMDXComponent=!0;const RNt={toc:[]};function INt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}INt.isMDXComponent=!0;const PNt={toc:[]};function SNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}SNt.isMDXComponent=!0;const ENt={toc:[]};function BNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}BNt.isMDXComponent=!0;const GNt={toc:[]};function ONt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ONt.isMDXComponent=!0;const UNt={toc:[]};function FNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}FNt.isMDXComponent=!0;const qNt={toc:[]};function VNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}VNt.isMDXComponent=!0;const jNt={toc:[]};function HNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}HNt.isMDXComponent=!0;const QNt={toc:[]};function YNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}YNt.isMDXComponent=!0;const $Nt={toc:[]};function KNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}KNt.isMDXComponent=!0;const JNt={toc:[]};function tzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}tzt.isMDXComponent=!0;const nzt={toc:[]};function ezt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}ezt.isMDXComponent=!0;const ozt={toc:[]};function pzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pzt.isMDXComponent=!0;const rzt={toc:[]};function szt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}szt.isMDXComponent=!0;const czt={toc:[]};function izt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}izt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hzt.isMDXComponent=!0;const fzt={toc:[]};function kzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kzt.isMDXComponent=!0;const yzt={toc:[]};function Mzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Mzt.isMDXComponent=!0;const Dzt={toc:[]};function wzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wzt.isMDXComponent=!0;const _zt={toc:[]};function Xzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Xzt.isMDXComponent=!0;const gzt={toc:[]};function Tzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Tzt.isMDXComponent=!0;const xzt={toc:[]};function Czt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Czt.isMDXComponent=!0;const vzt={toc:[]};function Lzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]};function bzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}bzt.isMDXComponent=!0;const Nzt={toc:[]};function zzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Wzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Wzt.isMDXComponent=!0;const Rzt={toc:[]};function Izt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Izt.isMDXComponent=!0;const Pzt={toc:[]};function Szt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Szt.isMDXComponent=!0;const Ezt={toc:[]};function Bzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ezt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Bzt.isMDXComponent=!0;const Gzt={toc:[]};function Ozt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ozt.isMDXComponent=!0;const Uzt={toc:[]};function Fzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Fzt.isMDXComponent=!0;const qzt={toc:[]};function Vzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Vzt.isMDXComponent=!0;const jzt={toc:[]};function Hzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Hzt.isMDXComponent=!0;const Qzt={toc:[]};function Yzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Yzt.isMDXComponent=!0;const $zt={toc:[]};function Kzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Kzt.isMDXComponent=!0;const Jzt={toc:[]};function tAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}tAt.isMDXComponent=!0;const nAt={toc:[]};function eAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}eAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pAt.isMDXComponent=!0;const rAt={toc:[]};function sAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sAt.isMDXComponent=!0;const cAt={toc:[]};function iAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}iAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}hAt.isMDXComponent=!0;const fAt={toc:[]};function kAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}kAt.isMDXComponent=!0;const yAt={toc:[]};function MAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}MAt.isMDXComponent=!0;const DAt={toc:[]};function wAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wAt.isMDXComponent=!0;const _At={toc:[]};function XAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_At,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}XAt.isMDXComponent=!0;const gAt={toc:[]};function TAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}TAt.isMDXComponent=!0;const xAt={toc:[]};function CAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}CAt.isMDXComponent=!0;const vAt={toc:[]};function LAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}LAt.isMDXComponent=!0;const ZAt={toc:[]};function bAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}bAt.isMDXComponent=!0;const NAt={toc:[]};function zAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function WAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}WAt.isMDXComponent=!0;const RAt={toc:[]};function IAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}IAt.isMDXComponent=!0;const PAt={toc:[]};function SAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}SAt.isMDXComponent=!0;const EAt={toc:[]};function BAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}BAt.isMDXComponent=!0;const GAt={toc:[]};function OAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}OAt.isMDXComponent=!0;const UAt={toc:[]};function FAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}FAt.isMDXComponent=!0;const qAt={toc:[]};function VAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}VAt.isMDXComponent=!0;const jAt={toc:[]};function HAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}HAt.isMDXComponent=!0;const QAt={toc:[]};function YAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}YAt.isMDXComponent=!0;const $At={toc:[]};function KAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$At,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KAt.isMDXComponent=!0;const JAt={toc:[]};function tWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}tWt.isMDXComponent=!0;const nWt={toc:[]};function eWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eWt.isMDXComponent=!0;const oWt={toc:[]};function pWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pWt.isMDXComponent=!0;const rWt={toc:[]};function sWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}sWt.isMDXComponent=!0;const cWt={toc:[]};function iWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}iWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hWt.isMDXComponent=!0;const fWt={toc:[]};function kWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}kWt.isMDXComponent=!0;const yWt={toc:[]};function MWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}MWt.isMDXComponent=!0;const DWt={toc:[]};function wWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}wWt.isMDXComponent=!0;const _Wt={toc:[]};function XWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}XWt.isMDXComponent=!0;const gWt={toc:[]};function TWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}TWt.isMDXComponent=!0;const xWt={toc:[]};function CWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}CWt.isMDXComponent=!0;const vWt={toc:[]};function LWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LWt.isMDXComponent=!0;const ZWt={toc:[]};function bWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bWt.isMDXComponent=!0;const NWt={toc:[]};function zWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function WWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}WWt.isMDXComponent=!0;const RWt={toc:[]};function IWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}IWt.isMDXComponent=!0;const PWt={toc:[]};function SWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}SWt.isMDXComponent=!0;const EWt={toc:[]};function BWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}BWt.isMDXComponent=!0;const GWt={toc:[]};function OWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}OWt.isMDXComponent=!0;const UWt={toc:[]};function FWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}FWt.isMDXComponent=!0;const qWt={toc:[]};function VWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}VWt.isMDXComponent=!0;const jWt={toc:[]};function HWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}HWt.isMDXComponent=!0;const QWt={toc:[]};function YWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}YWt.isMDXComponent=!0;const $Wt={toc:[]};function KWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}KWt.isMDXComponent=!0;const JWt={toc:[]};function tRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tRt.isMDXComponent=!0;const nRt={toc:[]};function eRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}eRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pRt.isMDXComponent=!0;const rRt={toc:[]};function sRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sRt.isMDXComponent=!0;const cRt={toc:[]};function iRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}iRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hRt.isMDXComponent=!0;const fRt={toc:[]};function kRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}kRt.isMDXComponent=!0;const yRt={toc:[]};function MRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}MRt.isMDXComponent=!0;const DRt={toc:[]};function wRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wRt.isMDXComponent=!0;const _Rt={toc:[]};function XRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}XRt.isMDXComponent=!0;const gRt={toc:[]};function TRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}TRt.isMDXComponent=!0;const xRt={toc:[]};function CRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}CRt.isMDXComponent=!0;const vRt={toc:[]};function LRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}LRt.isMDXComponent=!0;const ZRt={toc:[]};function bRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}bRt.isMDXComponent=!0;const NRt={toc:[]};function zRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function WRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}WRt.isMDXComponent=!0;const RRt={toc:[]};function IRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}IRt.isMDXComponent=!0;const PRt={toc:[]};function SRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}SRt.isMDXComponent=!0;const ERt={toc:[]};function BRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}BRt.isMDXComponent=!0;const GRt={toc:[]};function ORt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ORt.isMDXComponent=!0;const URt={toc:[]};function FRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},URt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}FRt.isMDXComponent=!0;const qRt={toc:[]};function VRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}VRt.isMDXComponent=!0;const jRt={toc:[]};function HRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}HRt.isMDXComponent=!0;const QRt={toc:[]};function YRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}YRt.isMDXComponent=!0;const $Rt={toc:[]};function KRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}KRt.isMDXComponent=!0;const JRt={toc:[]};function tIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}tIt.isMDXComponent=!0;const nIt={toc:[]};function eIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}eIt.isMDXComponent=!0;const oIt={toc:[]};function pIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pIt.isMDXComponent=!0;const rIt={toc:[]};function sIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}sIt.isMDXComponent=!0;const cIt={toc:[]};function iIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hIt.isMDXComponent=!0;const fIt={toc:[]};function kIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kIt.isMDXComponent=!0;const yIt={toc:[]};function MIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}MIt.isMDXComponent=!0;const DIt={toc:[]};function wIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wIt.isMDXComponent=!0;const _It={toc:[]};function XIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_It,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}XIt.isMDXComponent=!0;const gIt={toc:[]};function TIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}TIt.isMDXComponent=!0;const xIt={toc:[]};function CIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}CIt.isMDXComponent=!0;const vIt={toc:[]};function LIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}LIt.isMDXComponent=!0;const ZIt={toc:[]};function bIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bIt.isMDXComponent=!0;const NIt={toc:[]};function zIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function WIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}WIt.isMDXComponent=!0;const RIt={toc:[]};function IIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}IIt.isMDXComponent=!0;const PIt={toc:[]};function SIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}SIt.isMDXComponent=!0;const EIt={toc:[]};function BIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}BIt.isMDXComponent=!0;const GIt={toc:[]};function OIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}OIt.isMDXComponent=!0;const UIt={toc:[]};function FIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}FIt.isMDXComponent=!0;const qIt={toc:[]};function VIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}VIt.isMDXComponent=!0;const jIt={toc:[]};function HIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}HIt.isMDXComponent=!0;const QIt={toc:[]};function YIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}YIt.isMDXComponent=!0;const $It={toc:[]};function KIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$It,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}KIt.isMDXComponent=!0;const JIt={toc:[]};function tPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}tPt.isMDXComponent=!0;const nPt={toc:[]};function ePt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ePt.isMDXComponent=!0;const oPt={toc:[]};function pPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pPt.isMDXComponent=!0;const rPt={toc:[]};function sPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}sPt.isMDXComponent=!0;const cPt={toc:[]};function iPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}iPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}hPt.isMDXComponent=!0;const fPt={toc:[]};function kPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}kPt.isMDXComponent=!0;const yPt={toc:[]};function MPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}MPt.isMDXComponent=!0;const DPt={toc:[]};function wPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wPt.isMDXComponent=!0;const _Pt={toc:[]};function XPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}XPt.isMDXComponent=!0;const gPt={toc:[]};function TPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}TPt.isMDXComponent=!0;const xPt={toc:[]};function CPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}CPt.isMDXComponent=!0;const vPt={toc:[]};function LPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}LPt.isMDXComponent=!0;const ZPt={toc:[]};function bPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}bPt.isMDXComponent=!0;const NPt={toc:[]};function zPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}zPt.isMDXComponent=!0;const APt={toc:[]};function WPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}WPt.isMDXComponent=!0;const RPt={toc:[]};function IPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}IPt.isMDXComponent=!0;const PPt={toc:[]};function SPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}SPt.isMDXComponent=!0;const EPt={toc:[]};function BPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}BPt.isMDXComponent=!0;const GPt={toc:[]};function OPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}OPt.isMDXComponent=!0;const UPt={toc:[]};function FPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}FPt.isMDXComponent=!0;const qPt={toc:[]};function VPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}VPt.isMDXComponent=!0;const jPt={toc:[]};function HPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}HPt.isMDXComponent=!0;const QPt={toc:[]};function YPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}YPt.isMDXComponent=!0;const $Pt={toc:[]};function KPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}KPt.isMDXComponent=!0;const JPt={toc:[]};function tSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}tSt.isMDXComponent=!0;const nSt={toc:[]};function eSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}eSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}pSt.isMDXComponent=!0;const rSt={toc:[]};function sSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}sSt.isMDXComponent=!0;const cSt={toc:[]};function iSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}iSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}hSt.isMDXComponent=!0;const fSt={toc:[]};function kSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}kSt.isMDXComponent=!0;const ySt={toc:[]};function MSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}MSt.isMDXComponent=!0;const DSt={toc:[]};function wSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wSt.isMDXComponent=!0;const _St={toc:[]};function XSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_St,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}XSt.isMDXComponent=!0;const gSt={toc:[]};function TSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}TSt.isMDXComponent=!0;const xSt={toc:[]};function CSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}CSt.isMDXComponent=!0;const vSt={toc:[]};function LSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LSt.isMDXComponent=!0;const ZSt={toc:[]};function bSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}bSt.isMDXComponent=!0;const NSt={toc:[]};function zSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function WSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}WSt.isMDXComponent=!0;const RSt={toc:[]};function ISt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}ISt.isMDXComponent=!0;const PSt={toc:[]};function SSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}SSt.isMDXComponent=!0;const ESt={toc:[]};function BSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}BSt.isMDXComponent=!0;const GSt={toc:[]};function OSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}OSt.isMDXComponent=!0;const USt={toc:[]};function FSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},USt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}FSt.isMDXComponent=!0;const qSt={toc:[]};function VSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}VSt.isMDXComponent=!0;const jSt={toc:[]};function HSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}HSt.isMDXComponent=!0;const QSt={toc:[]};function YSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}YSt.isMDXComponent=!0;const $St={toc:[]};function KSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$St,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}KSt.isMDXComponent=!0;const JSt={toc:[]};function tEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}tEt.isMDXComponent=!0;const nEt={toc:[]};function eEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pEt.isMDXComponent=!0;const rEt={toc:[]};function sEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}sEt.isMDXComponent=!0;const cEt={toc:[]};function iEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}iEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}hEt.isMDXComponent=!0;const fEt={toc:[]};function kEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}kEt.isMDXComponent=!0;const yEt={toc:[]};function MEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MEt.isMDXComponent=!0;const DEt={toc:[]};function wEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wEt.isMDXComponent=!0;const _Et={toc:[]};function XEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}XEt.isMDXComponent=!0;const gEt={toc:[]};function TEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}TEt.isMDXComponent=!0;const xEt={toc:[]};function CEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}CEt.isMDXComponent=!0;const vEt={toc:[]};function LEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}LEt.isMDXComponent=!0;const ZEt={toc:[]};function bEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}bEt.isMDXComponent=!0;const NEt={toc:[]};function zEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zEt.isMDXComponent=!0;const AEt={toc:[]};function WEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}WEt.isMDXComponent=!0;const REt={toc:[]};function IEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}IEt.isMDXComponent=!0;const PEt={toc:[]};function SEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}SEt.isMDXComponent=!0;const EEt={toc:[]};function BEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}BEt.isMDXComponent=!0;const GEt={toc:[]};function OEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}OEt.isMDXComponent=!0;const UEt={toc:[]};function FEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FEt.isMDXComponent=!0;const qEt={toc:[]};function VEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}VEt.isMDXComponent=!0;const jEt={toc:[]};function HEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}HEt.isMDXComponent=!0;const QEt={toc:[]};function YEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}YEt.isMDXComponent=!0;const $Et={toc:[]};function KEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}KEt.isMDXComponent=!0;const JEt={toc:[]};function tBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}tBt.isMDXComponent=!0;const nBt={toc:[]};function eBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}eBt.isMDXComponent=!0;const oBt={toc:[]};function pBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pBt.isMDXComponent=!0;const rBt={toc:[]};function sBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}sBt.isMDXComponent=!0;const cBt={toc:[]};function iBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}iBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hBt.isMDXComponent=!0;const fBt={toc:[]};function kBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}kBt.isMDXComponent=!0;const yBt={toc:[]};function MBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}MBt.isMDXComponent=!0;const DBt={toc:[]};function wBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}wBt.isMDXComponent=!0;const _Bt={toc:[]};function XBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Bt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}XBt.isMDXComponent=!0;const gBt={toc:[]};function TBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}TBt.isMDXComponent=!0;const xBt={toc:[]};function CBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}CBt.isMDXComponent=!0;const vBt={toc:[]};function LBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}LBt.isMDXComponent=!0;const ZBt={toc:[]};function bBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}bBt.isMDXComponent=!0;const NBt={toc:[]};function zBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}zBt.isMDXComponent=!0;const ABt={toc:[]};function WBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}WBt.isMDXComponent=!0;const RBt={toc:[]};function IBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}IBt.isMDXComponent=!0;const PBt={toc:[]};function SBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}SBt.isMDXComponent=!0;const EBt={toc:[]};function BBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}BBt.isMDXComponent=!0;const GBt={toc:[]};function OBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}OBt.isMDXComponent=!0;const UBt={toc:[]};function FBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}FBt.isMDXComponent=!0;const qBt={toc:[]};function VBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}VBt.isMDXComponent=!0;const jBt={toc:[]};function HBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}HBt.isMDXComponent=!0;const QBt={toc:[]};function YBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YBt.isMDXComponent=!0;const $Bt={toc:[]};function KBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Bt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}KBt.isMDXComponent=!0;const JBt={toc:[]};function tGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}tGt.isMDXComponent=!0;const nGt={toc:[]};function eGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}eGt.isMDXComponent=!0;const oGt={toc:[]};function pGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pGt.isMDXComponent=!0;const rGt={toc:[]};function sGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}sGt.isMDXComponent=!0;const cGt={toc:[]};function iGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}iGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}hGt.isMDXComponent=!0;const fGt={toc:[]};function kGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kGt.isMDXComponent=!0;const yGt={toc:[]};function MGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}MGt.isMDXComponent=!0;const DGt={toc:[]};function wGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}wGt.isMDXComponent=!0;const _Gt={toc:[]};function XGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}XGt.isMDXComponent=!0;const gGt={toc:[]};function TGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}TGt.isMDXComponent=!0;const xGt={toc:[]};function CGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}CGt.isMDXComponent=!0;const vGt={toc:[]};function LGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LGt.isMDXComponent=!0;const ZGt={toc:[]};function bGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}bGt.isMDXComponent=!0;const NGt={toc:[]};function zGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function WGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}WGt.isMDXComponent=!0;const RGt={toc:[]};function IGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}IGt.isMDXComponent=!0;const PGt={toc:[]};function SGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}SGt.isMDXComponent=!0;const EGt={toc:[]};function BGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}BGt.isMDXComponent=!0;const GGt={toc:[]};function OGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}OGt.isMDXComponent=!0;const UGt={toc:[]};function FGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}FGt.isMDXComponent=!0;const qGt={toc:[]};function VGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}VGt.isMDXComponent=!0;const jGt={toc:[]};function HGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}HGt.isMDXComponent=!0;const QGt={toc:[]};function YGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}YGt.isMDXComponent=!0;const $Gt={toc:[]};function KGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}KGt.isMDXComponent=!0;const JGt={toc:[]};function tOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}tOt.isMDXComponent=!0;const nOt={toc:[]};function eOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eOt.isMDXComponent=!0;const oOt={toc:[]};function pOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pOt.isMDXComponent=!0;const rOt={toc:[]};function sOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}sOt.isMDXComponent=!0;const cOt={toc:[]};function iOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}iOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}hOt.isMDXComponent=!0;const fOt={toc:[]};function kOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}kOt.isMDXComponent=!0;const yOt={toc:[]};function MOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}MOt.isMDXComponent=!0;const DOt={toc:[]};function wOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wOt.isMDXComponent=!0;const _Ot={toc:[]};function XOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}XOt.isMDXComponent=!0;const gOt={toc:[]};function TOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}TOt.isMDXComponent=!0;const xOt={toc:[]};function COt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}COt.isMDXComponent=!0;const vOt={toc:[]};function LOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LOt.isMDXComponent=!0;const ZOt={toc:[]};function bOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}bOt.isMDXComponent=!0;const NOt={toc:[]};function zOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function WOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}WOt.isMDXComponent=!0;const ROt={toc:[]};function IOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ROt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}IOt.isMDXComponent=!0;const POt={toc:[]};function SOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},POt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}SOt.isMDXComponent=!0;const EOt={toc:[]};function BOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BOt.isMDXComponent=!0;const GOt={toc:[]};function OOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}OOt.isMDXComponent=!0;const UOt={toc:[]};function FOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}FOt.isMDXComponent=!0;const qOt={toc:[]};function VOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}VOt.isMDXComponent=!0;const jOt={toc:[]};function HOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}HOt.isMDXComponent=!0;const QOt={toc:[]};function YOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}YOt.isMDXComponent=!0;const $Ot={toc:[]};function KOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}KOt.isMDXComponent=!0;const JOt={toc:[]};function tUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}tUt.isMDXComponent=!0;const nUt={toc:[]};function eUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}eUt.isMDXComponent=!0;const oUt={toc:[]};function pUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pUt.isMDXComponent=!0;const rUt={toc:[]};function sUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sUt.isMDXComponent=!0;const cUt={toc:[]};function iUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}iUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}hUt.isMDXComponent=!0;const fUt={toc:[]};function kUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}kUt.isMDXComponent=!0;const yUt={toc:[]};function MUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}MUt.isMDXComponent=!0;const DUt={toc:[]};function wUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}wUt.isMDXComponent=!0;const _Ut={toc:[]};function XUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}XUt.isMDXComponent=!0;const gUt={toc:[]};function TUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}TUt.isMDXComponent=!0;const xUt={toc:[]};function CUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}CUt.isMDXComponent=!0;const vUt={toc:[]};function LUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}LUt.isMDXComponent=!0;const ZUt={toc:[]};function bUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}bUt.isMDXComponent=!0;const NUt={toc:[]};function zUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zUt.isMDXComponent=!0;const AUt={toc:[]};function WUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}WUt.isMDXComponent=!0;const RUt={toc:[]};function IUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}IUt.isMDXComponent=!0;const PUt={toc:[]};function SUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}SUt.isMDXComponent=!0;const EUt={toc:[]};function BUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}BUt.isMDXComponent=!0;const GUt={toc:[]};function OUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}OUt.isMDXComponent=!0;const UUt={toc:[]};function FUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FUt.isMDXComponent=!0;const qUt={toc:[]};function VUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}VUt.isMDXComponent=!0;const jUt={toc:[]};function HUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}HUt.isMDXComponent=!0;const QUt={toc:[]};function YUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}YUt.isMDXComponent=!0;const $Ut={toc:[]};function KUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}KUt.isMDXComponent=!0;const JUt={toc:[]};function tFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}tFt.isMDXComponent=!0;const nFt={toc:[]};function eFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eFt.isMDXComponent=!0;const oFt={toc:[]};function pFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pFt.isMDXComponent=!0;const rFt={toc:[]};function sFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}sFt.isMDXComponent=!0;const cFt={toc:[]};function iFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}iFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hFt.isMDXComponent=!0;const fFt={toc:[]};function kFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kFt.isMDXComponent=!0;const yFt={toc:[]};function MFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}MFt.isMDXComponent=!0;const DFt={toc:[]};function wFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wFt.isMDXComponent=!0;const _Ft={toc:[]};function XFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}XFt.isMDXComponent=!0;const gFt={toc:[]};function TFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}TFt.isMDXComponent=!0;const xFt={toc:[]};function CFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}CFt.isMDXComponent=!0;const vFt={toc:[]};function LFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}LFt.isMDXComponent=!0;const ZFt={toc:[]};function bFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}bFt.isMDXComponent=!0;const NFt={toc:[]};function zFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zFt.isMDXComponent=!0;const AFt={toc:[]};function WFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}WFt.isMDXComponent=!0;const RFt={toc:[]};function IFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}IFt.isMDXComponent=!0;const PFt={toc:[]};function SFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}SFt.isMDXComponent=!0;const EFt={toc:[]};function BFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}BFt.isMDXComponent=!0;const GFt={toc:[]};function OFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}OFt.isMDXComponent=!0;const UFt={toc:[]};function FFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}FFt.isMDXComponent=!0;const qFt={toc:[]};function VFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}VFt.isMDXComponent=!0;const jFt={toc:[]};function HFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}HFt.isMDXComponent=!0;const QFt={toc:[]};function YFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}YFt.isMDXComponent=!0;const $Ft={toc:[]};function KFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}KFt.isMDXComponent=!0;const JFt={toc:[]};function tqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tqt.isMDXComponent=!0;const nqt={toc:[]};function eqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eqt.isMDXComponent=!0;const oqt={toc:[]};function pqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}pqt.isMDXComponent=!0;const rqt={toc:[]};function sqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}sqt.isMDXComponent=!0;const cqt={toc:[]};function iqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}iqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}hqt.isMDXComponent=!0;const fqt={toc:[]};function kqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}kqt.isMDXComponent=!0;const yqt={toc:[]};function Mqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Mqt.isMDXComponent=!0;const Dqt={toc:[]};function wqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wqt.isMDXComponent=!0;const _qt={toc:[]};function Xqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Xqt.isMDXComponent=!0;const gqt={toc:[]};function Tqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Tqt.isMDXComponent=!0;const xqt={toc:[]};function Cqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Cqt.isMDXComponent=!0;const vqt={toc:[]};function Lqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Lqt.isMDXComponent=!0;const Zqt={toc:[]};function bqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}bqt.isMDXComponent=!0;const Nqt={toc:[]};function zqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}zqt.isMDXComponent=!0;const Aqt={toc:[]};function Wqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Wqt.isMDXComponent=!0;const Rqt={toc:[]};function Iqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Iqt.isMDXComponent=!0;const Pqt={toc:[]};function Sqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Sqt.isMDXComponent=!0;const Eqt={toc:[]};function Bqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Bqt.isMDXComponent=!0;const Gqt={toc:[]};function Oqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Oqt.isMDXComponent=!0;const Uqt={toc:[]};function Fqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Fqt.isMDXComponent=!0;const qqt={toc:[]};function Vqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}Vqt.isMDXComponent=!0;const jqt={toc:[]};function Hqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Hqt.isMDXComponent=!0;const Qqt={toc:[]};function Yqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Yqt.isMDXComponent=!0;const $qt={toc:[]};function Kqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]};function tVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tVt.isMDXComponent=!0;const nVt={toc:[]};function eVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}eVt.isMDXComponent=!0;const oVt={toc:[]};function pVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pVt.isMDXComponent=!0;const rVt={toc:[]};function sVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}sVt.isMDXComponent=!0;const cVt={toc:[]};function iVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}iVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hVt.isMDXComponent=!0;const fVt={toc:[]};function kVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}kVt.isMDXComponent=!0;const yVt={toc:[]};function MVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}MVt.isMDXComponent=!0;const DVt={toc:[]};function wVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}wVt.isMDXComponent=!0;const _Vt={toc:[]};function XVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}XVt.isMDXComponent=!0;const gVt={toc:[]};function TVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}TVt.isMDXComponent=!0;const xVt={toc:[]};function CVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CVt.isMDXComponent=!0;const vVt={toc:[]};function LVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}LVt.isMDXComponent=!0;const ZVt={toc:[]};function bVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}bVt.isMDXComponent=!0;const NVt={toc:[]};function zVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}zVt.isMDXComponent=!0;const AVt={toc:[]};function WVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}WVt.isMDXComponent=!0;const RVt={toc:[]};function IVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}IVt.isMDXComponent=!0;const PVt={toc:[]};function SVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}SVt.isMDXComponent=!0;const EVt={toc:[]};function BVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}BVt.isMDXComponent=!0;const GVt={toc:[]};function OVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}OVt.isMDXComponent=!0;const UVt={toc:[]};function FVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}FVt.isMDXComponent=!0;const qVt={toc:[]};function VVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}VVt.isMDXComponent=!0;const jVt={toc:[]};function HVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}HVt.isMDXComponent=!0;const QVt={toc:[]};function YVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}YVt.isMDXComponent=!0;const $Vt={toc:[]};function KVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}KVt.isMDXComponent=!0;const JVt={toc:[]};function tjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}tjt.isMDXComponent=!0;const njt={toc:[]};function ejt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},njt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}ejt.isMDXComponent=!0;const ojt={toc:[]};function pjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ojt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pjt.isMDXComponent=!0;const rjt={toc:[]};function sjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}sjt.isMDXComponent=!0;const cjt={toc:[]};function ijt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ijt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ajt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ujt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},djt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hjt.isMDXComponent=!0;const fjt={toc:[]};function kjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}kjt.isMDXComponent=!0;const yjt={toc:[]};function Mjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mjt.isMDXComponent=!0;const Djt={toc:[]};function wjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Djt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wjt.isMDXComponent=!0;const _jt={toc:[]};function Xjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Xjt.isMDXComponent=!0;const gjt={toc:[]};function Tjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Tjt.isMDXComponent=!0;const xjt={toc:[]};function Cjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Cjt.isMDXComponent=!0;const vjt={toc:[]};function Ljt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]};function bjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}bjt.isMDXComponent=!0;const Njt={toc:[]};function zjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Njt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}zjt.isMDXComponent=!0;const Ajt={toc:[]};function Wjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ajt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Wjt.isMDXComponent=!0;const Rjt={toc:[]};function Ijt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Ijt.isMDXComponent=!0;const Pjt={toc:[]};function Sjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Sjt.isMDXComponent=!0;const Ejt={toc:[]};function Bjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ejt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Bjt.isMDXComponent=!0;const Gjt={toc:[]};function Ojt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Ojt.isMDXComponent=!0;const Ujt={toc:[]};function Fjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ujt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Fjt.isMDXComponent=!0;const qjt={toc:[]};function Vjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Vjt.isMDXComponent=!0;const jjt={toc:[]};function Hjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Hjt.isMDXComponent=!0;const Qjt={toc:[]};function Yjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Yjt.isMDXComponent=!0;const $jt={toc:[]};function Kjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]};function tHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}tHt.isMDXComponent=!0;const nHt={toc:[]};function eHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}eHt.isMDXComponent=!0;const oHt={toc:[]};function pHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pHt.isMDXComponent=!0;const rHt={toc:[]};function sHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}sHt.isMDXComponent=!0;const cHt={toc:[]};function iHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}iHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}hHt.isMDXComponent=!0;const fHt={toc:[]};function kHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}kHt.isMDXComponent=!0;const yHt={toc:[]};function MHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}MHt.isMDXComponent=!0;const DHt={toc:[]};function wHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wHt.isMDXComponent=!0;const _Ht={toc:[]};function XHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}XHt.isMDXComponent=!0;const gHt={toc:[]};function THt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}THt.isMDXComponent=!0;const xHt={toc:[]};function CHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}CHt.isMDXComponent=!0;const vHt={toc:[]};function LHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}LHt.isMDXComponent=!0;const ZHt={toc:[]};function bHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}bHt.isMDXComponent=!0;const NHt={toc:[]};function zHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}zHt.isMDXComponent=!0;const AHt={toc:[]};function WHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}WHt.isMDXComponent=!0;const RHt={toc:[]};function IHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}IHt.isMDXComponent=!0;const PHt={toc:[]};function SHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}SHt.isMDXComponent=!0;const EHt={toc:[]};function BHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}BHt.isMDXComponent=!0;const GHt={toc:[]};function OHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}OHt.isMDXComponent=!0;const UHt={toc:[]};function FHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}FHt.isMDXComponent=!0;const qHt={toc:[]};function VHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}VHt.isMDXComponent=!0;const jHt={toc:[]};function HHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}HHt.isMDXComponent=!0;const QHt={toc:[]};function YHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}YHt.isMDXComponent=!0;const $Ht={toc:[]};function KHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}KHt.isMDXComponent=!0;const JHt={toc:[]};function tQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}tQt.isMDXComponent=!0;const nQt={toc:[]};function eQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}eQt.isMDXComponent=!0;const oQt={toc:[]};function pQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pQt.isMDXComponent=!0;const rQt={toc:[]};function sQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}sQt.isMDXComponent=!0;const cQt={toc:[]};function iQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}iQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hQt.isMDXComponent=!0;const fQt={toc:[]};function kQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}kQt.isMDXComponent=!0;const yQt={toc:[]};function MQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}MQt.isMDXComponent=!0;const DQt={toc:[]};function wQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wQt.isMDXComponent=!0;const _Qt={toc:[]};function XQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}XQt.isMDXComponent=!0;const gQt={toc:[]};function TQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}TQt.isMDXComponent=!0;const xQt={toc:[]};function CQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}CQt.isMDXComponent=!0;const vQt={toc:[]};function LQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}LQt.isMDXComponent=!0;const ZQt={toc:[]};function bQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bQt.isMDXComponent=!0;const NQt={toc:[]};function zQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}zQt.isMDXComponent=!0;const AQt={toc:[]};function WQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}WQt.isMDXComponent=!0;const RQt={toc:[]};function IQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}IQt.isMDXComponent=!0;const PQt={toc:[]};function SQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}SQt.isMDXComponent=!0;const EQt={toc:[]};function BQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}BQt.isMDXComponent=!0;const GQt={toc:[]};function OQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}OQt.isMDXComponent=!0;const UQt={toc:[]};function FQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}FQt.isMDXComponent=!0;const qQt={toc:[]};function VQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}VQt.isMDXComponent=!0;const jQt={toc:[]};function HQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}HQt.isMDXComponent=!0;const QQt={toc:[]};function YQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YQt.isMDXComponent=!0;const $Qt={toc:[]};function KQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}KQt.isMDXComponent=!0;const JQt={toc:[]};function tYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}tYt.isMDXComponent=!0;const nYt={toc:[]};function eYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}eYt.isMDXComponent=!0;const oYt={toc:[]};function pYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pYt.isMDXComponent=!0;const rYt={toc:[]};function sYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sYt.isMDXComponent=!0;const cYt={toc:[]};function iYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hYt.isMDXComponent=!0;const fYt={toc:[]};function kYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kYt.isMDXComponent=!0;const yYt={toc:[]};function MYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}MYt.isMDXComponent=!0;const DYt={toc:[]};function wYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wYt.isMDXComponent=!0;const _Yt={toc:[]};function XYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}XYt.isMDXComponent=!0;const gYt={toc:[]};function TYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}TYt.isMDXComponent=!0;const xYt={toc:[]};function CYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}CYt.isMDXComponent=!0;const vYt={toc:[]};function LYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LYt.isMDXComponent=!0;const ZYt={toc:[]};function bYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}bYt.isMDXComponent=!0;const NYt={toc:[]};function zYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zYt.isMDXComponent=!0;const AYt={toc:[]};function WYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}WYt.isMDXComponent=!0;const RYt={toc:[]};function IYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}IYt.isMDXComponent=!0;const PYt={toc:[]};function SYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}SYt.isMDXComponent=!0;const EYt={toc:[]};function BYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}BYt.isMDXComponent=!0;const GYt={toc:[]};function OYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}OYt.isMDXComponent=!0;const UYt={toc:[]};function FYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}FYt.isMDXComponent=!0;const qYt={toc:[]};function VYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}VYt.isMDXComponent=!0;const jYt={toc:[]};function HYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}HYt.isMDXComponent=!0;const QYt={toc:[]};function YYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}YYt.isMDXComponent=!0;const $Yt={toc:[]};function KYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}KYt.isMDXComponent=!0;const JYt={toc:[]};function t$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}t$t.isMDXComponent=!0;const n$t={toc:[]};function e$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}e$t.isMDXComponent=!0;const o$t={toc:[]};function p$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}p$t.isMDXComponent=!0;const r$t={toc:[]};function s$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}s$t.isMDXComponent=!0;const c$t={toc:[]};function i$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}i$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}h$t.isMDXComponent=!0;const f$t={toc:[]};function k$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}k$t.isMDXComponent=!0;const y$t={toc:[]};function M$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}M$t.isMDXComponent=!0;const D$t={toc:[]};function w$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}w$t.isMDXComponent=!0;const _$t={toc:[]};function X$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}X$t.isMDXComponent=!0;const g$t={toc:[]};function T$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}T$t.isMDXComponent=!0;const x$t={toc:[]};function C$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}C$t.isMDXComponent=!0;const v$t={toc:[]};function L$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}L$t.isMDXComponent=!0;const Z$t={toc:[]};function b$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}b$t.isMDXComponent=!0;const N$t={toc:[]};function z$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}z$t.isMDXComponent=!0;const A$t={toc:[]};function W$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}W$t.isMDXComponent=!0;const R$t={toc:[]};function I$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}I$t.isMDXComponent=!0;const P$t={toc:[]};function S$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}S$t.isMDXComponent=!0;const E$t={toc:[]};function B$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}B$t.isMDXComponent=!0;const G$t={toc:[]};function O$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}O$t.isMDXComponent=!0;const U$t={toc:[]};function F$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}F$t.isMDXComponent=!0;const q$t={toc:[]};function V$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}V$t.isMDXComponent=!0;const j$t={toc:[]};function H$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}H$t.isMDXComponent=!0;const Q$t={toc:[]};function Y$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Y$t.isMDXComponent=!0;const $$t={toc:[]};function K$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}K$t.isMDXComponent=!0;const J$t={toc:[]};function tKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}tKt.isMDXComponent=!0;const nKt={toc:[]};function eKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}eKt.isMDXComponent=!0;const oKt={toc:[]};function pKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}pKt.isMDXComponent=!0;const rKt={toc:[]};function sKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sKt.isMDXComponent=!0;const cKt={toc:[]};function iKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}iKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}hKt.isMDXComponent=!0;const fKt={toc:[]};function kKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kKt.isMDXComponent=!0;const yKt={toc:[]};function MKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}MKt.isMDXComponent=!0;const DKt={toc:[]};function wKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wKt.isMDXComponent=!0;const _Kt={toc:[]};function XKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}XKt.isMDXComponent=!0;const gKt={toc:[]};function TKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}TKt.isMDXComponent=!0;const xKt={toc:[]};function CKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}CKt.isMDXComponent=!0;const vKt={toc:[]};function LKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}LKt.isMDXComponent=!0;const ZKt={toc:[]};function bKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}bKt.isMDXComponent=!0;const NKt={toc:[]};function zKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}zKt.isMDXComponent=!0;const AKt={toc:[]};function WKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}WKt.isMDXComponent=!0;const RKt={toc:[]};function IKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}IKt.isMDXComponent=!0;const PKt={toc:[]};function SKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}SKt.isMDXComponent=!0;const EKt={toc:[]};function BKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}BKt.isMDXComponent=!0;const GKt={toc:[]};function OKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}OKt.isMDXComponent=!0;const UKt={toc:[]};function FKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FKt.isMDXComponent=!0;const qKt={toc:[]};function VKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}VKt.isMDXComponent=!0;const jKt={toc:[]};function HKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}HKt.isMDXComponent=!0;const QKt={toc:[]};function YKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}YKt.isMDXComponent=!0;const $Kt={toc:[]};function KKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}KKt.isMDXComponent=!0;const JKt={toc:[]};function tJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}tJt.isMDXComponent=!0;const nJt={toc:[]};function eJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}eJt.isMDXComponent=!0;const oJt={toc:[]};function pJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}pJt.isMDXComponent=!0;const rJt={toc:[]};function sJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}sJt.isMDXComponent=!0;const cJt={toc:[]};function iJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}iJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}hJt.isMDXComponent=!0;const fJt={toc:[]};function kJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}kJt.isMDXComponent=!0;const yJt={toc:[]};function MJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}MJt.isMDXComponent=!0;const DJt={toc:[]};function wJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wJt.isMDXComponent=!0;const _Jt={toc:[]};function XJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}XJt.isMDXComponent=!0;const gJt={toc:[]};function TJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}TJt.isMDXComponent=!0;const xJt={toc:[]};function CJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}CJt.isMDXComponent=!0;const vJt={toc:[]};function LJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}LJt.isMDXComponent=!0;const ZJt={toc:[]};function bJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}bJt.isMDXComponent=!0;const NJt={toc:[]};function zJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}zJt.isMDXComponent=!0;const AJt={toc:[]};function WJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}WJt.isMDXComponent=!0;const RJt={toc:[]};function IJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IJt.isMDXComponent=!0;const PJt={toc:[]};function SJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}SJt.isMDXComponent=!0;const EJt={toc:[]};function BJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}BJt.isMDXComponent=!0;const GJt={toc:[]};function OJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}OJt.isMDXComponent=!0;const UJt={toc:[]};function FJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}FJt.isMDXComponent=!0;const qJt={toc:[]};function VJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}VJt.isMDXComponent=!0;const jJt={toc:[]};function HJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}HJt.isMDXComponent=!0;const QJt={toc:[]};function YJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}YJt.isMDXComponent=!0;const $Jt={toc:[]};function KJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}KJt.isMDXComponent=!0;const JJt={toc:[]};function t0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}t0t.isMDXComponent=!0;const n0t={toc:[]};function e0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}e0t.isMDXComponent=!0;const o0t={toc:[]};function p0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}p0t.isMDXComponent=!0;const r0t={toc:[]};function s0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}s0t.isMDXComponent=!0;const c0t={toc:[]};function i0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}i0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}h0t.isMDXComponent=!0;const f0t={toc:[]};function k0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}k0t.isMDXComponent=!0;const y0t={toc:[]};function M0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}M0t.isMDXComponent=!0;const D0t={toc:[]};function w0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}w0t.isMDXComponent=!0;const _0t={toc:[]};function X0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}X0t.isMDXComponent=!0;const g0t={toc:[]};function T0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}T0t.isMDXComponent=!0;const x0t={toc:[]};function C0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}C0t.isMDXComponent=!0;const v0t={toc:[]};function L0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}L0t.isMDXComponent=!0;const Z0t={toc:[]};function b0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}b0t.isMDXComponent=!0;const N0t={toc:[]};function z0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}z0t.isMDXComponent=!0;const A0t={toc:[]};function W0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}W0t.isMDXComponent=!0;const R0t={toc:[]};function I0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}I0t.isMDXComponent=!0;const P0t={toc:[]};function S0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}S0t.isMDXComponent=!0;const E0t={toc:[]};function B0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}B0t.isMDXComponent=!0;const G0t={toc:[]};function O0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}O0t.isMDXComponent=!0;const U0t={toc:[]};function F0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}F0t.isMDXComponent=!0;const q0t={toc:[]};function V0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}V0t.isMDXComponent=!0;const j0t={toc:[]};function H0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}H0t.isMDXComponent=!0;const Q0t={toc:[]};function Y0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Y0t.isMDXComponent=!0;const $0t={toc:[]};function K0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}K0t.isMDXComponent=!0;const J0t={toc:[]};function t4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}t4t.isMDXComponent=!0;const n4t={toc:[]};function e4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}e4t.isMDXComponent=!0;const o4t={toc:[]};function p4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}p4t.isMDXComponent=!0;const r4t={toc:[]};function s4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}s4t.isMDXComponent=!0;const c4t={toc:[]};function i4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}i4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}h4t.isMDXComponent=!0;const f4t={toc:[]};function k4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}k4t.isMDXComponent=!0;const y4t={toc:[]};function M4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}M4t.isMDXComponent=!0;const D4t={toc:[]};function w4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}w4t.isMDXComponent=!0;const _4t={toc:[]};function X4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}X4t.isMDXComponent=!0;const g4t={toc:[]};function T4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}T4t.isMDXComponent=!0;const x4t={toc:[]};function C4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}C4t.isMDXComponent=!0;const v4t={toc:[]};function L4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}L4t.isMDXComponent=!0;const Z4t={toc:[]};function b4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}b4t.isMDXComponent=!0;const N4t={toc:[]};function z4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}z4t.isMDXComponent=!0;const A4t={toc:[]};function W4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}W4t.isMDXComponent=!0;const R4t={toc:[]};function I4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}I4t.isMDXComponent=!0;const P4t={toc:[]};function S4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}S4t.isMDXComponent=!0;const E4t={toc:[]};function B4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}B4t.isMDXComponent=!0;const G4t={toc:[]};function O4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}O4t.isMDXComponent=!0;const U4t={toc:[]};function F4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}F4t.isMDXComponent=!0;const q4t={toc:[]};function V4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}V4t.isMDXComponent=!0;const j4t={toc:[]};function H4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}H4t.isMDXComponent=!0;const Q4t={toc:[]};function Y4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Y4t.isMDXComponent=!0;const $4t={toc:[]};function K4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}K4t.isMDXComponent=!0;const J4t={toc:[]};function t3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}t3t.isMDXComponent=!0;const n3t={toc:[]};function e3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}e3t.isMDXComponent=!0;const o3t={toc:[]};function p3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}p3t.isMDXComponent=!0;const r3t={toc:[]};function s3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}s3t.isMDXComponent=!0;const c3t={toc:[]};function i3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}i3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}h3t.isMDXComponent=!0;const f3t={toc:[]};function k3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}k3t.isMDXComponent=!0;const y3t={toc:[]};function M3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}M3t.isMDXComponent=!0;const D3t={toc:[]};function w3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}w3t.isMDXComponent=!0;const _3t={toc:[]};function X3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}X3t.isMDXComponent=!0;const g3t={toc:[]};function T3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}T3t.isMDXComponent=!0;const x3t={toc:[]};function C3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}C3t.isMDXComponent=!0;const v3t={toc:[]};function L3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}L3t.isMDXComponent=!0;const Z3t={toc:[]};function b3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}b3t.isMDXComponent=!0;const N3t={toc:[]};function z3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}z3t.isMDXComponent=!0;const A3t={toc:[]};function W3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}W3t.isMDXComponent=!0;const R3t={toc:[]};function I3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}I3t.isMDXComponent=!0;const P3t={toc:[]};function S3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}S3t.isMDXComponent=!0;const E3t={toc:[]};function B3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}B3t.isMDXComponent=!0;const G3t={toc:[]};function O3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}O3t.isMDXComponent=!0;const U3t={toc:[]};function F3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}F3t.isMDXComponent=!0;const q3t={toc:[]};function V3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}V3t.isMDXComponent=!0;const j3t={toc:[]};function H3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}H3t.isMDXComponent=!0;const Q3t={toc:[]};function Y3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Y3t.isMDXComponent=!0;const $3t={toc:[]};function K3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}K3t.isMDXComponent=!0;const J3t={toc:[]};function t5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}t5t.isMDXComponent=!0;const n5t={toc:[]};function e5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}e5t.isMDXComponent=!0;const o5t={toc:[]};function p5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}p5t.isMDXComponent=!0;const r5t={toc:[]};function s5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}s5t.isMDXComponent=!0;const c5t={toc:[]};function i5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}i5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}h5t.isMDXComponent=!0;const f5t={toc:[]};function k5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}k5t.isMDXComponent=!0;const y5t={toc:[]};function M5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}M5t.isMDXComponent=!0;const D5t={toc:[]};function w5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}w5t.isMDXComponent=!0;const _5t={toc:[]};function X5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}X5t.isMDXComponent=!0;const g5t={toc:[]};function T5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}T5t.isMDXComponent=!0;const x5t={toc:[]};function C5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}C5t.isMDXComponent=!0;const v5t={toc:[]};function L5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}L5t.isMDXComponent=!0;const Z5t={toc:[]};function b5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}b5t.isMDXComponent=!0;const N5t={toc:[]};function z5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}z5t.isMDXComponent=!0;const A5t={toc:[]};function W5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}W5t.isMDXComponent=!0;const R5t={toc:[]};function I5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}I5t.isMDXComponent=!0;const P5t={toc:[]};function S5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}S5t.isMDXComponent=!0;const E5t={toc:[]};function B5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}B5t.isMDXComponent=!0;const G5t={toc:[]};function O5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}O5t.isMDXComponent=!0;const U5t={toc:[]};function F5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}F5t.isMDXComponent=!0;const q5t={toc:[]};function V5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}V5t.isMDXComponent=!0;const j5t={toc:[]};function H5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}H5t.isMDXComponent=!0;const Q5t={toc:[]};function Y5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Y5t.isMDXComponent=!0;const $5t={toc:[]};function K5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}K5t.isMDXComponent=!0;const J5t={toc:[]};function t2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}t2t.isMDXComponent=!0;const n2t={toc:[]};function e2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}e2t.isMDXComponent=!0;const o2t={toc:[]};function p2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}p2t.isMDXComponent=!0;const r2t={toc:[]};function s2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}s2t.isMDXComponent=!0;const c2t={toc:[]};function i2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}i2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}h2t.isMDXComponent=!0;const f2t={toc:[]};function k2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}k2t.isMDXComponent=!0;const y2t={toc:[]};function M2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}M2t.isMDXComponent=!0;const D2t={toc:[]};function w2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}w2t.isMDXComponent=!0;const _2t={toc:[]};function X2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}X2t.isMDXComponent=!0;const g2t={toc:[]};function T2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}T2t.isMDXComponent=!0;const x2t={toc:[]};function C2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}C2t.isMDXComponent=!0;const v2t={toc:[]};function L2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}L2t.isMDXComponent=!0;const Z2t={toc:[]};function b2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}b2t.isMDXComponent=!0;const N2t={toc:[]};function z2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}z2t.isMDXComponent=!0;const A2t={toc:[]};function W2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}W2t.isMDXComponent=!0;const R2t={toc:[]};function I2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}I2t.isMDXComponent=!0;const P2t={toc:[]};function S2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}S2t.isMDXComponent=!0;const E2t={toc:[]};function B2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}B2t.isMDXComponent=!0;const G2t={toc:[]};function O2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}O2t.isMDXComponent=!0;const U2t={toc:[]};function F2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}F2t.isMDXComponent=!0;const q2t={toc:[]};function V2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}V2t.isMDXComponent=!0;const j2t={toc:[]};function H2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}H2t.isMDXComponent=!0;const Q2t={toc:[]};function Y2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Y2t.isMDXComponent=!0;const $2t={toc:[]};function K2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}K2t.isMDXComponent=!0;const J2t={toc:[]};function t1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}t1t.isMDXComponent=!0;const n1t={toc:[]};function e1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}e1t.isMDXComponent=!0;const o1t={toc:[]};function p1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}p1t.isMDXComponent=!0;const r1t={toc:[]};function s1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}s1t.isMDXComponent=!0;const c1t={toc:[]};function i1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}i1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}h1t.isMDXComponent=!0;const f1t={toc:[]};function k1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}k1t.isMDXComponent=!0;const y1t={toc:[]};function M1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}M1t.isMDXComponent=!0;const D1t={toc:[]};function w1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}w1t.isMDXComponent=!0;const _1t={toc:[]};function X1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}X1t.isMDXComponent=!0;const g1t={toc:[]};function T1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}T1t.isMDXComponent=!0;const x1t={toc:[]};function C1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}C1t.isMDXComponent=!0;const v1t={toc:[]};function L1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}L1t.isMDXComponent=!0;const Z1t={toc:[]};function b1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}b1t.isMDXComponent=!0;const N1t={toc:[]};function z1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}z1t.isMDXComponent=!0;const A1t={toc:[]};function W1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}W1t.isMDXComponent=!0;const R1t={toc:[]};function I1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}I1t.isMDXComponent=!0;const P1t={toc:[]};function S1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}S1t.isMDXComponent=!0;const E1t={toc:[]};function B1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}B1t.isMDXComponent=!0;const G1t={toc:[]};function O1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}O1t.isMDXComponent=!0;const U1t={toc:[]};function F1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}F1t.isMDXComponent=!0;const q1t={toc:[]};function V1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}V1t.isMDXComponent=!0;const j1t={toc:[]};function H1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}H1t.isMDXComponent=!0;const Q1t={toc:[]};function Y1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Y1t.isMDXComponent=!0;const $1t={toc:[]};function K1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}K1t.isMDXComponent=!0;const J1t={toc:[]};function t6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}t6t.isMDXComponent=!0;const n6t={toc:[]};function e6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}e6t.isMDXComponent=!0;const o6t={toc:[]};function p6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}p6t.isMDXComponent=!0;const r6t={toc:[]};function s6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}s6t.isMDXComponent=!0;const c6t={toc:[]};function i6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}i6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}h6t.isMDXComponent=!0;const f6t={toc:[]};function k6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}k6t.isMDXComponent=!0;const y6t={toc:[]};function M6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}M6t.isMDXComponent=!0;const D6t={toc:[]};function w6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}w6t.isMDXComponent=!0;const _6t={toc:[]};function X6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}X6t.isMDXComponent=!0;const g6t={toc:[]};function T6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}T6t.isMDXComponent=!0;const x6t={toc:[]};function C6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}C6t.isMDXComponent=!0;const v6t={toc:[]};function L6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}L6t.isMDXComponent=!0;const Z6t={toc:[]};function b6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}b6t.isMDXComponent=!0;const N6t={toc:[]};function z6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}z6t.isMDXComponent=!0;const A6t={toc:[]};function W6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}W6t.isMDXComponent=!0;const R6t={toc:[]};function I6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}I6t.isMDXComponent=!0;const P6t={toc:[]};function S6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}S6t.isMDXComponent=!0;const E6t={toc:[]};function B6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}B6t.isMDXComponent=!0;const G6t={toc:[]};function O6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}O6t.isMDXComponent=!0;const U6t={toc:[]};function F6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}F6t.isMDXComponent=!0;const q6t={toc:[]};function V6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}V6t.isMDXComponent=!0;const j6t={toc:[]};function H6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}H6t.isMDXComponent=!0;const Q6t={toc:[]};function Y6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Y6t.isMDXComponent=!0;const $6t={toc:[]};function K6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}K6t.isMDXComponent=!0;const J6t={toc:[]};function t8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}t8t.isMDXComponent=!0;const n8t={toc:[]};function e8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}e8t.isMDXComponent=!0;const o8t={toc:[]};function p8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}p8t.isMDXComponent=!0;const r8t={toc:[]};function s8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}s8t.isMDXComponent=!0;const c8t={toc:[]};function i8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}i8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}h8t.isMDXComponent=!0;const f8t={toc:[]};function k8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}k8t.isMDXComponent=!0;const y8t={toc:[]};function M8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}M8t.isMDXComponent=!0;const D8t={toc:[]};function w8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}w8t.isMDXComponent=!0;const _8t={toc:[]};function X8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}X8t.isMDXComponent=!0;const g8t={toc:[]};function T8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}T8t.isMDXComponent=!0;const x8t={toc:[]};function C8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}C8t.isMDXComponent=!0;const v8t={toc:[]};function L8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}L8t.isMDXComponent=!0;const Z8t={toc:[]};function b8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}b8t.isMDXComponent=!0;const N8t={toc:[]};function z8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}z8t.isMDXComponent=!0;const A8t={toc:[]};function W8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}W8t.isMDXComponent=!0;const R8t={toc:[]};function I8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}I8t.isMDXComponent=!0;const P8t={toc:[]};function S8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}S8t.isMDXComponent=!0;const E8t={toc:[]};function B8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}B8t.isMDXComponent=!0;const G8t={toc:[]};function O8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}O8t.isMDXComponent=!0;const U8t={toc:[]};function F8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}F8t.isMDXComponent=!0;const q8t={toc:[]};function V8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}V8t.isMDXComponent=!0;const j8t={toc:[]};function H8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}H8t.isMDXComponent=!0;const Q8t={toc:[]};function Y8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Y8t.isMDXComponent=!0;const $8t={toc:[]};function K8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}K8t.isMDXComponent=!0;const J8t={toc:[]};function t7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}t7t.isMDXComponent=!0;const n7t={toc:[]};function e7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}e7t.isMDXComponent=!0;const o7t={toc:[]};function p7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}p7t.isMDXComponent=!0;const r7t={toc:[]};function s7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}s7t.isMDXComponent=!0;const c7t={toc:[]};function i7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}i7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}h7t.isMDXComponent=!0;const f7t={toc:[]};function k7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}k7t.isMDXComponent=!0;const y7t={toc:[]};function M7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}M7t.isMDXComponent=!0;const D7t={toc:[]};function w7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}w7t.isMDXComponent=!0;const _7t={toc:[]};function X7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}X7t.isMDXComponent=!0;const g7t={toc:[]};function T7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}T7t.isMDXComponent=!0;const x7t={toc:[]};function C7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}C7t.isMDXComponent=!0;const v7t={toc:[]};function L7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}L7t.isMDXComponent=!0;const Z7t={toc:[]};function b7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}b7t.isMDXComponent=!0;const N7t={toc:[]};function z7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}z7t.isMDXComponent=!0;const A7t={toc:[]};function W7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}W7t.isMDXComponent=!0;const R7t={toc:[]};function I7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}I7t.isMDXComponent=!0;const P7t={toc:[]};function S7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}S7t.isMDXComponent=!0;const E7t={toc:[]};function B7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}B7t.isMDXComponent=!0;const G7t={toc:[]};function O7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}O7t.isMDXComponent=!0;const U7t={toc:[]};function F7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}F7t.isMDXComponent=!0;const q7t={toc:[]};function V7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}V7t.isMDXComponent=!0;const j7t={toc:[]};function H7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}H7t.isMDXComponent=!0;const Q7t={toc:[]};function Y7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Y7t.isMDXComponent=!0;const $7t={toc:[]};function K7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}K7t.isMDXComponent=!0;const J7t={toc:[]};function t9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}t9t.isMDXComponent=!0;const n9t={toc:[]};function e9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}e9t.isMDXComponent=!0;const o9t={toc:[]};function p9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}p9t.isMDXComponent=!0;const r9t={toc:[]};function s9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}s9t.isMDXComponent=!0;const c9t={toc:[]};function i9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}i9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}h9t.isMDXComponent=!0;const f9t={toc:[]};function k9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}k9t.isMDXComponent=!0;const y9t={toc:[]};function M9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}M9t.isMDXComponent=!0;const D9t={toc:[]};function w9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}w9t.isMDXComponent=!0;const _9t={toc:[]};function X9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}X9t.isMDXComponent=!0;const g9t={toc:[]};function T9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}T9t.isMDXComponent=!0;const x9t={toc:[]};function C9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}C9t.isMDXComponent=!0;const v9t={toc:[]};function L9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}L9t.isMDXComponent=!0;const Z9t={toc:[]};function b9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}b9t.isMDXComponent=!0;const N9t={toc:[]};function z9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}z9t.isMDXComponent=!0;const A9t={toc:[]};function W9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}W9t.isMDXComponent=!0;const R9t={toc:[]};function I9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}I9t.isMDXComponent=!0;const P9t={toc:[]};function S9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}S9t.isMDXComponent=!0;const E9t={toc:[]};function B9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}B9t.isMDXComponent=!0;const G9t={toc:[]};function O9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}O9t.isMDXComponent=!0;const U9t={toc:[]};function F9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}F9t.isMDXComponent=!0;const q9t={toc:[]};function V9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}V9t.isMDXComponent=!0;const j9t={toc:[]};function H9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}H9t.isMDXComponent=!0;const Q9t={toc:[]};function Y9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Y9t.isMDXComponent=!0;const $9t={toc:[]};function K9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}K9t.isMDXComponent=!0;const J9t={toc:[]};function ttn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ttn.isMDXComponent=!0;const ntn={toc:[]};function etn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ntn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}etn.isMDXComponent=!0;const otn={toc:[]};function ptn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},otn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ptn.isMDXComponent=!0;const rtn={toc:[]};function stn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}stn.isMDXComponent=!0;const ctn={toc:[]};function itn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ctn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}itn.isMDXComponent=!0;const atn={toc:[]};function ltn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},atn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ltn.isMDXComponent=!0;const utn={toc:[]};function mtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},utn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}mtn.isMDXComponent=!0;const dtn={toc:[]};function htn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}htn.isMDXComponent=!0;const ftn={toc:[]};function ktn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ftn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ktn.isMDXComponent=!0;const ytn={toc:[]};function Mtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ytn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mtn.isMDXComponent=!0;const Dtn={toc:[]};function wtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wtn.isMDXComponent=!0;const _tn={toc:[]};function Xtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Xtn.isMDXComponent=!0;const gtn={toc:[]};function Ttn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Ttn.isMDXComponent=!0;const xtn={toc:[]};function Ctn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Ctn.isMDXComponent=!0;const vtn={toc:[]};function Ltn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Ltn.isMDXComponent=!0;const Ztn={toc:[]};function btn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ztn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}btn.isMDXComponent=!0;const Ntn={toc:[]};function ztn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ntn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ztn.isMDXComponent=!0;const Atn={toc:[]};function Wtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Atn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Wtn.isMDXComponent=!0;const Rtn={toc:[]};function Itn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Itn.isMDXComponent=!0;const Ptn={toc:[]};function Stn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ptn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Stn.isMDXComponent=!0;const Etn={toc:[]};function Btn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Etn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Btn.isMDXComponent=!0;const Gtn={toc:[]};function Otn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Otn.isMDXComponent=!0;const Utn={toc:[]};function Ftn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Utn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Ftn.isMDXComponent=!0;const qtn={toc:[]};function Vtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Vtn.isMDXComponent=!0;const jtn={toc:[]};function Htn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Htn.isMDXComponent=!0;const Qtn={toc:[]};function Ytn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Ytn.isMDXComponent=!0;const $tn={toc:[]};function Ktn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Ktn.isMDXComponent=!0;const Jtn={toc:[]};function tnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}tnn.isMDXComponent=!0;const nnn={toc:[]};function enn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}enn.isMDXComponent=!0;const onn={toc:[]};function pnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},onn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pnn.isMDXComponent=!0;const rnn={toc:[]};function snn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}snn.isMDXComponent=!0;const cnn={toc:[]};function inn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}inn.isMDXComponent=!0;const ann={toc:[]};function lnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ann,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lnn.isMDXComponent=!0;const unn={toc:[]};function mnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mnn.isMDXComponent=!0;const dnn={toc:[]};function hnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hnn.isMDXComponent=!0;const fnn={toc:[]};function knn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}knn.isMDXComponent=!0;const ynn={toc:[]};function Mnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ynn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Mnn.isMDXComponent=!0;const Dnn={toc:[]};function wnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wnn.isMDXComponent=!0;const _nn={toc:[]};function Xnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Xnn.isMDXComponent=!0;const gnn={toc:[]};function Tnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Tnn.isMDXComponent=!0;const xnn={toc:[]};function Cnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Cnn.isMDXComponent=!0;const vnn={toc:[]};function Lnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Lnn.isMDXComponent=!0;const Znn={toc:[]};function bnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}bnn.isMDXComponent=!0;const Nnn={toc:[]};function znn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}znn.isMDXComponent=!0;const Ann={toc:[]};function Wnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ann,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wnn.isMDXComponent=!0;const Rnn={toc:[]};function Inn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Inn.isMDXComponent=!0;const Pnn={toc:[]};function Snn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Snn.isMDXComponent=!0;const Enn={toc:[]};function Bnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Enn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Bnn.isMDXComponent=!0;const Gnn={toc:[]};function Onn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Onn.isMDXComponent=!0;const Unn={toc:[]};function Fnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Unn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Fnn.isMDXComponent=!0;const qnn={toc:[]};function Vnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Vnn.isMDXComponent=!0;const jnn={toc:[]};function Hnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Hnn.isMDXComponent=!0;const Qnn={toc:[]};function Ynn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Ynn.isMDXComponent=!0;const $nn={toc:[]};function Knn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Knn.isMDXComponent=!0;const Jnn={toc:[]};function ten(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}ten.isMDXComponent=!0;const nen={toc:[]};function een(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}een.isMDXComponent=!0;const oen={toc:[]};function pen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}pen.isMDXComponent=!0;const ren={toc:[]};function sen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ren,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sen.isMDXComponent=!0;const cen={toc:[]};function ien(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}ien.isMDXComponent=!0;const aen={toc:[]};function len(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}len.isMDXComponent=!0;const uen={toc:[]};function men(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}men.isMDXComponent=!0;const den={toc:[]};function hen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},den,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}hen.isMDXComponent=!0;const fen={toc:[]};function ken(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ken.isMDXComponent=!0;const yen={toc:[]};function Men(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Men.isMDXComponent=!0;const Den={toc:[]};function wen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Den,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wen.isMDXComponent=!0;const _en={toc:[]};function Xen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_en,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Xen.isMDXComponent=!0;const gen={toc:[]};function Ten(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Ten.isMDXComponent=!0;const xen={toc:[]};function Cen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Cen.isMDXComponent=!0;const ven={toc:[]};function Len(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ven,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Len.isMDXComponent=!0;const Zen={toc:[]};function ben(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}ben.isMDXComponent=!0;const Nen={toc:[]};function zen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}zen.isMDXComponent=!0;const Aen={toc:[]};function Wen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Wen.isMDXComponent=!0;const Ren={toc:[]};function Ien(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ren,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Ien.isMDXComponent=!0;const Pen={toc:[]};function Sen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Sen.isMDXComponent=!0;const Een={toc:[]};function Ben(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Een,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Ben.isMDXComponent=!0;const Gen={toc:[]};function Oen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Oen.isMDXComponent=!0;const Uen={toc:[]};function Fen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Fen.isMDXComponent=!0;const qen={toc:[]};function Ven(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ven.isMDXComponent=!0;const jen={toc:[]};function Hen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Hen.isMDXComponent=!0;const Qen={toc:[]};function Yen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Yen.isMDXComponent=!0;const $en={toc:[]};function Ken(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$en,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ken.isMDXComponent=!0;const Jen={toc:[]};function ton(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}ton.isMDXComponent=!0;const non={toc:[]};function eon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},non,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eon.isMDXComponent=!0;const oon={toc:[]};function pon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}pon.isMDXComponent=!0;const ron={toc:[]};function son(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ron,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}son.isMDXComponent=!0;const con={toc:[]};function ion(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},con,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}ion.isMDXComponent=!0;const aon={toc:[]};function lon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}lon.isMDXComponent=!0;const uon={toc:[]};function mon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}mon.isMDXComponent=!0;const don={toc:[]};function hon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},don,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}hon.isMDXComponent=!0;const fon={toc:[]};function kon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kon.isMDXComponent=!0;const yon={toc:[]};function Mon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Mon.isMDXComponent=!0;const Don={toc:[]};function won(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Don,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}won.isMDXComponent=!0;const _on={toc:[]};function Xon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_on,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Xon.isMDXComponent=!0;const gon={toc:[]};function Ton(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ton.isMDXComponent=!0;const xon={toc:[]};function Con(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Con.isMDXComponent=!0;const von={toc:[]};function Lon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},von,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Lon.isMDXComponent=!0;const Zon={toc:[]};function bon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}bon.isMDXComponent=!0;const Non={toc:[]};function zon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Non,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}zon.isMDXComponent=!0;const Aon={toc:[]};function Won(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Won.isMDXComponent=!0;const Ron={toc:[]};function Ion(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ron,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ion.isMDXComponent=!0;const Pon={toc:[]};function Son(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Son.isMDXComponent=!0;const Eon={toc:[]};function Bon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Bon.isMDXComponent=!0;const Gon={toc:[]};function Oon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Oon.isMDXComponent=!0;const Uon={toc:[]};function Fon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Fon.isMDXComponent=!0;const qon={toc:[]};function Von(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Von.isMDXComponent=!0;const jon={toc:[]};function Hon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Hon.isMDXComponent=!0;const Qon={toc:[]};function Yon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Yon.isMDXComponent=!0;const $on={toc:[]};function Kon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$on,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Kon.isMDXComponent=!0;const Jon={toc:[]};function tpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}tpn.isMDXComponent=!0;const npn={toc:[]};function epn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},npn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}epn.isMDXComponent=!0;const opn={toc:[]};function ppn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}ppn.isMDXComponent=!0;const rpn={toc:[]};function spn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}spn.isMDXComponent=!0;const cpn={toc:[]};function ipn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ipn.isMDXComponent=!0;const apn={toc:[]};function lpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lpn.isMDXComponent=!0;const upn={toc:[]};function mpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}mpn.isMDXComponent=!0;const dpn={toc:[]};function hpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}hpn.isMDXComponent=!0;const fpn={toc:[]};function kpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kpn.isMDXComponent=!0;const ypn={toc:[]};function Mpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ypn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Mpn.isMDXComponent=!0;const Dpn={toc:[]};function wpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}wpn.isMDXComponent=!0;const _pn={toc:[]};function Xpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Xpn.isMDXComponent=!0;const gpn={toc:[]};function Tpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Tpn.isMDXComponent=!0;const xpn={toc:[]};function Cpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Cpn.isMDXComponent=!0;const vpn={toc:[]};function Lpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lpn.isMDXComponent=!0;const Zpn={toc:[]};function bpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}bpn.isMDXComponent=!0;const Npn={toc:[]};function zpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zpn.isMDXComponent=!0;const Apn={toc:[]};function Wpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Wpn.isMDXComponent=!0;const Rpn={toc:[]};function Ipn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ipn.isMDXComponent=!0;const Ppn={toc:[]};function Spn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ppn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Spn.isMDXComponent=!0;const Epn={toc:[]};function Bpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Epn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Bpn.isMDXComponent=!0;const Gpn={toc:[]};function Opn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Opn.isMDXComponent=!0;const Upn={toc:[]};function Fpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Fpn.isMDXComponent=!0;const qpn={toc:[]};function Vpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Vpn.isMDXComponent=!0;const jpn={toc:[]};function Hpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Hpn.isMDXComponent=!0;const Qpn={toc:[]};function Ypn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ypn.isMDXComponent=!0;const $pn={toc:[]};function Kpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]};function trn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}trn.isMDXComponent=!0;const nrn={toc:[]};function ern(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ern.isMDXComponent=!0;const orn={toc:[]};function prn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},orn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}prn.isMDXComponent=!0;const rrn={toc:[]};function srn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}srn.isMDXComponent=!0;const crn={toc:[]};function irn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}irn.isMDXComponent=!0;const arn={toc:[]};function lrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},arn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lrn.isMDXComponent=!0;const urn={toc:[]};function mrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}mrn.isMDXComponent=!0;const drn={toc:[]};function hrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}hrn.isMDXComponent=!0;const frn={toc:[]};function krn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}krn.isMDXComponent=!0;const yrn={toc:[]};function Mrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mrn.isMDXComponent=!0;const Drn={toc:[]};function wrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wrn.isMDXComponent=!0;const _rn={toc:[]};function Xrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Xrn.isMDXComponent=!0;const grn={toc:[]};function Trn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Trn.isMDXComponent=!0;const xrn={toc:[]};function Crn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Crn.isMDXComponent=!0;const vrn={toc:[]};function Lrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Lrn.isMDXComponent=!0;const Zrn={toc:[]};function brn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}brn.isMDXComponent=!0;const Nrn={toc:[]};function zrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}zrn.isMDXComponent=!0;const Arn={toc:[]};function Wrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Arn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Wrn.isMDXComponent=!0;const Rrn={toc:[]};function Irn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Irn.isMDXComponent=!0;const Prn={toc:[]};function Srn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Prn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Srn.isMDXComponent=!0;const Ern={toc:[]};function Brn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ern,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Brn.isMDXComponent=!0;const Grn={toc:[]};function Orn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Orn.isMDXComponent=!0;const Urn={toc:[]};function Frn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Urn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Frn.isMDXComponent=!0;const qrn={toc:[]};function Vrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Vrn.isMDXComponent=!0;const jrn={toc:[]};function Hrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Hrn.isMDXComponent=!0;const Qrn={toc:[]};function Yrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Yrn.isMDXComponent=!0;const $rn={toc:[]};function Krn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Krn.isMDXComponent=!0;const Jrn={toc:[]};function tsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}tsn.isMDXComponent=!0;const nsn={toc:[]};function esn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}esn.isMDXComponent=!0;const osn={toc:[]};function psn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},osn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}psn.isMDXComponent=!0;const rsn={toc:[]};function ssn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}ssn.isMDXComponent=!0;const csn={toc:[]};function isn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},csn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}isn.isMDXComponent=!0;const asn={toc:[]};function lsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},asn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}lsn.isMDXComponent=!0;const usn={toc:[]};function msn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},usn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}msn.isMDXComponent=!0;const dsn={toc:[]};function hsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}hsn.isMDXComponent=!0;const fsn={toc:[]};function ksn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}ksn.isMDXComponent=!0;const ysn={toc:[]};function Msn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ysn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Msn.isMDXComponent=!0;const Dsn={toc:[]};function wsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}wsn.isMDXComponent=!0;const _sn={toc:[]};function Xsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_sn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Xsn.isMDXComponent=!0;const gsn={toc:[]};function Tsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Tsn.isMDXComponent=!0;const xsn={toc:[]};function Csn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Csn.isMDXComponent=!0;const vsn={toc:[]};function Lsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Lsn.isMDXComponent=!0;const Zsn={toc:[]};function bsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}bsn.isMDXComponent=!0;const Nsn={toc:[]};function zsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}zsn.isMDXComponent=!0;const Asn={toc:[]};function Wsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Asn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Wsn.isMDXComponent=!0;const Rsn={toc:[]};function Isn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Isn.isMDXComponent=!0;const Psn={toc:[]};function Ssn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Psn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Ssn.isMDXComponent=!0;const Esn={toc:[]};function Bsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Esn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Bsn.isMDXComponent=!0;const Gsn={toc:[]};function Osn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Osn.isMDXComponent=!0;const Usn={toc:[]};function Fsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Usn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Fsn.isMDXComponent=!0;const qsn={toc:[]};function Vsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Vsn.isMDXComponent=!0;const jsn={toc:[]};function Hsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Hsn.isMDXComponent=!0;const Qsn={toc:[]};function Ysn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Ysn.isMDXComponent=!0;const $sn={toc:[]};function Ksn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$sn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ksn.isMDXComponent=!0;const Jsn={toc:[]};function tcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}tcn.isMDXComponent=!0;const ncn={toc:[]};function ecn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ncn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ecn.isMDXComponent=!0;const ocn={toc:[]};function pcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ocn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}pcn.isMDXComponent=!0;const rcn={toc:[]};function scn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}scn.isMDXComponent=!0;const ccn={toc:[]};function icn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ccn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}icn.isMDXComponent=!0;const acn={toc:[]};function lcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},acn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}lcn.isMDXComponent=!0;const ucn={toc:[]};function mcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ucn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}mcn.isMDXComponent=!0;const dcn={toc:[]};function hcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hcn.isMDXComponent=!0;const fcn={toc:[]};function kcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}kcn.isMDXComponent=!0;const ycn={toc:[]};function Mcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ycn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Mcn.isMDXComponent=!0;const Dcn={toc:[]};function wcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wcn.isMDXComponent=!0;const _cn={toc:[]};function Xcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Xcn.isMDXComponent=!0;const gcn={toc:[]};function Tcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Tcn.isMDXComponent=!0;const xcn={toc:[]};function Ccn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Ccn.isMDXComponent=!0;const vcn={toc:[]};function Lcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Lcn.isMDXComponent=!0;const Zcn={toc:[]};function bcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bcn.isMDXComponent=!0;const Ncn={toc:[]};function zcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ncn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}zcn.isMDXComponent=!0;const Acn={toc:[]};function Wcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Acn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Wcn.isMDXComponent=!0;const Rcn={toc:[]};function Icn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Icn.isMDXComponent=!0;const Pcn={toc:[]};function Scn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Scn.isMDXComponent=!0;const Ecn={toc:[]};function Bcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ecn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Bcn.isMDXComponent=!0;const Gcn={toc:[]};function Ocn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ocn.isMDXComponent=!0;const Ucn={toc:[]};function Fcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ucn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Fcn.isMDXComponent=!0;const qcn={toc:[]};function Vcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Vcn.isMDXComponent=!0;const jcn={toc:[]};function Hcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Hcn.isMDXComponent=!0;const Qcn={toc:[]};function Ycn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ycn.isMDXComponent=!0;const $cn={toc:[]};function Kcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Kcn.isMDXComponent=!0;const Jcn={toc:[]};function tin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}tin.isMDXComponent=!0;const nin={toc:[]};function ein(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ein.isMDXComponent=!0;const oin={toc:[]};function pin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pin.isMDXComponent=!0;const rin={toc:[]};function sin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sin.isMDXComponent=!0;const cin={toc:[]};function iin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iin.isMDXComponent=!0;const ain={toc:[]};function lin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ain,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lin.isMDXComponent=!0;const uin={toc:[]};function min(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}min.isMDXComponent=!0;const din={toc:[]};function hin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},din,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hin.isMDXComponent=!0;const fin={toc:[]};function kin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kin.isMDXComponent=!0;const yin={toc:[]};function Min(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Min.isMDXComponent=!0;const Din={toc:[]};function win(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Din,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}win.isMDXComponent=!0;const _in={toc:[]};function Xin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_in,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Xin.isMDXComponent=!0;const gin={toc:[]};function Tin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Tin.isMDXComponent=!0;const xin={toc:[]};function Cin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Cin.isMDXComponent=!0;const vin={toc:[]};function Lin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lin.isMDXComponent=!0;const Zin={toc:[]};function bin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}bin.isMDXComponent=!0;const Nin={toc:[]};function zin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zin.isMDXComponent=!0;const Ain={toc:[]};function Win(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ain,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Win.isMDXComponent=!0;const Rin={toc:[]};function Iin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Iin.isMDXComponent=!0;const Pin={toc:[]};function Sin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Sin.isMDXComponent=!0;const Ein={toc:[]};function Bin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ein,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Bin.isMDXComponent=!0;const Gin={toc:[]};function Oin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}Oin.isMDXComponent=!0;const Uin={toc:[]};function Fin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Fin.isMDXComponent=!0;const qin={toc:[]};function Vin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Vin.isMDXComponent=!0;const jin={toc:[]};function Hin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Hin.isMDXComponent=!0;const Qin={toc:[]};function Yin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Yin.isMDXComponent=!0;const $in={toc:[]};function Kin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$in,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Kin.isMDXComponent=!0;const Jin={toc:[]};function tan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}tan.isMDXComponent=!0;const nan={toc:[]};function ean(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ean.isMDXComponent=!0;const oan={toc:[]};function pan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}pan.isMDXComponent=!0;const ran={toc:[]};function san(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ran,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}san.isMDXComponent=!0;const can={toc:[]};function ian(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},can,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ian.isMDXComponent=!0;const aan={toc:[]};function lan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lan.isMDXComponent=!0;const uan={toc:[]};function man(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}man.isMDXComponent=!0;const dan={toc:[]};function han(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}han.isMDXComponent=!0;const fan={toc:[]};function kan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}kan.isMDXComponent=!0;const yan={toc:[]};function Man(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Man.isMDXComponent=!0;const Dan={toc:[]};function wan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wan.isMDXComponent=!0;const _an={toc:[]};function Xan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_an,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Xan.isMDXComponent=!0;const gan={toc:[]};function Tan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Tan.isMDXComponent=!0;const xan={toc:[]};function Can(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Can.isMDXComponent=!0;const van={toc:[]};function Lan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},van,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Lan.isMDXComponent=!0;const Zan={toc:[]};function ban(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ban.isMDXComponent=!0;const Nan={toc:[]};function zan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zan.isMDXComponent=!0;const Aan={toc:[]};function Wan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Wan.isMDXComponent=!0;const Ran={toc:[]};function Ian(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ran,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Ian.isMDXComponent=!0;const Pan={toc:[]};function San(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}San.isMDXComponent=!0;const Ean={toc:[]};function Ban(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ean,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ban.isMDXComponent=!0;const Gan={toc:[]};function Oan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Oan.isMDXComponent=!0;const Uan={toc:[]};function Fan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Fan.isMDXComponent=!0;const qan={toc:[]};function Van(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Van.isMDXComponent=!0;const jan={toc:[]};function Han(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Han.isMDXComponent=!0;const Qan={toc:[]};function Yan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Yan.isMDXComponent=!0;const $an={toc:[]};function Kan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$an,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Kan.isMDXComponent=!0;const Jan={toc:[]};function tln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}tln.isMDXComponent=!0;const nln={toc:[]};function eln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}eln.isMDXComponent=!0;const oln={toc:[]};function pln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}pln.isMDXComponent=!0;const rln={toc:[]};function sln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}sln.isMDXComponent=!0;const cln={toc:[]};function iln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}iln.isMDXComponent=!0;const aln={toc:[]};function lln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lln.isMDXComponent=!0;const uln={toc:[]};function mln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}mln.isMDXComponent=!0;const dln={toc:[]};function hln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}hln.isMDXComponent=!0;const fln={toc:[]};function kln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}kln.isMDXComponent=!0;const yln={toc:[]};function Mln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Mln.isMDXComponent=!0;const Dln={toc:[]};function wln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}wln.isMDXComponent=!0;const _ln={toc:[]};function Xln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Xln.isMDXComponent=!0;const gln={toc:[]};function Tln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Tln.isMDXComponent=!0;const xln={toc:[]};function Cln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Cln.isMDXComponent=!0;const vln={toc:[]};function Lln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lln.isMDXComponent=!0;const Zln={toc:[]};function bln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}bln.isMDXComponent=!0;const Nln={toc:[]};function zln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}zln.isMDXComponent=!0;const Aln={toc:[]};function Wln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Wln.isMDXComponent=!0;const Rln={toc:[]};function Iln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Iln.isMDXComponent=!0;const Pln={toc:[]};function Sln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Sln.isMDXComponent=!0;const Eln={toc:[]};function Bln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Bln.isMDXComponent=!0;const Gln={toc:[]};function Oln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Oln.isMDXComponent=!0;const Uln={toc:[]};function Fln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Fln.isMDXComponent=!0;const qln={toc:[]};function Vln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Vln.isMDXComponent=!0;const jln={toc:[]};function Hln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Hln.isMDXComponent=!0;const Qln={toc:[]};function Yln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Yln.isMDXComponent=!0;const $ln={toc:[]};function Kln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Kln.isMDXComponent=!0;const Jln={toc:[]};function tun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}tun.isMDXComponent=!0;const nun={toc:[]};function eun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}eun.isMDXComponent=!0;const oun={toc:[]};function pun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pun.isMDXComponent=!0;const run={toc:[]};function sun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},run,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sun.isMDXComponent=!0;const cun={toc:[]};function iun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}iun.isMDXComponent=!0;const aun={toc:[]};function lun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lun.isMDXComponent=!0;const uun={toc:[]};function mun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}mun.isMDXComponent=!0;const dun={toc:[]};function hun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hun.isMDXComponent=!0;const fun={toc:[]};function kun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kun.isMDXComponent=!0;const yun={toc:[]};function Mun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mun.isMDXComponent=!0;const Dun={toc:[]};function wun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wun.isMDXComponent=!0;const _un={toc:[]};function Xun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_un,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Xun.isMDXComponent=!0;const gun={toc:[]};function Tun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Tun.isMDXComponent=!0;const xun={toc:[]};function Cun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Cun.isMDXComponent=!0;const vun={toc:[]};function Lun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Lun.isMDXComponent=!0;const Zun={toc:[]};function bun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bun.isMDXComponent=!0;const Nun={toc:[]};function zun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}zun.isMDXComponent=!0;const Aun={toc:[]};function Wun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Wun.isMDXComponent=!0;const Run={toc:[]};function Iun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Run,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Iun.isMDXComponent=!0;const Pun={toc:[]};function Sun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Sun.isMDXComponent=!0;const Eun={toc:[]};function Bun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Bun.isMDXComponent=!0;const Gun={toc:[]};function Oun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Oun.isMDXComponent=!0;const Uun={toc:[]};function Fun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Fun.isMDXComponent=!0;const qun={toc:[]};function Vun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Vun.isMDXComponent=!0;const jun={toc:[]};function Hun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Hun.isMDXComponent=!0;const Qun={toc:[]};function Yun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Yun.isMDXComponent=!0;const $un={toc:[]};function Kun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$un,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Kun.isMDXComponent=!0;const Jun={toc:[]};function tmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}tmn.isMDXComponent=!0;const nmn={toc:[]};function emn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}emn.isMDXComponent=!0;const omn={toc:[]};function pmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pmn.isMDXComponent=!0;const rmn={toc:[]};function smn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}smn.isMDXComponent=!0;const cmn={toc:[]};function imn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}imn.isMDXComponent=!0;const amn={toc:[]};function lmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lmn.isMDXComponent=!0;const umn={toc:[]};function mmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mmn.isMDXComponent=!0;const dmn={toc:[]};function hmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hmn.isMDXComponent=!0;const fmn={toc:[]};function kmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kmn.isMDXComponent=!0;const ymn={toc:[]};function Mmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ymn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Mmn.isMDXComponent=!0;const Dmn={toc:[]};function wmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wmn.isMDXComponent=!0;const _mn={toc:[]};function Xmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Xmn.isMDXComponent=!0;const gmn={toc:[]};function Tmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Tmn.isMDXComponent=!0;const xmn={toc:[]};function Cmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Cmn.isMDXComponent=!0;const vmn={toc:[]};function Lmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Lmn.isMDXComponent=!0;const Zmn={toc:[]};function bmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}bmn.isMDXComponent=!0;const Nmn={toc:[]};function zmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}zmn.isMDXComponent=!0;const Amn={toc:[]};function Wmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wmn.isMDXComponent=!0;const Rmn={toc:[]};function Imn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Imn.isMDXComponent=!0;const Pmn={toc:[]};function Smn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Smn.isMDXComponent=!0;const Emn={toc:[]};function Bmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Bmn.isMDXComponent=!0;const Gmn={toc:[]};function Omn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Omn.isMDXComponent=!0;const Umn={toc:[]};function Fmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Umn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Fmn.isMDXComponent=!0;const qmn={toc:[]};function Vmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Vmn.isMDXComponent=!0;const jmn={toc:[]};function Hmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Hmn.isMDXComponent=!0;const Qmn={toc:[]};function Ymn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Ymn.isMDXComponent=!0;const $mn={toc:[]};function Kmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Kmn.isMDXComponent=!0;const Jmn={toc:[]};function tdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tdn.isMDXComponent=!0;const ndn={toc:[]};function edn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ndn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}edn.isMDXComponent=!0;const odn={toc:[]};function pdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pdn.isMDXComponent=!0;const rdn={toc:[]};function sdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}sdn.isMDXComponent=!0;const cdn={toc:[]};function idn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}idn.isMDXComponent=!0;const adn={toc:[]};function ldn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}ldn.isMDXComponent=!0;const udn={toc:[]};function mdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}mdn.isMDXComponent=!0;const ddn={toc:[]};function hdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}hdn.isMDXComponent=!0;const fdn={toc:[]};function kdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kdn.isMDXComponent=!0;const ydn={toc:[]};function Mdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ydn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Mdn.isMDXComponent=!0;const Ddn={toc:[]};function wdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}wdn.isMDXComponent=!0;const _dn={toc:[]};function Xdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_dn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Xdn.isMDXComponent=!0;const gdn={toc:[]};function Tdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Tdn.isMDXComponent=!0;const xdn={toc:[]};function Cdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Cdn.isMDXComponent=!0;const vdn={toc:[]};function Ldn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ldn.isMDXComponent=!0;const Zdn={toc:[]};function bdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}bdn.isMDXComponent=!0;const Ndn={toc:[]};function zdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}zdn.isMDXComponent=!0;const Adn={toc:[]};function Wdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Wdn.isMDXComponent=!0;const Rdn={toc:[]};function Idn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Idn.isMDXComponent=!0;const Pdn={toc:[]};function Sdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Sdn.isMDXComponent=!0;const Edn={toc:[]};function Bdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Bdn.isMDXComponent=!0;const Gdn={toc:[]};function Odn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Odn.isMDXComponent=!0;const Udn={toc:[]};function Fdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Udn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Fdn.isMDXComponent=!0;const qdn={toc:[]};function Vdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Vdn.isMDXComponent=!0;const jdn={toc:[]};function Hdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Hdn.isMDXComponent=!0;const Qdn={toc:[]};function Ydn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ydn.isMDXComponent=!0;const $dn={toc:[]};function Kdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$dn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Kdn.isMDXComponent=!0;const Jdn={toc:[]};function thn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}thn.isMDXComponent=!0;const nhn={toc:[]};function ehn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ehn.isMDXComponent=!0;const ohn={toc:[]};function phn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ohn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}phn.isMDXComponent=!0;const rhn={toc:[]};function shn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}shn.isMDXComponent=!0;const chn={toc:[]};function ihn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},chn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ihn.isMDXComponent=!0;const ahn={toc:[]};function lhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ahn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lhn.isMDXComponent=!0;const uhn={toc:[]};function mhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}mhn.isMDXComponent=!0;const dhn={toc:[]};function hhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hhn.isMDXComponent=!0;const fhn={toc:[]};function khn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}khn.isMDXComponent=!0;const yhn={toc:[]};function Mhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Mhn.isMDXComponent=!0;const Dhn={toc:[]};function whn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}whn.isMDXComponent=!0;const _hn={toc:[]};function Xhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Xhn.isMDXComponent=!0;const ghn={toc:[]};function Thn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ghn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Thn.isMDXComponent=!0;const xhn={toc:[]};function Chn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Chn.isMDXComponent=!0;const vhn={toc:[]};function Lhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lhn.isMDXComponent=!0;const Zhn={toc:[]};function bhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}bhn.isMDXComponent=!0;const Nhn={toc:[]};function zhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zhn.isMDXComponent=!0;const Ahn={toc:[]};function Whn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ahn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Whn.isMDXComponent=!0;const Rhn={toc:[]};function Ihn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ihn.isMDXComponent=!0;const Phn={toc:[]};function Shn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Phn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Shn.isMDXComponent=!0;const Ehn={toc:[]};function Bhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ehn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Bhn.isMDXComponent=!0;const Ghn={toc:[]};function Ohn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ghn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Ohn.isMDXComponent=!0;const Uhn={toc:[]};function Fhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Fhn.isMDXComponent=!0;const qhn={toc:[]};function Vhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Vhn.isMDXComponent=!0;const jhn={toc:[]};function Hhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Hhn.isMDXComponent=!0;const Qhn={toc:[]};function Yhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Yhn.isMDXComponent=!0;const $hn={toc:[]};function Khn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Khn.isMDXComponent=!0;const Jhn={toc:[]};function tfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}tfn.isMDXComponent=!0;const nfn={toc:[]};function efn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}efn.isMDXComponent=!0;const ofn={toc:[]};function pfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ofn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}pfn.isMDXComponent=!0;const rfn={toc:[]};function sfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}sfn.isMDXComponent=!0;const cfn={toc:[]};function ifn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}ifn.isMDXComponent=!0;const afn={toc:[]};function lfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},afn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lfn.isMDXComponent=!0;const ufn={toc:[]};function mfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ufn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mfn.isMDXComponent=!0;const dfn={toc:[]};function hfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hfn.isMDXComponent=!0;const ffn={toc:[]};function kfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ffn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kfn.isMDXComponent=!0;const yfn={toc:[]};function Mfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Mfn.isMDXComponent=!0;const Dfn={toc:[]};function wfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}wfn.isMDXComponent=!0;const _fn={toc:[]};function Xfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_fn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Xfn.isMDXComponent=!0;const gfn={toc:[]};function Tfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Tfn.isMDXComponent=!0;const xfn={toc:[]};function Cfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Cfn.isMDXComponent=!0;const vfn={toc:[]};function Lfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Lfn.isMDXComponent=!0;const Zfn={toc:[]};function bfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}bfn.isMDXComponent=!0;const Nfn={toc:[]};function zfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}zfn.isMDXComponent=!0;const Afn={toc:[]};function Wfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Afn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wfn.isMDXComponent=!0;const Rfn={toc:[]};function Ifn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ifn.isMDXComponent=!0;const Pfn={toc:[]};function Sfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Sfn.isMDXComponent=!0;const Efn={toc:[]};function Bfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Efn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Bfn.isMDXComponent=!0;const Gfn={toc:[]};function Ofn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Ofn.isMDXComponent=!0;const Ufn={toc:[]};function Ffn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ufn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Ffn.isMDXComponent=!0;const qfn={toc:[]};function Vfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Vfn.isMDXComponent=!0;const jfn={toc:[]};function Hfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Hfn.isMDXComponent=!0;const Qfn={toc:[]};function Yfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Yfn.isMDXComponent=!0;const $fn={toc:[]};function Kfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$fn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]};function tkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}tkn.isMDXComponent=!0;const nkn={toc:[]};function ekn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ekn.isMDXComponent=!0;const okn={toc:[]};function pkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pkn.isMDXComponent=!0;const rkn={toc:[]};function skn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}skn.isMDXComponent=!0;const ckn={toc:[]};function ikn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ikn.isMDXComponent=!0;const akn={toc:[]};function lkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}lkn.isMDXComponent=!0;const ukn={toc:[]};function mkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}mkn.isMDXComponent=!0;const dkn={toc:[]};function hkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}hkn.isMDXComponent=!0;const fkn={toc:[]};function kkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}kkn.isMDXComponent=!0;const ykn={toc:[]};function Mkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ykn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Mkn.isMDXComponent=!0;const Dkn={toc:[]};function wkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wkn.isMDXComponent=!0;const _kn={toc:[]};function Xkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Xkn.isMDXComponent=!0;const gkn={toc:[]};function Tkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Tkn.isMDXComponent=!0;const xkn={toc:[]};function Ckn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Ckn.isMDXComponent=!0;const vkn={toc:[]};function Lkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lkn.isMDXComponent=!0;const Zkn={toc:[]};function bkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}bkn.isMDXComponent=!0;const Nkn={toc:[]};function zkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}zkn.isMDXComponent=!0;const Akn={toc:[]};function Wkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wkn.isMDXComponent=!0;const Rkn={toc:[]};function Ikn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Ikn.isMDXComponent=!0;const Pkn={toc:[]};function Skn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Skn.isMDXComponent=!0;const Ekn={toc:[]};function Bkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Bkn.isMDXComponent=!0;const Gkn={toc:[]};function Okn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Okn.isMDXComponent=!0;const Ukn={toc:[]};function Fkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ukn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Fkn.isMDXComponent=!0;const qkn={toc:[]};function Vkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Vkn.isMDXComponent=!0;const jkn={toc:[]};function Hkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Hkn.isMDXComponent=!0;const Qkn={toc:[]};function Ykn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Ykn.isMDXComponent=!0;const $kn={toc:[]};function Kkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]};function tyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}tyn.isMDXComponent=!0;const nyn={toc:[]};function eyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}eyn.isMDXComponent=!0;const oyn={toc:[]};function pyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}pyn.isMDXComponent=!0;const ryn={toc:[]};function syn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}syn.isMDXComponent=!0;const cyn={toc:[]};function iyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}iyn.isMDXComponent=!0;const ayn={toc:[]};function lyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}lyn.isMDXComponent=!0;const uyn={toc:[]};function myn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}myn.isMDXComponent=!0;const dyn={toc:[]};function hyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}hyn.isMDXComponent=!0;const fyn={toc:[]};function kyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kyn.isMDXComponent=!0;const yyn={toc:[]};function Myn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Myn.isMDXComponent=!0;const Dyn={toc:[]};function wyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wyn.isMDXComponent=!0;const _yn={toc:[]};function Xyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_yn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Xyn.isMDXComponent=!0;const gyn={toc:[]};function Tyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Tyn.isMDXComponent=!0;const xyn={toc:[]};function Cyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Cyn.isMDXComponent=!0;const vyn={toc:[]};function Lyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Lyn.isMDXComponent=!0;const Zyn={toc:[]};function byn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}byn.isMDXComponent=!0;const Nyn={toc:[]};function zyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}zyn.isMDXComponent=!0;const Ayn={toc:[]};function Wyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wyn.isMDXComponent=!0;const Ryn={toc:[]};function Iyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Iyn.isMDXComponent=!0;const Pyn={toc:[]};function Syn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Syn.isMDXComponent=!0;const Eyn={toc:[]};function Byn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Byn.isMDXComponent=!0;const Gyn={toc:[]};function Oyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Oyn.isMDXComponent=!0;const Uyn={toc:[]};function Fyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Fyn.isMDXComponent=!0;const qyn={toc:[]};function Vyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Vyn.isMDXComponent=!0;const jyn={toc:[]};function Hyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Hyn.isMDXComponent=!0;const Qyn={toc:[]};function Yyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Yyn.isMDXComponent=!0;const $yn={toc:[]};function Kyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$yn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Kyn.isMDXComponent=!0;const Jyn={toc:[]};function tMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}tMn.isMDXComponent=!0;const nMn={toc:[]};function eMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}eMn.isMDXComponent=!0;const oMn={toc:[]};function pMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}pMn.isMDXComponent=!0;const rMn={toc:[]};function sMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}sMn.isMDXComponent=!0;const cMn={toc:[]};function iMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}iMn.isMDXComponent=!0;const aMn={toc:[]};function lMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lMn.isMDXComponent=!0;const uMn={toc:[]};function mMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}mMn.isMDXComponent=!0;const dMn={toc:[]};function hMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}hMn.isMDXComponent=!0;const fMn={toc:[]};function kMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kMn.isMDXComponent=!0;const yMn={toc:[]};function MMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}MMn.isMDXComponent=!0;const DMn={toc:[]};function wMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wMn.isMDXComponent=!0;const _Mn={toc:[]};function XMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}XMn.isMDXComponent=!0;const gMn={toc:[]};function TMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}TMn.isMDXComponent=!0;const xMn={toc:[]};function CMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}CMn.isMDXComponent=!0;const vMn={toc:[]};function LMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}LMn.isMDXComponent=!0;const ZMn={toc:[]};function bMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}bMn.isMDXComponent=!0;const NMn={toc:[]};function zMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zMn.isMDXComponent=!0;const AMn={toc:[]};function WMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}WMn.isMDXComponent=!0;const RMn={toc:[]};function IMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}IMn.isMDXComponent=!0;const PMn={toc:[]};function SMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}SMn.isMDXComponent=!0;const EMn={toc:[]};function BMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}BMn.isMDXComponent=!0;const GMn={toc:[]};function OMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}OMn.isMDXComponent=!0;const UMn={toc:[]};function FMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}FMn.isMDXComponent=!0;const qMn={toc:[]};function VMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}VMn.isMDXComponent=!0;const jMn={toc:[]};function HMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}HMn.isMDXComponent=!0;const QMn={toc:[]};function YMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}YMn.isMDXComponent=!0;const $Mn={toc:[]};function KMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}KMn.isMDXComponent=!0;const JMn={toc:[]};function tDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}tDn.isMDXComponent=!0;const nDn={toc:[]};function eDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}eDn.isMDXComponent=!0;const oDn={toc:[]};function pDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}pDn.isMDXComponent=!0;const rDn={toc:[]};function sDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sDn.isMDXComponent=!0;const cDn={toc:[]};function iDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iDn.isMDXComponent=!0;const aDn={toc:[]};function lDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}lDn.isMDXComponent=!0;const uDn={toc:[]};function mDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}mDn.isMDXComponent=!0;const dDn={toc:[]};function hDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}hDn.isMDXComponent=!0;const fDn={toc:[]};function kDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kDn.isMDXComponent=!0;const yDn={toc:[]};function MDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}MDn.isMDXComponent=!0;const DDn={toc:[]};function wDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wDn.isMDXComponent=!0;const _Dn={toc:[]};function XDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Dn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}XDn.isMDXComponent=!0;const gDn={toc:[]};function TDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}TDn.isMDXComponent=!0;const xDn={toc:[]};function CDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}CDn.isMDXComponent=!0;const vDn={toc:[]};function LDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}LDn.isMDXComponent=!0;const ZDn={toc:[]};function bDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}bDn.isMDXComponent=!0;const NDn={toc:[]};function zDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}zDn.isMDXComponent=!0;const ADn={toc:[]};function WDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}WDn.isMDXComponent=!0;const RDn={toc:[]};function IDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}IDn.isMDXComponent=!0;const PDn={toc:[]};function SDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SDn.isMDXComponent=!0;const EDn={toc:[]};function BDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}BDn.isMDXComponent=!0;const GDn={toc:[]};function ODn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ODn.isMDXComponent=!0;const UDn={toc:[]};function FDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}FDn.isMDXComponent=!0;const qDn={toc:[]};function VDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VDn.isMDXComponent=!0;const jDn={toc:[]};function HDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}HDn.isMDXComponent=!0;const QDn={toc:[]};function YDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}YDn.isMDXComponent=!0;const $Dn={toc:[]};function KDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Dn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}KDn.isMDXComponent=!0;const JDn={toc:[]};function twn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}twn.isMDXComponent=!0;const nwn={toc:[]};function ewn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}ewn.isMDXComponent=!0;const own={toc:[]};function pwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},own,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pwn.isMDXComponent=!0;const rwn={toc:[]};function swn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}swn.isMDXComponent=!0;const cwn={toc:[]};function iwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iwn.isMDXComponent=!0;const awn={toc:[]};function lwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lwn.isMDXComponent=!0;const uwn={toc:[]};function mwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}mwn.isMDXComponent=!0;const dwn={toc:[]};function hwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}hwn.isMDXComponent=!0;const fwn={toc:[]};function kwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kwn.isMDXComponent=!0;const ywn={toc:[]};function Mwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Mwn.isMDXComponent=!0;const Dwn={toc:[]};function wwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wwn.isMDXComponent=!0;const _wn={toc:[]};function Xwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Xwn.isMDXComponent=!0;const gwn={toc:[]};function Twn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Twn.isMDXComponent=!0;const xwn={toc:[]};function Cwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Cwn.isMDXComponent=!0;const vwn={toc:[]};function Lwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Lwn.isMDXComponent=!0;const Zwn={toc:[]};function bwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}bwn.isMDXComponent=!0;const Nwn={toc:[]};function zwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zwn.isMDXComponent=!0;const Awn={toc:[]};function Wwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Wwn.isMDXComponent=!0;const Rwn={toc:[]};function Iwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Iwn.isMDXComponent=!0;const Pwn={toc:[]};function Swn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Swn.isMDXComponent=!0;const Ewn={toc:[]};function Bwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bwn.isMDXComponent=!0;const Gwn={toc:[]};function Own(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Own.isMDXComponent=!0;const Uwn={toc:[]};function Fwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Fwn.isMDXComponent=!0;const qwn={toc:[]};function Vwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Vwn.isMDXComponent=!0;const jwn={toc:[]};function Hwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Hwn.isMDXComponent=!0;const Qwn={toc:[]};function Ywn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Ywn.isMDXComponent=!0;const $wn={toc:[]};function Kwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]};function t_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}t_n.isMDXComponent=!0;const n_n={toc:[]};function e_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}e_n.isMDXComponent=!0;const o_n={toc:[]};function p_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}p_n.isMDXComponent=!0;const r_n={toc:[]};function s_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}s_n.isMDXComponent=!0;const c_n={toc:[]};function i_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}i_n.isMDXComponent=!0;const a_n={toc:[]};function l_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l_n.isMDXComponent=!0;const u_n={toc:[]};function m_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}m_n.isMDXComponent=!0;const d_n={toc:[]};function h_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}h_n.isMDXComponent=!0;const f_n={toc:[]};function k_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}k_n.isMDXComponent=!0;const y_n={toc:[]};function M_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}M_n.isMDXComponent=!0;const D_n={toc:[]};function w_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}w_n.isMDXComponent=!0;const __n={toc:[]};function X_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}X_n.isMDXComponent=!0;const g_n={toc:[]};function T_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}T_n.isMDXComponent=!0;const x_n={toc:[]};function C_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}C_n.isMDXComponent=!0;const v_n={toc:[]};function L_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}L_n.isMDXComponent=!0;const Z_n={toc:[]};function b_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b_n.isMDXComponent=!0;const N_n={toc:[]};function z_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}z_n.isMDXComponent=!0;const A_n={toc:[]};function W_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}W_n.isMDXComponent=!0;const R_n={toc:[]};function I_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}I_n.isMDXComponent=!0;const P_n={toc:[]};function S_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}S_n.isMDXComponent=!0;const E_n={toc:[]};function B_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}B_n.isMDXComponent=!0;const G_n={toc:[]};function O_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}O_n.isMDXComponent=!0;const U_n={toc:[]};function F_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}F_n.isMDXComponent=!0;const q_n={toc:[]};function V_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}V_n.isMDXComponent=!0;const j_n={toc:[]};function H_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}H_n.isMDXComponent=!0;const Q_n={toc:[]};function Y_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y_n.isMDXComponent=!0;const $_n={toc:[]};function K_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}K_n.isMDXComponent=!0;const J_n={toc:[]};function tXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}tXn.isMDXComponent=!0;const nXn={toc:[]};function eXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}eXn.isMDXComponent=!0;const oXn={toc:[]};function pXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pXn.isMDXComponent=!0;const rXn={toc:[]};function sXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}sXn.isMDXComponent=!0;const cXn={toc:[]};function iXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}iXn.isMDXComponent=!0;const aXn={toc:[]};function lXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}lXn.isMDXComponent=!0;const uXn={toc:[]};function mXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}mXn.isMDXComponent=!0;const dXn={toc:[]};function hXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}hXn.isMDXComponent=!0;const fXn={toc:[]};function kXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kXn.isMDXComponent=!0;const yXn={toc:[]};function MXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}MXn.isMDXComponent=!0;const DXn={toc:[]};function wXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wXn.isMDXComponent=!0;const _Xn={toc:[]};function XXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}XXn.isMDXComponent=!0;const gXn={toc:[]};function TXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}TXn.isMDXComponent=!0;const xXn={toc:[]};function CXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}CXn.isMDXComponent=!0;const vXn={toc:[]};function LXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LXn.isMDXComponent=!0;const ZXn={toc:[]};function bXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}bXn.isMDXComponent=!0;const NXn={toc:[]};function zXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}zXn.isMDXComponent=!0;const AXn={toc:[]};function WXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}WXn.isMDXComponent=!0;const RXn={toc:[]};function IXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IXn.isMDXComponent=!0;const PXn={toc:[]};function SXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}SXn.isMDXComponent=!0;const EXn={toc:[]};function BXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BXn.isMDXComponent=!0;const GXn={toc:[]};function OXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}OXn.isMDXComponent=!0;const UXn={toc:[]};function FXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FXn.isMDXComponent=!0;const qXn={toc:[]};function VXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}VXn.isMDXComponent=!0;const jXn={toc:[]};function HXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HXn.isMDXComponent=!0;const QXn={toc:[]};function YXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YXn.isMDXComponent=!0;const $Xn={toc:[]};function KXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KXn.isMDXComponent=!0;const JXn={toc:[]};function tgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}tgn.isMDXComponent=!0;const ngn={toc:[]};function egn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ngn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}egn.isMDXComponent=!0;const ogn={toc:[]};function pgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pgn.isMDXComponent=!0;const rgn={toc:[]};function sgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sgn.isMDXComponent=!0;const cgn={toc:[]};function ign(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}ign.isMDXComponent=!0;const agn={toc:[]};function lgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lgn.isMDXComponent=!0;const ugn={toc:[]};function mgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mgn.isMDXComponent=!0;const dgn={toc:[]};function hgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hgn.isMDXComponent=!0;const fgn={toc:[]};function kgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kgn.isMDXComponent=!0;const ygn={toc:[]};function Mgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ygn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mgn.isMDXComponent=!0;const Dgn={toc:[]};function wgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wgn.isMDXComponent=!0;const _gn={toc:[]};function Xgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_gn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xgn.isMDXComponent=!0;const ggn={toc:[]};function Tgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Tgn.isMDXComponent=!0;const xgn={toc:[]};function Cgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Cgn.isMDXComponent=!0;const vgn={toc:[]};function Lgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Lgn.isMDXComponent=!0;const Zgn={toc:[]};function bgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bgn.isMDXComponent=!0;const Ngn={toc:[]};function zgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zgn.isMDXComponent=!0;const Agn={toc:[]};function Wgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wgn.isMDXComponent=!0;const Rgn={toc:[]};function Ign(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ign.isMDXComponent=!0;const Pgn={toc:[]};function Sgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sgn.isMDXComponent=!0;const Egn={toc:[]};function Bgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Bgn.isMDXComponent=!0;const Ggn={toc:[]};function Ogn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}Ogn.isMDXComponent=!0;const Ugn={toc:[]};function Fgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ugn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}Fgn.isMDXComponent=!0;const qgn={toc:[]};function Vgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Vgn.isMDXComponent=!0;const jgn={toc:[]};function Hgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Hgn.isMDXComponent=!0;const Qgn={toc:[]};function Ygn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Ygn.isMDXComponent=!0;const $gn={toc:[]};function Kgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$gn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}Kgn.isMDXComponent=!0;const Jgn={toc:[]};function tTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tTn.isMDXComponent=!0;const nTn={toc:[]};function eTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}eTn.isMDXComponent=!0;const oTn={toc:[]};function pTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}pTn.isMDXComponent=!0;const rTn={toc:[]};function sTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}sTn.isMDXComponent=!0;const cTn={toc:[]};function iTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iTn.isMDXComponent=!0;const aTn={toc:[]};function lTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lTn.isMDXComponent=!0;const uTn={toc:[]};function mTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}mTn.isMDXComponent=!0;const dTn={toc:[]};function hTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}hTn.isMDXComponent=!0;const fTn={toc:[]};function kTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}kTn.isMDXComponent=!0;const yTn={toc:[]};function MTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}MTn.isMDXComponent=!0;const DTn={toc:[]};function wTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}wTn.isMDXComponent=!0;const _Tn={toc:[]};function XTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XTn.isMDXComponent=!0;const gTn={toc:[]};function TTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}TTn.isMDXComponent=!0;const xTn={toc:[]};function CTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CTn.isMDXComponent=!0;const vTn={toc:[]};function LTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}LTn.isMDXComponent=!0;const ZTn={toc:[]};function bTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bTn.isMDXComponent=!0;const NTn={toc:[]};function zTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zTn.isMDXComponent=!0;const ATn={toc:[]};function WTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}WTn.isMDXComponent=!0;const RTn={toc:[]};function ITn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}ITn.isMDXComponent=!0;const PTn={toc:[]};function STn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}STn.isMDXComponent=!0;const ETn={toc:[]};function BTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}BTn.isMDXComponent=!0;const GTn={toc:[]};function OTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OTn.isMDXComponent=!0;const UTn={toc:[]};function FTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}FTn.isMDXComponent=!0;const qTn={toc:[]};function VTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VTn.isMDXComponent=!0;const jTn={toc:[]};function HTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}HTn.isMDXComponent=!0;const QTn={toc:[]};function YTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}YTn.isMDXComponent=!0;const $Tn={toc:[]};function KTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}KTn.isMDXComponent=!0;const JTn={toc:[]};function txn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}txn.isMDXComponent=!0;const nxn={toc:[]};function exn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}exn.isMDXComponent=!0;const oxn={toc:[]};function pxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}pxn.isMDXComponent=!0;const rxn={toc:[]};function sxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}sxn.isMDXComponent=!0;const cxn={toc:[]};function ixn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ixn.isMDXComponent=!0;const axn={toc:[]};function lxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lxn.isMDXComponent=!0;const uxn={toc:[]};function mxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}mxn.isMDXComponent=!0;const dxn={toc:[]};function hxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}hxn.isMDXComponent=!0;const fxn={toc:[]};function kxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}kxn.isMDXComponent=!0;const yxn={toc:[]};function Mxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Mxn.isMDXComponent=!0;const Dxn={toc:[]};function wxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}wxn.isMDXComponent=!0;const _xn={toc:[]};function Xxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xxn.isMDXComponent=!0;const gxn={toc:[]};function Txn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Txn.isMDXComponent=!0;const xxn={toc:[]};function Cxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cxn.isMDXComponent=!0;const vxn={toc:[]};function Lxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lxn.isMDXComponent=!0;const Zxn={toc:[]};function bxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bxn.isMDXComponent=!0;const Nxn={toc:[]};function zxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zxn.isMDXComponent=!0;const Axn={toc:[]};function Wxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}Wxn.isMDXComponent=!0;const Rxn={toc:[]};function Ixn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}Ixn.isMDXComponent=!0;const Pxn={toc:[]};function Sxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Sxn.isMDXComponent=!0;const Exn={toc:[]};function Bxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Exn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Bxn.isMDXComponent=!0;const Gxn={toc:[]};function Oxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Oxn.isMDXComponent=!0;const Uxn={toc:[]};function Fxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}Fxn.isMDXComponent=!0;const qxn={toc:[]};function Vxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Vxn.isMDXComponent=!0;const jxn={toc:[]};function Hxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Hxn.isMDXComponent=!0;const Qxn={toc:[]};function Yxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yxn.isMDXComponent=!0;const $xn={toc:[]};function Kxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Kxn.isMDXComponent=!0;const Jxn={toc:[]};function tCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tCn.isMDXComponent=!0;const nCn={toc:[]};function eCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}eCn.isMDXComponent=!0;const oCn={toc:[]};function pCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pCn.isMDXComponent=!0;const rCn={toc:[]};function sCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}sCn.isMDXComponent=!0;const cCn={toc:[]};function iCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}iCn.isMDXComponent=!0;const aCn={toc:[]};function lCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}lCn.isMDXComponent=!0;const uCn={toc:[]};function mCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mCn.isMDXComponent=!0;const dCn={toc:[]};function hCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}hCn.isMDXComponent=!0;const fCn={toc:[]};function kCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}kCn.isMDXComponent=!0;const yCn={toc:[]};function MCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}MCn.isMDXComponent=!0;const DCn={toc:[]};function wCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wCn.isMDXComponent=!0;const _Cn={toc:[]};function XCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}XCn.isMDXComponent=!0;const gCn={toc:[]};function TCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}TCn.isMDXComponent=!0;const xCn={toc:[]};function CCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}CCn.isMDXComponent=!0;const vCn={toc:[]};function LCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}LCn.isMDXComponent=!0;const ZCn={toc:[]};function bCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}bCn.isMDXComponent=!0;const NCn={toc:[]};function zCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}zCn.isMDXComponent=!0;const ACn={toc:[]};function WCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WCn.isMDXComponent=!0;const RCn={toc:[]};function ICn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ICn.isMDXComponent=!0;const PCn={toc:[]};function SCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SCn.isMDXComponent=!0;const ECn={toc:[]};function BCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}BCn.isMDXComponent=!0;const GCn={toc:[]};function OCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OCn.isMDXComponent=!0;const UCn={toc:[]};function FCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}FCn.isMDXComponent=!0;const qCn={toc:[]};function VCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VCn.isMDXComponent=!0;const jCn={toc:[]};function HCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}HCn.isMDXComponent=!0;const QCn={toc:[]};function YCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YCn.isMDXComponent=!0;const $Cn={toc:[]};function KCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KCn.isMDXComponent=!0;const JCn={toc:[]};function tvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tvn.isMDXComponent=!0;const nvn={toc:[]};function evn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}evn.isMDXComponent=!0;const ovn={toc:[]};function pvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pvn.isMDXComponent=!0;const rvn={toc:[]};function svn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}svn.isMDXComponent=!0;const cvn={toc:[]};function ivn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ivn.isMDXComponent=!0;const avn={toc:[]};function lvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lvn.isMDXComponent=!0;const uvn={toc:[]};function mvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mvn.isMDXComponent=!0;const dvn={toc:[]};function hvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}hvn.isMDXComponent=!0;const fvn={toc:[]};function kvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kvn.isMDXComponent=!0;const yvn={toc:[]};function Mvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mvn.isMDXComponent=!0;const Dvn={toc:[]};function wvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wvn.isMDXComponent=!0;const _vn={toc:[]};function Xvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_vn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Xvn.isMDXComponent=!0;const gvn={toc:[]};function Tvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Tvn.isMDXComponent=!0;const xvn={toc:[]};function Cvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Cvn.isMDXComponent=!0;const vvn={toc:[]};function Lvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lvn.isMDXComponent=!0;const Zvn={toc:[]};function bvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}bvn.isMDXComponent=!0;const Nvn={toc:[]};function zvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zvn.isMDXComponent=!0;const Avn={toc:[]};function Wvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Wvn.isMDXComponent=!0;const Rvn={toc:[]};function Ivn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ivn.isMDXComponent=!0;const Pvn={toc:[]};function Svn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Svn.isMDXComponent=!0;const Evn={toc:[]};function Bvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Bvn.isMDXComponent=!0;const Gvn={toc:[]};function Ovn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Ovn.isMDXComponent=!0;const Uvn={toc:[]};function Fvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fvn.isMDXComponent=!0;const qvn={toc:[]};function Vvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Vvn.isMDXComponent=!0;const jvn={toc:[]};function Hvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Hvn.isMDXComponent=!0;const Qvn={toc:[]};function Yvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Yvn.isMDXComponent=!0;const $vn={toc:[]};function Kvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$vn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Kvn.isMDXComponent=!0;const Jvn={toc:[]};function tLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}tLn.isMDXComponent=!0;const nLn={toc:[]};function eLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eLn.isMDXComponent=!0;const oLn={toc:[]};function pLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pLn.isMDXComponent=!0;const rLn={toc:[]};function sLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sLn.isMDXComponent=!0;const cLn={toc:[]};function iLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}iLn.isMDXComponent=!0;const aLn={toc:[]};function lLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lLn.isMDXComponent=!0;const uLn={toc:[]};function mLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}mLn.isMDXComponent=!0;const dLn={toc:[]};function hLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}hLn.isMDXComponent=!0;const fLn={toc:[]};function kLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}kLn.isMDXComponent=!0;const yLn={toc:[]};function MLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}MLn.isMDXComponent=!0;const DLn={toc:[]};function wLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}wLn.isMDXComponent=!0;const _Ln={toc:[]};function XLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XLn.isMDXComponent=!0;const gLn={toc:[]};function TLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}TLn.isMDXComponent=!0;const xLn={toc:[]};function CLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CLn.isMDXComponent=!0;const vLn={toc:[]};function LLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}LLn.isMDXComponent=!0;const ZLn={toc:[]};function bLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bLn.isMDXComponent=!0;const NLn={toc:[]};function zLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}zLn.isMDXComponent=!0;const ALn={toc:[]};function WLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WLn.isMDXComponent=!0;const RLn={toc:[]};function ILn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ILn.isMDXComponent=!0;const PLn={toc:[]};function SLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SLn.isMDXComponent=!0;const ELn={toc:[]};function BLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}BLn.isMDXComponent=!0;const GLn={toc:[]};function OLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OLn.isMDXComponent=!0;const ULn={toc:[]};function FLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ULn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}FLn.isMDXComponent=!0;const qLn={toc:[]};function VLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VLn.isMDXComponent=!0;const jLn={toc:[]};function HLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}HLn.isMDXComponent=!0;const QLn={toc:[]};function YLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YLn.isMDXComponent=!0;const $Ln={toc:[]};function KLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}KLn.isMDXComponent=!0;const JLn={toc:[]};function tZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}tZn.isMDXComponent=!0;const nZn={toc:[]};function eZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}eZn.isMDXComponent=!0;const oZn={toc:[]};function pZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pZn.isMDXComponent=!0;const rZn={toc:[]};function sZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}sZn.isMDXComponent=!0;const cZn={toc:[]};function iZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iZn.isMDXComponent=!0;const aZn={toc:[]};function lZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lZn.isMDXComponent=!0;const uZn={toc:[]};function mZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mZn.isMDXComponent=!0;const dZn={toc:[]};function hZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hZn.isMDXComponent=!0;const fZn={toc:[]};function kZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}kZn.isMDXComponent=!0;const yZn={toc:[]};function MZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}MZn.isMDXComponent=!0;const DZn={toc:[]};function wZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wZn.isMDXComponent=!0;const _Zn={toc:[]};function XZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}XZn.isMDXComponent=!0;const gZn={toc:[]};function TZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TZn.isMDXComponent=!0;const xZn={toc:[]};function CZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}CZn.isMDXComponent=!0;const vZn={toc:[]};function LZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LZn.isMDXComponent=!0;const ZZn={toc:[]};function bZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}bZn.isMDXComponent=!0;const NZn={toc:[]};function zZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}zZn.isMDXComponent=!0;const AZn={toc:[]};function WZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}WZn.isMDXComponent=!0;const RZn={toc:[]};function IZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}IZn.isMDXComponent=!0;const PZn={toc:[]};function SZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}SZn.isMDXComponent=!0;const EZn={toc:[]};function BZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}BZn.isMDXComponent=!0;const GZn={toc:[]};function OZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}OZn.isMDXComponent=!0;const UZn={toc:[]};function FZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}FZn.isMDXComponent=!0;const qZn={toc:[]};function VZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}VZn.isMDXComponent=!0;const jZn={toc:[]};function HZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HZn.isMDXComponent=!0;const QZn={toc:[]};function YZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}YZn.isMDXComponent=!0;const $Zn={toc:[]};function KZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KZn.isMDXComponent=!0;const JZn={toc:[]};function tbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tbn.isMDXComponent=!0;const nbn={toc:[]};function ebn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ebn.isMDXComponent=!0;const obn={toc:[]};function pbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pbn.isMDXComponent=!0;const rbn={toc:[]};function sbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sbn.isMDXComponent=!0;const cbn={toc:[]};function ibn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ibn.isMDXComponent=!0;const abn={toc:[]};function lbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lbn.isMDXComponent=!0;const ubn={toc:[]};function mbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}mbn.isMDXComponent=!0;const dbn={toc:[]};function hbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hbn.isMDXComponent=!0;const fbn={toc:[]};function kbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kbn.isMDXComponent=!0;const ybn={toc:[]};function Mbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mbn.isMDXComponent=!0;const Dbn={toc:[]};function wbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wbn.isMDXComponent=!0;const _bn={toc:[]};function Xbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xbn.isMDXComponent=!0;const gbn={toc:[]};function Tbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Tbn.isMDXComponent=!0;const xbn={toc:[]};function Cbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Cbn.isMDXComponent=!0;const vbn={toc:[]};function Lbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Lbn.isMDXComponent=!0;const Zbn={toc:[]};function bbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bbn.isMDXComponent=!0;const Nbn={toc:[]};function zbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zbn.isMDXComponent=!0;const Abn={toc:[]};function Wbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wbn.isMDXComponent=!0;const Rbn={toc:[]};function Ibn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ibn.isMDXComponent=!0;const Pbn={toc:[]};function Sbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sbn.isMDXComponent=!0;const Ebn={toc:[]};function Bbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Bbn.isMDXComponent=!0;const Gbn={toc:[]};function Obn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Obn.isMDXComponent=!0;const Ubn={toc:[]};function Fbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ubn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Fbn.isMDXComponent=!0;const qbn={toc:[]};function Vbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Vbn.isMDXComponent=!0;const jbn={toc:[]};function Hbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Hbn.isMDXComponent=!0;const Qbn={toc:[]};function Ybn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ybn.isMDXComponent=!0;const $bn={toc:[]};function Kbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Kbn.isMDXComponent=!0;const Jbn={toc:[]};function tNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tNn.isMDXComponent=!0;const nNn={toc:[]};function eNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eNn.isMDXComponent=!0;const oNn={toc:[]};function pNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}pNn.isMDXComponent=!0;const rNn={toc:[]};function sNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sNn.isMDXComponent=!0;const cNn={toc:[]};function iNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}iNn.isMDXComponent=!0;const aNn={toc:[]};function lNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lNn.isMDXComponent=!0;const uNn={toc:[]};function mNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mNn.isMDXComponent=!0;const dNn={toc:[]};function hNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}hNn.isMDXComponent=!0;const fNn={toc:[]};function kNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}kNn.isMDXComponent=!0;const yNn={toc:[]};function MNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MNn.isMDXComponent=!0;const DNn={toc:[]};function wNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}wNn.isMDXComponent=!0;const _Nn={toc:[]};function XNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}XNn.isMDXComponent=!0;const gNn={toc:[]};function TNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}TNn.isMDXComponent=!0;const xNn={toc:[]};function CNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}CNn.isMDXComponent=!0;const vNn={toc:[]};function LNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LNn.isMDXComponent=!0;const ZNn={toc:[]};function bNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}bNn.isMDXComponent=!0;const NNn={toc:[]};function zNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zNn.isMDXComponent=!0;const ANn={toc:[]};function WNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}WNn.isMDXComponent=!0;const RNn={toc:[]};function INn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}INn.isMDXComponent=!0;const PNn={toc:[]};function SNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}SNn.isMDXComponent=!0;const ENn={toc:[]};function BNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BNn.isMDXComponent=!0;const GNn={toc:[]};function ONn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ONn.isMDXComponent=!0;const UNn={toc:[]};function FNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FNn.isMDXComponent=!0;const qNn={toc:[]};function VNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}VNn.isMDXComponent=!0;const jNn={toc:[]};function HNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HNn.isMDXComponent=!0;const QNn={toc:[]};function YNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}YNn.isMDXComponent=!0;const $Nn={toc:[]};function KNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}KNn.isMDXComponent=!0;const JNn={toc:[]};function tzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}tzn.isMDXComponent=!0;const nzn={toc:[]};function ezn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ezn.isMDXComponent=!0;const ozn={toc:[]};function pzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pzn.isMDXComponent=!0;const rzn={toc:[]};function szn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}szn.isMDXComponent=!0;const czn={toc:[]};function izn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}izn.isMDXComponent=!0;const azn={toc:[]};function lzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lzn.isMDXComponent=!0;const uzn={toc:[]};function mzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mzn.isMDXComponent=!0;const dzn={toc:[]};function hzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}hzn.isMDXComponent=!0;const fzn={toc:[]};function kzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}kzn.isMDXComponent=!0;const yzn={toc:[]};function Mzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mzn.isMDXComponent=!0;const Dzn={toc:[]};function wzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wzn.isMDXComponent=!0;const _zn={toc:[]};function Xzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Xzn.isMDXComponent=!0;const gzn={toc:[]};function Tzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Tzn.isMDXComponent=!0;const xzn={toc:[]};function Czn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Czn.isMDXComponent=!0;const vzn={toc:[]};function Lzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Lzn.isMDXComponent=!0;const Zzn={toc:[]};function bzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bzn.isMDXComponent=!0;const Nzn={toc:[]};function zzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zzn.isMDXComponent=!0;const Azn={toc:[]};function Wzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wzn.isMDXComponent=!0;const Rzn={toc:[]};function Izn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Izn.isMDXComponent=!0;const Pzn={toc:[]};function Szn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Szn.isMDXComponent=!0;const Ezn={toc:[]};function Bzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ezn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Bzn.isMDXComponent=!0;const Gzn={toc:[]};function Ozn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ozn.isMDXComponent=!0;const Uzn={toc:[]};function Fzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Fzn.isMDXComponent=!0;const qzn={toc:[]};function Vzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vzn.isMDXComponent=!0;const jzn={toc:[]};function Hzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Hzn.isMDXComponent=!0;const Qzn={toc:[]};function Yzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yzn.isMDXComponent=!0;const $zn={toc:[]};function Kzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Kzn.isMDXComponent=!0;const Jzn={toc:[]};function tAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tAn.isMDXComponent=!0;const nAn={toc:[]};function eAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}eAn.isMDXComponent=!0;const oAn={toc:[]};function pAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pAn.isMDXComponent=!0;const rAn={toc:[]};function sAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}sAn.isMDXComponent=!0;const cAn={toc:[]};function iAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}iAn.isMDXComponent=!0;const aAn={toc:[]};function lAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}lAn.isMDXComponent=!0;const uAn={toc:[]};function mAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mAn.isMDXComponent=!0;const dAn={toc:[]};function hAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}hAn.isMDXComponent=!0;const fAn={toc:[]};function kAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kAn.isMDXComponent=!0;const yAn={toc:[]};function MAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}MAn.isMDXComponent=!0;const DAn={toc:[]};function wAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wAn.isMDXComponent=!0;const _An={toc:[]};function XAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_An,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}XAn.isMDXComponent=!0;const gAn={toc:[]};function TAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}TAn.isMDXComponent=!0;const xAn={toc:[]};function CAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}CAn.isMDXComponent=!0;const vAn={toc:[]};function LAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}LAn.isMDXComponent=!0;const ZAn={toc:[]};function bAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}bAn.isMDXComponent=!0;const NAn={toc:[]};function zAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}zAn.isMDXComponent=!0;const AAn={toc:[]};function WAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}WAn.isMDXComponent=!0;const RAn={toc:[]};function IAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}IAn.isMDXComponent=!0;const PAn={toc:[]};function SAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}SAn.isMDXComponent=!0;const EAn={toc:[]};function BAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BAn.isMDXComponent=!0;const GAn={toc:[]};function OAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}OAn.isMDXComponent=!0;const UAn={toc:[]};function FAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}FAn.isMDXComponent=!0;const qAn={toc:[]};function VAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VAn.isMDXComponent=!0;const jAn={toc:[]};function HAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}HAn.isMDXComponent=!0;const QAn={toc:[]};function YAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}YAn.isMDXComponent=!0;const $An={toc:[]};function KAn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$An,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}KAn.isMDXComponent=!0;const JAn={toc:[]};function tWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}tWn.isMDXComponent=!0;const nWn={toc:[]};function eWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}eWn.isMDXComponent=!0;const oWn={toc:[]};function pWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pWn.isMDXComponent=!0;const rWn={toc:[]};function sWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}sWn.isMDXComponent=!0;const cWn={toc:[]};function iWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}iWn.isMDXComponent=!0;const aWn={toc:[]};function lWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}lWn.isMDXComponent=!0;const uWn={toc:[]};function mWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mWn.isMDXComponent=!0;const dWn={toc:[]};function hWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}hWn.isMDXComponent=!0;const fWn={toc:[]};function kWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kWn.isMDXComponent=!0;const yWn={toc:[]};function MWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}MWn.isMDXComponent=!0;const DWn={toc:[]};function wWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wWn.isMDXComponent=!0;const _Wn={toc:[]};function XWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}XWn.isMDXComponent=!0;const gWn={toc:[]};function TWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TWn.isMDXComponent=!0;const xWn={toc:[]};function CWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}CWn.isMDXComponent=!0;const vWn={toc:[]};function LWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LWn.isMDXComponent=!0;const ZWn={toc:[]};function bWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}bWn.isMDXComponent=!0;const NWn={toc:[]};function zWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zWn.isMDXComponent=!0;const AWn={toc:[]};function WWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}WWn.isMDXComponent=!0;const RWn={toc:[]};function IWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IWn.isMDXComponent=!0;const PWn={toc:[]};function SWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}SWn.isMDXComponent=!0;const EWn={toc:[]};function BWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BWn.isMDXComponent=!0;const GWn={toc:[]};function OWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}OWn.isMDXComponent=!0;const UWn={toc:[]};function FWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FWn.isMDXComponent=!0;const qWn={toc:[]};function VWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}VWn.isMDXComponent=!0;const jWn={toc:[]};function HWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HWn.isMDXComponent=!0;const QWn={toc:[]};function YWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}YWn.isMDXComponent=!0;const $Wn={toc:[]};function KWn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KWn.isMDXComponent=!0;const JWn={toc:[]};function tRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tRn.isMDXComponent=!0;const nRn={toc:[]};function eRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}eRn.isMDXComponent=!0;const oRn={toc:[]};function pRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}pRn.isMDXComponent=!0;const rRn={toc:[]};function sRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sRn.isMDXComponent=!0;const cRn={toc:[]};function iRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iRn.isMDXComponent=!0;const aRn={toc:[]};function lRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lRn.isMDXComponent=!0;const uRn={toc:[]};function mRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mRn.isMDXComponent=!0;const dRn={toc:[]};function hRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hRn.isMDXComponent=!0;const fRn={toc:[]};function kRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kRn.isMDXComponent=!0;const yRn={toc:[]};function MRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}MRn.isMDXComponent=!0;const DRn={toc:[]};function wRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wRn.isMDXComponent=!0;const _Rn={toc:[]};function XRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XRn.isMDXComponent=!0;const gRn={toc:[]};function TRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}TRn.isMDXComponent=!0;const xRn={toc:[]};function CRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}CRn.isMDXComponent=!0;const vRn={toc:[]};function LRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}LRn.isMDXComponent=!0;const ZRn={toc:[]};function bRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}bRn.isMDXComponent=!0;const NRn={toc:[]};function zRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zRn.isMDXComponent=!0;const ARn={toc:[]};function WRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}WRn.isMDXComponent=!0;const RRn={toc:[]};function IRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}IRn.isMDXComponent=!0;const PRn={toc:[]};function SRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}SRn.isMDXComponent=!0;const ERn={toc:[]};function BRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}BRn.isMDXComponent=!0;const GRn={toc:[]};function ORn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}ORn.isMDXComponent=!0;const URn={toc:[]};function FRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},URn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}FRn.isMDXComponent=!0;const qRn={toc:[]};function VRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}VRn.isMDXComponent=!0;const jRn={toc:[]};function HRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HRn.isMDXComponent=!0;const QRn={toc:[]};function YRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}YRn.isMDXComponent=!0;const $Rn={toc:[]};function KRn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KRn.isMDXComponent=!0;const JRn={toc:[]};function tIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tIn.isMDXComponent=!0;const nIn={toc:[]};function eIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eIn.isMDXComponent=!0;const oIn={toc:[]};function pIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pIn.isMDXComponent=!0;const rIn={toc:[]};function sIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sIn.isMDXComponent=!0;const cIn={toc:[]};function iIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iIn.isMDXComponent=!0;const aIn={toc:[]};function lIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lIn.isMDXComponent=!0;const uIn={toc:[]};function mIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mIn.isMDXComponent=!0;const dIn={toc:[]};function hIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hIn.isMDXComponent=!0;const fIn={toc:[]};function kIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kIn.isMDXComponent=!0;const yIn={toc:[]};function MIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}MIn.isMDXComponent=!0;const DIn={toc:[]};function wIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wIn.isMDXComponent=!0;const _In={toc:[]};function XIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_In,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XIn.isMDXComponent=!0;const gIn={toc:[]};function TIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}TIn.isMDXComponent=!0;const xIn={toc:[]};function CIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}CIn.isMDXComponent=!0;const vIn={toc:[]};function LIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}LIn.isMDXComponent=!0;const ZIn={toc:[]};function bIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bIn.isMDXComponent=!0;const NIn={toc:[]};function zIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zIn.isMDXComponent=!0;const AIn={toc:[]};function WIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}WIn.isMDXComponent=!0;const RIn={toc:[]};function IIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}IIn.isMDXComponent=!0;const PIn={toc:[]};function SIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SIn.isMDXComponent=!0;const EIn={toc:[]};function BIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}BIn.isMDXComponent=!0;const GIn={toc:[]};function OIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OIn.isMDXComponent=!0;const UIn={toc:[]};function FIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}FIn.isMDXComponent=!0;const qIn={toc:[]};function VIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VIn.isMDXComponent=!0;const jIn={toc:[]};function HIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}HIn.isMDXComponent=!0;const QIn={toc:[]};function YIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}YIn.isMDXComponent=!0;const $In={toc:[]};function KIn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$In,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}KIn.isMDXComponent=!0;const JIn={toc:[]};function tPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}tPn.isMDXComponent=!0;const nPn={toc:[]};function ePn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}ePn.isMDXComponent=!0;const oPn={toc:[]};function pPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}pPn.isMDXComponent=!0;const rPn={toc:[]};function sPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}sPn.isMDXComponent=!0;const cPn={toc:[]};function iPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}iPn.isMDXComponent=!0;const aPn={toc:[]};function lPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}lPn.isMDXComponent=!0;const uPn={toc:[]};function mPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}mPn.isMDXComponent=!0;const dPn={toc:[]};function hPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}hPn.isMDXComponent=!0;const fPn={toc:[]};function kPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}kPn.isMDXComponent=!0;const yPn={toc:[]};function MPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}MPn.isMDXComponent=!0;const DPn={toc:[]};function wPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}wPn.isMDXComponent=!0;const _Pn={toc:[]};function XPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}XPn.isMDXComponent=!0;const gPn={toc:[]};function TPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}TPn.isMDXComponent=!0;const xPn={toc:[]};function CPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}CPn.isMDXComponent=!0;const vPn={toc:[]};function LPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}LPn.isMDXComponent=!0;const ZPn={toc:[]};function bPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}bPn.isMDXComponent=!0;const NPn={toc:[]};function zPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}zPn.isMDXComponent=!0;const APn={toc:[]};function WPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}WPn.isMDXComponent=!0;const RPn={toc:[]};function IPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}IPn.isMDXComponent=!0;const PPn={toc:[]};function SPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}SPn.isMDXComponent=!0;const EPn={toc:[]};function BPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}BPn.isMDXComponent=!0;const GPn={toc:[]};function OPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}OPn.isMDXComponent=!0;const UPn={toc:[]};function FPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}FPn.isMDXComponent=!0;const qPn={toc:[]};function VPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}VPn.isMDXComponent=!0;const jPn={toc:[]};function HPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}HPn.isMDXComponent=!0;const QPn={toc:[]};function YPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}YPn.isMDXComponent=!0;const $Pn={toc:[]};function KPn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}KPn.isMDXComponent=!0;const JPn={toc:[]};function tSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}tSn.isMDXComponent=!0;const nSn={toc:[]};function eSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}eSn.isMDXComponent=!0;const oSn={toc:[]};function pSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}pSn.isMDXComponent=!0;const rSn={toc:[]};function sSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}sSn.isMDXComponent=!0;const cSn={toc:[]};function iSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}iSn.isMDXComponent=!0;const aSn={toc:[]};function lSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}lSn.isMDXComponent=!0;const uSn={toc:[]};function mSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}mSn.isMDXComponent=!0;const dSn={toc:[]};function hSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}hSn.isMDXComponent=!0;const fSn={toc:[]};function kSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}kSn.isMDXComponent=!0;const ySn={toc:[]};function MSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}MSn.isMDXComponent=!0;const DSn={toc:[]};function wSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}wSn.isMDXComponent=!0;const _Sn={toc:[]};function XSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Sn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}XSn.isMDXComponent=!0;const gSn={toc:[]};function TSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}TSn.isMDXComponent=!0;const xSn={toc:[]};function CSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}CSn.isMDXComponent=!0;const vSn={toc:[]};function LSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}LSn.isMDXComponent=!0;const ZSn={toc:[]};function bSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}bSn.isMDXComponent=!0;const NSn={toc:[]};function zSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}zSn.isMDXComponent=!0;const ASn={toc:[]};function WSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}WSn.isMDXComponent=!0;const RSn={toc:[]};function ISn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}ISn.isMDXComponent=!0;const PSn={toc:[]};function SSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}SSn.isMDXComponent=!0;const ESn={toc:[]};function BSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}BSn.isMDXComponent=!0;const GSn={toc:[]};function OSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}OSn.isMDXComponent=!0;const USn={toc:[]};function FSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},USn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}FSn.isMDXComponent=!0;const qSn={toc:[]};function VSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSn,e,{components:n,mdxType:"MDXLayout"}))}VSn.isMDXComponent=!0;const jSn={toc:[]};function HSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}HSn.isMDXComponent=!0;const QSn={toc:[]};function YSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}YSn.isMDXComponent=!0;const $Sn={toc:[]};function KSn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Sn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}KSn.isMDXComponent=!0;const JSn={toc:[]};function tEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}tEn.isMDXComponent=!0;const nEn={toc:[]};function eEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}eEn.isMDXComponent=!0;const oEn={toc:[]};function pEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}pEn.isMDXComponent=!0;const rEn={toc:[]};function sEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}sEn.isMDXComponent=!0;const cEn={toc:[]};function iEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}iEn.isMDXComponent=!0;const aEn={toc:[]};function lEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}lEn.isMDXComponent=!0;const uEn={toc:[]};function mEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}mEn.isMDXComponent=!0;const dEn={toc:[]};function hEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}hEn.isMDXComponent=!0;const fEn={toc:[]};function kEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}kEn.isMDXComponent=!0;const yEn={toc:[]};function MEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}MEn.isMDXComponent=!0;const DEn={toc:[]};function wEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}wEn.isMDXComponent=!0;const _En={toc:[]};function XEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_En,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}XEn.isMDXComponent=!0;const gEn={toc:[]};function TEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}TEn.isMDXComponent=!0;const xEn={toc:[]};function CEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}CEn.isMDXComponent=!0;const vEn={toc:[]};function LEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}LEn.isMDXComponent=!0;const ZEn={toc:[]};function bEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}bEn.isMDXComponent=!0;const NEn={toc:[]};function zEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}zEn.isMDXComponent=!0;const AEn={toc:[]};function WEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}WEn.isMDXComponent=!0;const REn={toc:[]};function IEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}IEn.isMDXComponent=!0;const PEn={toc:[]};function SEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}SEn.isMDXComponent=!0;const EEn={toc:[]};function BEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}BEn.isMDXComponent=!0;const GEn={toc:[]};function OEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}OEn.isMDXComponent=!0;const UEn={toc:[]};function FEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}FEn.isMDXComponent=!0;const qEn={toc:[]};function VEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}VEn.isMDXComponent=!0;const jEn={toc:[]};function HEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}HEn.isMDXComponent=!0;const QEn={toc:[]};function YEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}YEn.isMDXComponent=!0;const $En={toc:[]};function KEn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$En,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}KEn.isMDXComponent=!0;const JEn={toc:[]};function tBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}tBn.isMDXComponent=!0;const nBn={toc:[]};function eBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}eBn.isMDXComponent=!0;const oBn={toc:[]};function pBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}pBn.isMDXComponent=!0;const rBn={toc:[]};function sBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}sBn.isMDXComponent=!0;const cBn={toc:[]};function iBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}iBn.isMDXComponent=!0;const aBn={toc:[]};function lBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}lBn.isMDXComponent=!0;const uBn={toc:[]};function mBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}mBn.isMDXComponent=!0;const dBn={toc:[]};function hBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}hBn.isMDXComponent=!0;const fBn={toc:[]};function kBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}kBn.isMDXComponent=!0;const yBn={toc:[]};function MBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}MBn.isMDXComponent=!0;const DBn={toc:[]};function wBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}wBn.isMDXComponent=!0;const _Bn={toc:[]};function XBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}XBn.isMDXComponent=!0;const gBn={toc:[]};function TBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}TBn.isMDXComponent=!0;const xBn={toc:[]};function CBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}CBn.isMDXComponent=!0;const vBn={toc:[]};function LBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}LBn.isMDXComponent=!0;const ZBn={toc:[]};function bBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}bBn.isMDXComponent=!0;const NBn={toc:[]};function zBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}zBn.isMDXComponent=!0;const ABn={toc:[]};function WBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}WBn.isMDXComponent=!0;const RBn={toc:[]};function IBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}IBn.isMDXComponent=!0;const PBn={toc:[]};function SBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}SBn.isMDXComponent=!0;const EBn={toc:[]};function BBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}BBn.isMDXComponent=!0;const GBn={toc:[]};function OBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}OBn.isMDXComponent=!0;const UBn={toc:[]};function FBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}FBn.isMDXComponent=!0;const qBn={toc:[]};function VBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}VBn.isMDXComponent=!0;const jBn={toc:[]};function HBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}HBn.isMDXComponent=!0;const QBn={toc:[]};function YBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}YBn.isMDXComponent=!0;const $Bn={toc:[]};function KBn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}KBn.isMDXComponent=!0;const JBn={toc:[]};function tGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}tGn.isMDXComponent=!0;const nGn={toc:[]};function eGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}eGn.isMDXComponent=!0;const oGn={toc:[]};function pGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}pGn.isMDXComponent=!0;const rGn={toc:[]};function sGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}sGn.isMDXComponent=!0;const cGn={toc:[]};function iGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}iGn.isMDXComponent=!0;const aGn={toc:[]};function lGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}lGn.isMDXComponent=!0;const uGn={toc:[]};function mGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}mGn.isMDXComponent=!0;const dGn={toc:[]};function hGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}hGn.isMDXComponent=!0;const fGn={toc:[]};function kGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}kGn.isMDXComponent=!0;const yGn={toc:[]};function MGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}MGn.isMDXComponent=!0;const DGn={toc:[]};function wGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}wGn.isMDXComponent=!0;const _Gn={toc:[]};function XGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Gn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}XGn.isMDXComponent=!0;const gGn={toc:[]};function TGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}TGn.isMDXComponent=!0;const xGn={toc:[]};function CGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}CGn.isMDXComponent=!0;const vGn={toc:[]};function LGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}LGn.isMDXComponent=!0;const ZGn={toc:[]};function bGn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}function NGn(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}bGn.isMDXComponent=!0},9322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(3328),r=e(8698);const s="toggle_S_IX",c="collapsed_wdUB",i="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@preview"===n}))}),[n]),h=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),f=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@defaultValue"===n}))}),[n]),k=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),y=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(s,e&&c),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:i},h.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),f&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,f.content.map((t=>t.text)).join(""))),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:k.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:y.contentId})))}},1930:(t,n,e)=>{e.d(n,{Z:()=>Ot});var o=e(2784),p=e(7390),r=e(6835),s=e(68),c=e(6277),i=e(8569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,s.s2)();return o.createElement("div",{className:(0,c.Z)(i.Z.codeBlockContent,a.codeBlock,e&&a.highlight,p&&a.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(i.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:i.Z.codeBlockLines,style:d},n)),l&&o.createElement("div",{className:i.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(9318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(a.codeBlockContainer,"language-typescript")},n)}var f=e(9817);function k(t){let{children:n,type:e,to:p,id:r,tooltip:c}=t;const i=(0,s.Ld)(e);return p?o.createElement(f.Z,(0,l.Z)({id:r,to:p,"data-tooltip":c},i),n):o.createElement("span",(0,l.Z)({id:r},i),n)}let y,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(y||(y={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[y.None]:a.none,[y.Angle]:a.angle,[y.Curly]:a.curly,[y.Square]:a.square,[y.Parentheses]:a.parentheses};function w(t){let{children:n,type:e,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,c.Z)(a.list,D[e??y.None])},o.createElement("span",{className:(0,c.Z)(a.elements,p!==M.Comma&&a.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:a.element},t)))))}var _=e(8617);function X(t){var n;let{type:e}=t;const p=(0,_.RU)(e.project),r=null==p?void 0:p[e.id],s=e.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(k,{to:s,type:s?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(w,{type:y.Angle},e.typeArguments.map(((t,n)=>o.createElement(E,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(k,{type:"keyword"},n.name)}function T(t){let{type:n}=t;return n.elements?o.createElement(w,{type:y.Square},n.elements.map(((t,n)=>o.createElement(E,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function x(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.elementType}),"[]")}function C(t){let{type:n}=t;return o.createElement(w,{type:y.Parentheses,separator:M.Pipe},n.types.map(((t,n)=>o.createElement(E,{key:n,type:t}))))}function v(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(k,{type:p},e)}function L(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"asserts "),o.createElement(k,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(k,null,n.name," "),o.createElement(k,{type:"keyword"},"is "),o.createElement(E,{type:n.targetType}))}function Z(t){let{type:n}=t;const e=(0,_.in)();return o.createElement(Y,{reflection:e(n.declaration)})}function b(t){let{type:n}=t;return o.createElement(w,{type:y.Parentheses,separator:M.Ampersand},n.types.map(((t,n)=>o.createElement(E,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(E,{key:n,type:e}),"}",o.createElement(k,{type:"string"},p))})),o.createElement(k,{type:"string"},"`"))}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"typeof "),o.createElement(E,{type:n.queryType}))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.checkType}),o.createElement(k,{type:"keyword"}," extends "),o.createElement(E,{type:n.extendsType})," ? ",o.createElement(E,{type:n.trueType})," : ",o.createElement(E,{type:n.falseType}))}function W(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"infer "),o.createElement(k,{type:"constant"},n.name))}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.objectType}),"[",o.createElement(E,{type:n.indexType}),"]")}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},n.operator," "),o.createElement(E,{type:n.target}))}function P(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(w,{type:y.Curly},o.createElement(o.Fragment,null,"[",o.createElement(k,{type:"class"},n.parameter),o.createElement(k,{type:"keyword"}," in "),o.createElement(E,{type:n.parameterType}),"]: ",o.createElement(E,{type:n.templateType}))))}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(E,{type:n.element}))}function E(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return I;case"conditional":return A;case"reflection":return Z;case"query":return z;case"named-tuple-member":return S;case"union":return C;case"intrinsic":return g;case"literal":return v;case"reference":return X;case"predicate":return L;case"tuple":return T;case"array":return x;case"intersection":return b;case"inferred":return W;case"mapped":return P;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function B(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(k,{key:t,type:"keyword"},t," "))))}function G(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(k,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(E,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(k,{type:"plain"},n.defaultValue)))}function O(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),n.varianceModifier&&o.createElement(k,{type:"keyword"},n.varianceModifier," "),o.createElement(k,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(E,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(E,{type:n.default})))}function U(t){var n,e;let{reflection:r,flags:s}=t;const c=(0,_.in)(),i="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:s??r.flags,explicitAccessModifier:!i}),r.kind===p.W.GetSignature&&o.createElement(k,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(k,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(k,{to:r.overwrites.externalUrl??(0,_.Gr)(c(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(k,{to:"#",type:"keyword"},"new")," ",o.createElement(k,{type:"plain"},r.type.name)):i?"":o.createElement(k,{type:"function"},r.name),!(null==(n=r.typeParameter)||!n.length)&&o.createElement(w,{type:y.Angle},r.typeParameter.map((t=>o.createElement(O,{key:t.id,reflection:c(t)})))),null!=(e=r.parameters)&&e.length?o.createElement(w,{type:y.Parentheses},r.parameters.map((t=>o.createElement(G,{key:t,reflection:c(t)})))):"()",r.type&&o.createElement(o.Fragment,null,i?" => ":": ",o.createElement(E,{type:r.type})))}function F(t){let{reflection:n}=t;return o.createElement(G,{reflection:n})}const q={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function V(t){var n,e,p;let{reflection:r}=t;const s=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:r.flags}),o.createElement(k,{type:"keyword"},q[r.kind]," "),o.createElement(k,{type:"class-name"},r.name),!(null==(n=r.typeParameters)||!n.length)&&o.createElement(w,{type:y.Angle},r.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:s(t)}))))," ",!(null==(e=r.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"extends "),o.createElement(w,null,r.extendedTypes.map(((t,n)=>o.createElement(E,{key:n,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"implements "),o.createElement(w,null,r.implementedTypes.map(((t,n)=>o.createElement(E,{key:n,type:t}))))))}function j(t){let{reflection:n}=t;const e=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),o.createElement(k,{type:"keyword"},"type "),o.createElement(k,{type:"class-name"},n.name),n.typeParameters&&o.createElement(w,{type:y.Angle},n.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:e(t)}))))," = ",o.createElement(E,{type:n.type}))}function H(t){let{reflection:n}=t;const e=(0,_.in)();return n.signatures?o.createElement(U,{reflection:n.signatures[0]}):n.children?o.createElement(w,{type:y.Curly},n.children.map((t=>o.createElement(Y,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"unknown"))}function Q(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(U,{reflection:p})}function Y(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return V;case p.W.Constructor:return U;case p.W.Property:return F;case p.W.Method:return Q;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return H;case p.W.TypeParameter:return O;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return j;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function $(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${a.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,c.Z)(a.line,"token-line")},n),o.createElement("br",null))}var K=e(9322),J=e(3328);function tt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(O,{reflection:t})),o.createElement(J.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(J.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const r=(0,_.in)(),s=(0,o.useMemo)((()=>n.map(r)),[n]),[c,i]=(0,o.useState)(s[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,s.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===c.id,onClick:n.length>1?()=>i(t):void 0},o.createElement($,null,o.createElement(U,{reflection:t,flags:e})))))),o.createElement(K.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(nt,{parameters:c.parameters}))}var ot=e(7708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",st="filters_z1iC",ct="icon_ROIU";function it(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",rt)},o.createElement("div",{className:(0,c.Z)("col",st)},o.createElement(it,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var lt=e(3181),ut=e(3851),mt=e(4126),dt=e(2424),ht=e(2244),ft=e(4155);function kt(t){return function(t){var n;return(null==(n=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:n}=t;return!!n&&"object"==typeof n&&"value"in n}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:n.filter(Boolean))??[]}(t).map((t=>{let{props:{value:n,label:e,attributes:o,default:p}}=t;return{value:n,label:e,attributes:o,default:p}}))}function yt(t){const{values:n,children:e}=t;return(0,o.useMemo)((()=>{const t=n??kt(e);return function(t){const n=(0,ht.l)(t,((t,n)=>t.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[n,e])}function Mt(t){let{value:n,tabValues:e}=t;return e.some((t=>t.value===n))}function Dt(t){let{queryString:n=!1,groupId:e}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:n=!1,groupId:e}=t;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const n=new URLSearchParams(p.location.search);n.set(r,t),p.replace({...p.location,search:n.toString()})}),[r,p])]}function wt(t){const{defaultValue:n,queryString:e=!1,groupId:p}=t,r=yt(t),[s,c]=(0,o.useState)((()=>function(t){let{defaultValue:n,tabValues:e}=t;if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!Mt({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=e.find((t=>t.default))??e[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:r}))),[i,a]=Dt({queryString:e,groupId:p}),[l,u]=function(t){let{groupId:n}=t;const e=function(t){return t?`docusaurus.tab.${t}`:null}(n),[p,r]=(0,ft.Nk)(e);return[p,(0,o.useCallback)((t=>{e&&r.set(t)}),[e,r])]}({groupId:p}),m=(()=>{const t=i??l;return Mt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((t=>{if(!Mt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var _t=e(9741);const Xt="tabList_M0Dn",gt="tabItem_ysIP";function Tt(t){let{className:n,block:e,selectedValue:p,selectValue:r,tabValues:s}=t;const i=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const n=t.currentTarget,e=i.indexOf(n),o=s[e].value;o!==p&&(a(n),r(o))},m=t=>{var n;let e=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const n=i.indexOf(t.currentTarget)+1;e=i[n]??i[0];break}case"ArrowLeft":{const n=i.indexOf(t.currentTarget)-1;e=i[n]??i[i.length-1];break}}null==(n=e)||n.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":e},n)},s.map((t=>{let{value:n,label:e,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===n?0:-1,"aria-selected":p===n,key:n,ref:t=>i.push(t),onKeyDown:m,onClick:u},r,{className:(0,c.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===n})}),e??n)})))}function xt(t){let{lazy:n,children:e,selectedValue:p}=t;const r=(Array.isArray(e)?e:[e]).filter(Boolean);if(n){const t=r.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,n)=>(0,o.cloneElement)(t,{key:n,hidden:t.props.value!==p}))))}function Ct(t){const n=wt(t);return o.createElement("div",{className:(0,c.Z)("tabs-container",Xt)},o.createElement(Tt,(0,l.Z)({},t,n)),o.createElement(xt,(0,l.Z)({},t,n)))}function vt(t){const n=(0,_t.Z)();return o.createElement(Ct,(0,l.Z)({key:String(n)},t))}const Lt="tabItem_OMyP";function Zt(t){let{children:n,hidden:e,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,c.Z)(Lt,p),hidden:e},n)}function bt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(Ot,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(Ot,{reflection:t})))))}function Nt(t){let{group:n,project:e}=t;const p=(0,lt.TH)(),r=(0,_.RU)(e),s=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],r=[];for(const s of t.children){const t=n[s];t&&(0,ot.It)(e,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,c))).filter((t=>!!t))),[n,r,c]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const n of i)if(n.anchors.includes(t))return}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:n.title},n.title),i.length>1?o.createElement(vt,{groupId:n.title},i.map((t=>o.createElement(Zt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(bt,{group:t}))))):o.createElement(bt,{group:i[0]}))}function zt(t){var n,e,p,r,s;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=c.sources)||null==(e=n[0])?void 0:e.url},o.createElement($,null,o.createElement(Y,{reflection:c})))),o.createElement(at,{kind:c.kind},o.createElement(K.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=c.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:c.signatures})),null==(s=c.groups)?void 0:s.map((t=>o.createElement(Nt,{group:t,key:t.title,project:c.project}))))}function At(t){var n;let{reflection:e,headless:p}=t;const r=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(ut.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:r,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:e.overwrites}))))}function Wt(t){var n,e;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement($,null,o.createElement(F,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function Rt(t){var n,e,p;let{reflection:r}=t;const s=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=r.sources)||null==(e=n[0])?void 0:e.url},o.createElement($,null,o.createElement(Y,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>s[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ot,{key:t.id,reflection:t})))))))}var It=e(8128);function Pt(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(It.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(at,{kind:e.kind},o.createElement(K.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(Nt,{group:t,key:t.title,project:e.project}))))}const St="cardContainer_ybwo",Et="cardTitle_Ehd1",Bt="cardDescription_b6wr";function Gt(t){let{reflection:n}=t;const e=(0,_.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(f.Z,{href:t.href,className:(0,c.Z)("card padding--lg",St)},o.createElement("h2",{className:(0,c.Z)("text--truncate",Et)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",Bt)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function Ot(t){let{reflection:n,headless:e=!1}=t;const r=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return Gt;case p.W.Module:return Pt;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return zt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Wt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Rt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(r,{reflection:n,headless:e})}},7390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,n,e)=>{e.d(n,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:n,lookup:e,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:r}},n)}function s(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function i(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function a(t){if(t)return t.href}},68:(t,n,e)=>{e.d(n,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=e(2784),p=e(822);const r=o.createContext(null);function s(t){let{children:n}=t;const e=(0,p.p)(),s=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(r.Provider,{value:s},n)}function c(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return{className:`token ${t}`,style:n[t]??n.plain}}function i(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return n[t]??n.plain}},7708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(2784),p=e(1263),r=e(9741);const s="api-filters",c=p.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=o.createContext([i,()=>{}]);function l(t){let{children:n}=t;const[e,p]=(0,o.useState)(i),c=(0,r.Z)();return o.createElement(a.Provider,{value:[e,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(a)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!n.inheritedFrom;return!(!t.inherited&&r)}},5192:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>u});var o=e(7896),p=(e(2784),e(876)),r=e(2072),s=e(2665);const c={sidebar_position:10,slug:"/transitions"},i="Transitions",a={unversionedId:"getting-started/transitions",id:"getting-started/transitions",title:"Transitions",description:"Transitions allow you to customize the way scenes transition from one into",source:"@site/docs/getting-started/transitions.mdx",sourceDirName:"getting-started",slug:"/transitions",permalink:"/docs/transitions",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/transitions.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:10,frontMatter:{sidebar_position:10,slug:"/transitions"},sidebar:"docs",previous:{title:"Time Events",permalink:"/docs/time-events"},next:{title:"Logging",permalink:"/docs/logging"}},l={},u=[{value:"Before we start",id:"before-we-start",level:2},{value:"Pre-made transitions",id:"pre-made-transitions",level:2},{value:"<code>slideTransition</code>",id:"slidetransition",level:3},{value:"<code>zoomInTransition</code>",id:"zoomintransition",level:3},{value:"<code>zoomOutTransition</code>",id:"zoomouttransition",level:3},{value:"<code>fadeTransition</code>",id:"fadetransition",level:3},{value:"Custom transitions",id:"custom-transitions",level:2},{value:"Animate when transitioning",id:"animate-when-transitioning",level:2}],m={toc:u};function d(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"transitions"},"Transitions"),(0,p.kt)("p",null,"Transitions allow you to customize the way scenes transition from one into\nanother. A transition is an animation performed at the beginning of the scene.\nIt can modify the context of both the current and the previous scene."),(0,p.kt)("h2",{id:"before-we-start"},"Before we start"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col"},(0,p.kt)("p",null,"Make sure your project contains at least two scenes. In this example, we've\nprepared ",(0,p.kt)("inlineCode",{parentName:"p"},"firstScene.tsx")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"secondScene.tsx"),", and configured our project to\ndisplay one after the other. We'll be setting up our transitions in the second\nscene."),(0,p.kt)("p",null,"Make sure to put something different in both scenes to easier see the\ntransitions.")),(0,p.kt)("div",{className:"col"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre"},"my-animation/\n\u2514\u2500 src/\n   \u251c\u2500 scenes/\n   \u2502  \u251c\u2500 firstScene.tsx\n   \u2502  \u2514\u2500 secondScene.tsx\n   \u2514\u2500 project.ts\n")))),(0,p.kt)("h2",{id:"pre-made-transitions"},"Pre-made transitions"),(0,p.kt)("p",null,"Motion Canvas comes with a set of common transitions in a form of easy-to-use\ngenerators. To use them, ",(0,p.kt)("inlineCode",{parentName:"p"},"yield*")," the transition generator at the beginning of\nthe new scene:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/scenes/secondScene.tsx"',title:'"src/scenes/secondScene.tsx"'},"export default makeScene2D(function* (view) {\n  // set up the scene:\n  view.add(/* your nodes here */);\n\n  // perform a slide transition to the left:\n  yield* slideTransition(Direction.Left);\n\n  // proceed with the animation\n  yield* waitFor(3);\n});\n")),(0,p.kt)(s.Z,{small:!0,name:"transitions",link:"transitions-second",mdxType:"AnimationPlayer"}),(0,p.kt)("admonition",{type:"caution"},(0,p.kt)("p",{parentName:"admonition"},"Make sure to add nodes to the view before yielding the transition generator.\nOtherwise, your scene will remain empty until the transition ends.")),(0,p.kt)("p",null,"All available transitions are listed below:"),(0,p.kt)("h3",{id:"slidetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"slideTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#slideTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomintransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomInTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomInTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomouttransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomOutTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomOutTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"fadetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"fadeTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#fadeTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"custom-transitions"},"Custom transitions"),(0,p.kt)("p",null,"You can use the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/transitions#useTransition"},(0,p.kt)("inlineCode",{parentName:"a"},"useTransition"))," function\nto implement custom transitions. It allows you to specify two callbacks that\nwill modify the contexts of the current and previous scene respectively. The\nvalue it returns is a callback that you need to call once you finish the\ntransition."),(0,p.kt)("p",null,"The transition template looks as follows:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// set up the transition\nconst endTransition = useTransition(\n  currentContext => {\n    // modify the context of the current scene\n  },\n  previousContext => {\n    // modify the context of the previous scene\n  },\n);\n\n// perform animations\n\n// finish the transition\nendTransition();\n")),(0,p.kt)("p",null,"Here's how you could implement a simple slide transition:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export function* slideTransition(\n  direction: Direction = Direction.Top,\n  duration = 0.6,\n): ThreadGenerator {\n  const size = useScene().getSize();\n  const position = size.getOriginOffset(direction).scale(2);\n  const previousPosition = Vector2.createSignal();\n  const currentPosition = Vector2.createSignal(position);\n\n  // set up the transition\n  const endTransition = useTransition(\n    // modify the context of the current scene\n    ctx => ctx.translate(currentPosition.x(), currentPosition.y()),\n    // modify the context of the previous scene\n    ctx => ctx.translate(previousPosition.x(), previousPosition.y()),\n  );\n\n  // perform animations\n  yield* all(\n    previousPosition(position.scale(-1), duration),\n    currentPosition(Vector2.zero, duration),\n  );\n\n  // finish the transition\n  endTransition();\n}\n")),(0,p.kt)("h2",{id:"animate-when-transitioning"},"Animate when transitioning"),(0,p.kt)("p",null,"By default, Motion Canvas will transition to the next scene once the generator\nof the current scene has reached the end. In this case, the scene will freeze\nfor the duration of the transition. You can use the\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#finishScene"},(0,p.kt)("inlineCode",{parentName:"a"},"finishScene"))," function to trigger the transition\nearly, allowing the animation to continue while transitioning:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  yield* animationOne();\n  // trigger the transition early:\n  finishScene();\n  // continue animating:\n  yield* animationTwo();\n});\n")))}d.isMDXComponent=!0}}]);