import{I as m,g as c,J as C,K as j,S as N,O as E,i as d,s as f,q as S,u as V,P as R,L as F,Q as J,T as K,U as Q,W as U}from"./makeScene2D-a3617e63.js";class k{}class $ extends k{constructor(t,e,s,n,i){super(),this.center=t,this.radius=e,this.from=s,this.to=n,this.counter=i,this.angle=Math.acos(m(-1,1,s.dot(n))),this.length=Math.abs(this.angle*e)}get arcLength(){return this.length}draw(t,e,s){const n=this.counter?-1:1,i=this.from.radians+e*this.angle*n,a=this.to.radians-(1-s)*this.angle*n;Math.abs(this.angle)>1e-4&&t.arc(this.center.x,this.center.y,this.radius,i,a,this.counter);const o=c.fromRadians(i),l=c.fromRadians(a);return[{position:this.center.add(o.scale(this.radius)),tangent:this.counter?o:o.flipped,normal:this.counter?o:o.flipped},{position:this.center.add(l.scale(this.radius)),tangent:this.counter?l.flipped:l,normal:this.counter?l.flipped:l}]}getPoint(t){const e=this.counter?-1:1,s=this.from.radians+t*this.angle*e,n=c.fromRadians(s);return{position:this.center.add(n.scale(this.radius)),tangent:this.counter?n:n.flipped,normal:this.counter?n:n.flipped}}}function W(r,t){const e=m(0,r.arcLength,t);let s=0;for(const n of r.segments){const i=s;if(s+=n.arcLength,s>=e){const a=(e-i)/n.arcLength;return n.getPoint(m(0,1,a))}}return{position:c.zero,tangent:c.up,normal:c.up}}class q extends k{constructor(t,e){super(),this.from=t,this.to=e,this.vector=e.sub(t),this.length=this.vector.magnitude,this.normal=this.vector.perpendicular.normalized.safe}get arcLength(){return this.length}draw(t,e=0,s=1,n=!1){const i=this.from.add(this.vector.scale(e)),a=this.from.add(this.vector.scale(s));return n&&C(t,i),j(t,a),[{position:i,tangent:this.normal.flipped,normal:this.normal},{position:a,tangent:this.normal,normal:this.normal}]}getPoint(t){return{position:this.from.add(this.vector.scale(t)),tangent:this.normal.flipped,normal:this.normal}}}function G(r,t,e){const s={arcLength:0,segments:[],minSin:1};if(r.length===0)return s;if(e){const a=r[0].add(r[r.length-1]).scale(.5);r.unshift(a),r.push(a)}let n=r[0];for(let a=2;a<r.length;a++){const o=r[a-2],l=r[a-1],O=r[a],L=o.sub(l),P=O.sub(l),p=L.normalized.safe,g=P.normalized.safe,D=Math.acos(m(-1,1,p.dot(g))),w=Math.tan(D/2),b=Math.sin(D/2),v=Math.min(t,w*L.magnitude*(a===2?1:.5),w*P.magnitude*(a===r.length-1?1:.5)),B=b===0?0:v/b,y=w===0?0:v/w,I=p.add(g).scale(1/2).normalized.safe.scale(B).add(l),z=p.perpendicular.dot(g)<0,M=new q(n,l.add(p.scale(y))),_=new $(I,v,p.perpendicular.scale(z?1:-1),g.perpendicular.scale(z?-1:1),z);s.segments.push(M),s.segments.push(_),s.arcLength+=M.arcLength,s.arcLength+=_.arcLength,s.minSin=Math.min(s.minSin,Math.abs(b)),n=l.add(g.scale(y))}const i=new q(n,r[r.length-1]);return s.segments.push(i),s.arcLength+=i.arcLength,s}var u=globalThis&&globalThis.__decorate||function(r,t,e,s){var n=arguments.length,i=n<3?t:s===null?s=Object.getOwnPropertyDescriptor(t,e):s,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,t,e,s);else for(var o=r.length-1;o>=0;o--)(a=r[o])&&(i=(n<3?a(i):n>3?a(t,e,i):a(t,e))||i);return n>3&&i&&Object.defineProperty(t,e,i),i};class h extends N{desiredSize(){return this.childrenBBox().size}constructor(t){super(t)}percentageToDistance(t){return m(0,this.baseArcLength(),this.startOffset()+this.offsetArcLength()*t)}distanceToPercentage(t){return(t-this.startOffset())/this.offsetArcLength()}baseArcLength(){return this.profile().arcLength}offsetArcLength(){const t=this.startOffset(),e=this.endOffset(),s=this.baseArcLength();return m(0,s,s-t-e)}arcLength(){return this.offsetArcLength()*Math.abs(this.start()-this.end())}completion(){return Math.abs(this.start()-this.end())}curveDrawingInfo(){const t=new Path2D,e=this.profile();let s=this.percentageToDistance(this.start()),n=this.percentageToDistance(this.end());s>n&&([s,n]=[n,s]);const i=n-s,a=Math.min(i/2,this.arrowSize());this.startArrow()&&(s+=a/2),this.endArrow()&&(n-=a/2);let o=0,l=null,O=null,L=null,P=null;for(const p of e.segments){const g=o;if(o+=p.arcLength,o<s)continue;const D=(s-g)/p.arcLength,w=(n-g)/p.arcLength,b=m(0,1,D),v=m(0,1,w),[B,y]=p.draw(t,b,v,l===null);if(l===null&&(l=B.position,O=B.normal.flipped.perpendicular),L=y.position,P=y.normal.flipped.perpendicular,o>n)break}return this.end()===1&&this.closed()&&t.closePath(),{startPoint:l??c.zero,startTangent:O??c.right,endPoint:L??c.zero,endTangent:P??c.right,arrowSize:a,path:t,startOffset:s}}getPointAtDistance(t){return W(this.profile(),t+this.startOffset())}getPointAtPercentage(t){return W(this.profile(),this.percentageToDistance(t))}applyStyle(t){super.applyStyle(t);const{arcLength:e}=this.profile();t.lineDashOffset-=e/2}getComputedLayout(){return this.offsetComputedLayout(super.getComputedLayout())}offsetComputedLayout(t){return t.position=t.position.sub(this.childrenBBox().center),t}getPath(){return this.curveDrawingInfo().path}getCacheBBox(){const t=this.childrenBBox(),e=this.arrowSize(),s=this.lineWidth(),n=this.lineWidthCoefficient();return t.expand(Math.max(0,e,s*n))}lineWidthCoefficient(){return this.lineCap()==="square"?.5*1.4143:.5}drawShape(t){super.drawShape(t);const{startPoint:e,startTangent:s,endPoint:n,endTangent:i,arrowSize:a}=this.curveDrawingInfo();a<.001||(t.save(),t.beginPath(),this.endArrow()&&this.drawArrow(t,n,i.flipped,a),this.startArrow()&&this.drawArrow(t,e,s,a),t.fillStyle=E(this.stroke(),t),t.closePath(),t.fill(),t.restore())}drawArrow(t,e,s,n){const i=s.perpendicular,a=e.add(s.scale(-n/2));C(t,a),j(t,a.add(s.add(i).scale(n))),j(t,a.add(s.sub(i).scale(n))),j(t,a),t.closePath()}}u([d(!1),f()],h.prototype,"closed",void 0);u([d(0),f()],h.prototype,"start",void 0);u([d(0),f()],h.prototype,"startOffset",void 0);u([d(!1),f()],h.prototype,"startArrow",void 0);u([d(1),f()],h.prototype,"end",void 0);u([d(0),f()],h.prototype,"endOffset",void 0);u([d(!1),f()],h.prototype,"endArrow",void 0);u([d(24),f()],h.prototype,"arrowSize",void 0);u([S()],h.prototype,"arcLength",null);u([S()],h.prototype,"curveDrawingInfo",null);var A=globalThis&&globalThis.__decorate||function(r,t,e,s){var n=arguments.length,i=n<3?t:s===null?s=Object.getOwnPropertyDescriptor(t,e):s,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(r,t,e,s);else for(var o=r.length-1;o>=0;o--)(a=r[o])&&(i=(n<3?a(i):n>3?a(t,e,i):a(t,e))||i);return n>3&&i&&Object.defineProperty(t,e,i),i};class T extends h{constructor(t){super(t),t.children===void 0&&t.points===void 0&&V().warn({message:"No points specified for the line",remarks:`<p>The line won&#39;t be visible unless you specify at least two points:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span>
  stroke=<span class="hljs-string">&quot;#fff&quot;</span>
  lineWidth={<span class="hljs-number">8</span>}
  points={[
    [<span class="hljs-number">100</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>],
  ]}
/&gt;
</code></pre>
<p>Alternatively, you can define the points using the children:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">x</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">y</span>=<span class="hljs-string">{100}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">Line</span>&gt;
</code></pre>
<p>If you did this intentionally, and want to disable this message, set the
<code>points</code> property to <code>null</code>:</p>
<pre><code class="language-tsx">&lt;<span class="hljs-title class_">Line</span> stroke=<span class="hljs-string">&quot;#fff&quot;</span> lineWidth={<span class="hljs-number">8</span>} points={<span class="hljs-literal">null</span>} /&gt;
</code></pre>
`,inspect:this.key})}childrenBBox(){const t=this.points(),e=t?t.map(s=>new c(R(s))):this.children().filter(s=>!(s instanceof F)||s.isLayoutRoot()).map(s=>s.position());return J.fromPoints(...e)}parsedPoints(){const t=this.points();return t?t.map(e=>new c(R(e))):this.children().map(e=>e.position())}profile(){return G(this.parsedPoints(),this.radius(),this.closed())}lineWidthCoefficient(){const t=this.radius(),e=this.lineJoin();let s=super.lineWidthCoefficient();if(t===0&&e==="miter"){const{minSin:n}=this.profile();n>0&&(s=Math.max(s,.5/n))}return s}drawOverlay(t,e){const s=this.childrenBBox().transformCorners(e),i=this.computedSize().mul(this.offset()).scale(.5).transformAsPoint(e);t.fillStyle="white",t.strokeStyle="black",t.lineWidth=1;const a=new Path2D,o=this.parsedPoints().map(l=>l.transformAsPoint(e));if(o.length>0){C(a,o[0]);for(const l of o)j(a,l),t.beginPath(),K(t,l,4),t.closePath(),t.fill(),t.stroke()}t.strokeStyle="white",t.stroke(a),t.beginPath(),Q(t,i),t.stroke(),t.beginPath(),U(t,s),t.closePath(),t.stroke()}}A([d(0),f()],T.prototype,"radius",void 0);A([d(null),f()],T.prototype,"points",void 0);A([S()],T.prototype,"childrenBBox",null);A([S()],T.prototype,"parsedPoints",null);A([S()],T.prototype,"profile",null);export{T as L};
