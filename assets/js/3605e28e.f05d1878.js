"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3805],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function r(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function s(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?r(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function c(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var i=o.createContext({}),a=function(t){var n=o.useContext(i),e=n;return t&&(e="function"==typeof t?t(n):s(s({},n),t)),e},l=function(t){var n=a(t.components);return o.createElement(i.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,r=t.originalType,i=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=a(e),d=p,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||r;return e?o.createElement(h,s(s({ref:n},l),{},{components:e})):o.createElement(h,s({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var r=e.length,s=new Array(r);s[0]=d;var c={};for(var i in n)hasOwnProperty.call(n,i)&&(c[i]=n[i]);c.originalType=t,c[u]="string"==typeof t?t:p,s[1]=c;for(var a=2;a<r;a++)s[a]=e[a];return o.createElement.apply(null,s)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},3851:(t,n,e)=>{e.d(n,{Z:()=>u});var o=e(7896),p=e(2784),r=e(6277),s=e(1077),c=e(7683),i=e(9817);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:n,id:e,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===n||!e)return p.createElement(n,(0,o.Z)({},u,{id:void 0}));const d=(0,s.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:e});return p.createElement(n,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:a,u.className),id:e}),u.children,p.createElement(i.Z,{className:"hash-link",to:`#${e}`,"aria-label":d,title:d},"\u200b"))}},2665:(t,n,e)=>{e.d(n,{Z:()=>k});var o=e(2784);const p="container_lQCo",r="small_As57",s="banner_A4QS",c="player_tELG",i="link_BTzN",a="icon_wSGd";var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}var m=e(9817),d=e(6277);function h(t){let{name:n}=t;const e=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${n}.tsx`;return o.createElement(m.Z,{to:e,className:(0,d.Z)("padding--sm",i)},o.createElement("span",null,"View source code"),o.createElement(u,{className:a}))}function k(t){let{name:n,banner:e,small:i,link:a}=t;return o.createElement("div",{className:(0,d.Z)(p,e&&s,i&&r)},o.createElement("motion-canvas-player",{class:c,src:`/examples/${n}.js`,auto:e}),o.createElement(h,{name:a||n}))}e(1263).Z.canUseDOM&&e.e(5455).then(e.bind(e,5455))},2072:(t,n,e)=>{e.d(n,{Z:()=>s});var o=e(2784),p=e(8617),r=e(1930);function s(t){let{url:n}=t;const e=(0,p.rG)()(n);return o.createElement(r.Z,{reflection:e,headless:!0})}},1947:(t,n,e)=>{e.d(n,{Z:()=>Izn});var o={};e.r(o),e.d(o,{content_0_0:()=>i,content_0_10:()=>M,content_0_100:()=>tn,content_0_1000:()=>Ef,content_0_1002:()=>Gf,content_0_1004:()=>Ff,content_0_1006:()=>qf,content_0_1008:()=>jf,content_0_1010:()=>Hf,content_0_1012:()=>Yf,content_0_1014:()=>Jf,content_0_1016:()=>nM,content_0_1018:()=>oM,content_0_102:()=>en,content_0_1020:()=>rM,content_0_1022:()=>cM,content_0_1024:()=>aM,content_0_1026:()=>uM,content_0_1028:()=>dM,content_0_1030:()=>kM,content_0_1032:()=>fM,content_0_1034:()=>DM,content_0_1036:()=>XM,content_0_1038:()=>gM,content_0_104:()=>pn,content_0_1040:()=>xM,content_0_1042:()=>vM,content_0_1044:()=>ZM,content_0_1046:()=>NM,content_0_1048:()=>AM,content_0_1050:()=>RM,content_0_1052:()=>IM,content_0_1054:()=>EM,content_0_1056:()=>GM,content_0_1058:()=>FM,content_0_106:()=>sn,content_0_1060:()=>qM,content_0_1062:()=>jM,content_0_1064:()=>HM,content_0_1066:()=>YM,content_0_1068:()=>JM,content_0_1070:()=>nD,content_0_1072:()=>oD,content_0_1074:()=>rD,content_0_1076:()=>cD,content_0_1078:()=>aD,content_0_108:()=>an,content_0_1080:()=>uD,content_0_1082:()=>dD,content_0_1084:()=>kD,content_0_1086:()=>fD,content_0_1088:()=>DD,content_0_1090:()=>XD,content_0_1092:()=>gD,content_0_1094:()=>xD,content_0_1096:()=>vD,content_0_1098:()=>ZD,content_0_110:()=>un,content_0_1100:()=>ND,content_0_1102:()=>AD,content_0_1104:()=>RD,content_0_1106:()=>ID,content_0_1108:()=>ED,content_0_1110:()=>GD,content_0_1112:()=>FD,content_0_1114:()=>qD,content_0_1116:()=>jD,content_0_1118:()=>HD,content_0_112:()=>dn,content_0_1120:()=>YD,content_0_1122:()=>JD,content_0_1124:()=>n_,content_0_1126:()=>o_,content_0_1128:()=>r_,content_0_1130:()=>c_,content_0_1132:()=>a_,content_0_1134:()=>u_,content_0_1136:()=>d_,content_0_1138:()=>k_,content_0_114:()=>kn,content_0_1140:()=>f_,content_0_1142:()=>D_,content_0_1144:()=>X_,content_0_1146:()=>g_,content_0_1148:()=>x_,content_0_1150:()=>v_,content_0_1152:()=>Z_,content_0_1154:()=>N_,content_0_1156:()=>A_,content_0_1158:()=>R_,content_0_116:()=>fn,content_0_1160:()=>I_,content_0_1162:()=>E_,content_0_1164:()=>G_,content_0_1166:()=>F_,content_0_1168:()=>q_,content_0_1170:()=>j_,content_0_1172:()=>H_,content_0_1174:()=>Y_,content_0_1176:()=>J_,content_0_1178:()=>nX,content_0_118:()=>Dn,content_0_1180:()=>oX,content_0_1182:()=>rX,content_0_1184:()=>cX,content_0_1186:()=>aX,content_0_1188:()=>uX,content_0_1190:()=>dX,content_0_1192:()=>kX,content_0_1194:()=>fX,content_0_1196:()=>DX,content_0_1198:()=>XX,content_0_12:()=>_,content_0_120:()=>Xn,content_0_1200:()=>gX,content_0_1202:()=>xX,content_0_1204:()=>vX,content_0_1206:()=>ZX,content_0_1208:()=>NX,content_0_1210:()=>AX,content_0_1212:()=>RX,content_0_1214:()=>IX,content_0_1216:()=>EX,content_0_1218:()=>GX,content_0_122:()=>gn,content_0_1220:()=>FX,content_0_1222:()=>qX,content_0_1224:()=>jX,content_0_1226:()=>HX,content_0_1228:()=>YX,content_0_1230:()=>JX,content_0_1232:()=>nw,content_0_1234:()=>ow,content_0_1236:()=>rw,content_0_1238:()=>cw,content_0_124:()=>xn,content_0_1240:()=>aw,content_0_1242:()=>uw,content_0_1244:()=>dw,content_0_1246:()=>kw,content_0_1248:()=>fw,content_0_1250:()=>Dw,content_0_1252:()=>Xw,content_0_1254:()=>gw,content_0_1256:()=>xw,content_0_1258:()=>vw,content_0_126:()=>vn,content_0_1260:()=>Zw,content_0_1262:()=>Nw,content_0_1264:()=>Aw,content_0_1266:()=>Rw,content_0_1268:()=>Iw,content_0_1270:()=>Ew,content_0_1272:()=>Gw,content_0_1274:()=>Fw,content_0_1276:()=>qw,content_0_1278:()=>jw,content_0_128:()=>Zn,content_0_1280:()=>Hw,content_0_1282:()=>Yw,content_0_1284:()=>Jw,content_0_1286:()=>ng,content_0_1288:()=>og,content_0_1290:()=>rg,content_0_1292:()=>cg,content_0_1294:()=>ag,content_0_1296:()=>ug,content_0_1298:()=>dg,content_0_130:()=>Nn,content_0_1300:()=>kg,content_0_1302:()=>fg,content_0_1304:()=>Dg,content_0_1306:()=>Xg,content_0_1308:()=>gg,content_0_1310:()=>xg,content_0_1312:()=>vg,content_0_1314:()=>Zg,content_0_1316:()=>Ng,content_0_1318:()=>Ag,content_0_132:()=>An,content_0_1320:()=>Rg,content_0_1322:()=>Ig,content_0_1324:()=>Eg,content_0_1326:()=>Gg,content_0_1328:()=>Fg,content_0_1330:()=>qg,content_0_1332:()=>jg,content_0_1334:()=>Hg,content_0_1336:()=>Yg,content_0_1338:()=>Jg,content_0_134:()=>Rn,content_0_1340:()=>nT,content_0_1342:()=>oT,content_0_1344:()=>rT,content_0_1346:()=>cT,content_0_1348:()=>aT,content_0_1350:()=>uT,content_0_1352:()=>dT,content_0_1354:()=>kT,content_0_1356:()=>fT,content_0_1358:()=>DT,content_0_136:()=>In,content_0_1360:()=>XT,content_0_1362:()=>gT,content_0_1364:()=>xT,content_0_1366:()=>vT,content_0_1368:()=>ZT,content_0_1370:()=>NT,content_0_1372:()=>AT,content_0_1374:()=>RT,content_0_1376:()=>IT,content_0_1378:()=>ET,content_0_138:()=>En,content_0_1380:()=>GT,content_0_1382:()=>FT,content_0_1384:()=>qT,content_0_1386:()=>jT,content_0_1388:()=>HT,content_0_1390:()=>YT,content_0_1392:()=>JT,content_0_1394:()=>nx,content_0_1396:()=>ox,content_0_1398:()=>rx,content_0_14:()=>w,content_0_140:()=>Gn,content_0_1400:()=>cx,content_0_1402:()=>ax,content_0_1404:()=>ux,content_0_1406:()=>dx,content_0_1408:()=>kx,content_0_1410:()=>fx,content_0_1412:()=>Dx,content_0_1414:()=>Xx,content_0_1416:()=>gx,content_0_1418:()=>xx,content_0_142:()=>Fn,content_0_1420:()=>vx,content_0_1422:()=>Zx,content_0_1424:()=>Nx,content_0_1426:()=>Ax,content_0_1428:()=>Rx,content_0_1430:()=>Ix,content_0_1432:()=>Ex,content_0_1434:()=>Gx,content_0_1436:()=>Fx,content_0_1438:()=>qx,content_0_144:()=>qn,content_0_1440:()=>jx,content_0_1442:()=>Hx,content_0_1444:()=>Yx,content_0_1446:()=>Jx,content_0_1448:()=>nC,content_0_1450:()=>oC,content_0_1452:()=>rC,content_0_1454:()=>cC,content_0_1456:()=>aC,content_0_1458:()=>uC,content_0_146:()=>jn,content_0_1460:()=>dC,content_0_1462:()=>kC,content_0_1464:()=>fC,content_0_1466:()=>DC,content_0_1468:()=>XC,content_0_1470:()=>gC,content_0_1472:()=>xC,content_0_1474:()=>vC,content_0_1476:()=>ZC,content_0_1478:()=>NC,content_0_148:()=>Hn,content_0_1480:()=>AC,content_0_1482:()=>RC,content_0_1484:()=>IC,content_0_1486:()=>EC,content_0_1488:()=>GC,content_0_1490:()=>FC,content_0_1492:()=>qC,content_0_1494:()=>jC,content_0_1496:()=>HC,content_0_1498:()=>YC,content_0_150:()=>Yn,content_0_1500:()=>JC,content_0_1502:()=>nv,content_0_1504:()=>ov,content_0_1506:()=>rv,content_0_1508:()=>cv,content_0_1510:()=>av,content_0_1512:()=>uv,content_0_1514:()=>dv,content_0_1516:()=>kv,content_0_1518:()=>fv,content_0_152:()=>Jn,content_0_1520:()=>Dv,content_0_1522:()=>Xv,content_0_1524:()=>gv,content_0_1526:()=>xv,content_0_1528:()=>vv,content_0_1530:()=>Zv,content_0_1532:()=>Nv,content_0_1534:()=>Av,content_0_1536:()=>Rv,content_0_1538:()=>Iv,content_0_154:()=>ne,content_0_1540:()=>Ev,content_0_1542:()=>Gv,content_0_1544:()=>Fv,content_0_1546:()=>qv,content_0_1548:()=>jv,content_0_1550:()=>Hv,content_0_1552:()=>Yv,content_0_1554:()=>Jv,content_0_1556:()=>nL,content_0_1558:()=>oL,content_0_156:()=>oe,content_0_1560:()=>rL,content_0_1562:()=>cL,content_0_1564:()=>aL,content_0_1566:()=>uL,content_0_1568:()=>dL,content_0_1570:()=>kL,content_0_1572:()=>fL,content_0_1574:()=>DL,content_0_1576:()=>XL,content_0_1578:()=>gL,content_0_158:()=>re,content_0_1580:()=>xL,content_0_1582:()=>vL,content_0_1584:()=>ZL,content_0_1586:()=>NL,content_0_1588:()=>AL,content_0_1590:()=>RL,content_0_1592:()=>IL,content_0_1594:()=>EL,content_0_1596:()=>GL,content_0_1598:()=>FL,content_0_16:()=>T,content_0_160:()=>ce,content_0_1600:()=>qL,content_0_1602:()=>jL,content_0_1604:()=>HL,content_0_1606:()=>YL,content_0_1608:()=>JL,content_0_1610:()=>nZ,content_0_1612:()=>oZ,content_0_1614:()=>rZ,content_0_162:()=>ae,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>ke,content_0_170:()=>fe,content_0_172:()=>De,content_0_174:()=>Xe,content_0_176:()=>ge,content_0_178:()=>xe,content_0_18:()=>C,content_0_180:()=>ve,content_0_182:()=>Ze,content_0_184:()=>Ne,content_0_186:()=>Ae,content_0_188:()=>Re,content_0_190:()=>Ie,content_0_192:()=>Ee,content_0_194:()=>Ge,content_0_196:()=>Fe,content_0_198:()=>qe,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>je,content_0_202:()=>He,content_0_204:()=>Ye,content_0_206:()=>Je,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>co,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>Mo,content_0_226:()=>_o,content_0_228:()=>wo,content_0_230:()=>To,content_0_232:()=>Co,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>zo,content_0_24:()=>z,content_0_240:()=>Wo,content_0_242:()=>So,content_0_244:()=>Po,content_0_246:()=>Bo,content_0_248:()=>Oo,content_0_250:()=>Uo,content_0_252:()=>Vo,content_0_254:()=>Qo,content_0_256:()=>$o,content_0_258:()=>Ko,content_0_26:()=>W,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>sp,content_0_268:()=>ip,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>yp,content_0_278:()=>Mp,content_0_28:()=>S,content_0_280:()=>_p,content_0_282:()=>wp,content_0_284:()=>Tp,content_0_286:()=>Cp,content_0_288:()=>Lp,content_0_290:()=>bp,content_0_292:()=>zp,content_0_294:()=>Wp,content_0_296:()=>Sp,content_0_298:()=>Pp,content_0_30:()=>P,content_0_300:()=>Bp,content_0_302:()=>Op,content_0_304:()=>Up,content_0_306:()=>Vp,content_0_308:()=>Qp,content_0_310:()=>$p,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>er,content_0_318:()=>pr,content_0_32:()=>B,content_0_320:()=>sr,content_0_322:()=>ir,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>yr,content_0_332:()=>Mr,content_0_334:()=>_r,content_0_336:()=>wr,content_0_338:()=>Tr,content_0_34:()=>O,content_0_340:()=>Cr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>zr,content_0_348:()=>Wr,content_0_350:()=>Sr,content_0_352:()=>Pr,content_0_354:()=>Br,content_0_356:()=>Or,content_0_358:()=>Ur,content_0_36:()=>U,content_0_360:()=>Vr,content_0_362:()=>Qr,content_0_364:()=>$r,content_0_366:()=>Kr,content_0_368:()=>ts,content_0_370:()=>es,content_0_372:()=>ps,content_0_374:()=>ss,content_0_376:()=>is,content_0_378:()=>ls,content_0_38:()=>V,content_0_380:()=>ms,content_0_382:()=>hs,content_0_384:()=>ys,content_0_386:()=>Ms,content_0_388:()=>_s,content_0_390:()=>ws,content_0_392:()=>Ts,content_0_394:()=>Cs,content_0_396:()=>Ls,content_0_398:()=>bs,content_0_4:()=>m,content_0_40:()=>Q,content_0_400:()=>zs,content_0_402:()=>Ws,content_0_404:()=>Ss,content_0_406:()=>Ps,content_0_408:()=>Bs,content_0_410:()=>Os,content_0_412:()=>Us,content_0_414:()=>Vs,content_0_416:()=>Qs,content_0_418:()=>$s,content_0_42:()=>$,content_0_420:()=>Ks,content_0_422:()=>tc,content_0_424:()=>ec,content_0_426:()=>pc,content_0_428:()=>sc,content_0_430:()=>ic,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>yc,content_0_44:()=>K,content_0_440:()=>Mc,content_0_442:()=>_c,content_0_444:()=>wc,content_0_446:()=>Tc,content_0_448:()=>Cc,content_0_450:()=>Lc,content_0_452:()=>bc,content_0_454:()=>zc,content_0_456:()=>Wc,content_0_458:()=>Sc,content_0_46:()=>tt,content_0_460:()=>Pc,content_0_462:()=>Bc,content_0_464:()=>Oc,content_0_466:()=>Uc,content_0_468:()=>Vc,content_0_470:()=>Qc,content_0_472:()=>$c,content_0_474:()=>Kc,content_0_476:()=>ti,content_0_478:()=>ei,content_0_48:()=>et,content_0_480:()=>pi,content_0_482:()=>si,content_0_484:()=>ii,content_0_486:()=>li,content_0_488:()=>mi,content_0_490:()=>hi,content_0_492:()=>yi,content_0_494:()=>Mi,content_0_496:()=>_i,content_0_498:()=>wi,content_0_50:()=>pt,content_0_500:()=>Ti,content_0_502:()=>Ci,content_0_504:()=>Li,content_0_506:()=>bi,content_0_508:()=>zi,content_0_510:()=>Wi,content_0_512:()=>Si,content_0_514:()=>Pi,content_0_516:()=>Bi,content_0_518:()=>Oi,content_0_52:()=>st,content_0_520:()=>Ui,content_0_522:()=>Vi,content_0_524:()=>Qi,content_0_526:()=>$i,content_0_528:()=>Ki,content_0_530:()=>ta,content_0_532:()=>ea,content_0_534:()=>pa,content_0_536:()=>sa,content_0_538:()=>ia,content_0_54:()=>it,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ya,content_0_548:()=>Ma,content_0_550:()=>_a,content_0_552:()=>wa,content_0_554:()=>Ta,content_0_556:()=>Ca,content_0_558:()=>La,content_0_56:()=>lt,content_0_560:()=>ba,content_0_562:()=>za,content_0_564:()=>Wa,content_0_566:()=>Sa,content_0_568:()=>Pa,content_0_570:()=>Ba,content_0_572:()=>Oa,content_0_574:()=>Ua,content_0_576:()=>Va,content_0_578:()=>Qa,content_0_58:()=>mt,content_0_580:()=>$a,content_0_582:()=>Ka,content_0_584:()=>tl,content_0_586:()=>el,content_0_588:()=>pl,content_0_590:()=>sl,content_0_592:()=>il,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yl,content_0_602:()=>Ml,content_0_604:()=>_l,content_0_606:()=>wl,content_0_608:()=>Tl,content_0_610:()=>Cl,content_0_612:()=>Ll,content_0_614:()=>bl,content_0_616:()=>zl,content_0_618:()=>Wl,content_0_62:()=>yt,content_0_620:()=>Sl,content_0_622:()=>Pl,content_0_624:()=>Bl,content_0_626:()=>Ol,content_0_628:()=>Ul,content_0_630:()=>Vl,content_0_632:()=>Ql,content_0_634:()=>$l,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>su,content_0_646:()=>iu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>Mu,content_0_658:()=>_u,content_0_66:()=>_t,content_0_660:()=>wu,content_0_662:()=>Tu,content_0_664:()=>Cu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>zu,content_0_672:()=>Wu,content_0_674:()=>Su,content_0_676:()=>Pu,content_0_678:()=>Bu,content_0_68:()=>wt,content_0_680:()=>Ou,content_0_682:()=>Uu,content_0_684:()=>Vu,content_0_686:()=>Qu,content_0_688:()=>$u,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>sm,content_0_70:()=>Tt,content_0_700:()=>im,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>Mm,content_0_712:()=>_m,content_0_714:()=>wm,content_0_716:()=>Tm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>zm,content_0_726:()=>Wm,content_0_728:()=>Sm,content_0_730:()=>Pm,content_0_732:()=>Bm,content_0_734:()=>Om,content_0_736:()=>Um,content_0_738:()=>Vm,content_0_74:()=>Lt,content_0_740:()=>Qm,content_0_742:()=>$m,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>sd,content_0_754:()=>id,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>Md,content_0_766:()=>_d,content_0_768:()=>wd,content_0_770:()=>Td,content_0_772:()=>Cd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>zd,content_0_78:()=>zt,content_0_780:()=>Wd,content_0_782:()=>Sd,content_0_784:()=>Pd,content_0_786:()=>Bd,content_0_788:()=>Od,content_0_790:()=>Ud,content_0_792:()=>Vd,content_0_794:()=>Qd,content_0_796:()=>$d,content_0_798:()=>Kd,content_0_8:()=>y,content_0_80:()=>Wt,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>sh,content_0_808:()=>ih,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>Mh,content_0_82:()=>St,content_0_820:()=>_h,content_0_822:()=>wh,content_0_824:()=>Th,content_0_826:()=>Ch,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>zh,content_0_834:()=>Wh,content_0_836:()=>Sh,content_0_838:()=>Ph,content_0_84:()=>Pt,content_0_840:()=>Bh,content_0_842:()=>Oh,content_0_844:()=>Uh,content_0_846:()=>Vh,content_0_848:()=>Qh,content_0_850:()=>$h,content_0_852:()=>Kh,content_0_854:()=>tk,content_0_856:()=>ek,content_0_858:()=>pk,content_0_86:()=>Bt,content_0_860:()=>sk,content_0_862:()=>ik,content_0_864:()=>lk,content_0_866:()=>mk,content_0_868:()=>hk,content_0_870:()=>yk,content_0_872:()=>Mk,content_0_874:()=>_k,content_0_876:()=>wk,content_0_878:()=>Tk,content_0_88:()=>Ot,content_0_880:()=>Ck,content_0_882:()=>Lk,content_0_884:()=>bk,content_0_886:()=>zk,content_0_888:()=>Wk,content_0_890:()=>Sk,content_0_892:()=>Pk,content_0_894:()=>Bk,content_0_896:()=>Ok,content_0_898:()=>Uk,content_0_90:()=>Ut,content_0_900:()=>Vk,content_0_902:()=>Qk,content_0_904:()=>$k,content_0_906:()=>Kk,content_0_908:()=>ty,content_0_910:()=>ey,content_0_912:()=>py,content_0_914:()=>sy,content_0_916:()=>iy,content_0_918:()=>ly,content_0_92:()=>Vt,content_0_920:()=>my,content_0_922:()=>hy,content_0_924:()=>yy,content_0_926:()=>My,content_0_928:()=>_y,content_0_930:()=>wy,content_0_932:()=>Ty,content_0_934:()=>Cy,content_0_936:()=>Ly,content_0_938:()=>by,content_0_94:()=>Qt,content_0_940:()=>zy,content_0_942:()=>Wy,content_0_944:()=>Sy,content_0_946:()=>Py,content_0_948:()=>By,content_0_950:()=>Oy,content_0_952:()=>Uy,content_0_954:()=>Vy,content_0_956:()=>Qy,content_0_958:()=>$y,content_0_96:()=>$t,content_0_960:()=>Ky,content_0_962:()=>tf,content_0_964:()=>ef,content_0_966:()=>pf,content_0_968:()=>sf,content_0_970:()=>af,content_0_972:()=>uf,content_0_974:()=>df,content_0_976:()=>kf,content_0_978:()=>ff,content_0_98:()=>Kt,content_0_980:()=>Df,content_0_982:()=>Xf,content_0_984:()=>gf,content_0_986:()=>xf,content_0_988:()=>vf,content_0_990:()=>Zf,content_0_992:()=>Nf,content_0_994:()=>Af,content_0_996:()=>Rf,content_0_998:()=>If,content_3498_0:()=>cZ,content_3498_10:()=>fZ,content_3498_100:()=>Jb,content_3498_1000:()=>Rj,content_3498_1002:()=>Ij,content_3498_1004:()=>Ej,content_3498_1006:()=>Gj,content_3498_1008:()=>Fj,content_3498_1010:()=>qj,content_3498_1012:()=>jj,content_3498_1014:()=>Hj,content_3498_1016:()=>Yj,content_3498_1018:()=>Jj,content_3498_102:()=>nN,content_3498_1020:()=>nQ,content_3498_1022:()=>oQ,content_3498_1024:()=>rQ,content_3498_1026:()=>cQ,content_3498_1028:()=>aQ,content_3498_1030:()=>uQ,content_3498_1032:()=>dQ,content_3498_1034:()=>kQ,content_3498_1036:()=>fQ,content_3498_1038:()=>DQ,content_3498_104:()=>oN,content_3498_1040:()=>XQ,content_3498_1042:()=>gQ,content_3498_1044:()=>xQ,content_3498_1046:()=>vQ,content_3498_1048:()=>ZQ,content_3498_1050:()=>NQ,content_3498_1052:()=>AQ,content_3498_1054:()=>RQ,content_3498_1056:()=>IQ,content_3498_1058:()=>EQ,content_3498_106:()=>rN,content_3498_1060:()=>GQ,content_3498_1062:()=>FQ,content_3498_1064:()=>qQ,content_3498_1066:()=>jQ,content_3498_1068:()=>HQ,content_3498_1070:()=>YQ,content_3498_1072:()=>JQ,content_3498_1074:()=>nH,content_3498_1076:()=>oH,content_3498_1078:()=>rH,content_3498_108:()=>cN,content_3498_1080:()=>cH,content_3498_1082:()=>aH,content_3498_1084:()=>uH,content_3498_1086:()=>dH,content_3498_1088:()=>kH,content_3498_1090:()=>fH,content_3498_1092:()=>DH,content_3498_1094:()=>XH,content_3498_1096:()=>gH,content_3498_1098:()=>xH,content_3498_110:()=>aN,content_3498_1100:()=>vH,content_3498_1102:()=>ZH,content_3498_1104:()=>NH,content_3498_1106:()=>AH,content_3498_1108:()=>RH,content_3498_1110:()=>IH,content_3498_1112:()=>EH,content_3498_1114:()=>GH,content_3498_1116:()=>FH,content_3498_1118:()=>qH,content_3498_112:()=>uN,content_3498_1120:()=>jH,content_3498_1122:()=>HH,content_3498_1124:()=>YH,content_3498_1126:()=>JH,content_3498_1128:()=>n$,content_3498_1130:()=>o$,content_3498_1132:()=>r$,content_3498_1134:()=>c$,content_3498_1136:()=>a$,content_3498_1138:()=>u$,content_3498_114:()=>dN,content_3498_1140:()=>d$,content_3498_1142:()=>k$,content_3498_1144:()=>f$,content_3498_1146:()=>D$,content_3498_1148:()=>X$,content_3498_1150:()=>g$,content_3498_1152:()=>x$,content_3498_1154:()=>v$,content_3498_1156:()=>Z$,content_3498_1158:()=>N$,content_3498_116:()=>kN,content_3498_1160:()=>A$,content_3498_1162:()=>R$,content_3498_1164:()=>I$,content_3498_1166:()=>E$,content_3498_1168:()=>G$,content_3498_1170:()=>F$,content_3498_1172:()=>q$,content_3498_1174:()=>j$,content_3498_1176:()=>H$,content_3498_1178:()=>Y$,content_3498_118:()=>fN,content_3498_1180:()=>J$,content_3498_1182:()=>nY,content_3498_1184:()=>oY,content_3498_1186:()=>rY,content_3498_1188:()=>cY,content_3498_1190:()=>aY,content_3498_1192:()=>uY,content_3498_1194:()=>dY,content_3498_1196:()=>kY,content_3498_1198:()=>fY,content_3498_12:()=>DZ,content_3498_120:()=>DN,content_3498_1200:()=>DY,content_3498_1202:()=>XY,content_3498_1204:()=>gY,content_3498_1206:()=>xY,content_3498_1208:()=>vY,content_3498_1210:()=>ZY,content_3498_1212:()=>NY,content_3498_1214:()=>AY,content_3498_1216:()=>RY,content_3498_1218:()=>IY,content_3498_122:()=>XN,content_3498_1220:()=>EY,content_3498_1222:()=>GY,content_3498_1224:()=>FY,content_3498_1226:()=>qY,content_3498_1228:()=>jY,content_3498_1230:()=>HY,content_3498_1232:()=>YY,content_3498_1234:()=>JY,content_3498_1236:()=>nK,content_3498_1238:()=>oK,content_3498_124:()=>gN,content_3498_1240:()=>rK,content_3498_1242:()=>cK,content_3498_1244:()=>aK,content_3498_1246:()=>uK,content_3498_1248:()=>dK,content_3498_1250:()=>kK,content_3498_1252:()=>fK,content_3498_1254:()=>DK,content_3498_1256:()=>XK,content_3498_1258:()=>gK,content_3498_126:()=>xN,content_3498_1260:()=>xK,content_3498_1262:()=>vK,content_3498_1264:()=>ZK,content_3498_1266:()=>NK,content_3498_1268:()=>AK,content_3498_1270:()=>RK,content_3498_1272:()=>IK,content_3498_1274:()=>EK,content_3498_1276:()=>GK,content_3498_1278:()=>FK,content_3498_128:()=>vN,content_3498_1280:()=>qK,content_3498_1282:()=>jK,content_3498_1284:()=>HK,content_3498_1286:()=>YK,content_3498_1288:()=>JK,content_3498_1290:()=>nJ,content_3498_1292:()=>oJ,content_3498_1294:()=>rJ,content_3498_1296:()=>cJ,content_3498_1298:()=>aJ,content_3498_130:()=>ZN,content_3498_1300:()=>uJ,content_3498_1302:()=>dJ,content_3498_1304:()=>kJ,content_3498_1306:()=>fJ,content_3498_1308:()=>DJ,content_3498_1310:()=>XJ,content_3498_1312:()=>gJ,content_3498_1314:()=>xJ,content_3498_1316:()=>vJ,content_3498_1318:()=>ZJ,content_3498_132:()=>NN,content_3498_1320:()=>NJ,content_3498_1322:()=>AJ,content_3498_1324:()=>RJ,content_3498_1326:()=>IJ,content_3498_1328:()=>EJ,content_3498_1330:()=>GJ,content_3498_1332:()=>FJ,content_3498_1334:()=>qJ,content_3498_1336:()=>jJ,content_3498_1338:()=>HJ,content_3498_134:()=>AN,content_3498_1340:()=>YJ,content_3498_1342:()=>JJ,content_3498_1344:()=>n0,content_3498_1346:()=>o0,content_3498_1348:()=>r0,content_3498_1350:()=>c0,content_3498_1352:()=>a0,content_3498_1354:()=>u0,content_3498_1356:()=>d0,content_3498_1358:()=>k0,content_3498_136:()=>RN,content_3498_1360:()=>f0,content_3498_1362:()=>D0,content_3498_1364:()=>X0,content_3498_1366:()=>g0,content_3498_1368:()=>x0,content_3498_1370:()=>v0,content_3498_1372:()=>Z0,content_3498_1374:()=>N0,content_3498_1376:()=>A0,content_3498_1378:()=>R0,content_3498_138:()=>IN,content_3498_1380:()=>I0,content_3498_1382:()=>E0,content_3498_1384:()=>G0,content_3498_1386:()=>F0,content_3498_1388:()=>q0,content_3498_1390:()=>j0,content_3498_1392:()=>H0,content_3498_1394:()=>Y0,content_3498_1396:()=>J0,content_3498_1398:()=>n4,content_3498_14:()=>XZ,content_3498_140:()=>EN,content_3498_1400:()=>o4,content_3498_1402:()=>r4,content_3498_1404:()=>c4,content_3498_1406:()=>a4,content_3498_1408:()=>u4,content_3498_1410:()=>d4,content_3498_1412:()=>k4,content_3498_1414:()=>f4,content_3498_1416:()=>D4,content_3498_1418:()=>X4,content_3498_142:()=>GN,content_3498_1420:()=>g4,content_3498_1422:()=>x4,content_3498_1424:()=>v4,content_3498_1426:()=>Z4,content_3498_1428:()=>N4,content_3498_1430:()=>A4,content_3498_1432:()=>R4,content_3498_1434:()=>I4,content_3498_1436:()=>E4,content_3498_1438:()=>G4,content_3498_144:()=>FN,content_3498_1440:()=>F4,content_3498_1442:()=>q4,content_3498_1444:()=>j4,content_3498_1446:()=>H4,content_3498_1448:()=>Y4,content_3498_1450:()=>J4,content_3498_1452:()=>n8,content_3498_1454:()=>o8,content_3498_1456:()=>r8,content_3498_1458:()=>c8,content_3498_146:()=>qN,content_3498_1460:()=>a8,content_3498_1462:()=>u8,content_3498_1464:()=>d8,content_3498_1466:()=>k8,content_3498_1468:()=>f8,content_3498_1470:()=>D8,content_3498_1472:()=>X8,content_3498_1474:()=>g8,content_3498_1476:()=>x8,content_3498_1478:()=>v8,content_3498_148:()=>jN,content_3498_1480:()=>Z8,content_3498_1482:()=>N8,content_3498_1484:()=>A8,content_3498_1486:()=>R8,content_3498_1488:()=>I8,content_3498_1490:()=>E8,content_3498_1492:()=>G8,content_3498_1494:()=>F8,content_3498_1496:()=>q8,content_3498_1498:()=>j8,content_3498_150:()=>HN,content_3498_1500:()=>H8,content_3498_1502:()=>Y8,content_3498_1504:()=>J8,content_3498_1506:()=>n3,content_3498_1508:()=>o3,content_3498_1510:()=>r3,content_3498_1512:()=>c3,content_3498_1514:()=>a3,content_3498_1516:()=>u3,content_3498_1518:()=>d3,content_3498_152:()=>YN,content_3498_1520:()=>k3,content_3498_1522:()=>f3,content_3498_1524:()=>D3,content_3498_1526:()=>X3,content_3498_1528:()=>g3,content_3498_1530:()=>x3,content_3498_1532:()=>v3,content_3498_1534:()=>Z3,content_3498_1536:()=>N3,content_3498_1538:()=>A3,content_3498_154:()=>JN,content_3498_1540:()=>R3,content_3498_1542:()=>I3,content_3498_1544:()=>E3,content_3498_1546:()=>G3,content_3498_1548:()=>F3,content_3498_1550:()=>q3,content_3498_1552:()=>j3,content_3498_1554:()=>H3,content_3498_1556:()=>Y3,content_3498_1558:()=>J3,content_3498_156:()=>nz,content_3498_1560:()=>n9,content_3498_1562:()=>o9,content_3498_1564:()=>r9,content_3498_1566:()=>c9,content_3498_1568:()=>a9,content_3498_1570:()=>u9,content_3498_1572:()=>d9,content_3498_1574:()=>k9,content_3498_1576:()=>f9,content_3498_1578:()=>D9,content_3498_158:()=>oz,content_3498_1580:()=>X9,content_3498_1582:()=>g9,content_3498_1584:()=>x9,content_3498_1586:()=>v9,content_3498_1588:()=>Z9,content_3498_1590:()=>N9,content_3498_1592:()=>A9,content_3498_1594:()=>R9,content_3498_1596:()=>I9,content_3498_1598:()=>E9,content_3498_16:()=>gZ,content_3498_160:()=>rz,content_3498_1600:()=>G9,content_3498_1602:()=>F9,content_3498_1604:()=>q9,content_3498_1606:()=>j9,content_3498_1608:()=>H9,content_3498_1610:()=>Y9,content_3498_1612:()=>J9,content_3498_1614:()=>n2,content_3498_1616:()=>o2,content_3498_1618:()=>r2,content_3498_162:()=>cz,content_3498_1620:()=>c2,content_3498_1622:()=>a2,content_3498_1624:()=>u2,content_3498_1626:()=>d2,content_3498_1628:()=>k2,content_3498_1630:()=>f2,content_3498_1632:()=>D2,content_3498_1634:()=>X2,content_3498_1636:()=>g2,content_3498_1638:()=>x2,content_3498_164:()=>az,content_3498_1640:()=>v2,content_3498_1642:()=>Z2,content_3498_1644:()=>N2,content_3498_1646:()=>A2,content_3498_1648:()=>R2,content_3498_1650:()=>I2,content_3498_1652:()=>E2,content_3498_1654:()=>G2,content_3498_1656:()=>F2,content_3498_1658:()=>q2,content_3498_166:()=>uz,content_3498_1660:()=>j2,content_3498_1662:()=>H2,content_3498_1664:()=>Y2,content_3498_1666:()=>J2,content_3498_1668:()=>n1,content_3498_1670:()=>o1,content_3498_1672:()=>r1,content_3498_1674:()=>c1,content_3498_1676:()=>a1,content_3498_1678:()=>u1,content_3498_168:()=>dz,content_3498_1680:()=>d1,content_3498_1682:()=>k1,content_3498_1684:()=>f1,content_3498_1686:()=>D1,content_3498_1688:()=>X1,content_3498_1690:()=>g1,content_3498_1692:()=>x1,content_3498_1694:()=>v1,content_3498_1696:()=>Z1,content_3498_1698:()=>N1,content_3498_170:()=>kz,content_3498_1700:()=>A1,content_3498_1702:()=>R1,content_3498_1704:()=>I1,content_3498_1706:()=>E1,content_3498_1708:()=>G1,content_3498_1710:()=>F1,content_3498_1712:()=>q1,content_3498_1714:()=>j1,content_3498_1716:()=>H1,content_3498_1718:()=>Y1,content_3498_172:()=>fz,content_3498_1720:()=>J1,content_3498_1722:()=>n6,content_3498_1724:()=>o6,content_3498_1726:()=>r6,content_3498_1728:()=>c6,content_3498_1730:()=>a6,content_3498_1732:()=>u6,content_3498_1734:()=>d6,content_3498_1736:()=>k6,content_3498_1738:()=>f6,content_3498_174:()=>Dz,content_3498_1740:()=>D6,content_3498_1742:()=>X6,content_3498_1744:()=>g6,content_3498_1746:()=>x6,content_3498_1748:()=>v6,content_3498_1750:()=>Z6,content_3498_1752:()=>N6,content_3498_1754:()=>A6,content_3498_1756:()=>R6,content_3498_1758:()=>I6,content_3498_176:()=>Xz,content_3498_1760:()=>E6,content_3498_1762:()=>G6,content_3498_1764:()=>F6,content_3498_1766:()=>q6,content_3498_1768:()=>j6,content_3498_1770:()=>H6,content_3498_1772:()=>Y6,content_3498_1774:()=>J6,content_3498_1776:()=>n5,content_3498_1778:()=>o5,content_3498_178:()=>gz,content_3498_1780:()=>r5,content_3498_1782:()=>c5,content_3498_1784:()=>a5,content_3498_1786:()=>u5,content_3498_1788:()=>d5,content_3498_1790:()=>k5,content_3498_1792:()=>f5,content_3498_1794:()=>D5,content_3498_1796:()=>X5,content_3498_1798:()=>g5,content_3498_18:()=>xZ,content_3498_180:()=>xz,content_3498_1800:()=>x5,content_3498_1802:()=>v5,content_3498_1804:()=>Z5,content_3498_1806:()=>N5,content_3498_1808:()=>A5,content_3498_1810:()=>R5,content_3498_1812:()=>I5,content_3498_1814:()=>E5,content_3498_1816:()=>G5,content_3498_1818:()=>F5,content_3498_182:()=>vz,content_3498_1820:()=>q5,content_3498_1822:()=>j5,content_3498_1824:()=>H5,content_3498_1826:()=>Y5,content_3498_1828:()=>J5,content_3498_1830:()=>n7,content_3498_1832:()=>o7,content_3498_1834:()=>r7,content_3498_1836:()=>c7,content_3498_1838:()=>a7,content_3498_184:()=>Zz,content_3498_1840:()=>u7,content_3498_1842:()=>d7,content_3498_1844:()=>k7,content_3498_1846:()=>f7,content_3498_1848:()=>D7,content_3498_1850:()=>X7,content_3498_1852:()=>g7,content_3498_1854:()=>x7,content_3498_1856:()=>v7,content_3498_1858:()=>Z7,content_3498_186:()=>Nz,content_3498_1860:()=>N7,content_3498_1862:()=>A7,content_3498_1864:()=>R7,content_3498_1866:()=>I7,content_3498_1868:()=>E7,content_3498_1870:()=>G7,content_3498_1872:()=>F7,content_3498_1874:()=>q7,content_3498_1876:()=>j7,content_3498_1878:()=>H7,content_3498_188:()=>Az,content_3498_1880:()=>Y7,content_3498_1882:()=>J7,content_3498_1884:()=>ntt,content_3498_1886:()=>ott,content_3498_1888:()=>rtt,content_3498_1890:()=>ctt,content_3498_1892:()=>att,content_3498_1894:()=>utt,content_3498_1896:()=>dtt,content_3498_1898:()=>ktt,content_3498_190:()=>Rz,content_3498_1900:()=>ftt,content_3498_1902:()=>Dtt,content_3498_1904:()=>Xtt,content_3498_1906:()=>gtt,content_3498_1908:()=>xtt,content_3498_1910:()=>vtt,content_3498_1912:()=>Ztt,content_3498_1914:()=>Ntt,content_3498_1916:()=>Att,content_3498_1918:()=>Rtt,content_3498_192:()=>Iz,content_3498_1920:()=>Itt,content_3498_1922:()=>Ett,content_3498_1924:()=>Gtt,content_3498_1926:()=>Ftt,content_3498_1928:()=>qtt,content_3498_1930:()=>jtt,content_3498_1932:()=>Htt,content_3498_1934:()=>Ytt,content_3498_1936:()=>Jtt,content_3498_1938:()=>nnt,content_3498_194:()=>Ez,content_3498_1940:()=>ont,content_3498_1942:()=>rnt,content_3498_1944:()=>cnt,content_3498_1946:()=>ant,content_3498_1948:()=>unt,content_3498_1950:()=>dnt,content_3498_1952:()=>knt,content_3498_1954:()=>fnt,content_3498_1956:()=>Dnt,content_3498_1958:()=>Xnt,content_3498_196:()=>Gz,content_3498_1960:()=>gnt,content_3498_1962:()=>xnt,content_3498_1964:()=>vnt,content_3498_1966:()=>Znt,content_3498_1968:()=>Nnt,content_3498_1970:()=>Ant,content_3498_1972:()=>Rnt,content_3498_1974:()=>Int,content_3498_1976:()=>Ent,content_3498_1978:()=>Gnt,content_3498_198:()=>Fz,content_3498_1980:()=>Fnt,content_3498_1982:()=>qnt,content_3498_1984:()=>jnt,content_3498_1986:()=>Hnt,content_3498_1988:()=>Ynt,content_3498_1990:()=>Jnt,content_3498_1992:()=>net,content_3498_1994:()=>oet,content_3498_1996:()=>ret,content_3498_1998:()=>cet,content_3498_2:()=>aZ,content_3498_20:()=>vZ,content_3498_200:()=>qz,content_3498_2000:()=>aet,content_3498_2002:()=>met,content_3498_2004:()=>het,content_3498_2006:()=>yet,content_3498_2008:()=>Met,content_3498_2010:()=>_et,content_3498_2012:()=>wet,content_3498_2014:()=>Tet,content_3498_2016:()=>Cet,content_3498_2018:()=>Let,content_3498_202:()=>jz,content_3498_2020:()=>bet,content_3498_2022:()=>zet,content_3498_2024:()=>Wet,content_3498_2026:()=>Set,content_3498_2028:()=>Pet,content_3498_2030:()=>Bet,content_3498_2032:()=>Oet,content_3498_2034:()=>Uet,content_3498_2036:()=>Vet,content_3498_2038:()=>Qet,content_3498_204:()=>Hz,content_3498_2040:()=>$et,content_3498_2042:()=>Ket,content_3498_2044:()=>tot,content_3498_2046:()=>eot,content_3498_2048:()=>pot,content_3498_2050:()=>sot,content_3498_2052:()=>iot,content_3498_2054:()=>lot,content_3498_2056:()=>mot,content_3498_2058:()=>hot,content_3498_206:()=>Yz,content_3498_2060:()=>yot,content_3498_2062:()=>Mot,content_3498_2064:()=>_ot,content_3498_2066:()=>wot,content_3498_2068:()=>Tot,content_3498_2070:()=>Cot,content_3498_2072:()=>Lot,content_3498_2074:()=>bot,content_3498_2076:()=>zot,content_3498_2078:()=>Wot,content_3498_208:()=>Jz,content_3498_2080:()=>Sot,content_3498_2082:()=>Pot,content_3498_2084:()=>Bot,content_3498_2086:()=>Oot,content_3498_2088:()=>Uot,content_3498_2090:()=>Vot,content_3498_2092:()=>Qot,content_3498_2094:()=>$ot,content_3498_2096:()=>Kot,content_3498_2098:()=>tpt,content_3498_210:()=>nA,content_3498_2100:()=>ept,content_3498_2102:()=>ppt,content_3498_2104:()=>spt,content_3498_2106:()=>ipt,content_3498_2108:()=>lpt,content_3498_2110:()=>mpt,content_3498_2112:()=>hpt,content_3498_2114:()=>ypt,content_3498_2116:()=>Mpt,content_3498_2118:()=>_pt,content_3498_212:()=>oA,content_3498_2120:()=>wpt,content_3498_2122:()=>Tpt,content_3498_2124:()=>Cpt,content_3498_2126:()=>Lpt,content_3498_2128:()=>bpt,content_3498_2130:()=>zpt,content_3498_2132:()=>Wpt,content_3498_2134:()=>Spt,content_3498_2136:()=>Ppt,content_3498_2138:()=>Bpt,content_3498_214:()=>rA,content_3498_2140:()=>Opt,content_3498_2142:()=>Upt,content_3498_2144:()=>Vpt,content_3498_2146:()=>Qpt,content_3498_2148:()=>$pt,content_3498_2150:()=>Kpt,content_3498_2152:()=>trt,content_3498_2154:()=>ert,content_3498_2156:()=>prt,content_3498_2158:()=>srt,content_3498_216:()=>cA,content_3498_2160:()=>irt,content_3498_2162:()=>lrt,content_3498_2164:()=>mrt,content_3498_2166:()=>hrt,content_3498_2168:()=>yrt,content_3498_2170:()=>Mrt,content_3498_2172:()=>_rt,content_3498_2174:()=>wrt,content_3498_2176:()=>Trt,content_3498_2178:()=>Crt,content_3498_218:()=>aA,content_3498_2180:()=>Lrt,content_3498_2182:()=>brt,content_3498_2184:()=>zrt,content_3498_2186:()=>Wrt,content_3498_2188:()=>Srt,content_3498_2190:()=>Prt,content_3498_2192:()=>Brt,content_3498_2194:()=>Ort,content_3498_2196:()=>Urt,content_3498_2198:()=>Vrt,content_3498_22:()=>ZZ,content_3498_220:()=>uA,content_3498_2200:()=>Qrt,content_3498_2202:()=>$rt,content_3498_2204:()=>Krt,content_3498_2206:()=>tst,content_3498_2208:()=>est,content_3498_2210:()=>pst,content_3498_2212:()=>sst,content_3498_2214:()=>ist,content_3498_2216:()=>lst,content_3498_2218:()=>mst,content_3498_222:()=>dA,content_3498_2220:()=>hst,content_3498_2222:()=>yst,content_3498_2224:()=>Mst,content_3498_2226:()=>_st,content_3498_2228:()=>wst,content_3498_2230:()=>Tst,content_3498_2232:()=>Cst,content_3498_2234:()=>Lst,content_3498_2236:()=>bst,content_3498_2238:()=>zst,content_3498_224:()=>kA,content_3498_2240:()=>Wst,content_3498_2242:()=>Sst,content_3498_2244:()=>Pst,content_3498_2246:()=>Bst,content_3498_2248:()=>Ost,content_3498_2250:()=>Ust,content_3498_2252:()=>Vst,content_3498_2254:()=>Qst,content_3498_2256:()=>$st,content_3498_2258:()=>Kst,content_3498_226:()=>fA,content_3498_2260:()=>tct,content_3498_2262:()=>ect,content_3498_2264:()=>pct,content_3498_2266:()=>sct,content_3498_2268:()=>ict,content_3498_2270:()=>lct,content_3498_2272:()=>mct,content_3498_2274:()=>hct,content_3498_2276:()=>yct,content_3498_2278:()=>Mct,content_3498_228:()=>DA,content_3498_2280:()=>_ct,content_3498_2282:()=>wct,content_3498_2284:()=>Tct,content_3498_2286:()=>Cct,content_3498_2288:()=>Lct,content_3498_2290:()=>bct,content_3498_2292:()=>zct,content_3498_2294:()=>Wct,content_3498_2296:()=>Sct,content_3498_2298:()=>Pct,content_3498_230:()=>XA,content_3498_2300:()=>Bct,content_3498_2302:()=>Oct,content_3498_2304:()=>Uct,content_3498_2306:()=>Vct,content_3498_2308:()=>Qct,content_3498_2310:()=>$ct,content_3498_2312:()=>Kct,content_3498_2314:()=>tit,content_3498_2316:()=>eit,content_3498_2318:()=>pit,content_3498_232:()=>gA,content_3498_2320:()=>sit,content_3498_2322:()=>iit,content_3498_2324:()=>lit,content_3498_2326:()=>mit,content_3498_2328:()=>hit,content_3498_2330:()=>yit,content_3498_2332:()=>Mit,content_3498_2334:()=>_it,content_3498_2336:()=>wit,content_3498_2338:()=>Tit,content_3498_234:()=>xA,content_3498_2340:()=>Cit,content_3498_2342:()=>Lit,content_3498_2344:()=>bit,content_3498_2346:()=>zit,content_3498_2348:()=>Wit,content_3498_2350:()=>Sit,content_3498_2352:()=>Pit,content_3498_2354:()=>Bit,content_3498_2356:()=>Oit,content_3498_2358:()=>Uit,content_3498_236:()=>vA,content_3498_2360:()=>Vit,content_3498_2362:()=>Qit,content_3498_2364:()=>$it,content_3498_2366:()=>Kit,content_3498_2368:()=>tat,content_3498_2370:()=>eat,content_3498_2372:()=>pat,content_3498_2374:()=>sat,content_3498_2376:()=>iat,content_3498_2378:()=>lat,content_3498_238:()=>ZA,content_3498_2380:()=>mat,content_3498_2382:()=>hat,content_3498_2384:()=>yat,content_3498_2386:()=>Mat,content_3498_2388:()=>_at,content_3498_2390:()=>wat,content_3498_2392:()=>Tat,content_3498_2394:()=>Cat,content_3498_2396:()=>Lat,content_3498_2398:()=>bat,content_3498_24:()=>NZ,content_3498_240:()=>NA,content_3498_2400:()=>zat,content_3498_2402:()=>Wat,content_3498_2404:()=>Sat,content_3498_2406:()=>Pat,content_3498_2408:()=>Bat,content_3498_2410:()=>Oat,content_3498_2412:()=>Uat,content_3498_2414:()=>Vat,content_3498_2416:()=>Qat,content_3498_2418:()=>$at,content_3498_242:()=>AA,content_3498_2420:()=>Kat,content_3498_2422:()=>tlt,content_3498_2424:()=>elt,content_3498_2426:()=>plt,content_3498_2428:()=>slt,content_3498_2430:()=>ilt,content_3498_2432:()=>llt,content_3498_2434:()=>mlt,content_3498_2436:()=>hlt,content_3498_2438:()=>ylt,content_3498_244:()=>RA,content_3498_2440:()=>Mlt,content_3498_2442:()=>_lt,content_3498_2444:()=>wlt,content_3498_2446:()=>Tlt,content_3498_2448:()=>Clt,content_3498_2450:()=>Llt,content_3498_2452:()=>blt,content_3498_2454:()=>zlt,content_3498_2456:()=>Wlt,content_3498_2458:()=>Slt,content_3498_246:()=>IA,content_3498_2460:()=>Plt,content_3498_2462:()=>Blt,content_3498_2464:()=>Olt,content_3498_2466:()=>Ult,content_3498_2468:()=>Vlt,content_3498_2470:()=>Qlt,content_3498_2472:()=>$lt,content_3498_2474:()=>Klt,content_3498_2476:()=>tut,content_3498_2478:()=>eut,content_3498_248:()=>EA,content_3498_2480:()=>put,content_3498_2482:()=>sut,content_3498_2484:()=>iut,content_3498_2486:()=>lut,content_3498_2488:()=>mut,content_3498_2490:()=>hut,content_3498_2492:()=>yut,content_3498_2494:()=>Mut,content_3498_2496:()=>_ut,content_3498_2498:()=>wut,content_3498_250:()=>GA,content_3498_2500:()=>Tut,content_3498_2502:()=>Cut,content_3498_2504:()=>Lut,content_3498_2506:()=>but,content_3498_2508:()=>zut,content_3498_2510:()=>Wut,content_3498_2512:()=>Sut,content_3498_2514:()=>Put,content_3498_2516:()=>But,content_3498_2518:()=>Out,content_3498_252:()=>FA,content_3498_2520:()=>Uut,content_3498_2522:()=>Vut,content_3498_2524:()=>Qut,content_3498_2526:()=>$ut,content_3498_2528:()=>Kut,content_3498_2530:()=>tmt,content_3498_2532:()=>emt,content_3498_2534:()=>pmt,content_3498_2536:()=>smt,content_3498_2538:()=>imt,content_3498_254:()=>qA,content_3498_2540:()=>lmt,content_3498_2542:()=>mmt,content_3498_2544:()=>hmt,content_3498_2546:()=>ymt,content_3498_2548:()=>Mmt,content_3498_2550:()=>_mt,content_3498_2552:()=>wmt,content_3498_2554:()=>Tmt,content_3498_2556:()=>Cmt,content_3498_2558:()=>Lmt,content_3498_256:()=>jA,content_3498_2560:()=>bmt,content_3498_2562:()=>zmt,content_3498_2564:()=>Wmt,content_3498_2566:()=>Smt,content_3498_2568:()=>Pmt,content_3498_2570:()=>Bmt,content_3498_2572:()=>Omt,content_3498_2574:()=>Umt,content_3498_2576:()=>Vmt,content_3498_2578:()=>Qmt,content_3498_258:()=>HA,content_3498_2580:()=>$mt,content_3498_2582:()=>Kmt,content_3498_2584:()=>tdt,content_3498_2586:()=>edt,content_3498_2588:()=>pdt,content_3498_2590:()=>sdt,content_3498_2592:()=>idt,content_3498_2594:()=>ldt,content_3498_2596:()=>mdt,content_3498_2598:()=>hdt,content_3498_26:()=>AZ,content_3498_260:()=>YA,content_3498_2600:()=>ydt,content_3498_2602:()=>Mdt,content_3498_2604:()=>_dt,content_3498_2606:()=>wdt,content_3498_2608:()=>Tdt,content_3498_2610:()=>Cdt,content_3498_2612:()=>Ldt,content_3498_2614:()=>bdt,content_3498_2616:()=>zdt,content_3498_2618:()=>Wdt,content_3498_262:()=>JA,content_3498_2620:()=>Sdt,content_3498_2622:()=>Pdt,content_3498_2624:()=>Bdt,content_3498_2626:()=>Odt,content_3498_2628:()=>Udt,content_3498_2630:()=>Vdt,content_3498_2632:()=>Qdt,content_3498_2634:()=>$dt,content_3498_2636:()=>Kdt,content_3498_2638:()=>tht,content_3498_264:()=>nW,content_3498_2640:()=>eht,content_3498_2642:()=>pht,content_3498_2644:()=>sht,content_3498_2646:()=>iht,content_3498_2648:()=>lht,content_3498_2650:()=>mht,content_3498_2652:()=>hht,content_3498_2654:()=>yht,content_3498_2656:()=>Mht,content_3498_2658:()=>_ht,content_3498_266:()=>oW,content_3498_2660:()=>wht,content_3498_2662:()=>Tht,content_3498_2664:()=>Cht,content_3498_2666:()=>Lht,content_3498_2668:()=>bht,content_3498_2670:()=>zht,content_3498_2672:()=>Wht,content_3498_2674:()=>Sht,content_3498_2676:()=>Pht,content_3498_2678:()=>Bht,content_3498_268:()=>rW,content_3498_2680:()=>Oht,content_3498_2682:()=>Uht,content_3498_2684:()=>Vht,content_3498_2686:()=>Qht,content_3498_2688:()=>$ht,content_3498_2690:()=>Kht,content_3498_2692:()=>tkt,content_3498_2694:()=>ekt,content_3498_2696:()=>pkt,content_3498_2698:()=>skt,content_3498_270:()=>cW,content_3498_2700:()=>ikt,content_3498_2702:()=>lkt,content_3498_2704:()=>mkt,content_3498_2706:()=>hkt,content_3498_2708:()=>ykt,content_3498_2710:()=>Mkt,content_3498_2712:()=>_kt,content_3498_2714:()=>wkt,content_3498_2716:()=>Tkt,content_3498_2718:()=>Ckt,content_3498_272:()=>aW,content_3498_2720:()=>Lkt,content_3498_2722:()=>bkt,content_3498_2724:()=>zkt,content_3498_2726:()=>Wkt,content_3498_2728:()=>Skt,content_3498_2730:()=>Pkt,content_3498_2732:()=>Bkt,content_3498_2734:()=>Okt,content_3498_2736:()=>Ukt,content_3498_2738:()=>Vkt,content_3498_274:()=>uW,content_3498_2740:()=>Qkt,content_3498_2742:()=>$kt,content_3498_2744:()=>Kkt,content_3498_2746:()=>tyt,content_3498_2748:()=>eyt,content_3498_2750:()=>pyt,content_3498_2752:()=>syt,content_3498_2754:()=>iyt,content_3498_2756:()=>lyt,content_3498_2758:()=>myt,content_3498_276:()=>dW,content_3498_2760:()=>hyt,content_3498_2762:()=>yyt,content_3498_2764:()=>Myt,content_3498_2766:()=>_yt,content_3498_2768:()=>wyt,content_3498_2770:()=>Tyt,content_3498_2772:()=>Cyt,content_3498_2774:()=>Lyt,content_3498_2776:()=>byt,content_3498_2778:()=>zyt,content_3498_278:()=>kW,content_3498_2780:()=>Wyt,content_3498_2782:()=>Syt,content_3498_2784:()=>Pyt,content_3498_2786:()=>Byt,content_3498_2788:()=>Oyt,content_3498_2790:()=>Uyt,content_3498_2792:()=>Vyt,content_3498_2794:()=>Qyt,content_3498_2796:()=>$yt,content_3498_2798:()=>Kyt,content_3498_28:()=>RZ,content_3498_280:()=>fW,content_3498_2800:()=>tft,content_3498_2802:()=>eft,content_3498_2804:()=>pft,content_3498_2806:()=>sft,content_3498_2808:()=>ift,content_3498_2810:()=>lft,content_3498_2812:()=>mft,content_3498_2814:()=>hft,content_3498_2816:()=>yft,content_3498_2818:()=>Mft,content_3498_282:()=>DW,content_3498_2820:()=>_ft,content_3498_2822:()=>wft,content_3498_2824:()=>Tft,content_3498_2826:()=>Cft,content_3498_2828:()=>Lft,content_3498_2830:()=>bft,content_3498_2832:()=>zft,content_3498_2834:()=>Wft,content_3498_2836:()=>Sft,content_3498_2838:()=>Pft,content_3498_284:()=>XW,content_3498_2840:()=>Bft,content_3498_2842:()=>Oft,content_3498_2844:()=>Uft,content_3498_2846:()=>Vft,content_3498_2848:()=>Qft,content_3498_2850:()=>$ft,content_3498_2852:()=>Kft,content_3498_2854:()=>tMt,content_3498_2856:()=>eMt,content_3498_2858:()=>pMt,content_3498_286:()=>gW,content_3498_2860:()=>sMt,content_3498_2862:()=>iMt,content_3498_2864:()=>lMt,content_3498_2866:()=>mMt,content_3498_2868:()=>hMt,content_3498_2870:()=>yMt,content_3498_2872:()=>MMt,content_3498_2874:()=>_Mt,content_3498_2876:()=>wMt,content_3498_2878:()=>TMt,content_3498_288:()=>xW,content_3498_2880:()=>CMt,content_3498_2882:()=>LMt,content_3498_2884:()=>bMt,content_3498_2886:()=>zMt,content_3498_2888:()=>WMt,content_3498_2890:()=>SMt,content_3498_2892:()=>PMt,content_3498_2894:()=>BMt,content_3498_2896:()=>OMt,content_3498_2898:()=>UMt,content_3498_290:()=>vW,content_3498_2900:()=>VMt,content_3498_2902:()=>QMt,content_3498_2904:()=>$Mt,content_3498_2906:()=>KMt,content_3498_2908:()=>tDt,content_3498_2910:()=>eDt,content_3498_2912:()=>pDt,content_3498_2914:()=>sDt,content_3498_2916:()=>iDt,content_3498_2918:()=>lDt,content_3498_292:()=>ZW,content_3498_2920:()=>mDt,content_3498_2922:()=>hDt,content_3498_2924:()=>yDt,content_3498_2926:()=>MDt,content_3498_2928:()=>_Dt,content_3498_2930:()=>wDt,content_3498_2932:()=>TDt,content_3498_2934:()=>CDt,content_3498_2936:()=>LDt,content_3498_2938:()=>bDt,content_3498_294:()=>NW,content_3498_2940:()=>zDt,content_3498_2942:()=>WDt,content_3498_2944:()=>SDt,content_3498_2946:()=>PDt,content_3498_2948:()=>BDt,content_3498_2950:()=>ODt,content_3498_2952:()=>UDt,content_3498_2954:()=>VDt,content_3498_2956:()=>QDt,content_3498_2958:()=>$Dt,content_3498_296:()=>AW,content_3498_2960:()=>KDt,content_3498_2962:()=>t_t,content_3498_2964:()=>e_t,content_3498_2966:()=>p_t,content_3498_2968:()=>s_t,content_3498_2970:()=>i_t,content_3498_2972:()=>l_t,content_3498_2974:()=>m_t,content_3498_2976:()=>h_t,content_3498_2978:()=>y_t,content_3498_298:()=>RW,content_3498_2980:()=>M_t,content_3498_2982:()=>__t,content_3498_2984:()=>w_t,content_3498_2986:()=>T_t,content_3498_2988:()=>C_t,content_3498_2990:()=>L_t,content_3498_2992:()=>b_t,content_3498_2994:()=>z_t,content_3498_2996:()=>W_t,content_3498_2998:()=>S_t,content_3498_30:()=>IZ,content_3498_300:()=>IW,content_3498_3000:()=>P_t,content_3498_3002:()=>B_t,content_3498_3004:()=>O_t,content_3498_3006:()=>U_t,content_3498_3008:()=>V_t,content_3498_3010:()=>Q_t,content_3498_3012:()=>$_t,content_3498_3014:()=>K_t,content_3498_3016:()=>tXt,content_3498_3018:()=>eXt,content_3498_302:()=>EW,content_3498_3020:()=>pXt,content_3498_3022:()=>sXt,content_3498_3024:()=>iXt,content_3498_3026:()=>lXt,content_3498_3028:()=>mXt,content_3498_3030:()=>hXt,content_3498_3032:()=>yXt,content_3498_3034:()=>MXt,content_3498_3036:()=>_Xt,content_3498_3038:()=>wXt,content_3498_304:()=>GW,content_3498_3040:()=>TXt,content_3498_3042:()=>CXt,content_3498_3044:()=>LXt,content_3498_3046:()=>bXt,content_3498_3048:()=>zXt,content_3498_3050:()=>WXt,content_3498_3052:()=>SXt,content_3498_3054:()=>PXt,content_3498_3056:()=>BXt,content_3498_3058:()=>OXt,content_3498_306:()=>FW,content_3498_3060:()=>UXt,content_3498_3062:()=>VXt,content_3498_3064:()=>QXt,content_3498_3066:()=>$Xt,content_3498_3068:()=>KXt,content_3498_3070:()=>twt,content_3498_3072:()=>ewt,content_3498_3074:()=>pwt,content_3498_3076:()=>swt,content_3498_3078:()=>iwt,content_3498_308:()=>qW,content_3498_3080:()=>lwt,content_3498_3082:()=>mwt,content_3498_3084:()=>hwt,content_3498_3086:()=>ywt,content_3498_3088:()=>Mwt,content_3498_3090:()=>_wt,content_3498_3092:()=>wwt,content_3498_3094:()=>Twt,content_3498_3096:()=>Cwt,content_3498_3098:()=>Lwt,content_3498_310:()=>jW,content_3498_3100:()=>bwt,content_3498_3102:()=>zwt,content_3498_3104:()=>Wwt,content_3498_3106:()=>Swt,content_3498_3108:()=>Pwt,content_3498_3110:()=>Bwt,content_3498_3112:()=>Owt,content_3498_3114:()=>Uwt,content_3498_3116:()=>Vwt,content_3498_3118:()=>Qwt,content_3498_312:()=>HW,content_3498_3120:()=>$wt,content_3498_3122:()=>Kwt,content_3498_3124:()=>tgt,content_3498_3126:()=>egt,content_3498_3128:()=>pgt,content_3498_3130:()=>sgt,content_3498_3132:()=>igt,content_3498_3134:()=>lgt,content_3498_3136:()=>mgt,content_3498_3138:()=>hgt,content_3498_314:()=>YW,content_3498_3140:()=>ygt,content_3498_3142:()=>Mgt,content_3498_3144:()=>_gt,content_3498_3146:()=>wgt,content_3498_3148:()=>Tgt,content_3498_3150:()=>Cgt,content_3498_3152:()=>Lgt,content_3498_3154:()=>bgt,content_3498_3156:()=>zgt,content_3498_3158:()=>Wgt,content_3498_316:()=>JW,content_3498_3160:()=>Sgt,content_3498_3162:()=>Pgt,content_3498_3164:()=>Bgt,content_3498_3166:()=>Ogt,content_3498_3168:()=>Ugt,content_3498_3170:()=>Vgt,content_3498_3172:()=>Qgt,content_3498_3174:()=>$gt,content_3498_3176:()=>Kgt,content_3498_3178:()=>tTt,content_3498_318:()=>nR,content_3498_3180:()=>eTt,content_3498_3182:()=>pTt,content_3498_3184:()=>sTt,content_3498_3186:()=>iTt,content_3498_3188:()=>lTt,content_3498_3190:()=>mTt,content_3498_3192:()=>hTt,content_3498_3194:()=>yTt,content_3498_3196:()=>MTt,content_3498_3198:()=>_Tt,content_3498_32:()=>EZ,content_3498_320:()=>oR,content_3498_3200:()=>wTt,content_3498_3202:()=>TTt,content_3498_3204:()=>CTt,content_3498_3206:()=>LTt,content_3498_3208:()=>bTt,content_3498_3210:()=>zTt,content_3498_3212:()=>WTt,content_3498_3214:()=>STt,content_3498_3216:()=>PTt,content_3498_3218:()=>BTt,content_3498_322:()=>rR,content_3498_3220:()=>OTt,content_3498_3222:()=>UTt,content_3498_3224:()=>VTt,content_3498_3226:()=>QTt,content_3498_3228:()=>$Tt,content_3498_3230:()=>KTt,content_3498_3232:()=>txt,content_3498_3234:()=>ext,content_3498_3236:()=>pxt,content_3498_3238:()=>sxt,content_3498_324:()=>cR,content_3498_3240:()=>ixt,content_3498_3242:()=>lxt,content_3498_3244:()=>mxt,content_3498_3246:()=>hxt,content_3498_3248:()=>yxt,content_3498_3250:()=>Mxt,content_3498_3252:()=>_xt,content_3498_3254:()=>wxt,content_3498_3256:()=>Txt,content_3498_3258:()=>Cxt,content_3498_326:()=>aR,content_3498_3260:()=>Lxt,content_3498_3262:()=>bxt,content_3498_3264:()=>zxt,content_3498_3266:()=>Wxt,content_3498_3268:()=>Sxt,content_3498_3270:()=>Pxt,content_3498_3272:()=>Bxt,content_3498_3274:()=>Oxt,content_3498_3276:()=>Uxt,content_3498_3278:()=>Vxt,content_3498_328:()=>uR,content_3498_3280:()=>Qxt,content_3498_3282:()=>$xt,content_3498_3284:()=>Kxt,content_3498_3286:()=>tCt,content_3498_3288:()=>eCt,content_3498_3290:()=>pCt,content_3498_3292:()=>sCt,content_3498_3294:()=>iCt,content_3498_3296:()=>lCt,content_3498_3298:()=>mCt,content_3498_330:()=>dR,content_3498_3300:()=>hCt,content_3498_3302:()=>yCt,content_3498_3304:()=>MCt,content_3498_3306:()=>_Ct,content_3498_3308:()=>wCt,content_3498_3310:()=>TCt,content_3498_3312:()=>CCt,content_3498_3314:()=>LCt,content_3498_3316:()=>bCt,content_3498_3318:()=>zCt,content_3498_332:()=>kR,content_3498_3320:()=>WCt,content_3498_3322:()=>SCt,content_3498_3324:()=>PCt,content_3498_3326:()=>BCt,content_3498_3328:()=>OCt,content_3498_3330:()=>UCt,content_3498_3332:()=>VCt,content_3498_3334:()=>QCt,content_3498_3336:()=>$Ct,content_3498_3338:()=>KCt,content_3498_334:()=>fR,content_3498_3340:()=>tvt,content_3498_3342:()=>evt,content_3498_3344:()=>pvt,content_3498_3346:()=>svt,content_3498_3348:()=>ivt,content_3498_3350:()=>lvt,content_3498_3352:()=>mvt,content_3498_3354:()=>hvt,content_3498_3356:()=>yvt,content_3498_3358:()=>Mvt,content_3498_336:()=>DR,content_3498_3360:()=>_vt,content_3498_3362:()=>wvt,content_3498_3364:()=>Tvt,content_3498_3366:()=>Cvt,content_3498_3368:()=>Lvt,content_3498_3370:()=>bvt,content_3498_3372:()=>zvt,content_3498_3374:()=>Wvt,content_3498_3376:()=>Svt,content_3498_3378:()=>Pvt,content_3498_338:()=>XR,content_3498_3380:()=>Bvt,content_3498_3382:()=>Ovt,content_3498_3384:()=>Uvt,content_3498_3386:()=>Vvt,content_3498_3388:()=>Qvt,content_3498_3390:()=>$vt,content_3498_3392:()=>Kvt,content_3498_3394:()=>tLt,content_3498_3396:()=>eLt,content_3498_3398:()=>pLt,content_3498_34:()=>GZ,content_3498_340:()=>gR,content_3498_3400:()=>sLt,content_3498_3402:()=>iLt,content_3498_3404:()=>lLt,content_3498_3406:()=>mLt,content_3498_3408:()=>hLt,content_3498_3410:()=>yLt,content_3498_3412:()=>MLt,content_3498_3414:()=>_Lt,content_3498_3416:()=>wLt,content_3498_3418:()=>TLt,content_3498_342:()=>xR,content_3498_3420:()=>CLt,content_3498_3422:()=>LLt,content_3498_3424:()=>bLt,content_3498_3426:()=>zLt,content_3498_3428:()=>WLt,content_3498_3430:()=>SLt,content_3498_3432:()=>PLt,content_3498_3434:()=>BLt,content_3498_3436:()=>OLt,content_3498_3438:()=>ULt,content_3498_344:()=>vR,content_3498_3440:()=>VLt,content_3498_3442:()=>QLt,content_3498_3444:()=>$Lt,content_3498_3446:()=>KLt,content_3498_3448:()=>tZt,content_3498_3450:()=>eZt,content_3498_3452:()=>pZt,content_3498_3454:()=>sZt,content_3498_3456:()=>iZt,content_3498_3458:()=>lZt,content_3498_346:()=>ZR,content_3498_3460:()=>mZt,content_3498_3462:()=>hZt,content_3498_3464:()=>yZt,content_3498_3466:()=>MZt,content_3498_3468:()=>_Zt,content_3498_3470:()=>wZt,content_3498_3472:()=>TZt,content_3498_3474:()=>CZt,content_3498_3476:()=>LZt,content_3498_3478:()=>bZt,content_3498_348:()=>NR,content_3498_3480:()=>zZt,content_3498_3482:()=>WZt,content_3498_3484:()=>SZt,content_3498_3486:()=>PZt,content_3498_3488:()=>BZt,content_3498_3490:()=>OZt,content_3498_3492:()=>UZt,content_3498_3494:()=>VZt,content_3498_3496:()=>QZt,content_3498_3498:()=>$Zt,content_3498_350:()=>AR,content_3498_3500:()=>KZt,content_3498_3502:()=>tbt,content_3498_3504:()=>ebt,content_3498_3506:()=>pbt,content_3498_3508:()=>sbt,content_3498_3510:()=>ibt,content_3498_3512:()=>lbt,content_3498_3514:()=>mbt,content_3498_3516:()=>hbt,content_3498_3518:()=>ybt,content_3498_352:()=>RR,content_3498_3520:()=>Mbt,content_3498_3522:()=>_bt,content_3498_3524:()=>wbt,content_3498_3526:()=>Tbt,content_3498_3528:()=>Cbt,content_3498_3530:()=>Lbt,content_3498_3532:()=>bbt,content_3498_3534:()=>zbt,content_3498_3536:()=>Wbt,content_3498_3538:()=>Sbt,content_3498_354:()=>IR,content_3498_3540:()=>Pbt,content_3498_3542:()=>Bbt,content_3498_3544:()=>Obt,content_3498_3546:()=>Ubt,content_3498_3548:()=>Vbt,content_3498_3550:()=>Qbt,content_3498_3552:()=>$bt,content_3498_3554:()=>Kbt,content_3498_3556:()=>tNt,content_3498_3558:()=>eNt,content_3498_356:()=>ER,content_3498_3560:()=>pNt,content_3498_3562:()=>sNt,content_3498_3564:()=>iNt,content_3498_3566:()=>lNt,content_3498_3568:()=>mNt,content_3498_3570:()=>hNt,content_3498_3572:()=>yNt,content_3498_3574:()=>MNt,content_3498_3576:()=>_Nt,content_3498_3578:()=>wNt,content_3498_358:()=>GR,content_3498_3580:()=>TNt,content_3498_3582:()=>CNt,content_3498_3584:()=>LNt,content_3498_3586:()=>bNt,content_3498_3588:()=>zNt,content_3498_3590:()=>WNt,content_3498_3592:()=>SNt,content_3498_3594:()=>PNt,content_3498_3596:()=>BNt,content_3498_3598:()=>ONt,content_3498_36:()=>FZ,content_3498_360:()=>FR,content_3498_3600:()=>UNt,content_3498_3602:()=>VNt,content_3498_3604:()=>QNt,content_3498_3606:()=>$Nt,content_3498_3608:()=>KNt,content_3498_3610:()=>tzt,content_3498_3612:()=>ezt,content_3498_3614:()=>pzt,content_3498_3616:()=>szt,content_3498_3618:()=>izt,content_3498_362:()=>qR,content_3498_3620:()=>lzt,content_3498_3622:()=>mzt,content_3498_3624:()=>hzt,content_3498_3626:()=>yzt,content_3498_3628:()=>Mzt,content_3498_3630:()=>_zt,content_3498_3632:()=>wzt,content_3498_3634:()=>Tzt,content_3498_3636:()=>Czt,content_3498_3638:()=>Lzt,content_3498_364:()=>jR,content_3498_3640:()=>bzt,content_3498_3642:()=>zzt,content_3498_3644:()=>Wzt,content_3498_3646:()=>Szt,content_3498_3648:()=>Pzt,content_3498_3650:()=>Bzt,content_3498_3652:()=>Ozt,content_3498_3654:()=>Uzt,content_3498_3656:()=>Vzt,content_3498_3658:()=>Qzt,content_3498_366:()=>HR,content_3498_3660:()=>$zt,content_3498_3662:()=>Kzt,content_3498_3664:()=>tAt,content_3498_3666:()=>eAt,content_3498_3668:()=>pAt,content_3498_3670:()=>sAt,content_3498_3672:()=>iAt,content_3498_3674:()=>lAt,content_3498_3676:()=>mAt,content_3498_3678:()=>hAt,content_3498_368:()=>YR,content_3498_3680:()=>yAt,content_3498_3682:()=>MAt,content_3498_3684:()=>_At,content_3498_3686:()=>wAt,content_3498_3688:()=>TAt,content_3498_3690:()=>CAt,content_3498_3692:()=>LAt,content_3498_3694:()=>bAt,content_3498_3696:()=>zAt,content_3498_3698:()=>WAt,content_3498_370:()=>JR,content_3498_3700:()=>SAt,content_3498_3702:()=>PAt,content_3498_3704:()=>BAt,content_3498_3706:()=>OAt,content_3498_3708:()=>UAt,content_3498_3710:()=>VAt,content_3498_3712:()=>QAt,content_3498_3714:()=>$At,content_3498_3716:()=>KAt,content_3498_3718:()=>tWt,content_3498_372:()=>nS,content_3498_3720:()=>eWt,content_3498_3722:()=>pWt,content_3498_3724:()=>sWt,content_3498_3726:()=>iWt,content_3498_3728:()=>lWt,content_3498_3730:()=>mWt,content_3498_3732:()=>hWt,content_3498_3734:()=>yWt,content_3498_3736:()=>MWt,content_3498_3738:()=>_Wt,content_3498_374:()=>oS,content_3498_3740:()=>wWt,content_3498_3742:()=>TWt,content_3498_3744:()=>CWt,content_3498_3746:()=>LWt,content_3498_3748:()=>bWt,content_3498_3750:()=>zWt,content_3498_3752:()=>WWt,content_3498_3754:()=>SWt,content_3498_3756:()=>PWt,content_3498_3758:()=>BWt,content_3498_376:()=>rS,content_3498_3760:()=>OWt,content_3498_3762:()=>UWt,content_3498_3764:()=>VWt,content_3498_3766:()=>QWt,content_3498_3768:()=>$Wt,content_3498_3770:()=>KWt,content_3498_3772:()=>tRt,content_3498_3774:()=>eRt,content_3498_3776:()=>pRt,content_3498_3778:()=>sRt,content_3498_378:()=>cS,content_3498_3780:()=>iRt,content_3498_3782:()=>lRt,content_3498_3784:()=>mRt,content_3498_3786:()=>hRt,content_3498_3788:()=>yRt,content_3498_3790:()=>MRt,content_3498_3792:()=>_Rt,content_3498_3794:()=>wRt,content_3498_3796:()=>TRt,content_3498_3798:()=>CRt,content_3498_38:()=>qZ,content_3498_380:()=>aS,content_3498_3800:()=>LRt,content_3498_3802:()=>bRt,content_3498_3804:()=>zRt,content_3498_3806:()=>WRt,content_3498_3808:()=>SRt,content_3498_3810:()=>PRt,content_3498_3812:()=>BRt,content_3498_3814:()=>ORt,content_3498_3816:()=>URt,content_3498_3818:()=>VRt,content_3498_382:()=>uS,content_3498_3820:()=>QRt,content_3498_3822:()=>$Rt,content_3498_3824:()=>KRt,content_3498_3826:()=>tSt,content_3498_3828:()=>eSt,content_3498_3830:()=>pSt,content_3498_3832:()=>sSt,content_3498_3834:()=>iSt,content_3498_3836:()=>lSt,content_3498_3838:()=>mSt,content_3498_384:()=>dS,content_3498_3840:()=>hSt,content_3498_3842:()=>ySt,content_3498_3844:()=>MSt,content_3498_3846:()=>_St,content_3498_3848:()=>wSt,content_3498_3850:()=>TSt,content_3498_3852:()=>CSt,content_3498_3854:()=>LSt,content_3498_3856:()=>bSt,content_3498_3858:()=>zSt,content_3498_386:()=>kS,content_3498_3860:()=>WSt,content_3498_3862:()=>SSt,content_3498_3864:()=>PSt,content_3498_3866:()=>BSt,content_3498_3868:()=>OSt,content_3498_3870:()=>USt,content_3498_3872:()=>VSt,content_3498_3874:()=>QSt,content_3498_3876:()=>$St,content_3498_3878:()=>KSt,content_3498_388:()=>fS,content_3498_3880:()=>tIt,content_3498_3882:()=>eIt,content_3498_3884:()=>pIt,content_3498_3886:()=>sIt,content_3498_3888:()=>iIt,content_3498_3890:()=>lIt,content_3498_3892:()=>mIt,content_3498_3894:()=>hIt,content_3498_3896:()=>yIt,content_3498_3898:()=>MIt,content_3498_390:()=>DS,content_3498_3900:()=>_It,content_3498_3902:()=>wIt,content_3498_3904:()=>TIt,content_3498_3906:()=>CIt,content_3498_3908:()=>LIt,content_3498_3910:()=>bIt,content_3498_3912:()=>zIt,content_3498_3914:()=>WIt,content_3498_3916:()=>SIt,content_3498_3918:()=>PIt,content_3498_392:()=>XS,content_3498_3920:()=>BIt,content_3498_3922:()=>OIt,content_3498_3924:()=>UIt,content_3498_3926:()=>VIt,content_3498_3928:()=>QIt,content_3498_3930:()=>$It,content_3498_3932:()=>KIt,content_3498_3934:()=>tPt,content_3498_3936:()=>ePt,content_3498_3938:()=>pPt,content_3498_394:()=>gS,content_3498_3940:()=>sPt,content_3498_3942:()=>iPt,content_3498_3944:()=>lPt,content_3498_3946:()=>mPt,content_3498_3948:()=>hPt,content_3498_3950:()=>yPt,content_3498_3952:()=>MPt,content_3498_3954:()=>_Pt,content_3498_3956:()=>wPt,content_3498_3958:()=>TPt,content_3498_396:()=>xS,content_3498_3960:()=>CPt,content_3498_3962:()=>LPt,content_3498_3964:()=>bPt,content_3498_3966:()=>zPt,content_3498_3968:()=>WPt,content_3498_3970:()=>SPt,content_3498_3972:()=>PPt,content_3498_3974:()=>BPt,content_3498_3976:()=>OPt,content_3498_3978:()=>UPt,content_3498_398:()=>vS,content_3498_3980:()=>VPt,content_3498_3982:()=>QPt,content_3498_3984:()=>$Pt,content_3498_3986:()=>KPt,content_3498_3988:()=>tEt,content_3498_3990:()=>eEt,content_3498_3992:()=>pEt,content_3498_3994:()=>sEt,content_3498_3996:()=>iEt,content_3498_3998:()=>lEt,content_3498_4:()=>uZ,content_3498_40:()=>jZ,content_3498_400:()=>ZS,content_3498_4000:()=>mEt,content_3498_4002:()=>hEt,content_3498_4004:()=>yEt,content_3498_4006:()=>MEt,content_3498_4008:()=>_Et,content_3498_4010:()=>wEt,content_3498_4012:()=>TEt,content_3498_4014:()=>CEt,content_3498_4016:()=>LEt,content_3498_4018:()=>bEt,content_3498_402:()=>NS,content_3498_4020:()=>zEt,content_3498_4022:()=>WEt,content_3498_4024:()=>SEt,content_3498_4026:()=>PEt,content_3498_4028:()=>BEt,content_3498_4030:()=>OEt,content_3498_4032:()=>UEt,content_3498_4034:()=>VEt,content_3498_4036:()=>QEt,content_3498_4038:()=>$Et,content_3498_404:()=>AS,content_3498_4040:()=>KEt,content_3498_4042:()=>tBt,content_3498_4044:()=>eBt,content_3498_4046:()=>pBt,content_3498_4048:()=>sBt,content_3498_4050:()=>iBt,content_3498_4052:()=>lBt,content_3498_4054:()=>mBt,content_3498_4056:()=>hBt,content_3498_4058:()=>yBt,content_3498_406:()=>RS,content_3498_4060:()=>MBt,content_3498_4062:()=>_Bt,content_3498_4064:()=>wBt,content_3498_4066:()=>TBt,content_3498_4068:()=>CBt,content_3498_4070:()=>LBt,content_3498_4072:()=>bBt,content_3498_4074:()=>zBt,content_3498_4076:()=>WBt,content_3498_4078:()=>SBt,content_3498_408:()=>IS,content_3498_4080:()=>PBt,content_3498_4082:()=>BBt,content_3498_4084:()=>OBt,content_3498_4086:()=>UBt,content_3498_4088:()=>VBt,content_3498_4090:()=>QBt,content_3498_4092:()=>$Bt,content_3498_4094:()=>KBt,content_3498_4096:()=>tGt,content_3498_4098:()=>eGt,content_3498_410:()=>ES,content_3498_4100:()=>pGt,content_3498_4102:()=>sGt,content_3498_4104:()=>iGt,content_3498_4106:()=>lGt,content_3498_4108:()=>mGt,content_3498_4110:()=>hGt,content_3498_4112:()=>yGt,content_3498_4114:()=>MGt,content_3498_4116:()=>_Gt,content_3498_4118:()=>wGt,content_3498_412:()=>GS,content_3498_4120:()=>TGt,content_3498_4122:()=>CGt,content_3498_4124:()=>LGt,content_3498_4126:()=>bGt,content_3498_4128:()=>zGt,content_3498_4130:()=>WGt,content_3498_4132:()=>SGt,content_3498_4134:()=>PGt,content_3498_4136:()=>BGt,content_3498_4138:()=>OGt,content_3498_414:()=>FS,content_3498_4140:()=>UGt,content_3498_4142:()=>VGt,content_3498_4144:()=>QGt,content_3498_4146:()=>$Gt,content_3498_4148:()=>KGt,content_3498_4150:()=>tOt,content_3498_4152:()=>eOt,content_3498_4154:()=>pOt,content_3498_4156:()=>sOt,content_3498_4158:()=>iOt,content_3498_416:()=>qS,content_3498_4160:()=>lOt,content_3498_4162:()=>mOt,content_3498_4164:()=>hOt,content_3498_4166:()=>yOt,content_3498_4168:()=>MOt,content_3498_4170:()=>_Ot,content_3498_4172:()=>wOt,content_3498_4174:()=>TOt,content_3498_4176:()=>COt,content_3498_4178:()=>LOt,content_3498_418:()=>jS,content_3498_4180:()=>bOt,content_3498_4182:()=>zOt,content_3498_4184:()=>WOt,content_3498_4186:()=>SOt,content_3498_4188:()=>POt,content_3498_4190:()=>BOt,content_3498_4192:()=>OOt,content_3498_4194:()=>UOt,content_3498_4196:()=>VOt,content_3498_4198:()=>QOt,content_3498_42:()=>HZ,content_3498_420:()=>HS,content_3498_4200:()=>$Ot,content_3498_4202:()=>KOt,content_3498_4204:()=>tFt,content_3498_4206:()=>eFt,content_3498_4208:()=>pFt,content_3498_4210:()=>sFt,content_3498_4212:()=>iFt,content_3498_4214:()=>lFt,content_3498_4216:()=>mFt,content_3498_4218:()=>hFt,content_3498_422:()=>YS,content_3498_4220:()=>yFt,content_3498_4222:()=>MFt,content_3498_4224:()=>_Ft,content_3498_4226:()=>wFt,content_3498_4228:()=>TFt,content_3498_4230:()=>CFt,content_3498_4232:()=>LFt,content_3498_4234:()=>bFt,content_3498_4236:()=>zFt,content_3498_4238:()=>WFt,content_3498_424:()=>JS,content_3498_4240:()=>SFt,content_3498_4242:()=>PFt,content_3498_4244:()=>BFt,content_3498_4246:()=>OFt,content_3498_4248:()=>UFt,content_3498_4250:()=>VFt,content_3498_4252:()=>QFt,content_3498_4254:()=>$Ft,content_3498_4256:()=>KFt,content_3498_4258:()=>tUt,content_3498_426:()=>nI,content_3498_4260:()=>eUt,content_3498_4262:()=>pUt,content_3498_4264:()=>sUt,content_3498_4266:()=>iUt,content_3498_4268:()=>lUt,content_3498_4270:()=>mUt,content_3498_4272:()=>hUt,content_3498_4274:()=>yUt,content_3498_4276:()=>MUt,content_3498_4278:()=>_Ut,content_3498_428:()=>oI,content_3498_4280:()=>wUt,content_3498_4282:()=>TUt,content_3498_4284:()=>CUt,content_3498_4286:()=>LUt,content_3498_4288:()=>bUt,content_3498_4290:()=>zUt,content_3498_4292:()=>WUt,content_3498_4294:()=>SUt,content_3498_4296:()=>PUt,content_3498_4298:()=>BUt,content_3498_430:()=>rI,content_3498_4300:()=>OUt,content_3498_4302:()=>UUt,content_3498_4304:()=>VUt,content_3498_4306:()=>QUt,content_3498_4308:()=>$Ut,content_3498_4310:()=>KUt,content_3498_4312:()=>tqt,content_3498_4314:()=>eqt,content_3498_4316:()=>pqt,content_3498_4318:()=>sqt,content_3498_432:()=>cI,content_3498_4320:()=>iqt,content_3498_4322:()=>lqt,content_3498_4324:()=>mqt,content_3498_4326:()=>hqt,content_3498_4328:()=>yqt,content_3498_4330:()=>Mqt,content_3498_4332:()=>_qt,content_3498_4334:()=>wqt,content_3498_4336:()=>Tqt,content_3498_4338:()=>Cqt,content_3498_434:()=>aI,content_3498_4340:()=>Lqt,content_3498_4342:()=>bqt,content_3498_4344:()=>zqt,content_3498_4346:()=>Wqt,content_3498_4348:()=>Sqt,content_3498_4350:()=>Pqt,content_3498_4352:()=>Bqt,content_3498_4354:()=>Oqt,content_3498_4356:()=>Uqt,content_3498_4358:()=>Vqt,content_3498_436:()=>uI,content_3498_4360:()=>Qqt,content_3498_4362:()=>$qt,content_3498_4364:()=>Kqt,content_3498_4366:()=>tVt,content_3498_4368:()=>eVt,content_3498_4370:()=>pVt,content_3498_4372:()=>sVt,content_3498_4374:()=>iVt,content_3498_4376:()=>lVt,content_3498_4378:()=>mVt,content_3498_438:()=>dI,content_3498_4380:()=>hVt,content_3498_4382:()=>yVt,content_3498_4384:()=>MVt,content_3498_4386:()=>_Vt,content_3498_4388:()=>wVt,content_3498_4390:()=>TVt,content_3498_4392:()=>CVt,content_3498_4394:()=>LVt,content_3498_4396:()=>bVt,content_3498_4398:()=>zVt,content_3498_44:()=>YZ,content_3498_440:()=>kI,content_3498_4400:()=>WVt,content_3498_4402:()=>SVt,content_3498_4404:()=>PVt,content_3498_4406:()=>BVt,content_3498_4408:()=>OVt,content_3498_4410:()=>UVt,content_3498_4412:()=>VVt,content_3498_4414:()=>QVt,content_3498_4416:()=>$Vt,content_3498_4418:()=>KVt,content_3498_442:()=>fI,content_3498_4420:()=>tjt,content_3498_4422:()=>ejt,content_3498_4424:()=>pjt,content_3498_4426:()=>sjt,content_3498_4428:()=>ijt,content_3498_4430:()=>ljt,content_3498_4432:()=>mjt,content_3498_4434:()=>hjt,content_3498_4436:()=>yjt,content_3498_4438:()=>Mjt,content_3498_444:()=>DI,content_3498_4440:()=>_jt,content_3498_4442:()=>wjt,content_3498_4444:()=>Tjt,content_3498_4446:()=>Cjt,content_3498_4448:()=>Ljt,content_3498_4450:()=>bjt,content_3498_4452:()=>zjt,content_3498_4454:()=>Wjt,content_3498_4456:()=>Sjt,content_3498_4458:()=>Pjt,content_3498_446:()=>XI,content_3498_4460:()=>Bjt,content_3498_4462:()=>Ojt,content_3498_4464:()=>Ujt,content_3498_4466:()=>Vjt,content_3498_4468:()=>Qjt,content_3498_4470:()=>$jt,content_3498_4472:()=>Kjt,content_3498_4474:()=>tQt,content_3498_4476:()=>eQt,content_3498_4478:()=>pQt,content_3498_448:()=>gI,content_3498_4480:()=>sQt,content_3498_4482:()=>iQt,content_3498_4484:()=>lQt,content_3498_4486:()=>mQt,content_3498_4488:()=>hQt,content_3498_4490:()=>yQt,content_3498_4492:()=>MQt,content_3498_4494:()=>_Qt,content_3498_4496:()=>wQt,content_3498_4498:()=>TQt,content_3498_450:()=>xI,content_3498_4500:()=>CQt,content_3498_4502:()=>LQt,content_3498_4504:()=>bQt,content_3498_4506:()=>zQt,content_3498_4508:()=>WQt,content_3498_4510:()=>SQt,content_3498_4512:()=>PQt,content_3498_4514:()=>BQt,content_3498_4516:()=>OQt,content_3498_4518:()=>UQt,content_3498_452:()=>vI,content_3498_4520:()=>VQt,content_3498_4522:()=>QQt,content_3498_4524:()=>$Qt,content_3498_4526:()=>KQt,content_3498_4528:()=>tHt,content_3498_4530:()=>eHt,content_3498_4532:()=>pHt,content_3498_4534:()=>sHt,content_3498_4536:()=>iHt,content_3498_4538:()=>lHt,content_3498_454:()=>ZI,content_3498_4540:()=>mHt,content_3498_4542:()=>hHt,content_3498_4544:()=>yHt,content_3498_4546:()=>MHt,content_3498_4548:()=>_Ht,content_3498_4550:()=>wHt,content_3498_4552:()=>THt,content_3498_4554:()=>CHt,content_3498_4556:()=>LHt,content_3498_4558:()=>bHt,content_3498_456:()=>NI,content_3498_4560:()=>zHt,content_3498_4562:()=>WHt,content_3498_4564:()=>SHt,content_3498_4566:()=>PHt,content_3498_4568:()=>BHt,content_3498_4570:()=>OHt,content_3498_4572:()=>UHt,content_3498_4574:()=>VHt,content_3498_4576:()=>QHt,content_3498_4578:()=>$Ht,content_3498_458:()=>AI,content_3498_4580:()=>KHt,content_3498_4582:()=>t$t,content_3498_4584:()=>e$t,content_3498_4586:()=>p$t,content_3498_4588:()=>s$t,content_3498_4590:()=>i$t,content_3498_4592:()=>l$t,content_3498_4594:()=>m$t,content_3498_4596:()=>h$t,content_3498_4598:()=>y$t,content_3498_46:()=>JZ,content_3498_460:()=>RI,content_3498_4600:()=>M$t,content_3498_4602:()=>_$t,content_3498_4604:()=>w$t,content_3498_4606:()=>T$t,content_3498_4608:()=>C$t,content_3498_4610:()=>L$t,content_3498_4612:()=>b$t,content_3498_4614:()=>z$t,content_3498_4616:()=>W$t,content_3498_4618:()=>S$t,content_3498_462:()=>II,content_3498_4620:()=>P$t,content_3498_4622:()=>B$t,content_3498_4624:()=>O$t,content_3498_4626:()=>U$t,content_3498_4628:()=>V$t,content_3498_4630:()=>Q$t,content_3498_4632:()=>$$t,content_3498_4634:()=>K$t,content_3498_4636:()=>tYt,content_3498_4638:()=>eYt,content_3498_464:()=>EI,content_3498_4640:()=>pYt,content_3498_4642:()=>sYt,content_3498_4644:()=>iYt,content_3498_4646:()=>lYt,content_3498_4648:()=>mYt,content_3498_4650:()=>hYt,content_3498_4652:()=>yYt,content_3498_4654:()=>MYt,content_3498_4656:()=>_Yt,content_3498_4658:()=>wYt,content_3498_466:()=>GI,content_3498_4660:()=>TYt,content_3498_4662:()=>CYt,content_3498_4664:()=>LYt,content_3498_4666:()=>bYt,content_3498_4668:()=>zYt,content_3498_4670:()=>WYt,content_3498_4672:()=>SYt,content_3498_4674:()=>PYt,content_3498_4676:()=>BYt,content_3498_4678:()=>OYt,content_3498_468:()=>FI,content_3498_4680:()=>UYt,content_3498_4682:()=>VYt,content_3498_4684:()=>QYt,content_3498_4686:()=>$Yt,content_3498_4688:()=>KYt,content_3498_4690:()=>tKt,content_3498_4692:()=>eKt,content_3498_4694:()=>pKt,content_3498_4696:()=>sKt,content_3498_4698:()=>iKt,content_3498_470:()=>qI,content_3498_4700:()=>lKt,content_3498_4702:()=>mKt,content_3498_4704:()=>hKt,content_3498_4706:()=>yKt,content_3498_4708:()=>MKt,content_3498_4710:()=>_Kt,content_3498_4712:()=>wKt,content_3498_4714:()=>TKt,content_3498_4716:()=>CKt,content_3498_4718:()=>LKt,content_3498_472:()=>jI,content_3498_4720:()=>bKt,content_3498_4722:()=>zKt,content_3498_4724:()=>WKt,content_3498_4726:()=>SKt,content_3498_4728:()=>PKt,content_3498_4730:()=>BKt,content_3498_4732:()=>OKt,content_3498_4734:()=>UKt,content_3498_4736:()=>VKt,content_3498_4738:()=>QKt,content_3498_474:()=>HI,content_3498_4740:()=>$Kt,content_3498_4742:()=>KKt,content_3498_4744:()=>tJt,content_3498_4746:()=>eJt,content_3498_4748:()=>pJt,content_3498_4750:()=>sJt,content_3498_4752:()=>iJt,content_3498_4754:()=>lJt,content_3498_4756:()=>mJt,content_3498_4758:()=>hJt,content_3498_476:()=>YI,content_3498_4760:()=>yJt,content_3498_4762:()=>MJt,content_3498_4764:()=>_Jt,content_3498_4766:()=>wJt,content_3498_4768:()=>TJt,content_3498_4770:()=>CJt,content_3498_4772:()=>LJt,content_3498_4774:()=>bJt,content_3498_4776:()=>zJt,content_3498_4778:()=>WJt,content_3498_478:()=>JI,content_3498_4780:()=>SJt,content_3498_4782:()=>PJt,content_3498_4784:()=>BJt,content_3498_4786:()=>OJt,content_3498_4788:()=>UJt,content_3498_4790:()=>VJt,content_3498_4792:()=>QJt,content_3498_4794:()=>$Jt,content_3498_4796:()=>KJt,content_3498_4798:()=>t0t,content_3498_48:()=>nb,content_3498_480:()=>nP,content_3498_4800:()=>e0t,content_3498_4802:()=>p0t,content_3498_4804:()=>s0t,content_3498_4806:()=>i0t,content_3498_4808:()=>l0t,content_3498_4810:()=>m0t,content_3498_4812:()=>h0t,content_3498_4814:()=>y0t,content_3498_4816:()=>M0t,content_3498_4818:()=>_0t,content_3498_482:()=>oP,content_3498_4820:()=>w0t,content_3498_4822:()=>T0t,content_3498_4824:()=>C0t,content_3498_4826:()=>L0t,content_3498_4828:()=>b0t,content_3498_4830:()=>z0t,content_3498_4832:()=>W0t,content_3498_4834:()=>S0t,content_3498_4836:()=>P0t,content_3498_4838:()=>B0t,content_3498_484:()=>rP,content_3498_4840:()=>O0t,content_3498_4842:()=>U0t,content_3498_4844:()=>V0t,content_3498_4846:()=>Q0t,content_3498_4848:()=>$0t,content_3498_4850:()=>K0t,content_3498_4852:()=>t4t,content_3498_4854:()=>e4t,content_3498_4856:()=>p4t,content_3498_4858:()=>s4t,content_3498_486:()=>cP,content_3498_4860:()=>i4t,content_3498_4862:()=>l4t,content_3498_4864:()=>m4t,content_3498_4866:()=>h4t,content_3498_4868:()=>y4t,content_3498_4870:()=>M4t,content_3498_4872:()=>_4t,content_3498_4874:()=>w4t,content_3498_4876:()=>T4t,content_3498_4878:()=>C4t,content_3498_488:()=>aP,content_3498_4880:()=>L4t,content_3498_4882:()=>b4t,content_3498_4884:()=>z4t,content_3498_4886:()=>W4t,content_3498_4888:()=>S4t,content_3498_4890:()=>P4t,content_3498_4892:()=>B4t,content_3498_4894:()=>O4t,content_3498_4896:()=>U4t,content_3498_4898:()=>V4t,content_3498_490:()=>uP,content_3498_4900:()=>Q4t,content_3498_4902:()=>$4t,content_3498_4904:()=>K4t,content_3498_4906:()=>t8t,content_3498_4908:()=>e8t,content_3498_4910:()=>p8t,content_3498_4912:()=>s8t,content_3498_4914:()=>i8t,content_3498_4916:()=>l8t,content_3498_4918:()=>m8t,content_3498_492:()=>dP,content_3498_4920:()=>h8t,content_3498_4922:()=>y8t,content_3498_4924:()=>M8t,content_3498_4926:()=>_8t,content_3498_4928:()=>w8t,content_3498_4930:()=>T8t,content_3498_4932:()=>C8t,content_3498_4934:()=>L8t,content_3498_4936:()=>b8t,content_3498_4938:()=>z8t,content_3498_494:()=>kP,content_3498_4940:()=>W8t,content_3498_4942:()=>S8t,content_3498_4944:()=>P8t,content_3498_4946:()=>B8t,content_3498_4948:()=>O8t,content_3498_4950:()=>U8t,content_3498_4952:()=>V8t,content_3498_4954:()=>Q8t,content_3498_4956:()=>$8t,content_3498_4958:()=>K8t,content_3498_496:()=>fP,content_3498_4960:()=>t3t,content_3498_4962:()=>e3t,content_3498_4964:()=>p3t,content_3498_4966:()=>s3t,content_3498_4968:()=>i3t,content_3498_4970:()=>l3t,content_3498_4972:()=>m3t,content_3498_4974:()=>h3t,content_3498_4976:()=>y3t,content_3498_4978:()=>M3t,content_3498_498:()=>DP,content_3498_4980:()=>_3t,content_3498_4982:()=>w3t,content_3498_4984:()=>T3t,content_3498_4986:()=>C3t,content_3498_4988:()=>L3t,content_3498_4990:()=>b3t,content_3498_4992:()=>z3t,content_3498_4994:()=>W3t,content_3498_4996:()=>S3t,content_3498_4998:()=>P3t,content_3498_50:()=>ob,content_3498_500:()=>XP,content_3498_5000:()=>B3t,content_3498_5002:()=>O3t,content_3498_5004:()=>U3t,content_3498_5006:()=>V3t,content_3498_5008:()=>Q3t,content_3498_5010:()=>$3t,content_3498_5012:()=>K3t,content_3498_5014:()=>t9t,content_3498_5016:()=>e9t,content_3498_5018:()=>p9t,content_3498_502:()=>gP,content_3498_5020:()=>s9t,content_3498_5022:()=>i9t,content_3498_5024:()=>l9t,content_3498_5026:()=>m9t,content_3498_5028:()=>h9t,content_3498_5030:()=>y9t,content_3498_5032:()=>M9t,content_3498_5034:()=>_9t,content_3498_5036:()=>w9t,content_3498_5038:()=>T9t,content_3498_504:()=>xP,content_3498_5040:()=>C9t,content_3498_5042:()=>L9t,content_3498_5044:()=>b9t,content_3498_5046:()=>z9t,content_3498_5048:()=>W9t,content_3498_5050:()=>S9t,content_3498_5052:()=>P9t,content_3498_5054:()=>B9t,content_3498_5056:()=>O9t,content_3498_5058:()=>U9t,content_3498_506:()=>vP,content_3498_5060:()=>V9t,content_3498_5062:()=>Q9t,content_3498_5064:()=>$9t,content_3498_5066:()=>K9t,content_3498_5068:()=>t2t,content_3498_5070:()=>e2t,content_3498_5072:()=>p2t,content_3498_5074:()=>s2t,content_3498_5076:()=>i2t,content_3498_5078:()=>l2t,content_3498_508:()=>ZP,content_3498_5080:()=>m2t,content_3498_5082:()=>h2t,content_3498_5084:()=>y2t,content_3498_5086:()=>M2t,content_3498_5088:()=>_2t,content_3498_5090:()=>w2t,content_3498_5092:()=>T2t,content_3498_5094:()=>C2t,content_3498_5096:()=>L2t,content_3498_5098:()=>b2t,content_3498_510:()=>NP,content_3498_5100:()=>z2t,content_3498_5102:()=>W2t,content_3498_5104:()=>S2t,content_3498_5106:()=>P2t,content_3498_5108:()=>B2t,content_3498_5110:()=>O2t,content_3498_5112:()=>U2t,content_3498_5114:()=>V2t,content_3498_5116:()=>Q2t,content_3498_5118:()=>$2t,content_3498_512:()=>AP,content_3498_5120:()=>K2t,content_3498_5122:()=>t1t,content_3498_5124:()=>e1t,content_3498_5126:()=>p1t,content_3498_5128:()=>s1t,content_3498_5130:()=>i1t,content_3498_5132:()=>l1t,content_3498_5134:()=>m1t,content_3498_5136:()=>h1t,content_3498_5138:()=>y1t,content_3498_514:()=>RP,content_3498_5140:()=>M1t,content_3498_5142:()=>_1t,content_3498_5144:()=>w1t,content_3498_5146:()=>T1t,content_3498_5148:()=>C1t,content_3498_5150:()=>L1t,content_3498_5152:()=>b1t,content_3498_5154:()=>z1t,content_3498_5156:()=>W1t,content_3498_5158:()=>S1t,content_3498_516:()=>IP,content_3498_5160:()=>P1t,content_3498_5162:()=>B1t,content_3498_5164:()=>O1t,content_3498_5166:()=>U1t,content_3498_5168:()=>V1t,content_3498_5170:()=>Q1t,content_3498_5172:()=>$1t,content_3498_5174:()=>K1t,content_3498_5176:()=>t6t,content_3498_5178:()=>e6t,content_3498_518:()=>EP,content_3498_5180:()=>p6t,content_3498_5182:()=>s6t,content_3498_5184:()=>i6t,content_3498_5186:()=>l6t,content_3498_5188:()=>m6t,content_3498_5190:()=>h6t,content_3498_5192:()=>y6t,content_3498_5194:()=>M6t,content_3498_5196:()=>_6t,content_3498_5198:()=>w6t,content_3498_52:()=>rb,content_3498_520:()=>GP,content_3498_5200:()=>T6t,content_3498_5202:()=>C6t,content_3498_5204:()=>L6t,content_3498_5206:()=>b6t,content_3498_5208:()=>z6t,content_3498_5210:()=>W6t,content_3498_5212:()=>S6t,content_3498_5214:()=>P6t,content_3498_5216:()=>B6t,content_3498_5218:()=>O6t,content_3498_522:()=>FP,content_3498_5220:()=>U6t,content_3498_5222:()=>V6t,content_3498_5224:()=>Q6t,content_3498_5226:()=>$6t,content_3498_5228:()=>K6t,content_3498_5230:()=>t5t,content_3498_5232:()=>e5t,content_3498_5234:()=>p5t,content_3498_5236:()=>s5t,content_3498_5238:()=>i5t,content_3498_524:()=>qP,content_3498_5240:()=>l5t,content_3498_5242:()=>m5t,content_3498_5244:()=>h5t,content_3498_5246:()=>y5t,content_3498_5248:()=>M5t,content_3498_5250:()=>_5t,content_3498_5252:()=>w5t,content_3498_5254:()=>T5t,content_3498_5256:()=>C5t,content_3498_5258:()=>L5t,content_3498_526:()=>jP,content_3498_5260:()=>b5t,content_3498_5262:()=>z5t,content_3498_5264:()=>W5t,content_3498_5266:()=>S5t,content_3498_5268:()=>P5t,content_3498_5270:()=>B5t,content_3498_5272:()=>O5t,content_3498_5274:()=>U5t,content_3498_5276:()=>V5t,content_3498_5278:()=>Q5t,content_3498_528:()=>HP,content_3498_5280:()=>$5t,content_3498_5282:()=>K5t,content_3498_5284:()=>t7t,content_3498_5286:()=>e7t,content_3498_5288:()=>p7t,content_3498_5290:()=>s7t,content_3498_5292:()=>i7t,content_3498_5294:()=>l7t,content_3498_5296:()=>m7t,content_3498_5298:()=>h7t,content_3498_530:()=>YP,content_3498_5300:()=>y7t,content_3498_5302:()=>M7t,content_3498_5304:()=>_7t,content_3498_5306:()=>w7t,content_3498_5308:()=>T7t,content_3498_5310:()=>C7t,content_3498_5312:()=>L7t,content_3498_5314:()=>b7t,content_3498_5316:()=>z7t,content_3498_5318:()=>W7t,content_3498_532:()=>JP,content_3498_5320:()=>S7t,content_3498_5322:()=>P7t,content_3498_5324:()=>B7t,content_3498_5326:()=>O7t,content_3498_5328:()=>U7t,content_3498_5330:()=>V7t,content_3498_5332:()=>Q7t,content_3498_5334:()=>$7t,content_3498_5336:()=>K7t,content_3498_5338:()=>ttn,content_3498_534:()=>nE,content_3498_5340:()=>etn,content_3498_5342:()=>ptn,content_3498_5344:()=>stn,content_3498_5346:()=>itn,content_3498_5348:()=>ltn,content_3498_5350:()=>mtn,content_3498_5352:()=>htn,content_3498_5354:()=>ytn,content_3498_5356:()=>Mtn,content_3498_5358:()=>_tn,content_3498_536:()=>oE,content_3498_5360:()=>wtn,content_3498_5362:()=>Ttn,content_3498_5364:()=>Ctn,content_3498_5366:()=>Ltn,content_3498_5368:()=>btn,content_3498_5370:()=>ztn,content_3498_5372:()=>Wtn,content_3498_5374:()=>Stn,content_3498_5376:()=>Ptn,content_3498_5378:()=>Btn,content_3498_538:()=>rE,content_3498_5380:()=>Otn,content_3498_5382:()=>Utn,content_3498_5384:()=>Vtn,content_3498_5386:()=>Qtn,content_3498_5388:()=>$tn,content_3498_5390:()=>Ktn,content_3498_5392:()=>tnn,content_3498_5394:()=>enn,content_3498_5396:()=>pnn,content_3498_5398:()=>snn,content_3498_54:()=>cb,content_3498_540:()=>cE,content_3498_5400:()=>inn,content_3498_5402:()=>lnn,content_3498_5404:()=>mnn,content_3498_5406:()=>hnn,content_3498_5408:()=>ynn,content_3498_5410:()=>Mnn,content_3498_5412:()=>_nn,content_3498_5414:()=>wnn,content_3498_5416:()=>Tnn,content_3498_5418:()=>Cnn,content_3498_542:()=>aE,content_3498_5420:()=>Lnn,content_3498_5422:()=>bnn,content_3498_5424:()=>znn,content_3498_5426:()=>Wnn,content_3498_5428:()=>Snn,content_3498_5430:()=>Pnn,content_3498_5432:()=>Bnn,content_3498_5434:()=>Onn,content_3498_5436:()=>Unn,content_3498_5438:()=>Vnn,content_3498_544:()=>uE,content_3498_5440:()=>Qnn,content_3498_5442:()=>$nn,content_3498_5444:()=>Knn,content_3498_5446:()=>ten,content_3498_5448:()=>een,content_3498_5450:()=>pen,content_3498_5452:()=>sen,content_3498_5454:()=>ien,content_3498_5456:()=>len,content_3498_5458:()=>men,content_3498_546:()=>dE,content_3498_5460:()=>hen,content_3498_5462:()=>yen,content_3498_5464:()=>Men,content_3498_5466:()=>_en,content_3498_5468:()=>wen,content_3498_5470:()=>Ten,content_3498_5472:()=>Cen,content_3498_5474:()=>Len,content_3498_5476:()=>ben,content_3498_5478:()=>zen,content_3498_548:()=>kE,content_3498_5480:()=>Wen,content_3498_5482:()=>Sen,content_3498_5484:()=>Pen,content_3498_5486:()=>Ben,content_3498_5488:()=>Oen,content_3498_5490:()=>Uen,content_3498_5492:()=>Ven,content_3498_5494:()=>Qen,content_3498_5496:()=>$en,content_3498_5498:()=>Ken,content_3498_550:()=>fE,content_3498_5500:()=>ton,content_3498_5502:()=>eon,content_3498_5504:()=>pon,content_3498_5506:()=>son,content_3498_5508:()=>ion,content_3498_5510:()=>lon,content_3498_5512:()=>mon,content_3498_5514:()=>hon,content_3498_5516:()=>yon,content_3498_5518:()=>Mon,content_3498_552:()=>DE,content_3498_5520:()=>_on,content_3498_5522:()=>won,content_3498_5524:()=>Ton,content_3498_5526:()=>Con,content_3498_5528:()=>Lon,content_3498_5530:()=>bon,content_3498_5532:()=>zon,content_3498_5534:()=>Won,content_3498_5536:()=>Son,content_3498_5538:()=>Pon,content_3498_554:()=>XE,content_3498_5540:()=>Bon,content_3498_5542:()=>Oon,content_3498_5544:()=>Uon,content_3498_5546:()=>Von,content_3498_5548:()=>Qon,content_3498_5550:()=>$on,content_3498_5552:()=>Kon,content_3498_5554:()=>tpn,content_3498_5556:()=>epn,content_3498_5558:()=>ppn,content_3498_556:()=>gE,content_3498_5560:()=>spn,content_3498_5562:()=>ipn,content_3498_5564:()=>lpn,content_3498_5566:()=>mpn,content_3498_5568:()=>hpn,content_3498_5570:()=>ypn,content_3498_5572:()=>Mpn,content_3498_5574:()=>_pn,content_3498_5576:()=>wpn,content_3498_5578:()=>Tpn,content_3498_558:()=>xE,content_3498_5580:()=>Cpn,content_3498_5582:()=>Lpn,content_3498_5584:()=>bpn,content_3498_5586:()=>zpn,content_3498_5588:()=>Wpn,content_3498_5590:()=>Spn,content_3498_5592:()=>Ppn,content_3498_5594:()=>Bpn,content_3498_5596:()=>Opn,content_3498_5598:()=>Upn,content_3498_56:()=>ab,content_3498_560:()=>vE,content_3498_5600:()=>Vpn,content_3498_5602:()=>Qpn,content_3498_5604:()=>$pn,content_3498_5606:()=>Kpn,content_3498_5608:()=>trn,content_3498_5610:()=>ern,content_3498_5612:()=>prn,content_3498_5614:()=>srn,content_3498_5616:()=>irn,content_3498_5618:()=>lrn,content_3498_562:()=>ZE,content_3498_5620:()=>mrn,content_3498_5622:()=>hrn,content_3498_5624:()=>yrn,content_3498_5626:()=>Mrn,content_3498_5628:()=>_rn,content_3498_5630:()=>wrn,content_3498_5632:()=>Trn,content_3498_5634:()=>Crn,content_3498_5636:()=>Lrn,content_3498_5638:()=>brn,content_3498_564:()=>NE,content_3498_5640:()=>zrn,content_3498_5642:()=>Wrn,content_3498_5644:()=>Srn,content_3498_5646:()=>Prn,content_3498_5648:()=>Brn,content_3498_5650:()=>Orn,content_3498_5652:()=>Urn,content_3498_5654:()=>Vrn,content_3498_5656:()=>Qrn,content_3498_5658:()=>$rn,content_3498_566:()=>AE,content_3498_5660:()=>Krn,content_3498_5662:()=>tsn,content_3498_5664:()=>esn,content_3498_5666:()=>psn,content_3498_5668:()=>ssn,content_3498_5670:()=>isn,content_3498_5672:()=>lsn,content_3498_5674:()=>msn,content_3498_5676:()=>hsn,content_3498_5678:()=>ysn,content_3498_568:()=>RE,content_3498_5680:()=>Msn,content_3498_5682:()=>_sn,content_3498_5684:()=>wsn,content_3498_5686:()=>Tsn,content_3498_5688:()=>Csn,content_3498_5690:()=>Lsn,content_3498_5692:()=>bsn,content_3498_5694:()=>zsn,content_3498_5696:()=>Wsn,content_3498_5698:()=>Ssn,content_3498_570:()=>IE,content_3498_5700:()=>Psn,content_3498_5702:()=>Bsn,content_3498_5704:()=>Osn,content_3498_5706:()=>Usn,content_3498_5708:()=>Vsn,content_3498_5710:()=>Qsn,content_3498_5712:()=>$sn,content_3498_5714:()=>Ksn,content_3498_5716:()=>tcn,content_3498_5718:()=>ecn,content_3498_572:()=>EE,content_3498_5720:()=>pcn,content_3498_5722:()=>scn,content_3498_5724:()=>icn,content_3498_5726:()=>lcn,content_3498_5728:()=>mcn,content_3498_5730:()=>hcn,content_3498_5732:()=>ycn,content_3498_5734:()=>Mcn,content_3498_5736:()=>_cn,content_3498_5738:()=>wcn,content_3498_574:()=>GE,content_3498_5740:()=>Tcn,content_3498_5742:()=>Ccn,content_3498_5744:()=>Lcn,content_3498_5746:()=>bcn,content_3498_5748:()=>zcn,content_3498_5750:()=>Wcn,content_3498_5752:()=>Scn,content_3498_5754:()=>Pcn,content_3498_5756:()=>Bcn,content_3498_5758:()=>Ocn,content_3498_576:()=>FE,content_3498_5760:()=>Ucn,content_3498_5762:()=>Vcn,content_3498_5764:()=>Qcn,content_3498_5766:()=>$cn,content_3498_5768:()=>Kcn,content_3498_5770:()=>tin,content_3498_5772:()=>ein,content_3498_5774:()=>pin,content_3498_5776:()=>sin,content_3498_5778:()=>iin,content_3498_578:()=>qE,content_3498_5780:()=>lin,content_3498_5782:()=>min,content_3498_5784:()=>hin,content_3498_5786:()=>yin,content_3498_5788:()=>Min,content_3498_5790:()=>_in,content_3498_5792:()=>win,content_3498_5794:()=>Tin,content_3498_5796:()=>Cin,content_3498_5798:()=>Lin,content_3498_58:()=>ub,content_3498_580:()=>jE,content_3498_5800:()=>bin,content_3498_5802:()=>zin,content_3498_5804:()=>Win,content_3498_5806:()=>Sin,content_3498_5808:()=>Pin,content_3498_5810:()=>Bin,content_3498_5812:()=>Oin,content_3498_5814:()=>Uin,content_3498_5816:()=>Vin,content_3498_5818:()=>Qin,content_3498_582:()=>HE,content_3498_5820:()=>$in,content_3498_5822:()=>Kin,content_3498_5824:()=>tan,content_3498_5826:()=>ean,content_3498_5828:()=>pan,content_3498_5830:()=>san,content_3498_5832:()=>ian,content_3498_5834:()=>lan,content_3498_5836:()=>man,content_3498_5838:()=>han,content_3498_584:()=>YE,content_3498_5840:()=>yan,content_3498_5842:()=>Man,content_3498_5844:()=>_an,content_3498_5846:()=>wan,content_3498_5848:()=>Tan,content_3498_5850:()=>Can,content_3498_5852:()=>Lan,content_3498_5854:()=>ban,content_3498_5856:()=>zan,content_3498_5858:()=>Wan,content_3498_586:()=>JE,content_3498_5860:()=>San,content_3498_5862:()=>Pan,content_3498_5864:()=>Ban,content_3498_5866:()=>Oan,content_3498_5868:()=>Uan,content_3498_5870:()=>Van,content_3498_5872:()=>Qan,content_3498_5874:()=>$an,content_3498_5876:()=>Kan,content_3498_5878:()=>tln,content_3498_588:()=>nB,content_3498_5880:()=>eln,content_3498_5882:()=>pln,content_3498_5884:()=>sln,content_3498_5886:()=>iln,content_3498_5888:()=>lln,content_3498_5890:()=>mln,content_3498_5892:()=>hln,content_3498_5894:()=>yln,content_3498_5896:()=>Mln,content_3498_5898:()=>_ln,content_3498_590:()=>oB,content_3498_5900:()=>wln,content_3498_5902:()=>Tln,content_3498_5904:()=>Cln,content_3498_5906:()=>Lln,content_3498_5908:()=>bln,content_3498_5910:()=>zln,content_3498_5912:()=>Wln,content_3498_5914:()=>Sln,content_3498_5916:()=>Pln,content_3498_5918:()=>Bln,content_3498_592:()=>rB,content_3498_5920:()=>Oln,content_3498_5922:()=>Uln,content_3498_5924:()=>Vln,content_3498_5926:()=>Qln,content_3498_5928:()=>$ln,content_3498_5930:()=>Kln,content_3498_5932:()=>tun,content_3498_5934:()=>eun,content_3498_5936:()=>pun,content_3498_5938:()=>sun,content_3498_594:()=>cB,content_3498_5940:()=>iun,content_3498_5942:()=>lun,content_3498_5944:()=>mun,content_3498_5946:()=>hun,content_3498_5948:()=>yun,content_3498_5950:()=>Mun,content_3498_5952:()=>_un,content_3498_5954:()=>wun,content_3498_5956:()=>Tun,content_3498_5958:()=>Cun,content_3498_596:()=>aB,content_3498_5960:()=>Lun,content_3498_5962:()=>bun,content_3498_5964:()=>zun,content_3498_5966:()=>Wun,content_3498_5968:()=>Sun,content_3498_5970:()=>Pun,content_3498_5972:()=>Bun,content_3498_5974:()=>Oun,content_3498_5976:()=>Uun,content_3498_5978:()=>Vun,content_3498_598:()=>uB,content_3498_5980:()=>Qun,content_3498_5982:()=>$un,content_3498_5984:()=>Kun,content_3498_5986:()=>tmn,content_3498_5988:()=>emn,content_3498_5990:()=>pmn,content_3498_5992:()=>smn,content_3498_5994:()=>imn,content_3498_5996:()=>lmn,content_3498_5998:()=>mmn,content_3498_6:()=>dZ,content_3498_60:()=>db,content_3498_600:()=>dB,content_3498_6000:()=>hmn,content_3498_6002:()=>ymn,content_3498_6004:()=>Mmn,content_3498_6006:()=>_mn,content_3498_6008:()=>wmn,content_3498_6010:()=>Tmn,content_3498_6012:()=>Cmn,content_3498_6014:()=>Lmn,content_3498_6016:()=>bmn,content_3498_6018:()=>zmn,content_3498_602:()=>kB,content_3498_6020:()=>Wmn,content_3498_6022:()=>Smn,content_3498_6024:()=>Pmn,content_3498_6026:()=>Bmn,content_3498_6028:()=>Omn,content_3498_6030:()=>Umn,content_3498_6032:()=>Vmn,content_3498_6034:()=>Qmn,content_3498_6036:()=>$mn,content_3498_6038:()=>Kmn,content_3498_604:()=>fB,content_3498_6040:()=>tdn,content_3498_6042:()=>edn,content_3498_6044:()=>pdn,content_3498_6046:()=>sdn,content_3498_6048:()=>idn,content_3498_6050:()=>ldn,content_3498_6052:()=>mdn,content_3498_6054:()=>hdn,content_3498_6056:()=>ydn,content_3498_6058:()=>Mdn,content_3498_606:()=>DB,content_3498_6060:()=>_dn,content_3498_6062:()=>wdn,content_3498_6064:()=>Tdn,content_3498_6066:()=>Cdn,content_3498_6068:()=>Ldn,content_3498_6070:()=>bdn,content_3498_6072:()=>zdn,content_3498_6074:()=>Wdn,content_3498_6076:()=>Sdn,content_3498_6078:()=>Pdn,content_3498_608:()=>XB,content_3498_6080:()=>Bdn,content_3498_6082:()=>Odn,content_3498_6084:()=>Udn,content_3498_6086:()=>Vdn,content_3498_6088:()=>Qdn,content_3498_6090:()=>$dn,content_3498_6092:()=>Kdn,content_3498_6094:()=>thn,content_3498_6096:()=>ehn,content_3498_6098:()=>phn,content_3498_610:()=>gB,content_3498_6100:()=>shn,content_3498_6102:()=>ihn,content_3498_6104:()=>lhn,content_3498_6106:()=>mhn,content_3498_6108:()=>hhn,content_3498_6110:()=>yhn,content_3498_6112:()=>Mhn,content_3498_6114:()=>_hn,content_3498_6116:()=>whn,content_3498_6118:()=>Thn,content_3498_612:()=>xB,content_3498_6120:()=>Chn,content_3498_6122:()=>Lhn,content_3498_6124:()=>bhn,content_3498_6126:()=>zhn,content_3498_6128:()=>Whn,content_3498_6130:()=>Shn,content_3498_6132:()=>Phn,content_3498_6134:()=>Bhn,content_3498_6136:()=>Ohn,content_3498_6138:()=>Uhn,content_3498_614:()=>vB,content_3498_6140:()=>Vhn,content_3498_6142:()=>Qhn,content_3498_6144:()=>$hn,content_3498_6146:()=>Khn,content_3498_6148:()=>tkn,content_3498_6150:()=>ekn,content_3498_6152:()=>pkn,content_3498_6154:()=>skn,content_3498_6156:()=>ikn,content_3498_6158:()=>lkn,content_3498_616:()=>ZB,content_3498_6160:()=>mkn,content_3498_6162:()=>hkn,content_3498_6164:()=>ykn,content_3498_6166:()=>Mkn,content_3498_6168:()=>_kn,content_3498_6170:()=>wkn,content_3498_6172:()=>Tkn,content_3498_6174:()=>Ckn,content_3498_6176:()=>Lkn,content_3498_6178:()=>bkn,content_3498_618:()=>NB,content_3498_6180:()=>zkn,content_3498_6182:()=>Wkn,content_3498_6184:()=>Skn,content_3498_6186:()=>Pkn,content_3498_6188:()=>Bkn,content_3498_6190:()=>Okn,content_3498_6192:()=>Ukn,content_3498_6194:()=>Vkn,content_3498_6196:()=>Qkn,content_3498_6198:()=>$kn,content_3498_62:()=>kb,content_3498_620:()=>AB,content_3498_6200:()=>Kkn,content_3498_6202:()=>tyn,content_3498_6204:()=>eyn,content_3498_6206:()=>pyn,content_3498_6208:()=>syn,content_3498_6210:()=>iyn,content_3498_6212:()=>lyn,content_3498_6214:()=>myn,content_3498_6216:()=>hyn,content_3498_6218:()=>yyn,content_3498_622:()=>RB,content_3498_6220:()=>Myn,content_3498_6222:()=>_yn,content_3498_6224:()=>wyn,content_3498_6226:()=>Tyn,content_3498_6228:()=>Cyn,content_3498_6230:()=>Lyn,content_3498_6232:()=>byn,content_3498_6234:()=>zyn,content_3498_6236:()=>Wyn,content_3498_6238:()=>Syn,content_3498_624:()=>IB,content_3498_6240:()=>Pyn,content_3498_6242:()=>Byn,content_3498_6244:()=>Oyn,content_3498_6246:()=>Uyn,content_3498_6248:()=>Vyn,content_3498_6250:()=>Qyn,content_3498_6252:()=>$yn,content_3498_6254:()=>Kyn,content_3498_6256:()=>tfn,content_3498_6258:()=>efn,content_3498_626:()=>EB,content_3498_6260:()=>pfn,content_3498_6262:()=>sfn,content_3498_6264:()=>ifn,content_3498_6266:()=>lfn,content_3498_6268:()=>mfn,content_3498_6270:()=>hfn,content_3498_6272:()=>yfn,content_3498_6274:()=>Mfn,content_3498_6276:()=>_fn,content_3498_6278:()=>wfn,content_3498_628:()=>GB,content_3498_6280:()=>Tfn,content_3498_6282:()=>Cfn,content_3498_6284:()=>Lfn,content_3498_6286:()=>bfn,content_3498_6288:()=>zfn,content_3498_6290:()=>Wfn,content_3498_6292:()=>Sfn,content_3498_6294:()=>Pfn,content_3498_6296:()=>Bfn,content_3498_6298:()=>Ofn,content_3498_630:()=>FB,content_3498_6300:()=>Ufn,content_3498_6302:()=>Vfn,content_3498_6304:()=>Qfn,content_3498_6306:()=>$fn,content_3498_6308:()=>Kfn,content_3498_6310:()=>tMn,content_3498_6312:()=>eMn,content_3498_6314:()=>pMn,content_3498_6316:()=>sMn,content_3498_6318:()=>iMn,content_3498_632:()=>qB,content_3498_6320:()=>lMn,content_3498_6322:()=>mMn,content_3498_6324:()=>hMn,content_3498_6326:()=>yMn,content_3498_6328:()=>MMn,content_3498_6330:()=>_Mn,content_3498_6332:()=>wMn,content_3498_6334:()=>TMn,content_3498_6336:()=>CMn,content_3498_6338:()=>LMn,content_3498_634:()=>jB,content_3498_6340:()=>bMn,content_3498_6342:()=>zMn,content_3498_6344:()=>WMn,content_3498_6346:()=>SMn,content_3498_6348:()=>PMn,content_3498_6350:()=>BMn,content_3498_6352:()=>OMn,content_3498_6354:()=>UMn,content_3498_6356:()=>VMn,content_3498_6358:()=>QMn,content_3498_636:()=>HB,content_3498_6360:()=>$Mn,content_3498_6362:()=>KMn,content_3498_6364:()=>tDn,content_3498_6366:()=>eDn,content_3498_6368:()=>pDn,content_3498_6370:()=>sDn,content_3498_6372:()=>iDn,content_3498_6374:()=>lDn,content_3498_6376:()=>mDn,content_3498_6378:()=>hDn,content_3498_638:()=>YB,content_3498_6380:()=>yDn,content_3498_6382:()=>MDn,content_3498_6384:()=>_Dn,content_3498_6386:()=>wDn,content_3498_6388:()=>TDn,content_3498_6390:()=>CDn,content_3498_6392:()=>LDn,content_3498_6394:()=>bDn,content_3498_6396:()=>zDn,content_3498_6398:()=>WDn,content_3498_64:()=>fb,content_3498_640:()=>JB,content_3498_6400:()=>SDn,content_3498_6402:()=>PDn,content_3498_6404:()=>BDn,content_3498_6406:()=>ODn,content_3498_6408:()=>UDn,content_3498_6410:()=>VDn,content_3498_6412:()=>QDn,content_3498_6414:()=>$Dn,content_3498_6416:()=>KDn,content_3498_6418:()=>t_n,content_3498_642:()=>nG,content_3498_6420:()=>e_n,content_3498_6422:()=>p_n,content_3498_6424:()=>s_n,content_3498_6426:()=>i_n,content_3498_6428:()=>l_n,content_3498_6430:()=>m_n,content_3498_6432:()=>h_n,content_3498_6434:()=>y_n,content_3498_6436:()=>M_n,content_3498_6438:()=>__n,content_3498_644:()=>oG,content_3498_6440:()=>w_n,content_3498_6442:()=>T_n,content_3498_6444:()=>C_n,content_3498_6446:()=>L_n,content_3498_6448:()=>b_n,content_3498_6450:()=>z_n,content_3498_6452:()=>W_n,content_3498_6454:()=>S_n,content_3498_6456:()=>P_n,content_3498_6458:()=>B_n,content_3498_646:()=>rG,content_3498_6460:()=>O_n,content_3498_6462:()=>U_n,content_3498_6464:()=>V_n,content_3498_6466:()=>Q_n,content_3498_6468:()=>$_n,content_3498_6470:()=>K_n,content_3498_6472:()=>tXn,content_3498_6474:()=>eXn,content_3498_6476:()=>pXn,content_3498_6478:()=>sXn,content_3498_648:()=>cG,content_3498_6480:()=>iXn,content_3498_6482:()=>lXn,content_3498_6484:()=>mXn,content_3498_6486:()=>hXn,content_3498_6488:()=>yXn,content_3498_6490:()=>MXn,content_3498_6492:()=>_Xn,content_3498_6494:()=>wXn,content_3498_6496:()=>TXn,content_3498_6498:()=>CXn,content_3498_650:()=>aG,content_3498_6500:()=>LXn,content_3498_6502:()=>bXn,content_3498_6504:()=>zXn,content_3498_6506:()=>WXn,content_3498_6508:()=>SXn,content_3498_6510:()=>PXn,content_3498_6512:()=>BXn,content_3498_6514:()=>OXn,content_3498_6516:()=>UXn,content_3498_6518:()=>VXn,content_3498_652:()=>uG,content_3498_6520:()=>QXn,content_3498_6522:()=>$Xn,content_3498_6524:()=>KXn,content_3498_6526:()=>twn,content_3498_6528:()=>ewn,content_3498_6530:()=>pwn,content_3498_6532:()=>swn,content_3498_6534:()=>iwn,content_3498_6536:()=>lwn,content_3498_6538:()=>mwn,content_3498_654:()=>dG,content_3498_6540:()=>hwn,content_3498_6542:()=>ywn,content_3498_6544:()=>Mwn,content_3498_6546:()=>_wn,content_3498_6548:()=>wwn,content_3498_6550:()=>Twn,content_3498_6552:()=>Cwn,content_3498_6554:()=>Lwn,content_3498_6556:()=>bwn,content_3498_6558:()=>zwn,content_3498_656:()=>kG,content_3498_6560:()=>Wwn,content_3498_6562:()=>Swn,content_3498_6564:()=>Pwn,content_3498_6566:()=>Bwn,content_3498_6568:()=>Own,content_3498_6570:()=>Uwn,content_3498_6572:()=>Vwn,content_3498_6574:()=>Qwn,content_3498_6576:()=>$wn,content_3498_6578:()=>Kwn,content_3498_658:()=>fG,content_3498_6580:()=>tgn,content_3498_6582:()=>egn,content_3498_6584:()=>pgn,content_3498_6586:()=>sgn,content_3498_6588:()=>ign,content_3498_6590:()=>lgn,content_3498_6592:()=>mgn,content_3498_6594:()=>hgn,content_3498_6596:()=>ygn,content_3498_6598:()=>Mgn,content_3498_66:()=>Db,content_3498_660:()=>DG,content_3498_6600:()=>_gn,content_3498_6602:()=>wgn,content_3498_6604:()=>Tgn,content_3498_6606:()=>Cgn,content_3498_6608:()=>Lgn,content_3498_6610:()=>bgn,content_3498_6612:()=>zgn,content_3498_6614:()=>Wgn,content_3498_6616:()=>Sgn,content_3498_6618:()=>Pgn,content_3498_662:()=>XG,content_3498_6620:()=>Bgn,content_3498_6622:()=>Ogn,content_3498_6624:()=>Ugn,content_3498_6626:()=>Vgn,content_3498_6628:()=>Qgn,content_3498_6630:()=>$gn,content_3498_6632:()=>Kgn,content_3498_6634:()=>tTn,content_3498_6636:()=>eTn,content_3498_6638:()=>pTn,content_3498_664:()=>gG,content_3498_6640:()=>sTn,content_3498_6642:()=>iTn,content_3498_6644:()=>lTn,content_3498_6646:()=>mTn,content_3498_6648:()=>hTn,content_3498_6650:()=>yTn,content_3498_6652:()=>MTn,content_3498_6654:()=>_Tn,content_3498_6656:()=>wTn,content_3498_6658:()=>TTn,content_3498_666:()=>xG,content_3498_6660:()=>CTn,content_3498_6662:()=>LTn,content_3498_6664:()=>bTn,content_3498_6666:()=>zTn,content_3498_6668:()=>WTn,content_3498_6670:()=>STn,content_3498_6672:()=>PTn,content_3498_6674:()=>BTn,content_3498_6676:()=>OTn,content_3498_6678:()=>UTn,content_3498_668:()=>vG,content_3498_6680:()=>VTn,content_3498_6682:()=>QTn,content_3498_6684:()=>$Tn,content_3498_6686:()=>KTn,content_3498_6688:()=>txn,content_3498_6690:()=>exn,content_3498_6692:()=>pxn,content_3498_6694:()=>sxn,content_3498_6696:()=>ixn,content_3498_6698:()=>lxn,content_3498_670:()=>ZG,content_3498_6700:()=>mxn,content_3498_6702:()=>hxn,content_3498_6704:()=>yxn,content_3498_6706:()=>Mxn,content_3498_6708:()=>_xn,content_3498_6710:()=>wxn,content_3498_6712:()=>Txn,content_3498_6714:()=>Cxn,content_3498_6716:()=>Lxn,content_3498_6718:()=>bxn,content_3498_672:()=>NG,content_3498_6720:()=>zxn,content_3498_6722:()=>Wxn,content_3498_6724:()=>Sxn,content_3498_6726:()=>Pxn,content_3498_6728:()=>Bxn,content_3498_6730:()=>Oxn,content_3498_6732:()=>Uxn,content_3498_6734:()=>Vxn,content_3498_6736:()=>Qxn,content_3498_6738:()=>$xn,content_3498_674:()=>AG,content_3498_6740:()=>Kxn,content_3498_6742:()=>tCn,content_3498_6744:()=>eCn,content_3498_6746:()=>pCn,content_3498_6748:()=>sCn,content_3498_6750:()=>iCn,content_3498_6752:()=>lCn,content_3498_6754:()=>mCn,content_3498_6756:()=>hCn,content_3498_6758:()=>yCn,content_3498_676:()=>RG,content_3498_6760:()=>MCn,content_3498_6762:()=>_Cn,content_3498_6764:()=>wCn,content_3498_6766:()=>TCn,content_3498_6768:()=>CCn,content_3498_6770:()=>LCn,content_3498_6772:()=>bCn,content_3498_6774:()=>zCn,content_3498_6776:()=>WCn,content_3498_6778:()=>SCn,content_3498_678:()=>IG,content_3498_6780:()=>PCn,content_3498_6782:()=>BCn,content_3498_6784:()=>OCn,content_3498_6786:()=>UCn,content_3498_6788:()=>VCn,content_3498_6790:()=>QCn,content_3498_6792:()=>$Cn,content_3498_6794:()=>KCn,content_3498_6796:()=>tvn,content_3498_6798:()=>evn,content_3498_68:()=>Xb,content_3498_680:()=>EG,content_3498_6800:()=>pvn,content_3498_6802:()=>svn,content_3498_6804:()=>ivn,content_3498_6806:()=>lvn,content_3498_6808:()=>mvn,content_3498_6810:()=>hvn,content_3498_6812:()=>yvn,content_3498_6814:()=>Mvn,content_3498_6816:()=>_vn,content_3498_6818:()=>wvn,content_3498_682:()=>GG,content_3498_6820:()=>Tvn,content_3498_6822:()=>Cvn,content_3498_6824:()=>Lvn,content_3498_6826:()=>bvn,content_3498_6828:()=>zvn,content_3498_6830:()=>Wvn,content_3498_6832:()=>Svn,content_3498_6834:()=>Pvn,content_3498_6836:()=>Bvn,content_3498_6838:()=>Ovn,content_3498_684:()=>FG,content_3498_6840:()=>Uvn,content_3498_6842:()=>Vvn,content_3498_6844:()=>Qvn,content_3498_6846:()=>$vn,content_3498_6848:()=>Kvn,content_3498_6850:()=>tLn,content_3498_6852:()=>eLn,content_3498_6854:()=>pLn,content_3498_6856:()=>sLn,content_3498_6858:()=>iLn,content_3498_686:()=>qG,content_3498_6860:()=>lLn,content_3498_6862:()=>mLn,content_3498_6864:()=>hLn,content_3498_6866:()=>yLn,content_3498_6868:()=>MLn,content_3498_6870:()=>_Ln,content_3498_6872:()=>wLn,content_3498_6874:()=>TLn,content_3498_6876:()=>CLn,content_3498_6878:()=>LLn,content_3498_688:()=>jG,content_3498_6880:()=>bLn,content_3498_6882:()=>zLn,content_3498_6884:()=>WLn,content_3498_6886:()=>SLn,content_3498_6888:()=>PLn,content_3498_6890:()=>BLn,content_3498_6892:()=>OLn,content_3498_6894:()=>ULn,content_3498_6896:()=>VLn,content_3498_6898:()=>QLn,content_3498_690:()=>HG,content_3498_6900:()=>$Ln,content_3498_6902:()=>KLn,content_3498_6904:()=>tZn,content_3498_6906:()=>eZn,content_3498_6908:()=>pZn,content_3498_6910:()=>sZn,content_3498_6912:()=>iZn,content_3498_6914:()=>lZn,content_3498_6916:()=>mZn,content_3498_6918:()=>hZn,content_3498_692:()=>YG,content_3498_6920:()=>yZn,content_3498_6922:()=>MZn,content_3498_6924:()=>_Zn,content_3498_6926:()=>wZn,content_3498_6928:()=>TZn,content_3498_6930:()=>CZn,content_3498_6932:()=>LZn,content_3498_6934:()=>bZn,content_3498_6936:()=>zZn,content_3498_6938:()=>WZn,content_3498_694:()=>JG,content_3498_6940:()=>SZn,content_3498_6942:()=>PZn,content_3498_6944:()=>BZn,content_3498_6946:()=>OZn,content_3498_6948:()=>UZn,content_3498_6950:()=>VZn,content_3498_6952:()=>QZn,content_3498_6954:()=>$Zn,content_3498_6956:()=>KZn,content_3498_6958:()=>tbn,content_3498_696:()=>nO,content_3498_6960:()=>ebn,content_3498_6962:()=>pbn,content_3498_6964:()=>sbn,content_3498_6966:()=>ibn,content_3498_6968:()=>lbn,content_3498_6970:()=>mbn,content_3498_6972:()=>hbn,content_3498_6974:()=>ybn,content_3498_6976:()=>Mbn,content_3498_6978:()=>_bn,content_3498_698:()=>oO,content_3498_6980:()=>wbn,content_3498_6982:()=>Tbn,content_3498_6984:()=>Cbn,content_3498_6986:()=>Lbn,content_3498_6988:()=>bbn,content_3498_6990:()=>zbn,content_3498_6992:()=>Wbn,content_3498_6994:()=>Sbn,content_3498_6996:()=>Pbn,content_3498_6998:()=>Bbn,content_3498_70:()=>gb,content_3498_700:()=>rO,content_3498_7000:()=>Obn,content_3498_7002:()=>Ubn,content_3498_7004:()=>Vbn,content_3498_7006:()=>Qbn,content_3498_7008:()=>$bn,content_3498_7010:()=>Kbn,content_3498_7012:()=>tNn,content_3498_7014:()=>eNn,content_3498_7016:()=>pNn,content_3498_7018:()=>sNn,content_3498_702:()=>cO,content_3498_7020:()=>iNn,content_3498_7022:()=>lNn,content_3498_7024:()=>mNn,content_3498_7026:()=>hNn,content_3498_7028:()=>yNn,content_3498_7030:()=>MNn,content_3498_7032:()=>_Nn,content_3498_7034:()=>wNn,content_3498_7036:()=>TNn,content_3498_7038:()=>CNn,content_3498_704:()=>aO,content_3498_7040:()=>LNn,content_3498_7042:()=>bNn,content_3498_7044:()=>zNn,content_3498_7046:()=>WNn,content_3498_7048:()=>SNn,content_3498_7050:()=>PNn,content_3498_7052:()=>BNn,content_3498_7054:()=>ONn,content_3498_7056:()=>UNn,content_3498_7058:()=>VNn,content_3498_706:()=>uO,content_3498_7060:()=>QNn,content_3498_7062:()=>$Nn,content_3498_7064:()=>KNn,content_3498_7066:()=>tzn,content_3498_7068:()=>ezn,content_3498_7070:()=>pzn,content_3498_7072:()=>szn,content_3498_7074:()=>izn,content_3498_7076:()=>lzn,content_3498_7078:()=>mzn,content_3498_708:()=>dO,content_3498_7080:()=>hzn,content_3498_7082:()=>yzn,content_3498_7084:()=>Mzn,content_3498_7086:()=>_zn,content_3498_7088:()=>wzn,content_3498_7090:()=>Tzn,content_3498_7092:()=>Czn,content_3498_7094:()=>Lzn,content_3498_7096:()=>bzn,content_3498_7098:()=>zzn,content_3498_710:()=>kO,content_3498_7100:()=>Wzn,content_3498_7102:()=>Szn,content_3498_712:()=>fO,content_3498_714:()=>DO,content_3498_716:()=>XO,content_3498_718:()=>gO,content_3498_72:()=>xb,content_3498_720:()=>xO,content_3498_722:()=>vO,content_3498_724:()=>ZO,content_3498_726:()=>NO,content_3498_728:()=>AO,content_3498_730:()=>RO,content_3498_732:()=>IO,content_3498_734:()=>EO,content_3498_736:()=>GO,content_3498_738:()=>FO,content_3498_74:()=>vb,content_3498_740:()=>qO,content_3498_742:()=>jO,content_3498_744:()=>HO,content_3498_746:()=>YO,content_3498_748:()=>JO,content_3498_750:()=>nF,content_3498_752:()=>oF,content_3498_754:()=>rF,content_3498_756:()=>cF,content_3498_758:()=>aF,content_3498_76:()=>Zb,content_3498_760:()=>uF,content_3498_762:()=>dF,content_3498_764:()=>kF,content_3498_766:()=>fF,content_3498_768:()=>DF,content_3498_770:()=>XF,content_3498_772:()=>gF,content_3498_774:()=>xF,content_3498_776:()=>vF,content_3498_778:()=>ZF,content_3498_78:()=>Nb,content_3498_780:()=>NF,content_3498_782:()=>AF,content_3498_784:()=>RF,content_3498_786:()=>IF,content_3498_788:()=>EF,content_3498_790:()=>GF,content_3498_792:()=>FF,content_3498_794:()=>qF,content_3498_796:()=>jF,content_3498_798:()=>HF,content_3498_8:()=>kZ,content_3498_80:()=>Ab,content_3498_800:()=>YF,content_3498_802:()=>JF,content_3498_804:()=>nU,content_3498_806:()=>oU,content_3498_808:()=>rU,content_3498_810:()=>cU,content_3498_812:()=>aU,content_3498_814:()=>uU,content_3498_816:()=>dU,content_3498_818:()=>kU,content_3498_82:()=>Rb,content_3498_820:()=>fU,content_3498_822:()=>DU,content_3498_824:()=>XU,content_3498_826:()=>gU,content_3498_828:()=>xU,content_3498_830:()=>vU,content_3498_832:()=>ZU,content_3498_834:()=>NU,content_3498_836:()=>AU,content_3498_838:()=>RU,content_3498_84:()=>Ib,content_3498_840:()=>IU,content_3498_842:()=>EU,content_3498_844:()=>GU,content_3498_846:()=>FU,content_3498_848:()=>qU,content_3498_850:()=>jU,content_3498_852:()=>HU,content_3498_854:()=>YU,content_3498_856:()=>JU,content_3498_858:()=>nq,content_3498_86:()=>Eb,content_3498_860:()=>oq,content_3498_862:()=>rq,content_3498_864:()=>cq,content_3498_866:()=>aq,content_3498_868:()=>uq,content_3498_870:()=>dq,content_3498_872:()=>kq,content_3498_874:()=>fq,content_3498_876:()=>Dq,content_3498_878:()=>Xq,content_3498_88:()=>Gb,content_3498_880:()=>gq,content_3498_882:()=>xq,content_3498_884:()=>vq,content_3498_886:()=>Zq,content_3498_888:()=>Nq,content_3498_890:()=>Aq,content_3498_892:()=>Rq,content_3498_894:()=>Iq,content_3498_896:()=>Eq,content_3498_898:()=>Gq,content_3498_90:()=>Fb,content_3498_900:()=>Fq,content_3498_902:()=>qq,content_3498_904:()=>jq,content_3498_906:()=>Hq,content_3498_908:()=>Yq,content_3498_910:()=>Jq,content_3498_912:()=>nV,content_3498_914:()=>oV,content_3498_916:()=>rV,content_3498_918:()=>cV,content_3498_92:()=>qb,content_3498_920:()=>aV,content_3498_922:()=>uV,content_3498_924:()=>dV,content_3498_926:()=>kV,content_3498_928:()=>fV,content_3498_930:()=>DV,content_3498_932:()=>XV,content_3498_934:()=>gV,content_3498_936:()=>xV,content_3498_938:()=>vV,content_3498_94:()=>jb,content_3498_940:()=>ZV,content_3498_942:()=>NV,content_3498_944:()=>AV,content_3498_946:()=>RV,content_3498_948:()=>IV,content_3498_950:()=>EV,content_3498_952:()=>GV,content_3498_954:()=>FV,content_3498_956:()=>qV,content_3498_958:()=>jV,content_3498_96:()=>Hb,content_3498_960:()=>HV,content_3498_962:()=>YV,content_3498_964:()=>JV,content_3498_966:()=>nj,content_3498_968:()=>oj,content_3498_970:()=>rj,content_3498_972:()=>cj,content_3498_974:()=>aj,content_3498_976:()=>uj,content_3498_978:()=>dj,content_3498_98:()=>Yb,content_3498_980:()=>kj,content_3498_982:()=>fj,content_3498_984:()=>Dj,content_3498_986:()=>Xj,content_3498_988:()=>gj,content_3498_990:()=>xj,content_3498_992:()=>vj,content_3498_994:()=>Zj,content_3498_996:()=>Nj,content_3498_998:()=>Aj});var p=e(2784),r=e(7896),s=e(876);const c={toc:[]};function i(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}h.isMDXComponent=!0;const k={toc:[]};function y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}y.isMDXComponent=!0;const f={toc:[]};function M(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}M.isMDXComponent=!0;const D={toc:[]};function _(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}_.isMDXComponent=!0;const X={toc:[]};function w(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}w.isMDXComponent=!0;const g={toc:[]};function T(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}T.isMDXComponent=!0;const x={toc:[]};function C(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}C.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}L.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}b.isMDXComponent=!0;const N={toc:[]};function z(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}z.isMDXComponent=!0;const A={toc:[]};function W(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}W.isMDXComponent=!0;const R={toc:[]};function S(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}S.isMDXComponent=!0;const I={toc:[]};function P(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}P.isMDXComponent=!0;const E={toc:[]};function B(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}B.isMDXComponent=!0;const G={toc:[]};function O(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}O.isMDXComponent=!0;const F={toc:[]};function U(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}U.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}V.isMDXComponent=!0;const j={toc:[]};function Q(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}Q.isMDXComponent=!0;const H={toc:[]};function $(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}$.isMDXComponent=!0;const Y={toc:[]};function K(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}K.isMDXComponent=!0;const J={toc:[]};function tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}pt.isMDXComponent=!0;const rt={toc:[]};function st(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}st.isMDXComponent=!0;const ct={toc:[]};function it(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}it.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},at,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ht.isMDXComponent=!0;const kt={toc:[]};function yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}yt.isMDXComponent=!0;const ft={toc:[]};function Mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function _t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}_t.isMDXComponent=!0;const Xt={toc:[]};function wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}wt.isMDXComponent=!0;const gt={toc:[]};function Tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}Tt.isMDXComponent=!0;const xt={toc:[]};function Ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}Ct.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}Lt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}bt.isMDXComponent=!0;const Nt={toc:[]};function zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}zt.isMDXComponent=!0;const At={toc:[]};function Wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}Wt.isMDXComponent=!0;const Rt={toc:[]};function St(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}St.isMDXComponent=!0;const It={toc:[]};function Pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},It,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Pt.isMDXComponent=!0;const Et={toc:[]};function Bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Et,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Bt.isMDXComponent=!0;const Gt={toc:[]};function Ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}Ot.isMDXComponent=!0;const Ft={toc:[]};function Ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}Ut.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}Vt.isMDXComponent=!0;const jt={toc:[]};function Qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}Qt.isMDXComponent=!0;const Ht={toc:[]};function $t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}$t.isMDXComponent=!0;const Yt={toc:[]};function Kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}Kt.isMDXComponent=!0;const Jt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}pn.isMDXComponent=!0;const rn={toc:[]};function sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}sn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}dn.isMDXComponent=!0;const hn={toc:[]};function kn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}kn.isMDXComponent=!0;const yn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}fn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}Dn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}Xn.isMDXComponent=!0;const wn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}gn.isMDXComponent=!0;const Tn={toc:[]};function xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}xn.isMDXComponent=!0;const Cn={toc:[]};function vn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}vn.isMDXComponent=!0;const Ln={toc:[]};function Zn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}Nn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}An.isMDXComponent=!0;const Wn={toc:[]};function Rn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}Rn.isMDXComponent=!0;const Sn={toc:[]};function In(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}In.isMDXComponent=!0;const Pn={toc:[]};function En(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}En.isMDXComponent=!0;const Bn={toc:[]};function Gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Gn.isMDXComponent=!0;const On={toc:[]};function Fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},On,e,{components:n,mdxType:"MDXLayout"}))}Fn.isMDXComponent=!0;const Un={toc:[]};function qn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}qn.isMDXComponent=!0;const Vn={toc:[]};function jn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}jn.isMDXComponent=!0;const Qn={toc:[]};function Hn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}Hn.isMDXComponent=!0;const $n={toc:[]};function Yn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}Yn.isMDXComponent=!0;const Kn={toc:[]};function Jn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}Jn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}oe.isMDXComponent=!0;const pe={toc:[]};function re(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}re.isMDXComponent=!0;const se={toc:[]};function ce(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},se,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}ce.isMDXComponent=!0;const ie={toc:[]};function ae(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}ae.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}de.isMDXComponent=!0;const he={toc:[]};function ke(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}ke.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}fe.isMDXComponent=!0;const Me={toc:[]};function De(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Me,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}De.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Xe.isMDXComponent=!0;const we={toc:[]};function ge(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ge.isMDXComponent=!0;const Te={toc:[]};function xe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}xe.isMDXComponent=!0;const Ce={toc:[]};function ve(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}ve.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Le,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ze.isMDXComponent=!0;const be={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},be,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Ne.isMDXComponent=!0;const ze={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Ae.isMDXComponent=!0;const We={toc:[]};function Re(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},We,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Re.isMDXComponent=!0;const Se={toc:[]};function Ie(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Se,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Ie.isMDXComponent=!0;const Pe={toc:[]};function Ee(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ee.isMDXComponent=!0;const Be={toc:[]};function Ge(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Be,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}Ge.isMDXComponent=!0;const Oe={toc:[]};function Fe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Fe.isMDXComponent=!0;const Ue={toc:[]};function qe(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}qe.isMDXComponent=!0;const Ve={toc:[]};function je(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}je.isMDXComponent=!0;const Qe={toc:[]};function He(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}He.isMDXComponent=!0;const $e={toc:[]};function Ye(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Ye.isMDXComponent=!0;const Ke={toc:[]};function Je(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Je.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}ro.isMDXComponent=!0;const so={toc:[]};function co(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},so,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}co.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},io,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ho.isMDXComponent=!0;const ko={toc:[]};function yo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}yo.isMDXComponent=!0;const fo={toc:[]};function Mo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}Mo.isMDXComponent=!0;const Do={toc:[]};function _o(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Do,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}_o.isMDXComponent=!0;const Xo={toc:[]};function wo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}wo.isMDXComponent=!0;const go={toc:[]};function To(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}To.isMDXComponent=!0;const xo={toc:[]};function Co(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Co.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Lo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}bo.isMDXComponent=!0;const No={toc:[]};function zo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Wo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Wo.isMDXComponent=!0;const Ro={toc:[]};function So(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}So.isMDXComponent=!0;const Io={toc:[]};function Po(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Io,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Po.isMDXComponent=!0;const Eo={toc:[]};function Bo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Bo.isMDXComponent=!0;const Go={toc:[]};function Oo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Go,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Oo.isMDXComponent=!0;const Fo={toc:[]};function Uo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Uo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Vo.isMDXComponent=!0;const jo={toc:[]};function Qo(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Qo.isMDXComponent=!0;const Ho={toc:[]};function $o(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}$o.isMDXComponent=!0;const Yo={toc:[]};function Ko(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Ko.isMDXComponent=!0;const Jo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}pp.isMDXComponent=!0;const rp={toc:[]};function sp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}sp.isMDXComponent=!0;const cp={toc:[]};function ip(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}ip.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}hp.isMDXComponent=!0;const kp={toc:[]};function yp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}yp.isMDXComponent=!0;const fp={toc:[]};function Mp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function _p(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}_p.isMDXComponent=!0;const Xp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}wp.isMDXComponent=!0;const gp={toc:[]};function Tp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Tp.isMDXComponent=!0;const xp={toc:[]};function Cp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}Cp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Lp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}bp.isMDXComponent=!0;const Np={toc:[]};function zp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Wp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Wp.isMDXComponent=!0;const Rp={toc:[]};function Sp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Sp.isMDXComponent=!0;const Ip={toc:[]};function Pp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Pp.isMDXComponent=!0;const Ep={toc:[]};function Bp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Bp.isMDXComponent=!0;const Gp={toc:[]};function Op(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Op.isMDXComponent=!0;const Fp={toc:[]};function Up(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Up.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Vp.isMDXComponent=!0;const jp={toc:[]};function Qp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Qp.isMDXComponent=!0;const Hp={toc:[]};function $p(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}$p.isMDXComponent=!0;const Yp={toc:[]};function Kp(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Kp.isMDXComponent=!0;const Jp={toc:[]};function tr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}pr.isMDXComponent=!0;const rr={toc:[]};function sr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}sr.isMDXComponent=!0;const cr={toc:[]};function ir(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ir.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ar,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}hr.isMDXComponent=!0;const kr={toc:[]};function yr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}yr.isMDXComponent=!0;const fr={toc:[]};function Mr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function _r(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}_r.isMDXComponent=!0;const Xr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}wr.isMDXComponent=!0;const gr={toc:[]};function Tr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Tr.isMDXComponent=!0;const xr={toc:[]};function Cr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Cr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Lr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}br.isMDXComponent=!0;const Nr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Wr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Wr.isMDXComponent=!0;const Rr={toc:[]};function Sr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Sr.isMDXComponent=!0;const Ir={toc:[]};function Pr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ir,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Pr.isMDXComponent=!0;const Er={toc:[]};function Br(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Er,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Br.isMDXComponent=!0;const Gr={toc:[]};function Or(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Or.isMDXComponent=!0;const Fr={toc:[]};function Ur(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Ur.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}Vr.isMDXComponent=!0;const jr={toc:[]};function Qr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}Qr.isMDXComponent=!0;const Hr={toc:[]};function $r(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}$r.isMDXComponent=!0;const Yr={toc:[]};function Kr(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}Kr.isMDXComponent=!0;const Jr={toc:[]};function ts(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}ps.isMDXComponent=!0;const rs={toc:[]};function ss(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}ss.isMDXComponent=!0;const cs={toc:[]};function is(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}is.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},as,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}hs.isMDXComponent=!0;const ks={toc:[]};function ys(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ks,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}ys.isMDXComponent=!0;const fs={toc:[]};function Ms(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function _s(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ds,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}_s.isMDXComponent=!0;const Xs={toc:[]};function ws(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ws.isMDXComponent=!0;const gs={toc:[]};function Ts(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Ts.isMDXComponent=!0;const xs={toc:[]};function Cs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Cs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Ls.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function zs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}zs.isMDXComponent=!0;const As={toc:[]};function Ws(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}Ws.isMDXComponent=!0;const Rs={toc:[]};function Ss(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Ss.isMDXComponent=!0;const Is={toc:[]};function Ps(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Is,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ps.isMDXComponent=!0;const Es={toc:[]};function Bs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Es,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Bs.isMDXComponent=!0;const Gs={toc:[]};function Os(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Os.isMDXComponent=!0;const Fs={toc:[]};function Us(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Us.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Vs.isMDXComponent=!0;const js={toc:[]};function Qs(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Qs.isMDXComponent=!0;const Hs={toc:[]};function $s(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}$s.isMDXComponent=!0;const Ys={toc:[]};function Ks(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ys,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ks.isMDXComponent=!0;const Js={toc:[]};function tc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Js,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}pc.isMDXComponent=!0;const rc={toc:[]};function sc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}sc.isMDXComponent=!0;const cc={toc:[]};function ic(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}ic.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ac,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}hc.isMDXComponent=!0;const kc={toc:[]};function yc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}yc.isMDXComponent=!0;const fc={toc:[]};function Mc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function _c(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}_c.isMDXComponent=!0;const Xc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}wc.isMDXComponent=!0;const gc={toc:[]};function Tc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Tc.isMDXComponent=!0;const xc={toc:[]};function Cc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Cc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}Lc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}bc.isMDXComponent=!0;const Nc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Wc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Wc.isMDXComponent=!0;const Rc={toc:[]};function Sc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Sc.isMDXComponent=!0;const Ic={toc:[]};function Pc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ic,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Pc.isMDXComponent=!0;const Ec={toc:[]};function Bc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ec,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Bc.isMDXComponent=!0;const Gc={toc:[]};function Oc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}Oc.isMDXComponent=!0;const Fc={toc:[]};function Uc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Uc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vc.isMDXComponent=!0;const jc={toc:[]};function Qc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Qc.isMDXComponent=!0;const Hc={toc:[]};function $c(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}$c.isMDXComponent=!0;const Yc={toc:[]};function Kc(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kc.isMDXComponent=!0;const Jc={toc:[]};function ti(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pi.isMDXComponent=!0;const ri={toc:[]};function si(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ri,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}si.isMDXComponent=!0;const ci={toc:[]};function ii(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}ii.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ai,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hi.isMDXComponent=!0;const ki={toc:[]};function yi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ki,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}yi.isMDXComponent=!0;const fi={toc:[]};function Mi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mi.isMDXComponent=!0;const Di={toc:[]};function _i(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Di,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}_i.isMDXComponent=!0;const Xi={toc:[]};function wi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}wi.isMDXComponent=!0;const gi={toc:[]};function Ti(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ti.isMDXComponent=!0;const xi={toc:[]};function Ci(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ci.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Li.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}bi.isMDXComponent=!0;const Ni={toc:[]};function zi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Wi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Wi.isMDXComponent=!0;const Ri={toc:[]};function Si(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ri,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Si.isMDXComponent=!0;const Ii={toc:[]};function Pi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ii,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Pi.isMDXComponent=!0;const Ei={toc:[]};function Bi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ei,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Bi.isMDXComponent=!0;const Gi={toc:[]};function Oi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Oi.isMDXComponent=!0;const Fi={toc:[]};function Ui(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ui.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Vi.isMDXComponent=!0;const ji={toc:[]};function Qi(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Qi.isMDXComponent=!0;const Hi={toc:[]};function $i(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}$i.isMDXComponent=!0;const Yi={toc:[]};function Ki(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ki.isMDXComponent=!0;const Ji={toc:[]};function ta(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ji,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}pa.isMDXComponent=!0;const ra={toc:[]};function sa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ra,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}sa.isMDXComponent=!0;const ca={toc:[]};function ia(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ia.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ha.isMDXComponent=!0;const ka={toc:[]};function ya(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ka,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ya.isMDXComponent=!0;const fa={toc:[]};function Ma(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}Ma.isMDXComponent=!0;const Da={toc:[]};function _a(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Da,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}_a.isMDXComponent=!0;const Xa={toc:[]};function wa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}wa.isMDXComponent=!0;const ga={toc:[]};function Ta(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ta.isMDXComponent=!0;const xa={toc:[]};function Ca(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Ca.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}La.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Za,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}ba.isMDXComponent=!0;const Na={toc:[]};function za(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}za.isMDXComponent=!0;const Aa={toc:[]};function Wa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Wa.isMDXComponent=!0;const Ra={toc:[]};function Sa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ra,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Sa.isMDXComponent=!0;const Ia={toc:[]};function Pa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ia,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Pa.isMDXComponent=!0;const Ea={toc:[]};function Ba(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ea,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ba.isMDXComponent=!0;const Ga={toc:[]};function Oa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ga,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Oa.isMDXComponent=!0;const Fa={toc:[]};function Ua(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Ua.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Va.isMDXComponent=!0;const ja={toc:[]};function Qa(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Qa.isMDXComponent=!0;const Ha={toc:[]};function $a(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ha,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}$a.isMDXComponent=!0;const Ya={toc:[]};function Ka(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ya,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ka.isMDXComponent=!0;const Ja={toc:[]};function tl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ja,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}pl.isMDXComponent=!0;const rl={toc:[]};function sl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}sl.isMDXComponent=!0;const cl={toc:[]};function il(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}il.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},al,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}hl.isMDXComponent=!0;const kl={toc:[]};function yl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}yl.isMDXComponent=!0;const fl={toc:[]};function Ml(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function _l(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}_l.isMDXComponent=!0;const Xl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}wl.isMDXComponent=!0;const gl={toc:[]};function Tl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Tl.isMDXComponent=!0;const xl={toc:[]};function Cl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Cl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ll.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}bl.isMDXComponent=!0;const Nl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}zl.isMDXComponent=!0;const Al={toc:[]};function Wl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Wl.isMDXComponent=!0;const Rl={toc:[]};function Sl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Sl.isMDXComponent=!0;const Il={toc:[]};function Pl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Il,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Pl.isMDXComponent=!0;const El={toc:[]};function Bl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},El,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Bl.isMDXComponent=!0;const Gl={toc:[]};function Ol(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}Ol.isMDXComponent=!0;const Fl={toc:[]};function Ul(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ul.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Vl.isMDXComponent=!0;const jl={toc:[]};function Ql(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ql.isMDXComponent=!0;const Hl={toc:[]};function $l(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}$l.isMDXComponent=!0;const Yl={toc:[]};function Kl(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kl.isMDXComponent=!0;const Jl={toc:[]};function tu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pu.isMDXComponent=!0;const ru={toc:[]};function su(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ru,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}su.isMDXComponent=!0;const cu={toc:[]};function iu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}iu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},au,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hu.isMDXComponent=!0;const ku={toc:[]};function yu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ku,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}yu.isMDXComponent=!0;const fu={toc:[]};function Mu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Mu.isMDXComponent=!0;const Du={toc:[]};function _u(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Du,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}_u.isMDXComponent=!0;const Xu={toc:[]};function wu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}wu.isMDXComponent=!0;const gu={toc:[]};function Tu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Tu.isMDXComponent=!0;const xu={toc:[]};function Cu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Cu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Lu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}bu.isMDXComponent=!0;const Nu={toc:[]};function zu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}zu.isMDXComponent=!0;const Au={toc:[]};function Wu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}Wu.isMDXComponent=!0;const Ru={toc:[]};function Su(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ru,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Su.isMDXComponent=!0;const Iu={toc:[]};function Pu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Pu.isMDXComponent=!0;const Eu={toc:[]};function Bu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Bu.isMDXComponent=!0;const Gu={toc:[]};function Ou(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ou.isMDXComponent=!0;const Fu={toc:[]};function Uu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Uu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Vu.isMDXComponent=!0;const ju={toc:[]};function Qu(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Qu.isMDXComponent=!0;const Hu={toc:[]};function $u(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}$u.isMDXComponent=!0;const Yu={toc:[]};function Ku(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ku.isMDXComponent=!0;const Ju={toc:[]};function tm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ju,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}pm.isMDXComponent=!0;const rm={toc:[]};function sm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sm.isMDXComponent=!0;const cm={toc:[]};function im(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}im.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},am,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}hm.isMDXComponent=!0;const km={toc:[]};function ym(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},km,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ym.isMDXComponent=!0;const fm={toc:[]};function Mm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function _m(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}_m.isMDXComponent=!0;const Xm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}wm.isMDXComponent=!0;const gm={toc:[]};function Tm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}Tm.isMDXComponent=!0;const xm={toc:[]};function Cm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Lm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bm.isMDXComponent=!0;const Nm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zm.isMDXComponent=!0;const Am={toc:[]};function Wm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wm.isMDXComponent=!0;const Rm={toc:[]};function Sm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Sm.isMDXComponent=!0;const Im={toc:[]};function Pm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Im,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Pm.isMDXComponent=!0;const Em={toc:[]};function Bm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Em,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bm.isMDXComponent=!0;const Gm={toc:[]};function Om(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Om.isMDXComponent=!0;const Fm={toc:[]};function Um(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Um.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vm.isMDXComponent=!0;const jm={toc:[]};function Qm(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Qm.isMDXComponent=!0;const Hm={toc:[]};function $m(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}$m.isMDXComponent=!0;const Ym={toc:[]};function Km(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ym,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Km.isMDXComponent=!0;const Jm={toc:[]};function td(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}pd.isMDXComponent=!0;const rd={toc:[]};function sd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sd.isMDXComponent=!0;const cd={toc:[]};function id(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}id.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ad,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}hd.isMDXComponent=!0;const kd={toc:[]};function yd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}yd.isMDXComponent=!0;const fd={toc:[]};function Md(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Md.isMDXComponent=!0;const Dd={toc:[]};function _d(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}_d.isMDXComponent=!0;const Xd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}wd.isMDXComponent=!0;const gd={toc:[]};function Td(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}Td.isMDXComponent=!0;const xd={toc:[]};function Cd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ld.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bd.isMDXComponent=!0;const Nd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Wd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wd.isMDXComponent=!0;const Rd={toc:[]};function Sd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Sd.isMDXComponent=!0;const Id={toc:[]};function Pd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Id,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Pd.isMDXComponent=!0;const Ed={toc:[]};function Bd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ed,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Bd.isMDXComponent=!0;const Gd={toc:[]};function Od(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Od.isMDXComponent=!0;const Fd={toc:[]};function Ud(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Ud.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vd.isMDXComponent=!0;const jd={toc:[]};function Qd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Qd.isMDXComponent=!0;const Hd={toc:[]};function $d(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}$d.isMDXComponent=!0;const Yd={toc:[]};function Kd(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Kd.isMDXComponent=!0;const Jd={toc:[]};function th(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}ph.isMDXComponent=!0;const rh={toc:[]};function sh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sh.isMDXComponent=!0;const ch={toc:[]};function ih(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ih.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ah,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}hh.isMDXComponent=!0;const kh={toc:[]};function yh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}yh.isMDXComponent=!0;const fh={toc:[]};function Mh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function _h(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}_h.isMDXComponent=!0;const Xh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}wh.isMDXComponent=!0;const gh={toc:[]};function Th(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Th.isMDXComponent=!0;const xh={toc:[]};function Ch(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ch.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Lh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}bh.isMDXComponent=!0;const Nh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Wh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Wh.isMDXComponent=!0;const Rh={toc:[]};function Sh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Sh.isMDXComponent=!0;const Ih={toc:[]};function Ph(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ih,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ph.isMDXComponent=!0;const Eh={toc:[]};function Bh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Bh.isMDXComponent=!0;const Gh={toc:[]};function Oh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Oh.isMDXComponent=!0;const Fh={toc:[]};function Uh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Uh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Vh.isMDXComponent=!0;const jh={toc:[]};function Qh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Qh.isMDXComponent=!0;const Hh={toc:[]};function $h(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}$h.isMDXComponent=!0;const Yh={toc:[]};function Kh(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Kh.isMDXComponent=!0;const Jh={toc:[]};function tk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}pk.isMDXComponent=!0;const rk={toc:[]};function sk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}sk.isMDXComponent=!0;const ck={toc:[]};function ik(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ck,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}ik.isMDXComponent=!0;const ak={toc:[]};function lk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ak,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}hk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}yk.isMDXComponent=!0;const fk={toc:[]};function Mk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Mk.isMDXComponent=!0;const Dk={toc:[]};function _k(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}_k.isMDXComponent=!0;const Xk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}wk.isMDXComponent=!0;const gk={toc:[]};function Tk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}Tk.isMDXComponent=!0;const xk={toc:[]};function Ck(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}Ck.isMDXComponent=!0;const vk={toc:[]};function Lk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}Lk.isMDXComponent=!0;const Zk={toc:[]};function bk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}bk.isMDXComponent=!0;const Nk={toc:[]};function zk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}zk.isMDXComponent=!0;const Ak={toc:[]};function Wk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ak,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}Wk.isMDXComponent=!0;const Rk={toc:[]};function Sk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}Sk.isMDXComponent=!0;const Ik={toc:[]};function Pk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ik,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Pk.isMDXComponent=!0;const Ek={toc:[]};function Bk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ek,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}Bk.isMDXComponent=!0;const Gk={toc:[]};function Ok(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Ok.isMDXComponent=!0;const Fk={toc:[]};function Uk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Uk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}Vk.isMDXComponent=!0;const jk={toc:[]};function Qk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}Qk.isMDXComponent=!0;const Hk={toc:[]};function $k(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}$k.isMDXComponent=!0;const Yk={toc:[]};function Kk(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}Kk.isMDXComponent=!0;const Jk={toc:[]};function ty(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}py.isMDXComponent=!0;const ry={toc:[]};function sy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ry,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}sy.isMDXComponent=!0;const cy={toc:[]};function iy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}iy.isMDXComponent=!0;const ay={toc:[]};function ly(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ay,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}hy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ky,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}yy.isMDXComponent=!0;const fy={toc:[]};function My(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}My.isMDXComponent=!0;const Dy={toc:[]};function _y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_y.isMDXComponent=!0;const Xy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}wy.isMDXComponent=!0;const gy={toc:[]};function Ty(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}Ty.isMDXComponent=!0;const xy={toc:[]};function Cy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}Cy.isMDXComponent=!0;const vy={toc:[]};function Ly(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Ly.isMDXComponent=!0;const Zy={toc:[]};function by(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}by.isMDXComponent=!0;const Ny={toc:[]};function zy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}zy.isMDXComponent=!0;const Ay={toc:[]};function Wy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ay,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Wy.isMDXComponent=!0;const Ry={toc:[]};function Sy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ry,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}Sy.isMDXComponent=!0;const Iy={toc:[]};function Py(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Py.isMDXComponent=!0;const Ey={toc:[]};function By(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ey,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}By.isMDXComponent=!0;const Gy={toc:[]};function Oy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Oy.isMDXComponent=!0;const Fy={toc:[]};function Uy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Uy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}Vy.isMDXComponent=!0;const jy={toc:[]};function Qy(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Qy.isMDXComponent=!0;const Hy={toc:[]};function $y(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}$y.isMDXComponent=!0;const Yy={toc:[]};function Ky(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Ky.isMDXComponent=!0;const Jy={toc:[]};function tf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}pf.isMDXComponent=!0;const rf={toc:[]};function sf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}sf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}df.isMDXComponent=!0;const hf={toc:[]};function kf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}kf.isMDXComponent=!0;const yf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}ff.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Df.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_f,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Xf.isMDXComponent=!0;const wf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}gf.isMDXComponent=!0;const Tf={toc:[]};function xf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}xf.isMDXComponent=!0;const Cf={toc:[]};function vf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}vf.isMDXComponent=!0;const Lf={toc:[]};function Zf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Nf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Af.isMDXComponent=!0;const Wf={toc:[]};function Rf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}Rf.isMDXComponent=!0;const Sf={toc:[]};function If(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}If.isMDXComponent=!0;const Pf={toc:[]};function Ef(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Ef.isMDXComponent=!0;const Bf={toc:[]};function Gf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Gf.isMDXComponent=!0;const Of={toc:[]};function Ff(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Of,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}Ff.isMDXComponent=!0;const Uf={toc:[]};function qf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}qf.isMDXComponent=!0;const Vf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}jf.isMDXComponent=!0;const Qf={toc:[]};function Hf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}Hf.isMDXComponent=!0;const $f={toc:[]};function Yf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$f,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Yf.isMDXComponent=!0;const Kf={toc:[]};function Jf(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Jf.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}rM.isMDXComponent=!0;const sM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}cM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}dM.isMDXComponent=!0;const hM={toc:[]};function kM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}kM.isMDXComponent=!0;const yM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}fM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}DM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_M,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}XM.isMDXComponent=!0;const wM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}gM.isMDXComponent=!0;const TM={toc:[]};function xM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}xM.isMDXComponent=!0;const CM={toc:[]};function vM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}vM.isMDXComponent=!0;const LM={toc:[]};function ZM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}NM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}AM.isMDXComponent=!0;const WM={toc:[]};function RM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}RM.isMDXComponent=!0;const SM={toc:[]};function IM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}IM.isMDXComponent=!0;const PM={toc:[]};function EM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}EM.isMDXComponent=!0;const BM={toc:[]};function GM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}GM.isMDXComponent=!0;const OM={toc:[]};function FM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}FM.isMDXComponent=!0;const UM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}qM.isMDXComponent=!0;const VM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}jM.isMDXComponent=!0;const QM={toc:[]};function HM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}HM.isMDXComponent=!0;const $M={toc:[]};function YM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$M,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YM.isMDXComponent=!0;const KM={toc:[]};function JM(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}JM.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}rD.isMDXComponent=!0;const sD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}cD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}dD.isMDXComponent=!0;const hD={toc:[]};function kD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}kD.isMDXComponent=!0;const yD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}fD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}DD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_D,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}XD.isMDXComponent=!0;const wD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}gD.isMDXComponent=!0;const TD={toc:[]};function xD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}xD.isMDXComponent=!0;const CD={toc:[]};function vD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}vD.isMDXComponent=!0;const LD={toc:[]};function ZD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}ND.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}AD.isMDXComponent=!0;const WD={toc:[]};function RD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}RD.isMDXComponent=!0;const SD={toc:[]};function ID(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}ID.isMDXComponent=!0;const PD={toc:[]};function ED(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}ED.isMDXComponent=!0;const BD={toc:[]};function GD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}GD.isMDXComponent=!0;const OD={toc:[]};function FD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}FD.isMDXComponent=!0;const UD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}qD.isMDXComponent=!0;const VD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}jD.isMDXComponent=!0;const QD={toc:[]};function HD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}HD.isMDXComponent=!0;const $D={toc:[]};function YD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$D,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}YD.isMDXComponent=!0;const KD={toc:[]};function JD(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}JD.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}r_.isMDXComponent=!0;const s_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}c_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}d_.isMDXComponent=!0;const h_={toc:[]};function k_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}k_.isMDXComponent=!0;const y_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}f_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}D_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}X_.isMDXComponent=!0;const w_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}g_.isMDXComponent=!0;const T_={toc:[]};function x_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}x_.isMDXComponent=!0;const C_={toc:[]};function v_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}v_.isMDXComponent=!0;const L_={toc:[]};function Z_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}N_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}A_.isMDXComponent=!0;const W_={toc:[]};function R_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}R_.isMDXComponent=!0;const S_={toc:[]};function I_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}I_.isMDXComponent=!0;const P_={toc:[]};function E_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}E_.isMDXComponent=!0;const B_={toc:[]};function G_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}G_.isMDXComponent=!0;const O_={toc:[]};function F_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}F_.isMDXComponent=!0;const U_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}q_.isMDXComponent=!0;const V_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}j_.isMDXComponent=!0;const Q_={toc:[]};function H_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}H_.isMDXComponent=!0;const $_={toc:[]};function Y_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Y_.isMDXComponent=!0;const K_={toc:[]};function J_(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}J_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}rX.isMDXComponent=!0;const sX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}cX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}dX.isMDXComponent=!0;const hX={toc:[]};function kX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}kX.isMDXComponent=!0;const yX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}fX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}DX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_X,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}XX.isMDXComponent=!0;const wX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}gX.isMDXComponent=!0;const TX={toc:[]};function xX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}xX.isMDXComponent=!0;const CX={toc:[]};function vX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}vX.isMDXComponent=!0;const LX={toc:[]};function ZX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}NX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}AX.isMDXComponent=!0;const WX={toc:[]};function RX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}RX.isMDXComponent=!0;const SX={toc:[]};function IX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}IX.isMDXComponent=!0;const PX={toc:[]};function EX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}EX.isMDXComponent=!0;const BX={toc:[]};function GX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}GX.isMDXComponent=!0;const OX={toc:[]};function FX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}FX.isMDXComponent=!0;const UX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}qX.isMDXComponent=!0;const VX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}jX.isMDXComponent=!0;const QX={toc:[]};function HX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}HX.isMDXComponent=!0;const $X={toc:[]};function YX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$X,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}YX.isMDXComponent=!0;const KX={toc:[]};function JX(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}JX.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}rw.isMDXComponent=!0;const sw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}cw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}dw.isMDXComponent=!0;const hw={toc:[]};function kw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}kw.isMDXComponent=!0;const yw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}fw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}Dw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_w,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Xw.isMDXComponent=!0;const ww={toc:[]};function gw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}gw.isMDXComponent=!0;const Tw={toc:[]};function xw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}xw.isMDXComponent=!0;const Cw={toc:[]};function vw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}vw.isMDXComponent=!0;const Lw={toc:[]};function Zw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}Nw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}Aw.isMDXComponent=!0;const Ww={toc:[]};function Rw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}Rw.isMDXComponent=!0;const Sw={toc:[]};function Iw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}Iw.isMDXComponent=!0;const Pw={toc:[]};function Ew(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}Ew.isMDXComponent=!0;const Bw={toc:[]};function Gw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}Gw.isMDXComponent=!0;const Ow={toc:[]};function Fw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ow,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}Fw.isMDXComponent=!0;const Uw={toc:[]};function qw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}qw.isMDXComponent=!0;const Vw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}jw.isMDXComponent=!0;const Qw={toc:[]};function Hw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}Hw.isMDXComponent=!0;const $w={toc:[]};function Yw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$w,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}Yw.isMDXComponent=!0;const Kw={toc:[]};function Jw(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}Jw.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}rg.isMDXComponent=!0;const sg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}cg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ig,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}dg.isMDXComponent=!0;const hg={toc:[]};function kg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}kg.isMDXComponent=!0;const yg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}fg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Dg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_g,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Xg.isMDXComponent=!0;const wg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}gg.isMDXComponent=!0;const Tg={toc:[]};function xg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}xg.isMDXComponent=!0;const Cg={toc:[]};function vg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}vg.isMDXComponent=!0;const Lg={toc:[]};function Zg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Ng.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Ag.isMDXComponent=!0;const Wg={toc:[]};function Rg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Rg.isMDXComponent=!0;const Sg={toc:[]};function Ig(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Ig.isMDXComponent=!0;const Pg={toc:[]};function Eg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}Eg.isMDXComponent=!0;const Bg={toc:[]};function Gg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}Gg.isMDXComponent=!0;const Og={toc:[]};function Fg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Og,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}Fg.isMDXComponent=!0;const Ug={toc:[]};function qg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ug,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}qg.isMDXComponent=!0;const Vg={toc:[]};function jg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}jg.isMDXComponent=!0;const Qg={toc:[]};function Hg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}Hg.isMDXComponent=!0;const $g={toc:[]};function Yg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$g,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}Yg.isMDXComponent=!0;const Kg={toc:[]};function Jg(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Jg.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}rT.isMDXComponent=!0;const sT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}cT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}dT.isMDXComponent=!0;const hT={toc:[]};function kT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}kT.isMDXComponent=!0;const yT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}fT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}DT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_T,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}XT.isMDXComponent=!0;const wT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gT.isMDXComponent=!0;const TT={toc:[]};function xT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}xT.isMDXComponent=!0;const CT={toc:[]};function vT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}vT.isMDXComponent=!0;const LT={toc:[]};function ZT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}NT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}AT.isMDXComponent=!0;const WT={toc:[]};function RT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}RT.isMDXComponent=!0;const ST={toc:[]};function IT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ST,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}IT.isMDXComponent=!0;const PT={toc:[]};function ET(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}ET.isMDXComponent=!0;const BT={toc:[]};function GT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}GT.isMDXComponent=!0;const OT={toc:[]};function FT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}FT.isMDXComponent=!0;const UT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}qT.isMDXComponent=!0;const VT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}jT.isMDXComponent=!0;const QT={toc:[]};function HT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}HT.isMDXComponent=!0;const $T={toc:[]};function YT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$T,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}YT.isMDXComponent=!0;const KT={toc:[]};function JT(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}JT.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}rx.isMDXComponent=!0;const sx={toc:[]};function cx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}cx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ix,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}dx.isMDXComponent=!0;const hx={toc:[]};function kx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}kx.isMDXComponent=!0;const yx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}fx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}Dx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_x,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Xx.isMDXComponent=!0;const wx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}gx.isMDXComponent=!0;const Tx={toc:[]};function xx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}xx.isMDXComponent=!0;const Cx={toc:[]};function vx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}vx.isMDXComponent=!0;const Lx={toc:[]};function Zx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Nx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}Ax.isMDXComponent=!0;const Wx={toc:[]};function Rx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Rx.isMDXComponent=!0;const Sx={toc:[]};function Ix(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Ix.isMDXComponent=!0;const Px={toc:[]};function Ex(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Px,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}Ex.isMDXComponent=!0;const Bx={toc:[]};function Gx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}Gx.isMDXComponent=!0;const Ox={toc:[]};function Fx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ox,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}Fx.isMDXComponent=!0;const Ux={toc:[]};function qx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ux,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}qx.isMDXComponent=!0;const Vx={toc:[]};function jx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}jx.isMDXComponent=!0;const Qx={toc:[]};function Hx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}Hx.isMDXComponent=!0;const $x={toc:[]};function Yx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$x,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Yx.isMDXComponent=!0;const Kx={toc:[]};function Jx(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}Jx.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}rC.isMDXComponent=!0;const sC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}cC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}dC.isMDXComponent=!0;const hC={toc:[]};function kC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}kC.isMDXComponent=!0;const yC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}fC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}DC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_C,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}XC.isMDXComponent=!0;const wC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}gC.isMDXComponent=!0;const TC={toc:[]};function xC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}xC.isMDXComponent=!0;const CC={toc:[]};function vC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}vC.isMDXComponent=!0;const LC={toc:[]};function ZC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}NC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}AC.isMDXComponent=!0;const WC={toc:[]};function RC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}RC.isMDXComponent=!0;const SC={toc:[]};function IC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}IC.isMDXComponent=!0;const PC={toc:[]};function EC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}EC.isMDXComponent=!0;const BC={toc:[]};function GC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}GC.isMDXComponent=!0;const OC={toc:[]};function FC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}FC.isMDXComponent=!0;const UC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}qC.isMDXComponent=!0;const VC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}jC.isMDXComponent=!0;const QC={toc:[]};function HC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}HC.isMDXComponent=!0;const $C={toc:[]};function YC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$C,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}YC.isMDXComponent=!0;const KC={toc:[]};function JC(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}JC.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}rv.isMDXComponent=!0;const sv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}cv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}dv.isMDXComponent=!0;const hv={toc:[]};function kv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}kv.isMDXComponent=!0;const yv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}fv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}Dv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_v,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}Xv.isMDXComponent=!0;const wv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}gv.isMDXComponent=!0;const Tv={toc:[]};function xv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}xv.isMDXComponent=!0;const Cv={toc:[]};function vv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}vv.isMDXComponent=!0;const Lv={toc:[]};function Zv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}Nv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}Av.isMDXComponent=!0;const Wv={toc:[]};function Rv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}Rv.isMDXComponent=!0;const Sv={toc:[]};function Iv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}Iv.isMDXComponent=!0;const Pv={toc:[]};function Ev(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}Ev.isMDXComponent=!0;const Bv={toc:[]};function Gv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Gv.isMDXComponent=!0;const Ov={toc:[]};function Fv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ov,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}Fv.isMDXComponent=!0;const Uv={toc:[]};function qv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}qv.isMDXComponent=!0;const Vv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}jv.isMDXComponent=!0;const Qv={toc:[]};function Hv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}Hv.isMDXComponent=!0;const $v={toc:[]};function Yv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$v,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}Yv.isMDXComponent=!0;const Kv={toc:[]};function Jv(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}Jv.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}rL.isMDXComponent=!0;const sL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}cL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}dL.isMDXComponent=!0;const hL={toc:[]};function kL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}kL.isMDXComponent=!0;const yL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}fL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ML,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}DL.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_L,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}XL.isMDXComponent=!0;const wL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}gL.isMDXComponent=!0;const TL={toc:[]};function xL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}xL.isMDXComponent=!0;const CL={toc:[]};function vL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}vL.isMDXComponent=!0;const LL={toc:[]};function ZL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}NL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}AL.isMDXComponent=!0;const WL={toc:[]};function RL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}RL.isMDXComponent=!0;const SL={toc:[]};function IL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}IL.isMDXComponent=!0;const PL={toc:[]};function EL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}EL.isMDXComponent=!0;const BL={toc:[]};function GL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}GL.isMDXComponent=!0;const OL={toc:[]};function FL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}FL.isMDXComponent=!0;const UL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}qL.isMDXComponent=!0;const VL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}jL.isMDXComponent=!0;const QL={toc:[]};function HL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}HL.isMDXComponent=!0;const $L={toc:[]};function YL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$L,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}YL.isMDXComponent=!0;const KL={toc:[]};function JL(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}JL.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}rZ.isMDXComponent=!0;const sZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}cZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n")))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function kZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kZ.isMDXComponent=!0;const yZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}fZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}DZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}XZ.isMDXComponent=!0;const wZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}gZ.isMDXComponent=!0;const TZ={toc:[]};function xZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}xZ.isMDXComponent=!0;const CZ={toc:[]};function vZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function ZZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}NZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}AZ.isMDXComponent=!0;const WZ={toc:[]};function RZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}RZ.isMDXComponent=!0;const SZ={toc:[]};function IZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}IZ.isMDXComponent=!0;const PZ={toc:[]};function EZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}EZ.isMDXComponent=!0;const BZ={toc:[]};function GZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}GZ.isMDXComponent=!0;const OZ={toc:[]};function FZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}FZ.isMDXComponent=!0;const UZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}jZ.isMDXComponent=!0;const QZ={toc:[]};function HZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}HZ.isMDXComponent=!0;const $Z={toc:[]};function YZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}YZ.isMDXComponent=!0;const KZ={toc:[]};function JZ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}JZ.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}rb.isMDXComponent=!0;const sb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}cb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ib,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}db.isMDXComponent=!0;const hb={toc:[]};function kb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kb.isMDXComponent=!0;const yb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}fb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Db.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_b,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Xb.isMDXComponent=!0;const wb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}gb.isMDXComponent=!0;const Tb={toc:[]};function xb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}xb.isMDXComponent=!0;const Cb={toc:[]};function vb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}vb.isMDXComponent=!0;const Lb={toc:[]};function Zb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Nb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Ab.isMDXComponent=!0;const Wb={toc:[]};function Rb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Rb.isMDXComponent=!0;const Sb={toc:[]};function Ib(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ib.isMDXComponent=!0;const Pb={toc:[]};function Eb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Eb.isMDXComponent=!0;const Bb={toc:[]};function Gb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Gb.isMDXComponent=!0;const Ob={toc:[]};function Fb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ob,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Fb.isMDXComponent=!0;const Ub={toc:[]};function qb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ub,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qb.isMDXComponent=!0;const Vb={toc:[]};function jb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}jb.isMDXComponent=!0;const Qb={toc:[]};function Hb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Hb.isMDXComponent=!0;const $b={toc:[]};function Yb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$b,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Yb.isMDXComponent=!0;const Kb={toc:[]};function Jb(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Jb.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}rN.isMDXComponent=!0;const sN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}dN.isMDXComponent=!0;const hN={toc:[]};function kN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}kN.isMDXComponent=!0;const yN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}fN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}DN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_N,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}XN.isMDXComponent=!0;const wN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gN.isMDXComponent=!0;const TN={toc:[]};function xN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}xN.isMDXComponent=!0;const CN={toc:[]};function vN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}vN.isMDXComponent=!0;const LN={toc:[]};function ZN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}NN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}AN.isMDXComponent=!0;const WN={toc:[]};function RN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}RN.isMDXComponent=!0;const SN={toc:[]};function IN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}IN.isMDXComponent=!0;const PN={toc:[]};function EN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}EN.isMDXComponent=!0;const BN={toc:[]};function GN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}GN.isMDXComponent=!0;const ON={toc:[]};function FN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ON,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}FN.isMDXComponent=!0;const UN={toc:[]};function qN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qN.isMDXComponent=!0;const VN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}jN.isMDXComponent=!0;const QN={toc:[]};function HN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}HN.isMDXComponent=!0;const $N={toc:[]};function YN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$N,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}YN.isMDXComponent=!0;const KN={toc:[]};function JN(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}JN.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}rz.isMDXComponent=!0;const sz={toc:[]};function cz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}cz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}dz.isMDXComponent=!0;const hz={toc:[]};function kz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kz.isMDXComponent=!0;const yz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}fz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Dz.isMDXComponent=!0;const _z={toc:[]};function Xz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Xz.isMDXComponent=!0;const wz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}gz.isMDXComponent=!0;const Tz={toc:[]};function xz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xz.isMDXComponent=!0;const Cz={toc:[]};function vz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}vz.isMDXComponent=!0;const Lz={toc:[]};function Zz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Az.isMDXComponent=!0;const Wz={toc:[]};function Rz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Rz.isMDXComponent=!0;const Sz={toc:[]};function Iz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Iz.isMDXComponent=!0;const Pz={toc:[]};function Ez(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ez.isMDXComponent=!0;const Bz={toc:[]};function Gz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Gz.isMDXComponent=!0;const Oz={toc:[]};function Fz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Fz.isMDXComponent=!0;const Uz={toc:[]};function qz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}qz.isMDXComponent=!0;const Vz={toc:[]};function jz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jz.isMDXComponent=!0;const Qz={toc:[]};function Hz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Hz.isMDXComponent=!0;const $z={toc:[]};function Yz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$z,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Yz.isMDXComponent=!0;const Kz={toc:[]};function Jz(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Jz.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}rA.isMDXComponent=!0;const sA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}dA.isMDXComponent=!0;const hA={toc:[]};function kA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kA.isMDXComponent=!0;const yA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}fA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}DA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_A,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}XA.isMDXComponent=!0;const wA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gA.isMDXComponent=!0;const TA={toc:[]};function xA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}xA.isMDXComponent=!0;const CA={toc:[]};function vA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}vA.isMDXComponent=!0;const LA={toc:[]};function ZA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}NA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}AA.isMDXComponent=!0;const WA={toc:[]};function RA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}RA.isMDXComponent=!0;const SA={toc:[]};function IA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}IA.isMDXComponent=!0;const PA={toc:[]};function EA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}EA.isMDXComponent=!0;const BA={toc:[]};function GA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}GA.isMDXComponent=!0;const OA={toc:[]};function FA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}FA.isMDXComponent=!0;const UA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qA.isMDXComponent=!0;const VA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}jA.isMDXComponent=!0;const QA={toc:[]};function HA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}HA.isMDXComponent=!0;const $A={toc:[]};function YA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$A,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}YA.isMDXComponent=!0;const KA={toc:[]};function JA(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}JA.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}rW.isMDXComponent=!0;const sW={toc:[]};function cW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}cW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dW.isMDXComponent=!0;const hW={toc:[]};function kW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kW.isMDXComponent=!0;const yW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}DW.isMDXComponent=!0;const _W={toc:[]};function XW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_W,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}XW.isMDXComponent=!0;const wW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}gW.isMDXComponent=!0;const TW={toc:[]};function xW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}xW.isMDXComponent=!0;const CW={toc:[]};function vW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vW.isMDXComponent=!0;const LW={toc:[]};function ZW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}NW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}AW.isMDXComponent=!0;const WW={toc:[]};function RW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}RW.isMDXComponent=!0;const SW={toc:[]};function IW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining a cubic B\xe9zier curve using ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  <CubicBezier\n    lineWidth={4}\n    stroke={'lightseagreen'}\n    p0={[-200, -200]}\n    p1={[100, -200]}\n    p2={[-100, 200]}\n    p3={[200, 200]}\n    end={0}\n  />\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}IW.isMDXComponent=!0;const PW={toc:[]};function EW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}EW.isMDXComponent=!0;const BW={toc:[]};function GW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}GW.isMDXComponent=!0;const OW={toc:[]};function FW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}FW.isMDXComponent=!0;const UW={toc:[]};function qW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qW.isMDXComponent=!0;const VW={toc:[]};function jW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}jW.isMDXComponent=!0;const QW={toc:[]};function HW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}HW.isMDXComponent=!0;const $W={toc:[]};function YW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$W,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}YW.isMDXComponent=!0;const KW={toc:[]};function JW(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}JW.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}rR.isMDXComponent=!0;const sR={toc:[]};function cR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dR.isMDXComponent=!0;const hR={toc:[]};function kR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}kR.isMDXComponent=!0;const yR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}fR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}DR.isMDXComponent=!0;const _R={toc:[]};function XR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_R,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}XR.isMDXComponent=!0;const wR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gR.isMDXComponent=!0;const TR={toc:[]};function xR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}xR.isMDXComponent=!0;const CR={toc:[]};function vR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}vR.isMDXComponent=!0;const LR={toc:[]};function ZR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}NR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}AR.isMDXComponent=!0;const WR={toc:[]};function RR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}RR.isMDXComponent=!0;const SR={toc:[]};function IR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}IR.isMDXComponent=!0;const PR={toc:[]};function ER(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}ER.isMDXComponent=!0;const BR={toc:[]};function GR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}GR.isMDXComponent=!0;const OR={toc:[]};function FR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}FR.isMDXComponent=!0;const UR={toc:[]};function qR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}qR.isMDXComponent=!0;const VR={toc:[]};function jR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jR.isMDXComponent=!0;const QR={toc:[]};function HR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}HR.isMDXComponent=!0;const $R={toc:[]};function YR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$R,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}YR.isMDXComponent=!0;const KR={toc:[]};function JR(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}JR.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}rS.isMDXComponent=!0;const sS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dS.isMDXComponent=!0;const hS={toc:[]};function kS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}kS.isMDXComponent=!0;const yS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}fS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}DS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_S,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}XS.isMDXComponent=!0;const wS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}gS.isMDXComponent=!0;const TS={toc:[]};function xS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}xS.isMDXComponent=!0;const CS={toc:[]};function vS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}vS.isMDXComponent=!0;const LS={toc:[]};function ZS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}NS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}AS.isMDXComponent=!0;const WS={toc:[]};function RS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}RS.isMDXComponent=!0;const SS={toc:[]};function IS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}IS.isMDXComponent=!0;const PS={toc:[]};function ES(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}ES.isMDXComponent=!0;const BS={toc:[]};function GS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}GS.isMDXComponent=!0;const OS={toc:[]};function FS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}FS.isMDXComponent=!0;const US={toc:[]};function qS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},US,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qS.isMDXComponent=!0;const VS={toc:[]};function jS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}jS.isMDXComponent=!0;const QS={toc:[]};function HS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}HS.isMDXComponent=!0;const $S={toc:[]};function YS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$S,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}YS.isMDXComponent=!0;const KS={toc:[]};function JS(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}JS.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}rI.isMDXComponent=!0;const sI={toc:[]};function cI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}dI.isMDXComponent=!0;const hI={toc:[]};function kI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}kI.isMDXComponent=!0;const yI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}fI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}DI.isMDXComponent=!0;const _I={toc:[]};function XI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_I,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}XI.isMDXComponent=!0;const wI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}gI.isMDXComponent=!0;const TI={toc:[]};function xI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}xI.isMDXComponent=!0;const CI={toc:[]};function vI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}vI.isMDXComponent=!0;const LI={toc:[]};function ZI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}NI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}AI.isMDXComponent=!0;const WI={toc:[]};function RI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}RI.isMDXComponent=!0;const SI={toc:[]};function II(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}II.isMDXComponent=!0;const PI={toc:[]};function EI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}EI.isMDXComponent=!0;const BI={toc:[]};function GI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}GI.isMDXComponent=!0;const OI={toc:[]};function FI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}FI.isMDXComponent=!0;const UI={toc:[]};function qI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}qI.isMDXComponent=!0;const VI={toc:[]};function jI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}jI.isMDXComponent=!0;const QI={toc:[]};function HI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}HI.isMDXComponent=!0;const $I={toc:[]};function YI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$I,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}YI.isMDXComponent=!0;const KI={toc:[]};function JI(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}JI.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}rP.isMDXComponent=!0;const sP={toc:[]};function cP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}cP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}dP.isMDXComponent=!0;const hP={toc:[]};function kP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}kP.isMDXComponent=!0;const yP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}fP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}DP.isMDXComponent=!0;const _P={toc:[]};function XP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_P,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}XP.isMDXComponent=!0;const wP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gP.isMDXComponent=!0;const TP={toc:[]};function xP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}xP.isMDXComponent=!0;const CP={toc:[]};function vP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}vP.isMDXComponent=!0;const LP={toc:[]};function ZP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}NP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}AP.isMDXComponent=!0;const WP={toc:[]};function RP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}RP.isMDXComponent=!0;const SP={toc:[]};function IP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}IP.isMDXComponent=!0;const PP={toc:[]};function EP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}EP.isMDXComponent=!0;const BP={toc:[]};function GP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}GP.isMDXComponent=!0;const OP={toc:[]};function FP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}FP.isMDXComponent=!0;const UP={toc:[]};function qP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}qP.isMDXComponent=!0;const VP={toc:[]};function jP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jP.isMDXComponent=!0;const QP={toc:[]};function HP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}HP.isMDXComponent=!0;const $P={toc:[]};function YP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$P,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}YP.isMDXComponent=!0;const KP={toc:[]};function JP(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}JP.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}rE.isMDXComponent=!0;const sE={toc:[]};function cE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}dE.isMDXComponent=!0;const hE={toc:[]};function kE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kE.isMDXComponent=!0;const yE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}fE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ME,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}DE.isMDXComponent=!0;const _E={toc:[]};function XE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_E,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}XE.isMDXComponent=!0;const wE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gE.isMDXComponent=!0;const TE={toc:[]};function xE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}xE.isMDXComponent=!0;const CE={toc:[]};function vE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vE.isMDXComponent=!0;const LE={toc:[]};function ZE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}NE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}AE.isMDXComponent=!0;const WE={toc:[]};function RE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}RE.isMDXComponent=!0;const SE={toc:[]};function IE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}IE.isMDXComponent=!0;const PE={toc:[]};function EE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}EE.isMDXComponent=!0;const BE={toc:[]};function GE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}GE.isMDXComponent=!0;const OE={toc:[]};function FE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}FE.isMDXComponent=!0;const UE={toc:[]};function qE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}qE.isMDXComponent=!0;const VE={toc:[]};function jE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jE.isMDXComponent=!0;const QE={toc:[]};function HE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}HE.isMDXComponent=!0;const $E={toc:[]};function YE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$E,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}YE.isMDXComponent=!0;const KE={toc:[]};function JE(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JE.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rB.isMDXComponent=!0;const sB={toc:[]};function cB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}dB.isMDXComponent=!0;const hB={toc:[]};function kB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kB.isMDXComponent=!0;const yB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}DB.isMDXComponent=!0;const _B={toc:[]};function XB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_B,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}XB.isMDXComponent=!0;const wB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}gB.isMDXComponent=!0;const TB={toc:[]};function xB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xB.isMDXComponent=!0;const CB={toc:[]};function vB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}vB.isMDXComponent=!0;const LB={toc:[]};function ZB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}AB.isMDXComponent=!0;const WB={toc:[]};function RB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}RB.isMDXComponent=!0;const SB={toc:[]};function IB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}IB.isMDXComponent=!0;const PB={toc:[]};function EB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}EB.isMDXComponent=!0;const BB={toc:[]};function GB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}GB.isMDXComponent=!0;const OB={toc:[]};function FB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}FB.isMDXComponent=!0;const UB={toc:[]};function qB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qB.isMDXComponent=!0;const VB={toc:[]};function jB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}jB.isMDXComponent=!0;const QB={toc:[]};function HB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}HB.isMDXComponent=!0;const $B={toc:[]};function YB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$B,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}YB.isMDXComponent=!0;const KB={toc:[]};function JB(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}JB.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}rG.isMDXComponent=!0;const sG={toc:[]};function cG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}dG.isMDXComponent=!0;const hG={toc:[]};function kG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}kG.isMDXComponent=!0;const yG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}fG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}DG.isMDXComponent=!0;const _G={toc:[]};function XG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_G,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}XG.isMDXComponent=!0;const wG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gG.isMDXComponent=!0;const TG={toc:[]};function xG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}xG.isMDXComponent=!0;const CG={toc:[]};function vG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}vG.isMDXComponent=!0;const LG={toc:[]};function ZG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}NG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}AG.isMDXComponent=!0;const WG={toc:[]};function RG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}RG.isMDXComponent=!0;const SG={toc:[]};function IG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}IG.isMDXComponent=!0;const PG={toc:[]};function EG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}EG.isMDXComponent=!0;const BG={toc:[]};function GG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}GG.isMDXComponent=!0;const OG={toc:[]};function FG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}FG.isMDXComponent=!0;const UG={toc:[]};function qG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}qG.isMDXComponent=!0;const VG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}jG.isMDXComponent=!0;const QG={toc:[]};function HG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}HG.isMDXComponent=!0;const $G={toc:[]};function YG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$G,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}YG.isMDXComponent=!0;const KG={toc:[]};function JG(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}JG.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}rO.isMDXComponent=!0;const sO={toc:[]};function cO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}cO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}dO.isMDXComponent=!0;const hO={toc:[]};function kO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kO.isMDXComponent=!0;const yO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}fO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}DO.isMDXComponent=!0;const _O={toc:[]};function XO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_O,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}XO.isMDXComponent=!0;const wO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}gO.isMDXComponent=!0;const TO={toc:[]};function xO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}xO.isMDXComponent=!0;const CO={toc:[]};function vO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}vO.isMDXComponent=!0;const LO={toc:[]};function ZO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}NO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}AO.isMDXComponent=!0;const WO={toc:[]};function RO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}RO.isMDXComponent=!0;const SO={toc:[]};function IO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}IO.isMDXComponent=!0;const PO={toc:[]};function EO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}EO.isMDXComponent=!0;const BO={toc:[]};function GO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}GO.isMDXComponent=!0;const OO={toc:[]};function FO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}FO.isMDXComponent=!0;const UO={toc:[]};function qO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}qO.isMDXComponent=!0;const VO={toc:[]};function jO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}jO.isMDXComponent=!0;const QO={toc:[]};function HO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}HO.isMDXComponent=!0;const $O={toc:[]};function YO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$O,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}YO.isMDXComponent=!0;const KO={toc:[]};function JO(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}JO.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}rF.isMDXComponent=!0;const sF={toc:[]};function cF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}cF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}dF.isMDXComponent=!0;const hF={toc:[]};function kF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kF.isMDXComponent=!0;const yF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}fF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}DF.isMDXComponent=!0;const _F={toc:[]};function XF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_F,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}XF.isMDXComponent=!0;const wF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}gF.isMDXComponent=!0;const TF={toc:[]};function xF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xF.isMDXComponent=!0;const CF={toc:[]};function vF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}vF.isMDXComponent=!0;const LF={toc:[]};function ZF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}NF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}AF.isMDXComponent=!0;const WF={toc:[]};function RF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}RF.isMDXComponent=!0;const SF={toc:[]};function IF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}IF.isMDXComponent=!0;const PF={toc:[]};function EF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}EF.isMDXComponent=!0;const BF={toc:[]};function GF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}GF.isMDXComponent=!0;const OF={toc:[]};function FF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}FF.isMDXComponent=!0;const UF={toc:[]};function qF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}qF.isMDXComponent=!0;const VF={toc:[]};function jF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}jF.isMDXComponent=!0;const QF={toc:[]};function HF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}HF.isMDXComponent=!0;const $F={toc:[]};function YF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$F,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}YF.isMDXComponent=!0;const KF={toc:[]};function JF(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}JF.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}rU.isMDXComponent=!0;const sU={toc:[]};function cU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dU.isMDXComponent=!0;const hU={toc:[]};function kU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kU.isMDXComponent=!0;const yU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}fU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}DU.isMDXComponent=!0;const _U={toc:[]};function XU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_U,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}XU.isMDXComponent=!0;const wU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}gU.isMDXComponent=!0;const TU={toc:[]};function xU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xU.isMDXComponent=!0;const CU={toc:[]};function vU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vU.isMDXComponent=!0;const LU={toc:[]};function ZU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}NU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}AU.isMDXComponent=!0;const WU={toc:[]};function RU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}RU.isMDXComponent=!0;const SU={toc:[]};function IU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}IU.isMDXComponent=!0;const PU={toc:[]};function EU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}EU.isMDXComponent=!0;const BU={toc:[]};function GU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}GU.isMDXComponent=!0;const OU={toc:[]};function FU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}FU.isMDXComponent=!0;const UU={toc:[]};function qU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}qU.isMDXComponent=!0;const VU={toc:[]};function jU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}jU.isMDXComponent=!0;const QU={toc:[]};function HU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}HU.isMDXComponent=!0;const $U={toc:[]};function YU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$U,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}YU.isMDXComponent=!0;const KU={toc:[]};function JU(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}JU.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}rq.isMDXComponent=!0;const sq={toc:[]};function cq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}cq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}dq.isMDXComponent=!0;const hq={toc:[]};function kq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}kq.isMDXComponent=!0;const yq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}fq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Dq.isMDXComponent=!0;const _q={toc:[]};function Xq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Xq.isMDXComponent=!0;const wq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}gq.isMDXComponent=!0;const Tq={toc:[]};function xq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}xq.isMDXComponent=!0;const Cq={toc:[]};function vq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}vq.isMDXComponent=!0;const Lq={toc:[]};function Zq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Nq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Aq.isMDXComponent=!0;const Wq={toc:[]};function Rq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Rq.isMDXComponent=!0;const Sq={toc:[]};function Iq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Iq.isMDXComponent=!0;const Pq={toc:[]};function Eq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Eq.isMDXComponent=!0;const Bq={toc:[]};function Gq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Gq.isMDXComponent=!0;const Oq={toc:[]};function Fq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Fq.isMDXComponent=!0;const Uq={toc:[]};function qq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qq.isMDXComponent=!0;const Vq={toc:[]};function jq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}jq.isMDXComponent=!0;const Qq={toc:[]};function Hq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Hq.isMDXComponent=!0;const $q={toc:[]};function Yq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}Yq.isMDXComponent=!0;const Kq={toc:[]};function Jq(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Jq.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rV.isMDXComponent=!0;const sV={toc:[]};function cV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}cV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dV.isMDXComponent=!0;const hV={toc:[]};function kV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kV.isMDXComponent=!0;const yV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}DV.isMDXComponent=!0;const _V={toc:[]};function XV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_V,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}XV.isMDXComponent=!0;const wV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gV.isMDXComponent=!0;const TV={toc:[]};function xV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}xV.isMDXComponent=!0;const CV={toc:[]};function vV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vV.isMDXComponent=!0;const LV={toc:[]};function ZV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}AV.isMDXComponent=!0;const WV={toc:[]};function RV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}RV.isMDXComponent=!0;const SV={toc:[]};function IV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}IV.isMDXComponent=!0;const PV={toc:[]};function EV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}EV.isMDXComponent=!0;const BV={toc:[]};function GV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}GV.isMDXComponent=!0;const OV={toc:[]};function FV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}FV.isMDXComponent=!0;const UV={toc:[]};function qV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qV.isMDXComponent=!0;const VV={toc:[]};function jV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}jV.isMDXComponent=!0;const QV={toc:[]};function HV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}HV.isMDXComponent=!0;const $V={toc:[]};function YV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$V,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}YV.isMDXComponent=!0;const KV={toc:[]};function JV(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}JV.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}rj.isMDXComponent=!0;const sj={toc:[]};function cj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ij,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}dj.isMDXComponent=!0;const hj={toc:[]};function kj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}kj.isMDXComponent=!0;const yj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}fj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Dj.isMDXComponent=!0;const _j={toc:[]};function Xj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_j,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Xj.isMDXComponent=!0;const wj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}gj.isMDXComponent=!0;const Tj={toc:[]};function xj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}xj.isMDXComponent=!0;const Cj={toc:[]};function vj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}vj.isMDXComponent=!0;const Lj={toc:[]};function Zj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Nj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Aj.isMDXComponent=!0;const Wj={toc:[]};function Rj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Rj.isMDXComponent=!0;const Sj={toc:[]};function Ij(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ij.isMDXComponent=!0;const Pj={toc:[]};function Ej(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ej.isMDXComponent=!0;const Bj={toc:[]};function Gj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Gj.isMDXComponent=!0;const Oj={toc:[]};function Fj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Fj.isMDXComponent=!0;const Uj={toc:[]};function qj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qj.isMDXComponent=!0;const Vj={toc:[]};function jj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jj.isMDXComponent=!0;const Qj={toc:[]};function Hj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Hj.isMDXComponent=!0;const $j={toc:[]};function Yj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$j,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Yj.isMDXComponent=!0;const Kj={toc:[]};function Jj(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Jj.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}rQ.isMDXComponent=!0;const sQ={toc:[]};function cQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function kQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}kQ.isMDXComponent=!0;const yQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}fQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}DQ.isMDXComponent=!0;const _Q={toc:[]};function XQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}XQ.isMDXComponent=!0;const wQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}gQ.isMDXComponent=!0;const TQ={toc:[]};function xQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xQ.isMDXComponent=!0;const CQ={toc:[]};function vQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}vQ.isMDXComponent=!0;const LQ={toc:[]};function ZQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}NQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}AQ.isMDXComponent=!0;const WQ={toc:[]};function RQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}RQ.isMDXComponent=!0;const SQ={toc:[]};function IQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}IQ.isMDXComponent=!0;const PQ={toc:[]};function EQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}EQ.isMDXComponent=!0;const BQ={toc:[]};function GQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}GQ.isMDXComponent=!0;const OQ={toc:[]};function FQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}FQ.isMDXComponent=!0;const UQ={toc:[]};function qQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}qQ.isMDXComponent=!0;const VQ={toc:[]};function jQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}jQ.isMDXComponent=!0;const QQ={toc:[]};function HQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}HQ.isMDXComponent=!0;const $Q={toc:[]};function YQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}YQ.isMDXComponent=!0;const KQ={toc:[]};function JQ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}JQ.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}rH.isMDXComponent=!0;const sH={toc:[]};function cH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}cH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}dH.isMDXComponent=!0;const hH={toc:[]};function kH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}kH.isMDXComponent=!0;const yH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}fH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}DH.isMDXComponent=!0;const _H={toc:[]};function XH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_H,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}XH.isMDXComponent=!0;const wH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}gH.isMDXComponent=!0;const TH={toc:[]};function xH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}xH.isMDXComponent=!0;const CH={toc:[]};function vH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}vH.isMDXComponent=!0;const LH={toc:[]};function ZH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}NH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}AH.isMDXComponent=!0;const WH={toc:[]};function RH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}RH.isMDXComponent=!0;const SH={toc:[]};function IH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}IH.isMDXComponent=!0;const PH={toc:[]};function EH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}EH.isMDXComponent=!0;const BH={toc:[]};function GH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}GH.isMDXComponent=!0;const OH={toc:[]};function FH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}FH.isMDXComponent=!0;const UH={toc:[]};function qH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qH.isMDXComponent=!0;const VH={toc:[]};function jH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jH.isMDXComponent=!0;const QH={toc:[]};function HH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}HH.isMDXComponent=!0;const $H={toc:[]};function YH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$H,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}YH.isMDXComponent=!0;const KH={toc:[]};function JH(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}JH.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}r$.isMDXComponent=!0;const s$={toc:[]};function c$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}c$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}d$.isMDXComponent=!0;const h$={toc:[]};function k$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}k$.isMDXComponent=!0;const y$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}f$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}D$.isMDXComponent=!0;const _$={toc:[]};function X$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}X$.isMDXComponent=!0;const w$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}g$.isMDXComponent=!0;const T$={toc:[]};function x$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}x$.isMDXComponent=!0;const C$={toc:[]};function v$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}v$.isMDXComponent=!0;const L$={toc:[]};function Z$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}N$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}A$.isMDXComponent=!0;const W$={toc:[]};function R$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}R$.isMDXComponent=!0;const S$={toc:[]};function I$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}I$.isMDXComponent=!0;const P$={toc:[]};function E$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}E$.isMDXComponent=!0;const B$={toc:[]};function G$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}G$.isMDXComponent=!0;const O$={toc:[]};function F$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}F$.isMDXComponent=!0;const U$={toc:[]};function q$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}q$.isMDXComponent=!0;const V$={toc:[]};function j$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}j$.isMDXComponent=!0;const Q$={toc:[]};function H$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}H$.isMDXComponent=!0;const $$={toc:[]};function Y$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Y$.isMDXComponent=!0;const K$={toc:[]};function J$(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}J$.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}rY.isMDXComponent=!0;const sY={toc:[]};function cY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}cY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dY.isMDXComponent=!0;const hY={toc:[]};function kY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kY.isMDXComponent=!0;const yY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}fY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}DY.isMDXComponent=!0;const _Y={toc:[]};function XY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}XY.isMDXComponent=!0;const wY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}gY.isMDXComponent=!0;const TY={toc:[]};function xY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}xY.isMDXComponent=!0;const CY={toc:[]};function vY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}vY.isMDXComponent=!0;const LY={toc:[]};function ZY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}NY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}AY.isMDXComponent=!0;const WY={toc:[]};function RY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}RY.isMDXComponent=!0;const SY={toc:[]};function IY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}IY.isMDXComponent=!0;const PY={toc:[]};function EY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides an easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}EY.isMDXComponent=!0;const BY={toc:[]};function GY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}GY.isMDXComponent=!0;const OY={toc:[]};function FY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}FY.isMDXComponent=!0;const UY={toc:[]};function qY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qY.isMDXComponent=!0;const VY={toc:[]};function jY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}jY.isMDXComponent=!0;const QY={toc:[]};function HY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}HY.isMDXComponent=!0;const $Y={toc:[]};function YY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Y,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}YY.isMDXComponent=!0;const KY={toc:[]};function JY(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}JY.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}rK.isMDXComponent=!0;const sK={toc:[]};function cK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dK.isMDXComponent=!0;const hK={toc:[]};function kK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}kK.isMDXComponent=!0;const yK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}fK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}DK.isMDXComponent=!0;const _K={toc:[]};function XK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_K,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}XK.isMDXComponent=!0;const wK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}gK.isMDXComponent=!0;const TK={toc:[]};function xK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}xK.isMDXComponent=!0;const CK={toc:[]};function vK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}vK.isMDXComponent=!0;const LK={toc:[]};function ZK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}NK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}AK.isMDXComponent=!0;const WK={toc:[]};function RK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}RK.isMDXComponent=!0;const SK={toc:[]};function IK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}IK.isMDXComponent=!0;const PK={toc:[]};function EK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}EK.isMDXComponent=!0;const BK={toc:[]};function GK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}GK.isMDXComponent=!0;const OK={toc:[]};function FK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}FK.isMDXComponent=!0;const UK={toc:[]};function qK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qK.isMDXComponent=!0;const VK={toc:[]};function jK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}jK.isMDXComponent=!0;const QK={toc:[]};function HK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}HK.isMDXComponent=!0;const $K={toc:[]};function YK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$K,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}YK.isMDXComponent=!0;const KK={toc:[]};function JK(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}JK.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}rJ.isMDXComponent=!0;const sJ={toc:[]};function cJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}cJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}dJ.isMDXComponent=!0;const hJ={toc:[]};function kJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}kJ.isMDXComponent=!0;const yJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}fJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}DJ.isMDXComponent=!0;const _J={toc:[]};function XJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_J,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}XJ.isMDXComponent=!0;const wJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}gJ.isMDXComponent=!0;const TJ={toc:[]};function xJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}xJ.isMDXComponent=!0;const CJ={toc:[]};function vJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function ZJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}AJ.isMDXComponent=!0;const WJ={toc:[]};function RJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}RJ.isMDXComponent=!0;const SJ={toc:[]};function IJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}IJ.isMDXComponent=!0;const PJ={toc:[]};function EJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}EJ.isMDXComponent=!0;const BJ={toc:[]};function GJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}GJ.isMDXComponent=!0;const OJ={toc:[]};function FJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}FJ.isMDXComponent=!0;const UJ={toc:[]};function qJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qJ.isMDXComponent=!0;const VJ={toc:[]};function jJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}jJ.isMDXComponent=!0;const QJ={toc:[]};function HJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}HJ.isMDXComponent=!0;const $J={toc:[]};function YJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$J,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}YJ.isMDXComponent=!0;const KJ={toc:[]};function JJ(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}JJ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}r0.isMDXComponent=!0;const s0={toc:[]};function c0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}c0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}d0.isMDXComponent=!0;const h0={toc:[]};function k0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}k0.isMDXComponent=!0;const y0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}f0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}D0.isMDXComponent=!0;const _0={toc:[]};function X0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}X0.isMDXComponent=!0;const w0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}g0.isMDXComponent=!0;const T0={toc:[]};function x0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}x0.isMDXComponent=!0;const C0={toc:[]};function v0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}v0.isMDXComponent=!0;const L0={toc:[]};function Z0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}N0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}A0.isMDXComponent=!0;const W0={toc:[]};function R0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}R0.isMDXComponent=!0;const S0={toc:[]};function I0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}I0.isMDXComponent=!0;const P0={toc:[]};function E0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}E0.isMDXComponent=!0;const B0={toc:[]};function G0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}G0.isMDXComponent=!0;const O0={toc:[]};function F0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}F0.isMDXComponent=!0;const U0={toc:[]};function q0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}q0.isMDXComponent=!0;const V0={toc:[]};function j0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}j0.isMDXComponent=!0;const Q0={toc:[]};function H0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}H0.isMDXComponent=!0;const $0={toc:[]};function Y0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Y0.isMDXComponent=!0;const K0={toc:[]};function J0(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}J0.isMDXComponent=!0;const t4={toc:[]};function n4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}n4.isMDXComponent=!0;const e4={toc:[]};function o4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}r4.isMDXComponent=!0;const s4={toc:[]};function c4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}c4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}d4.isMDXComponent=!0;const h4={toc:[]};function k4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}k4.isMDXComponent=!0;const y4={toc:[]};function f4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}f4.isMDXComponent=!0;const M4={toc:[]};function D4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}D4.isMDXComponent=!0;const _4={toc:[]};function X4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}X4.isMDXComponent=!0;const w4={toc:[]};function g4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}g4.isMDXComponent=!0;const T4={toc:[]};function x4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}x4.isMDXComponent=!0;const C4={toc:[]};function v4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}v4.isMDXComponent=!0;const L4={toc:[]};function Z4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Z4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}N4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}A4.isMDXComponent=!0;const W4={toc:[]};function R4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}R4.isMDXComponent=!0;const S4={toc:[]};function I4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}I4.isMDXComponent=!0;const P4={toc:[]};function E4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}E4.isMDXComponent=!0;const B4={toc:[]};function G4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}G4.isMDXComponent=!0;const O4={toc:[]};function F4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}F4.isMDXComponent=!0;const U4={toc:[]};function q4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}q4.isMDXComponent=!0;const V4={toc:[]};function j4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}j4.isMDXComponent=!0;const Q4={toc:[]};function H4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}H4.isMDXComponent=!0;const $4={toc:[]};function Y4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Y4.isMDXComponent=!0;const K4={toc:[]};function J4(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}J4.isMDXComponent=!0;const t8={toc:[]};function n8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}n8.isMDXComponent=!0;const e8={toc:[]};function o8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}r8.isMDXComponent=!0;const s8={toc:[]};function c8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}c8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}d8.isMDXComponent=!0;const h8={toc:[]};function k8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}k8.isMDXComponent=!0;const y8={toc:[]};function f8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}f8.isMDXComponent=!0;const M8={toc:[]};function D8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}D8.isMDXComponent=!0;const _8={toc:[]};function X8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}X8.isMDXComponent=!0;const w8={toc:[]};function g8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}g8.isMDXComponent=!0;const T8={toc:[]};function x8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}x8.isMDXComponent=!0;const C8={toc:[]};function v8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}v8.isMDXComponent=!0;const L8={toc:[]};function Z8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Z8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}N8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}A8.isMDXComponent=!0;const W8={toc:[]};function R8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}R8.isMDXComponent=!0;const S8={toc:[]};function I8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}I8.isMDXComponent=!0;const P8={toc:[]};function E8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}E8.isMDXComponent=!0;const B8={toc:[]};function G8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}G8.isMDXComponent=!0;const O8={toc:[]};function F8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}F8.isMDXComponent=!0;const U8={toc:[]};function q8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}q8.isMDXComponent=!0;const V8={toc:[]};function j8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}j8.isMDXComponent=!0;const Q8={toc:[]};function H8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}H8.isMDXComponent=!0;const $8={toc:[]};function Y8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Y8.isMDXComponent=!0;const K8={toc:[]};function J8(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}J8.isMDXComponent=!0;const t3={toc:[]};function n3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}n3.isMDXComponent=!0;const e3={toc:[]};function o3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}r3.isMDXComponent=!0;const s3={toc:[]};function c3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}c3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}d3.isMDXComponent=!0;const h3={toc:[]};function k3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}k3.isMDXComponent=!0;const y3={toc:[]};function f3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}f3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}D3.isMDXComponent=!0;const _3={toc:[]};function X3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}X3.isMDXComponent=!0;const w3={toc:[]};function g3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}g3.isMDXComponent=!0;const T3={toc:[]};function x3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}x3.isMDXComponent=!0;const C3={toc:[]};function v3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}v3.isMDXComponent=!0;const L3={toc:[]};function Z3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Z3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}N3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}A3.isMDXComponent=!0;const W3={toc:[]};function R3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}R3.isMDXComponent=!0;const S3={toc:[]};function I3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}I3.isMDXComponent=!0;const P3={toc:[]};function E3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}E3.isMDXComponent=!0;const B3={toc:[]};function G3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}G3.isMDXComponent=!0;const O3={toc:[]};function F3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}F3.isMDXComponent=!0;const U3={toc:[]};function q3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}q3.isMDXComponent=!0;const V3={toc:[]};function j3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}j3.isMDXComponent=!0;const Q3={toc:[]};function H3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}H3.isMDXComponent=!0;const $3={toc:[]};function Y3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Y3.isMDXComponent=!0;const K3={toc:[]};function J3(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}J3.isMDXComponent=!0;const t9={toc:[]};function n9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}n9.isMDXComponent=!0;const e9={toc:[]};function o9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}r9.isMDXComponent=!0;const s9={toc:[]};function c9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}c9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}d9.isMDXComponent=!0;const h9={toc:[]};function k9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}k9.isMDXComponent=!0;const y9={toc:[]};function f9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}f9.isMDXComponent=!0;const M9={toc:[]};function D9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}D9.isMDXComponent=!0;const _9={toc:[]};function X9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}X9.isMDXComponent=!0;const w9={toc:[]};function g9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}g9.isMDXComponent=!0;const T9={toc:[]};function x9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}x9.isMDXComponent=!0;const C9={toc:[]};function v9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}v9.isMDXComponent=!0;const L9={toc:[]};function Z9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Z9.isMDXComponent=!0;const b9={toc:[]};function N9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}N9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}A9.isMDXComponent=!0;const W9={toc:[]};function R9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}R9.isMDXComponent=!0;const S9={toc:[]};function I9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}I9.isMDXComponent=!0;const P9={toc:[]};function E9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}E9.isMDXComponent=!0;const B9={toc:[]};function G9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}G9.isMDXComponent=!0;const O9={toc:[]};function F9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}F9.isMDXComponent=!0;const U9={toc:[]};function q9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}q9.isMDXComponent=!0;const V9={toc:[]};function j9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}j9.isMDXComponent=!0;const Q9={toc:[]};function H9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}H9.isMDXComponent=!0;const $9={toc:[]};function Y9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Y9.isMDXComponent=!0;const K9={toc:[]};function J9(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}J9.isMDXComponent=!0;const t2={toc:[]};function n2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}n2.isMDXComponent=!0;const e2={toc:[]};function o2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}r2.isMDXComponent=!0;const s2={toc:[]};function c2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}c2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}d2.isMDXComponent=!0;const h2={toc:[]};function k2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}k2.isMDXComponent=!0;const y2={toc:[]};function f2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}f2.isMDXComponent=!0;const M2={toc:[]};function D2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}D2.isMDXComponent=!0;const _2={toc:[]};function X2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}X2.isMDXComponent=!0;const w2={toc:[]};function g2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}g2.isMDXComponent=!0;const T2={toc:[]};function x2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}x2.isMDXComponent=!0;const C2={toc:[]};function v2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}v2.isMDXComponent=!0;const L2={toc:[]};function Z2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}N2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}A2.isMDXComponent=!0;const W2={toc:[]};function R2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}R2.isMDXComponent=!0;const S2={toc:[]};function I2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}I2.isMDXComponent=!0;const P2={toc:[]};function E2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}E2.isMDXComponent=!0;const B2={toc:[]};function G2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}G2.isMDXComponent=!0;const O2={toc:[]};function F2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}F2.isMDXComponent=!0;const U2={toc:[]};function q2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}q2.isMDXComponent=!0;const V2={toc:[]};function j2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}j2.isMDXComponent=!0;const Q2={toc:[]};function H2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}H2.isMDXComponent=!0;const $2={toc:[]};function Y2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Y2.isMDXComponent=!0;const K2={toc:[]};function J2(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}J2.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}r1.isMDXComponent=!0;const s1={toc:[]};function c1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}c1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}d1.isMDXComponent=!0;const h1={toc:[]};function k1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}k1.isMDXComponent=!0;const y1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}f1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}D1.isMDXComponent=!0;const _1={toc:[]};function X1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}X1.isMDXComponent=!0;const w1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}g1.isMDXComponent=!0;const T1={toc:[]};function x1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}x1.isMDXComponent=!0;const C1={toc:[]};function v1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}v1.isMDXComponent=!0;const L1={toc:[]};function Z1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}N1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}A1.isMDXComponent=!0;const W1={toc:[]};function R1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}R1.isMDXComponent=!0;const S1={toc:[]};function I1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}I1.isMDXComponent=!0;const P1={toc:[]};function E1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}E1.isMDXComponent=!0;const B1={toc:[]};function G1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}G1.isMDXComponent=!0;const O1={toc:[]};function F1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}F1.isMDXComponent=!0;const U1={toc:[]};function q1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}q1.isMDXComponent=!0;const V1={toc:[]};function j1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}j1.isMDXComponent=!0;const Q1={toc:[]};function H1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}H1.isMDXComponent=!0;const $1={toc:[]};function Y1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Y1.isMDXComponent=!0;const K1={toc:[]};function J1(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}J1.isMDXComponent=!0;const t6={toc:[]};function n6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}n6.isMDXComponent=!0;const e6={toc:[]};function o6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}r6.isMDXComponent=!0;const s6={toc:[]};function c6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}c6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}d6.isMDXComponent=!0;const h6={toc:[]};function k6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}k6.isMDXComponent=!0;const y6={toc:[]};function f6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}f6.isMDXComponent=!0;const M6={toc:[]};function D6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}D6.isMDXComponent=!0;const _6={toc:[]};function X6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}X6.isMDXComponent=!0;const w6={toc:[]};function g6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}g6.isMDXComponent=!0;const T6={toc:[]};function x6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}x6.isMDXComponent=!0;const C6={toc:[]};function v6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}v6.isMDXComponent=!0;const L6={toc:[]};function Z6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Z6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}N6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}A6.isMDXComponent=!0;const W6={toc:[]};function R6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}R6.isMDXComponent=!0;const S6={toc:[]};function I6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}I6.isMDXComponent=!0;const P6={toc:[]};function E6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}E6.isMDXComponent=!0;const B6={toc:[]};function G6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}G6.isMDXComponent=!0;const O6={toc:[]};function F6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}F6.isMDXComponent=!0;const U6={toc:[]};function q6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}q6.isMDXComponent=!0;const V6={toc:[]};function j6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}j6.isMDXComponent=!0;const Q6={toc:[]};function H6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}H6.isMDXComponent=!0;const $6={toc:[]};function Y6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Y6.isMDXComponent=!0;const K6={toc:[]};function J6(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}J6.isMDXComponent=!0;const t5={toc:[]};function n5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}n5.isMDXComponent=!0;const e5={toc:[]};function o5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}r5.isMDXComponent=!0;const s5={toc:[]};function c5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}c5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}d5.isMDXComponent=!0;const h5={toc:[]};function k5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}k5.isMDXComponent=!0;const y5={toc:[]};function f5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}f5.isMDXComponent=!0;const M5={toc:[]};function D5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}D5.isMDXComponent=!0;const _5={toc:[]};function X5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}X5.isMDXComponent=!0;const w5={toc:[]};function g5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}g5.isMDXComponent=!0;const T5={toc:[]};function x5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}x5.isMDXComponent=!0;const C5={toc:[]};function v5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}v5.isMDXComponent=!0;const L5={toc:[]};function Z5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Z5.isMDXComponent=!0;const b5={toc:[]};function N5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}N5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}A5.isMDXComponent=!0;const W5={toc:[]};function R5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}R5.isMDXComponent=!0;const S5={toc:[]};function I5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}I5.isMDXComponent=!0;const P5={toc:[]};function E5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}E5.isMDXComponent=!0;const B5={toc:[]};function G5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}G5.isMDXComponent=!0;const O5={toc:[]};function F5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}F5.isMDXComponent=!0;const U5={toc:[]};function q5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}q5.isMDXComponent=!0;const V5={toc:[]};function j5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}j5.isMDXComponent=!0;const Q5={toc:[]};function H5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}H5.isMDXComponent=!0;const $5={toc:[]};function Y5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Y5.isMDXComponent=!0;const K5={toc:[]};function J5(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}J5.isMDXComponent=!0;const t7={toc:[]};function n7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}n7.isMDXComponent=!0;const e7={toc:[]};function o7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}r7.isMDXComponent=!0;const s7={toc:[]};function c7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}c7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}d7.isMDXComponent=!0;const h7={toc:[]};function k7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}k7.isMDXComponent=!0;const y7={toc:[]};function f7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}f7.isMDXComponent=!0;const M7={toc:[]};function D7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}D7.isMDXComponent=!0;const _7={toc:[]};function X7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}X7.isMDXComponent=!0;const w7={toc:[]};function g7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}g7.isMDXComponent=!0;const T7={toc:[]};function x7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}x7.isMDXComponent=!0;const C7={toc:[]};function v7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}v7.isMDXComponent=!0;const L7={toc:[]};function Z7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Z7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}N7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}A7.isMDXComponent=!0;const W7={toc:[]};function R7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}R7.isMDXComponent=!0;const S7={toc:[]};function I7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}I7.isMDXComponent=!0;const P7={toc:[]};function E7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}E7.isMDXComponent=!0;const B7={toc:[]};function G7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}G7.isMDXComponent=!0;const O7={toc:[]};function F7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}F7.isMDXComponent=!0;const U7={toc:[]};function q7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}q7.isMDXComponent=!0;const V7={toc:[]};function j7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}j7.isMDXComponent=!0;const Q7={toc:[]};function H7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}H7.isMDXComponent=!0;const $7={toc:[]};function Y7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Y7.isMDXComponent=!0;const K7={toc:[]};function J7(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}J7.isMDXComponent=!0;const ttt={toc:[]};function ntt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ttt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}ntt.isMDXComponent=!0;const ett={toc:[]};function ott(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ett,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ptt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}rtt.isMDXComponent=!0;const stt={toc:[]};function ctt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},stt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}ctt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},itt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ktt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},htt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ktt.isMDXComponent=!0;const ytt={toc:[]};function ftt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ytt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ftt.isMDXComponent=!0;const Mtt={toc:[]};function Dtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Dtt.isMDXComponent=!0;const _tt={toc:[]};function Xtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_tt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Xtt.isMDXComponent=!0;const wtt={toc:[]};function gtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}gtt.isMDXComponent=!0;const Ttt={toc:[]};function xtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ttt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}xtt.isMDXComponent=!0;const Ctt={toc:[]};function vtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ctt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function Ztt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ztt.isMDXComponent=!0;const btt={toc:[]};function Ntt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},btt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Ntt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ztt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Att.isMDXComponent=!0;const Wtt={toc:[]};function Rtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Rtt.isMDXComponent=!0;const Stt={toc:[]};function Itt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Stt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Itt.isMDXComponent=!0;const Ptt={toc:[]};function Ett(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ptt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Ett.isMDXComponent=!0;const Btt={toc:[]};function Gtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Btt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Gtt.isMDXComponent=!0;const Ott={toc:[]};function Ftt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ott,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ftt.isMDXComponent=!0;const Utt={toc:[]};function qtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Utt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qtt.isMDXComponent=!0;const Vtt={toc:[]};function jtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}jtt.isMDXComponent=!0;const Qtt={toc:[]};function Htt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Htt.isMDXComponent=!0;const $tt={toc:[]};function Ytt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$tt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Ytt.isMDXComponent=!0;const Ktt={toc:[]};function Jtt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ktt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Jtt.isMDXComponent=!0;const tnt={toc:[]};function nnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}nnt.isMDXComponent=!0;const ent={toc:[]};function ont(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ent,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ont.isMDXComponent=!0;const pnt={toc:[]};function rnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}rnt.isMDXComponent=!0;const snt={toc:[]};function cnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},snt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cnt.isMDXComponent=!0;const int={toc:[]};function ant(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},int,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ant.isMDXComponent=!0;const lnt={toc:[]};function unt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}unt.isMDXComponent=!0;const mnt={toc:[]};function dnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dnt.isMDXComponent=!0;const hnt={toc:[]};function knt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}knt.isMDXComponent=!0;const ynt={toc:[]};function fnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ynt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}fnt.isMDXComponent=!0;const Mnt={toc:[]};function Dnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Dnt.isMDXComponent=!0;const _nt={toc:[]};function Xnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Xnt.isMDXComponent=!0;const wnt={toc:[]};function gnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}gnt.isMDXComponent=!0;const Tnt={toc:[]};function xnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}xnt.isMDXComponent=!0;const Cnt={toc:[]};function vnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}vnt.isMDXComponent=!0;const Lnt={toc:[]};function Znt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Znt.isMDXComponent=!0;const bnt={toc:[]};function Nnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Nnt.isMDXComponent=!0;const znt={toc:[]};function Ant(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},znt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Ant.isMDXComponent=!0;const Wnt={toc:[]};function Rnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Rnt.isMDXComponent=!0;const Snt={toc:[]};function Int(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Snt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Int.isMDXComponent=!0;const Pnt={toc:[]};function Ent(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Ent.isMDXComponent=!0;const Bnt={toc:[]};function Gnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Gnt.isMDXComponent=!0;const Ont={toc:[]};function Fnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ont,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Fnt.isMDXComponent=!0;const Unt={toc:[]};function qnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Unt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qnt.isMDXComponent=!0;const Vnt={toc:[]};function jnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}jnt.isMDXComponent=!0;const Qnt={toc:[]};function Hnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Hnt.isMDXComponent=!0;const $nt={toc:[]};function Ynt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Ynt.isMDXComponent=!0;const Knt={toc:[]};function Jnt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Knt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Jnt.isMDXComponent=!0;const tet={toc:[]};function net(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}net.isMDXComponent=!0;const eet={toc:[]};function oet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}ret.isMDXComponent=!0;const set={toc:[]};function cet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},set,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}cet.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},det,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}het.isMDXComponent=!0;const ket={toc:[]};function yet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ket,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}yet.isMDXComponent=!0;const fet={toc:[]};function Met(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Met.isMDXComponent=!0;const Det={toc:[]};function _et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Det,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}_et.isMDXComponent=!0;const Xet={toc:[]};function wet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wet.isMDXComponent=!0;const get={toc:[]};function Tet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},get,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Tet.isMDXComponent=!0;const xet={toc:[]};function Cet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Cet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Let.isMDXComponent=!0;const Zet={toc:[]};function bet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}bet.isMDXComponent=!0;const Net={toc:[]};function zet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Net,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}zet.isMDXComponent=!0;const Aet={toc:[]};function Wet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Wet.isMDXComponent=!0;const Ret={toc:[]};function Set(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ret,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Set.isMDXComponent=!0;const Iet={toc:[]};function Pet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Pet.isMDXComponent=!0;const Eet={toc:[]};function Bet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Bet.isMDXComponent=!0;const Get={toc:[]};function Oet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Get,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Oet.isMDXComponent=!0;const Fet={toc:[]};function Uet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Uet.isMDXComponent=!0;const qet={toc:[]};function Vet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Vet.isMDXComponent=!0;const jet={toc:[]};function Qet(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Qet.isMDXComponent=!0;const Het={toc:[]};function $et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Het,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$et.isMDXComponent=!0;const Yet={toc:[]};function Ket(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Ket.isMDXComponent=!0;const Jet={toc:[]};function tot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}tot.isMDXComponent=!0;const not={toc:[]};function eot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},not,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}eot.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pot.isMDXComponent=!0;const rot={toc:[]};function sot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sot.isMDXComponent=!0;const cot={toc:[]};function iot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}iot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}hot.isMDXComponent=!0;const kot={toc:[]};function yot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}yot.isMDXComponent=!0;const fot={toc:[]};function Mot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Mot.isMDXComponent=!0;const Dot={toc:[]};function _ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}_ot.isMDXComponent=!0;const Xot={toc:[]};function wot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}wot.isMDXComponent=!0;const got={toc:[]};function Tot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},got,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Tot.isMDXComponent=!0;const xot={toc:[]};function Cot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Cot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lot.isMDXComponent=!0;const Zot={toc:[]};function bot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}bot.isMDXComponent=!0;const Not={toc:[]};function zot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Not,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}zot.isMDXComponent=!0;const Aot={toc:[]};function Wot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Wot.isMDXComponent=!0;const Rot={toc:[]};function Sot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Sot.isMDXComponent=!0;const Iot={toc:[]};function Pot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pot.isMDXComponent=!0;const Eot={toc:[]};function Bot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Bot.isMDXComponent=!0;const Got={toc:[]};function Oot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Got,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Oot.isMDXComponent=!0;const Fot={toc:[]};function Uot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Uot.isMDXComponent=!0;const qot={toc:[]};function Vot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Vot.isMDXComponent=!0;const jot={toc:[]};function Qot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Qot.isMDXComponent=!0;const Hot={toc:[]};function $ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}$ot.isMDXComponent=!0;const Yot={toc:[]};function Kot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Kot.isMDXComponent=!0;const Jot={toc:[]};function tpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}tpt.isMDXComponent=!0;const npt={toc:[]};function ept(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},npt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}ept.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n      clip\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}ppt.isMDXComponent=!0;const rpt={toc:[]};function spt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}spt.isMDXComponent=!0;const cpt={toc:[]};function ipt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ipt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}hpt.isMDXComponent=!0;const kpt={toc:[]};function ypt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ypt.isMDXComponent=!0;const fpt={toc:[]};function Mpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Mpt.isMDXComponent=!0;const Dpt={toc:[]};function _pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}_pt.isMDXComponent=!0;const Xpt={toc:[]};function wpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}wpt.isMDXComponent=!0;const gpt={toc:[]};function Tpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Tpt.isMDXComponent=!0;const xpt={toc:[]};function Cpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Cpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]};function bpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}bpt.isMDXComponent=!0;const Npt={toc:[]};function zpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Wpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Wpt.isMDXComponent=!0;const Rpt={toc:[]};function Spt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Spt.isMDXComponent=!0;const Ipt={toc:[]};function Ppt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ipt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Ppt.isMDXComponent=!0;const Ept={toc:[]};function Bpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ept,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Bpt.isMDXComponent=!0;const Gpt={toc:[]};function Opt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Opt.isMDXComponent=!0;const Fpt={toc:[]};function Upt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Upt.isMDXComponent=!0;const qpt={toc:[]};function Vpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Vpt.isMDXComponent=!0;const jpt={toc:[]};function Qpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Qpt.isMDXComponent=!0;const Hpt={toc:[]};function $pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}$pt.isMDXComponent=!0;const Ypt={toc:[]};function Kpt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ypt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]};function trt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}trt.isMDXComponent=!0;const nrt={toc:[]};function ert(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ert.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ort,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}prt.isMDXComponent=!0;const rrt={toc:[]};function srt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}srt.isMDXComponent=!0;const crt={toc:[]};function irt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}irt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},art,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}hrt.isMDXComponent=!0;const krt={toc:[]};function yrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},krt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}yrt.isMDXComponent=!0;const frt={toc:[]};function Mrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Mrt.isMDXComponent=!0;const Drt={toc:[]};function _rt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}_rt.isMDXComponent=!0;const Xrt={toc:[]};function wrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}wrt.isMDXComponent=!0;const grt={toc:[]};function Trt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Trt.isMDXComponent=!0;const xrt={toc:[]};function Crt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Crt.isMDXComponent=!0;const vrt={toc:[]};function Lrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Lrt.isMDXComponent=!0;const Zrt={toc:[]};function brt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}brt.isMDXComponent=!0;const Nrt={toc:[]};function zrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Wrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Art,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wrt.isMDXComponent=!0;const Rrt={toc:[]};function Srt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Srt.isMDXComponent=!0;const Irt={toc:[]};function Prt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Irt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Prt.isMDXComponent=!0;const Ert={toc:[]};function Brt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ert,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Brt.isMDXComponent=!0;const Grt={toc:[]};function Ort(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Ort.isMDXComponent=!0;const Frt={toc:[]};function Urt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Frt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Urt.isMDXComponent=!0;const qrt={toc:[]};function Vrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Vrt.isMDXComponent=!0;const jrt={toc:[]};function Qrt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Qrt.isMDXComponent=!0;const Hrt={toc:[]};function $rt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}$rt.isMDXComponent=!0;const Yrt={toc:[]};function Krt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Krt.isMDXComponent=!0;const Jrt={toc:[]};function tst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}tst.isMDXComponent=!0;const nst={toc:[]};function est(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}est.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ost,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pst.isMDXComponent=!0;const rst={toc:[]};function sst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}sst.isMDXComponent=!0;const cst={toc:[]};function ist(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ist.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ast,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ust,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}hst.isMDXComponent=!0;const kst={toc:[]};function yst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}yst.isMDXComponent=!0;const fst={toc:[]};function Mst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Mst.isMDXComponent=!0;const Dst={toc:[]};function _st(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_st.isMDXComponent=!0;const Xst={toc:[]};function wst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}wst.isMDXComponent=!0;const gst={toc:[]};function Tst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Tst.isMDXComponent=!0;const xst={toc:[]};function Cst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Cst.isMDXComponent=!0;const vst={toc:[]};function Lst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lst.isMDXComponent=!0;const Zst={toc:[]};function bst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}bst.isMDXComponent=!0;const Nst={toc:[]};function zst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}zst.isMDXComponent=!0;const Ast={toc:[]};function Wst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ast,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wst.isMDXComponent=!0;const Rst={toc:[]};function Sst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Sst.isMDXComponent=!0;const Ist={toc:[]};function Pst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ist,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Pst.isMDXComponent=!0;const Est={toc:[]};function Bst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Est,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Bst.isMDXComponent=!0;const Gst={toc:[]};function Ost(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Ost.isMDXComponent=!0;const Fst={toc:[]};function Ust(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Ust.isMDXComponent=!0;const qst={toc:[]};function Vst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Vst.isMDXComponent=!0;const jst={toc:[]};function Qst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Qst.isMDXComponent=!0;const Hst={toc:[]};function $st(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}$st.isMDXComponent=!0;const Yst={toc:[]};function Kst(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Kst.isMDXComponent=!0;const Jst={toc:[]};function tct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}tct.isMDXComponent=!0;const nct={toc:[]};function ect(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}ect.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}pct.isMDXComponent=!0;const rct={toc:[]};function sct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}sct.isMDXComponent=!0;const cct={toc:[]};function ict(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}ict.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},act,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}hct.isMDXComponent=!0;const kct={toc:[]};function yct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}yct.isMDXComponent=!0;const fct={toc:[]};function Mct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Mct.isMDXComponent=!0;const Dct={toc:[]};function _ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}_ct.isMDXComponent=!0;const Xct={toc:[]};function wct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wct.isMDXComponent=!0;const gct={toc:[]};function Tct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Tct.isMDXComponent=!0;const xct={toc:[]};function Cct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Cct.isMDXComponent=!0;const vct={toc:[]};function Lct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Lct.isMDXComponent=!0;const Zct={toc:[]};function bct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}bct.isMDXComponent=!0;const Nct={toc:[]};function zct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}zct.isMDXComponent=!0;const Act={toc:[]};function Wct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Act,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Wct.isMDXComponent=!0;const Rct={toc:[]};function Sct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Sct.isMDXComponent=!0;const Ict={toc:[]};function Pct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ict,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Pct.isMDXComponent=!0;const Ect={toc:[]};function Bct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ect,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Bct.isMDXComponent=!0;const Gct={toc:[]};function Oct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Oct.isMDXComponent=!0;const Fct={toc:[]};function Uct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Uct.isMDXComponent=!0;const qct={toc:[]};function Vct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Vct.isMDXComponent=!0;const jct={toc:[]};function Qct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Qct.isMDXComponent=!0;const Hct={toc:[]};function $ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}$ct.isMDXComponent=!0;const Yct={toc:[]};function Kct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Kct.isMDXComponent=!0;const Jct={toc:[]};function tit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}tit.isMDXComponent=!0;const nit={toc:[]};function eit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}pit.isMDXComponent=!0;const rit={toc:[]};function sit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}sit.isMDXComponent=!0;const cit={toc:[]};function iit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}iit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ait,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}hit.isMDXComponent=!0;const kit={toc:[]};function yit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}yit.isMDXComponent=!0;const fit={toc:[]};function Mit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Mit.isMDXComponent=!0;const Dit={toc:[]};function _it(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}_it.isMDXComponent=!0;const Xit={toc:[]};function wit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wit.isMDXComponent=!0;const git={toc:[]};function Tit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},git,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Tit.isMDXComponent=!0;const xit={toc:[]};function Cit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Cit.isMDXComponent=!0;const vit={toc:[]};function Lit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Lit.isMDXComponent=!0;const Zit={toc:[]};function bit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}bit.isMDXComponent=!0;const Nit={toc:[]};function zit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Wit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ait,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Wit.isMDXComponent=!0;const Rit={toc:[]};function Sit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Sit.isMDXComponent=!0;const Iit={toc:[]};function Pit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Pit.isMDXComponent=!0;const Eit={toc:[]};function Bit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Bit.isMDXComponent=!0;const Git={toc:[]};function Oit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Git,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Oit.isMDXComponent=!0;const Fit={toc:[]};function Uit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Uit.isMDXComponent=!0;const qit={toc:[]};function Vit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Vit.isMDXComponent=!0;const jit={toc:[]};function Qit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Qit.isMDXComponent=!0;const Hit={toc:[]};function $it(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}$it.isMDXComponent=!0;const Yit={toc:[]};function Kit(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Kit.isMDXComponent=!0;const Jit={toc:[]};function tat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}tat.isMDXComponent=!0;const nat={toc:[]};function eat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}eat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pat.isMDXComponent=!0;const rat={toc:[]};function sat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}sat.isMDXComponent=!0;const cat={toc:[]};function iat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}iat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}hat.isMDXComponent=!0;const kat={toc:[]};function yat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}yat.isMDXComponent=!0;const fat={toc:[]};function Mat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Mat.isMDXComponent=!0;const Dat={toc:[]};function _at(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_at.isMDXComponent=!0;const Xat={toc:[]};function wat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}wat.isMDXComponent=!0;const gat={toc:[]};function Tat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Tat.isMDXComponent=!0;const xat={toc:[]};function Cat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Cat.isMDXComponent=!0;const vat={toc:[]};function Lat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Lat.isMDXComponent=!0;const Zat={toc:[]};function bat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}bat.isMDXComponent=!0;const Nat={toc:[]};function zat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zat.isMDXComponent=!0;const Aat={toc:[]};function Wat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Wat.isMDXComponent=!0;const Rat={toc:[]};function Sat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Sat.isMDXComponent=!0;const Iat={toc:[]};function Pat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Pat.isMDXComponent=!0;const Eat={toc:[]};function Bat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Bat.isMDXComponent=!0;const Gat={toc:[]};function Oat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Oat.isMDXComponent=!0;const Fat={toc:[]};function Uat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Uat.isMDXComponent=!0;const qat={toc:[]};function Vat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Vat.isMDXComponent=!0;const jat={toc:[]};function Qat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Qat.isMDXComponent=!0;const Hat={toc:[]};function $at(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}$at.isMDXComponent=!0;const Yat={toc:[]};function Kat(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Kat.isMDXComponent=!0;const Jat={toc:[]};function tlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}tlt.isMDXComponent=!0;const nlt={toc:[]};function elt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}elt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},olt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}plt.isMDXComponent=!0;const rlt={toc:[]};function slt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}slt.isMDXComponent=!0;const clt={toc:[]};function ilt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},clt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}ilt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},alt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ult,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}hlt.isMDXComponent=!0;const klt={toc:[]};function ylt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},klt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}ylt.isMDXComponent=!0;const flt={toc:[]};function Mlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},flt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Mlt.isMDXComponent=!0;const Dlt={toc:[]};function _lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}_lt.isMDXComponent=!0;const Xlt={toc:[]};function wlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wlt.isMDXComponent=!0;const glt={toc:[]};function Tlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},glt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Tlt.isMDXComponent=!0;const xlt={toc:[]};function Clt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Clt.isMDXComponent=!0;const vlt={toc:[]};function Llt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Llt.isMDXComponent=!0;const Zlt={toc:[]};function blt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}blt.isMDXComponent=!0;const Nlt={toc:[]};function zlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Wlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Alt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Wlt.isMDXComponent=!0;const Rlt={toc:[]};function Slt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Slt.isMDXComponent=!0;const Ilt={toc:[]};function Plt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ilt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Plt.isMDXComponent=!0;const Elt={toc:[]};function Blt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Elt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Blt.isMDXComponent=!0;const Glt={toc:[]};function Olt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Glt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Olt.isMDXComponent=!0;const Flt={toc:[]};function Ult(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Flt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Ult.isMDXComponent=!0;const qlt={toc:[]};function Vlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Vlt.isMDXComponent=!0;const jlt={toc:[]};function Qlt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Qlt.isMDXComponent=!0;const Hlt={toc:[]};function $lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}$lt.isMDXComponent=!0;const Ylt={toc:[]};function Klt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ylt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Klt.isMDXComponent=!0;const Jlt={toc:[]};function tut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tut.isMDXComponent=!0;const nut={toc:[]};function eut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}eut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},out,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}put.isMDXComponent=!0;const rut={toc:[]};function sut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}sut.isMDXComponent=!0;const cut={toc:[]};function iut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}iut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hut.isMDXComponent=!0;const kut={toc:[]};function yut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}yut.isMDXComponent=!0;const fut={toc:[]};function Mut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Mut.isMDXComponent=!0;const Dut={toc:[]};function _ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}_ut.isMDXComponent=!0;const Xut={toc:[]};function wut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wut.isMDXComponent=!0;const gut={toc:[]};function Tut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Tut.isMDXComponent=!0;const xut={toc:[]};function Cut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Cut.isMDXComponent=!0;const vut={toc:[]};function Lut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Lut.isMDXComponent=!0;const Zut={toc:[]};function but(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}but.isMDXComponent=!0;const Nut={toc:[]};function zut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}zut.isMDXComponent=!0;const Aut={toc:[]};function Wut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Wut.isMDXComponent=!0;const Rut={toc:[]};function Sut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Sut.isMDXComponent=!0;const Iut={toc:[]};function Put(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Put.isMDXComponent=!0;const Eut={toc:[]};function But(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}But.isMDXComponent=!0;const Gut={toc:[]};function Out(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Out.isMDXComponent=!0;const Fut={toc:[]};function Uut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Uut.isMDXComponent=!0;const qut={toc:[]};function Vut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Vut.isMDXComponent=!0;const jut={toc:[]};function Qut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Qut.isMDXComponent=!0;const Hut={toc:[]};function $ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$ut.isMDXComponent=!0;const Yut={toc:[]};function Kut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Kut.isMDXComponent=!0;const Jut={toc:[]};function tmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}tmt.isMDXComponent=!0;const nmt={toc:[]};function emt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}emt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pmt.isMDXComponent=!0;const rmt={toc:[]};function smt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}smt.isMDXComponent=!0;const cmt={toc:[]};function imt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}imt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}hmt.isMDXComponent=!0;const kmt={toc:[]};function ymt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}ymt.isMDXComponent=!0;const fmt={toc:[]};function Mmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Mmt.isMDXComponent=!0;const Dmt={toc:[]};function _mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}_mt.isMDXComponent=!0;const Xmt={toc:[]};function wmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wmt.isMDXComponent=!0;const gmt={toc:[]};function Tmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Tmt.isMDXComponent=!0;const xmt={toc:[]};function Cmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Cmt.isMDXComponent=!0;const vmt={toc:[]};function Lmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]};function bmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}bmt.isMDXComponent=!0;const Nmt={toc:[]};function zmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Wmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Wmt.isMDXComponent=!0;const Rmt={toc:[]};function Smt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Smt.isMDXComponent=!0;const Imt={toc:[]};function Pmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Imt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Pmt.isMDXComponent=!0;const Emt={toc:[]};function Bmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Bmt.isMDXComponent=!0;const Gmt={toc:[]};function Omt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Omt.isMDXComponent=!0;const Fmt={toc:[]};function Umt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Umt.isMDXComponent=!0;const qmt={toc:[]};function Vmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Vmt.isMDXComponent=!0;const jmt={toc:[]};function Qmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Qmt.isMDXComponent=!0;const Hmt={toc:[]};function $mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$mt.isMDXComponent=!0;const Ymt={toc:[]};function Kmt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ymt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]};function tdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}tdt.isMDXComponent=!0;const ndt={toc:[]};function edt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ndt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}edt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pdt.isMDXComponent=!0;const rdt={toc:[]};function sdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}sdt.isMDXComponent=!0;const cdt={toc:[]};function idt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}idt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}hdt.isMDXComponent=!0;const kdt={toc:[]};function ydt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ydt.isMDXComponent=!0;const fdt={toc:[]};function Mdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Mdt.isMDXComponent=!0;const Ddt={toc:[]};function _dt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}_dt.isMDXComponent=!0;const Xdt={toc:[]};function wdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}wdt.isMDXComponent=!0;const gdt={toc:[]};function Tdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Tdt.isMDXComponent=!0;const xdt={toc:[]};function Cdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Cdt.isMDXComponent=!0;const vdt={toc:[]};function Ldt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]};function bdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}bdt.isMDXComponent=!0;const Ndt={toc:[]};function zdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Wdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Wdt.isMDXComponent=!0;const Rdt={toc:[]};function Sdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Sdt.isMDXComponent=!0;const Idt={toc:[]};function Pdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Idt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Pdt.isMDXComponent=!0;const Edt={toc:[]};function Bdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bdt.isMDXComponent=!0;const Gdt={toc:[]};function Odt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Odt.isMDXComponent=!0;const Fdt={toc:[]};function Udt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Udt.isMDXComponent=!0;const qdt={toc:[]};function Vdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Vdt.isMDXComponent=!0;const jdt={toc:[]};function Qdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Qdt.isMDXComponent=!0;const Hdt={toc:[]};function $dt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$dt.isMDXComponent=!0;const Ydt={toc:[]};function Kdt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ydt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]};function tht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}tht.isMDXComponent=!0;const nht={toc:[]};function eht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}eht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}pht.isMDXComponent=!0;const rht={toc:[]};function sht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}sht.isMDXComponent=!0;const cht={toc:[]};function iht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}iht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}hht.isMDXComponent=!0;const kht={toc:[]};function yht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}yht.isMDXComponent=!0;const fht={toc:[]};function Mht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Mht.isMDXComponent=!0;const Dht={toc:[]};function _ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}_ht.isMDXComponent=!0;const Xht={toc:[]};function wht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wht.isMDXComponent=!0;const ght={toc:[]};function Tht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ght,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Tht.isMDXComponent=!0;const xht={toc:[]};function Cht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Cht.isMDXComponent=!0;const vht={toc:[]};function Lht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Lht.isMDXComponent=!0;const Zht={toc:[]};function bht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}bht.isMDXComponent=!0;const Nht={toc:[]};function zht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Wht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Wht.isMDXComponent=!0;const Rht={toc:[]};function Sht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Sht.isMDXComponent=!0;const Iht={toc:[]};function Pht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Pht.isMDXComponent=!0;const Eht={toc:[]};function Bht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Bht.isMDXComponent=!0;const Ght={toc:[]};function Oht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ght,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Oht.isMDXComponent=!0;const Fht={toc:[]};function Uht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Uht.isMDXComponent=!0;const qht={toc:[]};function Vht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Vht.isMDXComponent=!0;const jht={toc:[]};function Qht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Qht.isMDXComponent=!0;const Hht={toc:[]};function $ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}$ht.isMDXComponent=!0;const Yht={toc:[]};function Kht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Kht.isMDXComponent=!0;const Jht={toc:[]};function tkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}tkt.isMDXComponent=!0;const nkt={toc:[]};function ekt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}ekt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pkt.isMDXComponent=!0;const rkt={toc:[]};function skt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}skt.isMDXComponent=!0;const ckt={toc:[]};function ikt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ikt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}hkt.isMDXComponent=!0;const kkt={toc:[]};function ykt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}ykt.isMDXComponent=!0;const fkt={toc:[]};function Mkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Mkt.isMDXComponent=!0;const Dkt={toc:[]};function _kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}_kt.isMDXComponent=!0;const Xkt={toc:[]};function wkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wkt.isMDXComponent=!0;const gkt={toc:[]};function Tkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Tkt.isMDXComponent=!0;const xkt={toc:[]};function Ckt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ckt.isMDXComponent=!0;const vkt={toc:[]};function Lkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]};function bkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}bkt.isMDXComponent=!0;const Nkt={toc:[]};function zkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Wkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Wkt.isMDXComponent=!0;const Rkt={toc:[]};function Skt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Skt.isMDXComponent=!0;const Ikt={toc:[]};function Pkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ikt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Pkt.isMDXComponent=!0;const Ekt={toc:[]};function Bkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Bkt.isMDXComponent=!0;const Gkt={toc:[]};function Okt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Okt.isMDXComponent=!0;const Fkt={toc:[]};function Ukt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Ukt.isMDXComponent=!0;const qkt={toc:[]};function Vkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Vkt.isMDXComponent=!0;const jkt={toc:[]};function Qkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Qkt.isMDXComponent=!0;const Hkt={toc:[]};function $kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}$kt.isMDXComponent=!0;const Ykt={toc:[]};function Kkt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ykt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Kkt.isMDXComponent=!0;const Jkt={toc:[]};function tyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}tyt.isMDXComponent=!0;const nyt={toc:[]};function eyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pyt.isMDXComponent=!0;const ryt={toc:[]};function syt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}syt.isMDXComponent=!0;const cyt={toc:[]};function iyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}iyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}hyt.isMDXComponent=!0;const kyt={toc:[]};function yyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}yyt.isMDXComponent=!0;const fyt={toc:[]};function Myt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Myt.isMDXComponent=!0;const Dyt={toc:[]};function _yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}_yt.isMDXComponent=!0;const Xyt={toc:[]};function wyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wyt.isMDXComponent=!0;const gyt={toc:[]};function Tyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Tyt.isMDXComponent=!0;const xyt={toc:[]};function Cyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Cyt.isMDXComponent=!0;const vyt={toc:[]};function Lyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]};function byt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}byt.isMDXComponent=!0;const Nyt={toc:[]};function zyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Wyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Wyt.isMDXComponent=!0;const Ryt={toc:[]};function Syt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Syt.isMDXComponent=!0;const Iyt={toc:[]};function Pyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Pyt.isMDXComponent=!0;const Eyt={toc:[]};function Byt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Byt.isMDXComponent=!0;const Gyt={toc:[]};function Oyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Oyt.isMDXComponent=!0;const Fyt={toc:[]};function Uyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Uyt.isMDXComponent=!0;const qyt={toc:[]};function Vyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Vyt.isMDXComponent=!0;const jyt={toc:[]};function Qyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Qyt.isMDXComponent=!0;const Hyt={toc:[]};function $yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$yt.isMDXComponent=!0;const Yyt={toc:[]};function Kyt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]};function tft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}tft.isMDXComponent=!0;const nft={toc:[]};function eft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}eft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pft.isMDXComponent=!0;const rft={toc:[]};function sft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}sft.isMDXComponent=!0;const cft={toc:[]};function ift(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ift.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hft.isMDXComponent=!0;const kft={toc:[]};function yft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}yft.isMDXComponent=!0;const fft={toc:[]};function Mft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Mft.isMDXComponent=!0;const Dft={toc:[]};function _ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}_ft.isMDXComponent=!0;const Xft={toc:[]};function wft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}wft.isMDXComponent=!0;const gft={toc:[]};function Tft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Tft.isMDXComponent=!0;const xft={toc:[]};function Cft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Cft.isMDXComponent=!0;const vft={toc:[]};function Lft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Lft.isMDXComponent=!0;const Zft={toc:[]};function bft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}bft.isMDXComponent=!0;const Nft={toc:[]};function zft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Wft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Wft.isMDXComponent=!0;const Rft={toc:[]};function Sft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Sft.isMDXComponent=!0;const Ift={toc:[]};function Pft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ift,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Pft.isMDXComponent=!0;const Eft={toc:[]};function Bft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Bft.isMDXComponent=!0;const Gft={toc:[]};function Oft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Oft.isMDXComponent=!0;const Fft={toc:[]};function Uft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Uft.isMDXComponent=!0;const qft={toc:[]};function Vft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Vft.isMDXComponent=!0;const jft={toc:[]};function Qft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Qft.isMDXComponent=!0;const Hft={toc:[]};function $ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$ft.isMDXComponent=!0;const Yft={toc:[]};function Kft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Kft.isMDXComponent=!0;const Jft={toc:[]};function tMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}tMt.isMDXComponent=!0;const nMt={toc:[]};function eMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}eMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pMt.isMDXComponent=!0;const rMt={toc:[]};function sMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}sMt.isMDXComponent=!0;const cMt={toc:[]};function iMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}hMt.isMDXComponent=!0;const kMt={toc:[]};function yMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}yMt.isMDXComponent=!0;const fMt={toc:[]};function MMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}MMt.isMDXComponent=!0;const DMt={toc:[]};function _Mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}_Mt.isMDXComponent=!0;const XMt={toc:[]};function wMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wMt.isMDXComponent=!0;const gMt={toc:[]};function TMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}TMt.isMDXComponent=!0;const xMt={toc:[]};function CMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}CMt.isMDXComponent=!0;const vMt={toc:[]};function LMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LMt.isMDXComponent=!0;const ZMt={toc:[]};function bMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}bMt.isMDXComponent=!0;const NMt={toc:[]};function zMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function WMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}WMt.isMDXComponent=!0;const RMt={toc:[]};function SMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}SMt.isMDXComponent=!0;const IMt={toc:[]};function PMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PMt.isMDXComponent=!0;const EMt={toc:[]};function BMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}BMt.isMDXComponent=!0;const GMt={toc:[]};function OMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}OMt.isMDXComponent=!0;const FMt={toc:[]};function UMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}UMt.isMDXComponent=!0;const qMt={toc:[]};function VMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}VMt.isMDXComponent=!0;const jMt={toc:[]};function QMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}QMt.isMDXComponent=!0;const HMt={toc:[]};function $Mt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$Mt.isMDXComponent=!0;const YMt={toc:[]};function KMt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}KMt.isMDXComponent=!0;const JMt={toc:[]};function tDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}tDt.isMDXComponent=!0;const nDt={toc:[]};function eDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pDt.isMDXComponent=!0;const rDt={toc:[]};function sDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}sDt.isMDXComponent=!0;const cDt={toc:[]};function iDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}iDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}hDt.isMDXComponent=!0;const kDt={toc:[]};function yDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}yDt.isMDXComponent=!0;const fDt={toc:[]};function MDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}MDt.isMDXComponent=!0;const DDt={toc:[]};function _Dt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}_Dt.isMDXComponent=!0;const XDt={toc:[]};function wDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}wDt.isMDXComponent=!0;const gDt={toc:[]};function TDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}TDt.isMDXComponent=!0;const xDt={toc:[]};function CDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}CDt.isMDXComponent=!0;const vDt={toc:[]};function LDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LDt.isMDXComponent=!0;const ZDt={toc:[]};function bDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}bDt.isMDXComponent=!0;const NDt={toc:[]};function zDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zDt.isMDXComponent=!0;const ADt={toc:[]};function WDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}WDt.isMDXComponent=!0;const RDt={toc:[]};function SDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}SDt.isMDXComponent=!0;const IDt={toc:[]};function PDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}PDt.isMDXComponent=!0;const EDt={toc:[]};function BDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BDt.isMDXComponent=!0;const GDt={toc:[]};function ODt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}ODt.isMDXComponent=!0;const FDt={toc:[]};function UDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}UDt.isMDXComponent=!0;const qDt={toc:[]};function VDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}VDt.isMDXComponent=!0;const jDt={toc:[]};function QDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}QDt.isMDXComponent=!0;const HDt={toc:[]};function $Dt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$Dt.isMDXComponent=!0;const YDt={toc:[]};function KDt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}KDt.isMDXComponent=!0;const JDt={toc:[]};function t_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}t_t.isMDXComponent=!0;const n_t={toc:[]};function e_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}e_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}p_t.isMDXComponent=!0;const r_t={toc:[]};function s_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}s_t.isMDXComponent=!0;const c_t={toc:[]};function i_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}h_t.isMDXComponent=!0;const k_t={toc:[]};function y_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}y_t.isMDXComponent=!0;const f_t={toc:[]};function M_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}M_t.isMDXComponent=!0;const D_t={toc:[]};function __t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}__t.isMDXComponent=!0;const X_t={toc:[]};function w_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}w_t.isMDXComponent=!0;const g_t={toc:[]};function T_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}T_t.isMDXComponent=!0;const x_t={toc:[]};function C_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}C_t.isMDXComponent=!0;const v_t={toc:[]};function L_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}L_t.isMDXComponent=!0;const Z_t={toc:[]};function b_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}b_t.isMDXComponent=!0;const N_t={toc:[]};function z_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function W_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}W_t.isMDXComponent=!0;const R_t={toc:[]};function S_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}S_t.isMDXComponent=!0;const I_t={toc:[]};function P_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}P_t.isMDXComponent=!0;const E_t={toc:[]};function B_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}B_t.isMDXComponent=!0;const G_t={toc:[]};function O_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}O_t.isMDXComponent=!0;const F_t={toc:[]};function U_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}U_t.isMDXComponent=!0;const q_t={toc:[]};function V_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}V_t.isMDXComponent=!0;const j_t={toc:[]};function Q_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Q_t.isMDXComponent=!0;const H_t={toc:[]};function $_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}$_t.isMDXComponent=!0;const Y_t={toc:[]};function K_t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}K_t.isMDXComponent=!0;const J_t={toc:[]};function tXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}tXt.isMDXComponent=!0;const nXt={toc:[]};function eXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pXt.isMDXComponent=!0;const rXt={toc:[]};function sXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}sXt.isMDXComponent=!0;const cXt={toc:[]};function iXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}iXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}hXt.isMDXComponent=!0;const kXt={toc:[]};function yXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}yXt.isMDXComponent=!0;const fXt={toc:[]};function MXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}MXt.isMDXComponent=!0;const DXt={toc:[]};function _Xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}_Xt.isMDXComponent=!0;const XXt={toc:[]};function wXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}wXt.isMDXComponent=!0;const gXt={toc:[]};function TXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}TXt.isMDXComponent=!0;const xXt={toc:[]};function CXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}CXt.isMDXComponent=!0;const vXt={toc:[]};function LXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LXt.isMDXComponent=!0;const ZXt={toc:[]};function bXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}bXt.isMDXComponent=!0;const NXt={toc:[]};function zXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}zXt.isMDXComponent=!0;const AXt={toc:[]};function WXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}WXt.isMDXComponent=!0;const RXt={toc:[]};function SXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}SXt.isMDXComponent=!0;const IXt={toc:[]};function PXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}PXt.isMDXComponent=!0;const EXt={toc:[]};function BXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}BXt.isMDXComponent=!0;const GXt={toc:[]};function OXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}OXt.isMDXComponent=!0;const FXt={toc:[]};function UXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}UXt.isMDXComponent=!0;const qXt={toc:[]};function VXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}VXt.isMDXComponent=!0;const jXt={toc:[]};function QXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}QXt.isMDXComponent=!0;const HXt={toc:[]};function $Xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$Xt.isMDXComponent=!0;const YXt={toc:[]};function KXt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}KXt.isMDXComponent=!0;const JXt={toc:[]};function twt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}twt.isMDXComponent=!0;const nwt={toc:[]};function ewt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}ewt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}pwt.isMDXComponent=!0;const rwt={toc:[]};function swt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}swt.isMDXComponent=!0;const cwt={toc:[]};function iwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}iwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hwt.isMDXComponent=!0;const kwt={toc:[]};function ywt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}ywt.isMDXComponent=!0;const fwt={toc:[]};function Mwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mwt.isMDXComponent=!0;const Dwt={toc:[]};function _wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}_wt.isMDXComponent=!0;const Xwt={toc:[]};function wwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wwt.isMDXComponent=!0;const gwt={toc:[]};function Twt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Twt.isMDXComponent=!0;const xwt={toc:[]};function Cwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Cwt.isMDXComponent=!0;const vwt={toc:[]};function Lwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]};function bwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}bwt.isMDXComponent=!0;const Nwt={toc:[]};function zwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Wwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Wwt.isMDXComponent=!0;const Rwt={toc:[]};function Swt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Swt.isMDXComponent=!0;const Iwt={toc:[]};function Pwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Pwt.isMDXComponent=!0;const Ewt={toc:[]};function Bwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Bwt.isMDXComponent=!0;const Gwt={toc:[]};function Owt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Owt.isMDXComponent=!0;const Fwt={toc:[]};function Uwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Uwt.isMDXComponent=!0;const qwt={toc:[]};function Vwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Vwt.isMDXComponent=!0;const jwt={toc:[]};function Qwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Qwt.isMDXComponent=!0;const Hwt={toc:[]};function $wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}$wt.isMDXComponent=!0;const Ywt={toc:[]};function Kwt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ywt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]};function tgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}tgt.isMDXComponent=!0;const ngt={toc:[]};function egt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ngt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}egt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pgt.isMDXComponent=!0;const rgt={toc:[]};function sgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}sgt.isMDXComponent=!0;const cgt={toc:[]};function igt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}igt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}hgt.isMDXComponent=!0;const kgt={toc:[]};function ygt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ygt.isMDXComponent=!0;const fgt={toc:[]};function Mgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Mgt.isMDXComponent=!0;const Dgt={toc:[]};function _gt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_gt.isMDXComponent=!0;const Xgt={toc:[]};function wgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}wgt.isMDXComponent=!0;const ggt={toc:[]};function Tgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Tgt.isMDXComponent=!0;const xgt={toc:[]};function Cgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Cgt.isMDXComponent=!0;const vgt={toc:[]};function Lgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]};function bgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}bgt.isMDXComponent=!0;const Ngt={toc:[]};function zgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Wgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wgt.isMDXComponent=!0;const Rgt={toc:[]};function Sgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Sgt.isMDXComponent=!0;const Igt={toc:[]};function Pgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Igt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Pgt.isMDXComponent=!0;const Egt={toc:[]};function Bgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Bgt.isMDXComponent=!0;const Ggt={toc:[]};function Ogt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Ogt.isMDXComponent=!0;const Fgt={toc:[]};function Ugt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Ugt.isMDXComponent=!0;const qgt={toc:[]};function Vgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Vgt.isMDXComponent=!0;const jgt={toc:[]};function Qgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Qgt.isMDXComponent=!0;const Hgt={toc:[]};function $gt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}$gt.isMDXComponent=!0;const Ygt={toc:[]};function Kgt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ygt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]};function tTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tTt.isMDXComponent=!0;const nTt={toc:[]};function eTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}eTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pTt.isMDXComponent=!0;const rTt={toc:[]};function sTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}sTt.isMDXComponent=!0;const cTt={toc:[]};function iTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}iTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}hTt.isMDXComponent=!0;const kTt={toc:[]};function yTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}yTt.isMDXComponent=!0;const fTt={toc:[]};function MTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}MTt.isMDXComponent=!0;const DTt={toc:[]};function _Tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}_Tt.isMDXComponent=!0;const XTt={toc:[]};function wTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}wTt.isMDXComponent=!0;const gTt={toc:[]};function TTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}TTt.isMDXComponent=!0;const xTt={toc:[]};function CTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}CTt.isMDXComponent=!0;const vTt={toc:[]};function LTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}LTt.isMDXComponent=!0;const ZTt={toc:[]};function bTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}bTt.isMDXComponent=!0;const NTt={toc:[]};function zTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zTt.isMDXComponent=!0;const ATt={toc:[]};function WTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}WTt.isMDXComponent=!0;const RTt={toc:[]};function STt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}STt.isMDXComponent=!0;const ITt={toc:[]};function PTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ITt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PTt.isMDXComponent=!0;const ETt={toc:[]};function BTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}BTt.isMDXComponent=!0;const GTt={toc:[]};function OTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}OTt.isMDXComponent=!0;const FTt={toc:[]};function UTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}UTt.isMDXComponent=!0;const qTt={toc:[]};function VTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}VTt.isMDXComponent=!0;const jTt={toc:[]};function QTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}QTt.isMDXComponent=!0;const HTt={toc:[]};function $Tt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}$Tt.isMDXComponent=!0;const YTt={toc:[]};function KTt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}KTt.isMDXComponent=!0;const JTt={toc:[]};function txt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}txt.isMDXComponent=!0;const nxt={toc:[]};function ext(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ext.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}pxt.isMDXComponent=!0;const rxt={toc:[]};function sxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}sxt.isMDXComponent=!0;const cxt={toc:[]};function ixt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}ixt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hxt.isMDXComponent=!0;const kxt={toc:[]};function yxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}yxt.isMDXComponent=!0;const fxt={toc:[]};function Mxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Mxt.isMDXComponent=!0;const Dxt={toc:[]};function _xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}_xt.isMDXComponent=!0;const Xxt={toc:[]};function wxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wxt.isMDXComponent=!0;const gxt={toc:[]};function Txt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Txt.isMDXComponent=!0;const xxt={toc:[]};function Cxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Cxt.isMDXComponent=!0;const vxt={toc:[]};function Lxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]};function bxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}bxt.isMDXComponent=!0;const Nxt={toc:[]};function zxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Wxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Wxt.isMDXComponent=!0;const Rxt={toc:[]};function Sxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Sxt.isMDXComponent=!0;const Ixt={toc:[]};function Pxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ixt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Pxt.isMDXComponent=!0;const Ext={toc:[]};function Bxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ext,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Bxt.isMDXComponent=!0;const Gxt={toc:[]};function Oxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Oxt.isMDXComponent=!0;const Fxt={toc:[]};function Uxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Uxt.isMDXComponent=!0;const qxt={toc:[]};function Vxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Vxt.isMDXComponent=!0;const jxt={toc:[]};function Qxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Qxt.isMDXComponent=!0;const Hxt={toc:[]};function $xt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}$xt.isMDXComponent=!0;const Yxt={toc:[]};function Kxt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]};function tCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}tCt.isMDXComponent=!0;const nCt={toc:[]};function eCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}eCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}pCt.isMDXComponent=!0;const rCt={toc:[]};function sCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}sCt.isMDXComponent=!0;const cCt={toc:[]};function iCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}iCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}hCt.isMDXComponent=!0;const kCt={toc:[]};function yCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}yCt.isMDXComponent=!0;const fCt={toc:[]};function MCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}MCt.isMDXComponent=!0;const DCt={toc:[]};function _Ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}_Ct.isMDXComponent=!0;const XCt={toc:[]};function wCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wCt.isMDXComponent=!0;const gCt={toc:[]};function TCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}TCt.isMDXComponent=!0;const xCt={toc:[]};function CCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}CCt.isMDXComponent=!0;const vCt={toc:[]};function LCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LCt.isMDXComponent=!0;const ZCt={toc:[]};function bCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}bCt.isMDXComponent=!0;const NCt={toc:[]};function zCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}zCt.isMDXComponent=!0;const ACt={toc:[]};function WCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}WCt.isMDXComponent=!0;const RCt={toc:[]};function SCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}SCt.isMDXComponent=!0;const ICt={toc:[]};function PCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ICt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}PCt.isMDXComponent=!0;const ECt={toc:[]};function BCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}BCt.isMDXComponent=!0;const GCt={toc:[]};function OCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}OCt.isMDXComponent=!0;const FCt={toc:[]};function UCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}UCt.isMDXComponent=!0;const qCt={toc:[]};function VCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}VCt.isMDXComponent=!0;const jCt={toc:[]};function QCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}QCt.isMDXComponent=!0;const HCt={toc:[]};function $Ct(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}$Ct.isMDXComponent=!0;const YCt={toc:[]};function KCt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}KCt.isMDXComponent=!0;const JCt={toc:[]};function tvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}tvt.isMDXComponent=!0;const nvt={toc:[]};function evt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}evt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}pvt.isMDXComponent=!0;const rvt={toc:[]};function svt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}svt.isMDXComponent=!0;const cvt={toc:[]};function ivt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}ivt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hvt.isMDXComponent=!0;const kvt={toc:[]};function yvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}yvt.isMDXComponent=!0;const fvt={toc:[]};function Mvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Mvt.isMDXComponent=!0;const Dvt={toc:[]};function _vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_vt.isMDXComponent=!0;const Xvt={toc:[]};function wvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wvt.isMDXComponent=!0;const gvt={toc:[]};function Tvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Tvt.isMDXComponent=!0;const xvt={toc:[]};function Cvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Cvt.isMDXComponent=!0;const vvt={toc:[]};function Lvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]};function bvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}bvt.isMDXComponent=!0;const Nvt={toc:[]};function zvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Wvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Wvt.isMDXComponent=!0;const Rvt={toc:[]};function Svt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Svt.isMDXComponent=!0;const Ivt={toc:[]};function Pvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ivt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Pvt.isMDXComponent=!0;const Evt={toc:[]};function Bvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Bvt.isMDXComponent=!0;const Gvt={toc:[]};function Ovt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Ovt.isMDXComponent=!0;const Fvt={toc:[]};function Uvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Uvt.isMDXComponent=!0;const qvt={toc:[]};function Vvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Vvt.isMDXComponent=!0;const jvt={toc:[]};function Qvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Qvt.isMDXComponent=!0;const Hvt={toc:[]};function $vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}$vt.isMDXComponent=!0;const Yvt={toc:[]};function Kvt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]};function tLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}tLt.isMDXComponent=!0;const nLt={toc:[]};function eLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}eLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}pLt.isMDXComponent=!0;const rLt={toc:[]};function sLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sLt.isMDXComponent=!0;const cLt={toc:[]};function iLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}hLt.isMDXComponent=!0;const kLt={toc:[]};function yLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}yLt.isMDXComponent=!0;const fLt={toc:[]};function MLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MLt.isMDXComponent=!0;const DLt={toc:[]};function _Lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_Lt.isMDXComponent=!0;const XLt={toc:[]};function wLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wLt.isMDXComponent=!0;const gLt={toc:[]};function TLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}TLt.isMDXComponent=!0;const xLt={toc:[]};function CLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}CLt.isMDXComponent=!0;const vLt={toc:[]};function LLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}LLt.isMDXComponent=!0;const ZLt={toc:[]};function bLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}bLt.isMDXComponent=!0;const NLt={toc:[]};function zLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}zLt.isMDXComponent=!0;const ALt={toc:[]};function WLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}WLt.isMDXComponent=!0;const RLt={toc:[]};function SLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}SLt.isMDXComponent=!0;const ILt={toc:[]};function PLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ILt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}PLt.isMDXComponent=!0;const ELt={toc:[]};function BLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}BLt.isMDXComponent=!0;const GLt={toc:[]};function OLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}OLt.isMDXComponent=!0;const FLt={toc:[]};function ULt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}ULt.isMDXComponent=!0;const qLt={toc:[]};function VLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}VLt.isMDXComponent=!0;const jLt={toc:[]};function QLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}QLt.isMDXComponent=!0;const HLt={toc:[]};function $Lt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}$Lt.isMDXComponent=!0;const YLt={toc:[]};function KLt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}KLt.isMDXComponent=!0;const JLt={toc:[]};function tZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}tZt.isMDXComponent=!0;const nZt={toc:[]};function eZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}eZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}pZt.isMDXComponent=!0;const rZt={toc:[]};function sZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sZt.isMDXComponent=!0;const cZt={toc:[]};function iZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}iZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}hZt.isMDXComponent=!0;const kZt={toc:[]};function yZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}yZt.isMDXComponent=!0;const fZt={toc:[]};function MZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}MZt.isMDXComponent=!0;const DZt={toc:[]};function _Zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_Zt.isMDXComponent=!0;const XZt={toc:[]};function wZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wZt.isMDXComponent=!0;const gZt={toc:[]};function TZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}TZt.isMDXComponent=!0;const xZt={toc:[]};function CZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}CZt.isMDXComponent=!0;const vZt={toc:[]};function LZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LZt.isMDXComponent=!0;const ZZt={toc:[]};function bZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}bZt.isMDXComponent=!0;const NZt={toc:[]};function zZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}zZt.isMDXComponent=!0;const AZt={toc:[]};function WZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}WZt.isMDXComponent=!0;const RZt={toc:[]};function SZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}SZt.isMDXComponent=!0;const IZt={toc:[]};function PZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}PZt.isMDXComponent=!0;const EZt={toc:[]};function BZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}BZt.isMDXComponent=!0;const GZt={toc:[]};function OZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}OZt.isMDXComponent=!0;const FZt={toc:[]};function UZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}UZt.isMDXComponent=!0;const qZt={toc:[]};function VZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}VZt.isMDXComponent=!0;const jZt={toc:[]};function QZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}QZt.isMDXComponent=!0;const HZt={toc:[]};function $Zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}$Zt.isMDXComponent=!0;const YZt={toc:[]};function KZt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}KZt.isMDXComponent=!0;const JZt={toc:[]};function tbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}tbt.isMDXComponent=!0;const nbt={toc:[]};function ebt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ebt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}pbt.isMDXComponent=!0;const rbt={toc:[]};function sbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sbt.isMDXComponent=!0;const cbt={toc:[]};function ibt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}ibt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}hbt.isMDXComponent=!0;const kbt={toc:[]};function ybt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ybt.isMDXComponent=!0;const fbt={toc:[]};function Mbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Mbt.isMDXComponent=!0;const Dbt={toc:[]};function _bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_bt.isMDXComponent=!0;const Xbt={toc:[]};function wbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}wbt.isMDXComponent=!0;const gbt={toc:[]};function Tbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}Tbt.isMDXComponent=!0;const xbt={toc:[]};function Cbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}Cbt.isMDXComponent=!0;const vbt={toc:[]};function Lbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]};function bbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}bbt.isMDXComponent=!0;const Nbt={toc:[]};function zbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Wbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Wbt.isMDXComponent=!0;const Rbt={toc:[]};function Sbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Sbt.isMDXComponent=!0;const Ibt={toc:[]};function Pbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ibt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Pbt.isMDXComponent=!0;const Ebt={toc:[]};function Bbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Bbt.isMDXComponent=!0;const Gbt={toc:[]};function Obt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Obt.isMDXComponent=!0;const Fbt={toc:[]};function Ubt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ubt.isMDXComponent=!0;const qbt={toc:[]};function Vbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Vbt.isMDXComponent=!0;const jbt={toc:[]};function Qbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Qbt.isMDXComponent=!0;const Hbt={toc:[]};function $bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}$bt.isMDXComponent=!0;const Ybt={toc:[]};function Kbt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ybt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]};function tNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}tNt.isMDXComponent=!0;const nNt={toc:[]};function eNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}eNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pNt.isMDXComponent=!0;const rNt={toc:[]};function sNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}sNt.isMDXComponent=!0;const cNt={toc:[]};function iNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}iNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}hNt.isMDXComponent=!0;const kNt={toc:[]};function yNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}yNt.isMDXComponent=!0;const fNt={toc:[]};function MNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}MNt.isMDXComponent=!0;const DNt={toc:[]};function _Nt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}_Nt.isMDXComponent=!0;const XNt={toc:[]};function wNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wNt.isMDXComponent=!0;const gNt={toc:[]};function TNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}TNt.isMDXComponent=!0;const xNt={toc:[]};function CNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}CNt.isMDXComponent=!0;const vNt={toc:[]};function LNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}LNt.isMDXComponent=!0;const ZNt={toc:[]};function bNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}bNt.isMDXComponent=!0;const NNt={toc:[]};function zNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}zNt.isMDXComponent=!0;const ANt={toc:[]};function WNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}WNt.isMDXComponent=!0;const RNt={toc:[]};function SNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}SNt.isMDXComponent=!0;const INt={toc:[]};function PNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},INt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}PNt.isMDXComponent=!0;const ENt={toc:[]};function BNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}BNt.isMDXComponent=!0;const GNt={toc:[]};function ONt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ONt.isMDXComponent=!0;const FNt={toc:[]};function UNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}UNt.isMDXComponent=!0;const qNt={toc:[]};function VNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}VNt.isMDXComponent=!0;const jNt={toc:[]};function QNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}QNt.isMDXComponent=!0;const HNt={toc:[]};function $Nt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}$Nt.isMDXComponent=!0;const YNt={toc:[]};function KNt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KNt.isMDXComponent=!0;const JNt={toc:[]};function tzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}tzt.isMDXComponent=!0;const nzt={toc:[]};function ezt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ezt.isMDXComponent=!0;const ozt={toc:[]};function pzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}pzt.isMDXComponent=!0;const rzt={toc:[]};function szt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}szt.isMDXComponent=!0;const czt={toc:[]};function izt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}izt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}hzt.isMDXComponent=!0;const kzt={toc:[]};function yzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}yzt.isMDXComponent=!0;const fzt={toc:[]};function Mzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Mzt.isMDXComponent=!0;const Dzt={toc:[]};function _zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}_zt.isMDXComponent=!0;const Xzt={toc:[]};function wzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}wzt.isMDXComponent=!0;const gzt={toc:[]};function Tzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Tzt.isMDXComponent=!0;const xzt={toc:[]};function Czt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Czt.isMDXComponent=!0;const vzt={toc:[]};function Lzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]};function bzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}bzt.isMDXComponent=!0;const Nzt={toc:[]};function zzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Wzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Wzt.isMDXComponent=!0;const Rzt={toc:[]};function Szt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Szt.isMDXComponent=!0;const Izt={toc:[]};function Pzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Izt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Pzt.isMDXComponent=!0;const Ezt={toc:[]};function Bzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ezt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Bzt.isMDXComponent=!0;const Gzt={toc:[]};function Ozt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Ozt.isMDXComponent=!0;const Fzt={toc:[]};function Uzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Uzt.isMDXComponent=!0;const qzt={toc:[]};function Vzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Vzt.isMDXComponent=!0;const jzt={toc:[]};function Qzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qzt.isMDXComponent=!0;const Hzt={toc:[]};function $zt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}$zt.isMDXComponent=!0;const Yzt={toc:[]};function Kzt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Kzt.isMDXComponent=!0;const Jzt={toc:[]};function tAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}tAt.isMDXComponent=!0;const nAt={toc:[]};function eAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}eAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}pAt.isMDXComponent=!0;const rAt={toc:[]};function sAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}sAt.isMDXComponent=!0;const cAt={toc:[]};function iAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}iAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}hAt.isMDXComponent=!0;const kAt={toc:[]};function yAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}yAt.isMDXComponent=!0;const fAt={toc:[]};function MAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}MAt.isMDXComponent=!0;const DAt={toc:[]};function _At(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_At.isMDXComponent=!0;const XAt={toc:[]};function wAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wAt.isMDXComponent=!0;const gAt={toc:[]};function TAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}TAt.isMDXComponent=!0;const xAt={toc:[]};function CAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}CAt.isMDXComponent=!0;const vAt={toc:[]};function LAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}LAt.isMDXComponent=!0;const ZAt={toc:[]};function bAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}bAt.isMDXComponent=!0;const NAt={toc:[]};function zAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function WAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}WAt.isMDXComponent=!0;const RAt={toc:[]};function SAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}SAt.isMDXComponent=!0;const IAt={toc:[]};function PAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PAt.isMDXComponent=!0;const EAt={toc:[]};function BAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}BAt.isMDXComponent=!0;const GAt={toc:[]};function OAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}OAt.isMDXComponent=!0;const FAt={toc:[]};function UAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}UAt.isMDXComponent=!0;const qAt={toc:[]};function VAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}VAt.isMDXComponent=!0;const jAt={toc:[]};function QAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}QAt.isMDXComponent=!0;const HAt={toc:[]};function $At(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$At.isMDXComponent=!0;const YAt={toc:[]};function KAt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}KAt.isMDXComponent=!0;const JAt={toc:[]};function tWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}tWt.isMDXComponent=!0;const nWt={toc:[]};function eWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eWt.isMDXComponent=!0;const oWt={toc:[]};function pWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pWt.isMDXComponent=!0;const rWt={toc:[]};function sWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}sWt.isMDXComponent=!0;const cWt={toc:[]};function iWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}iWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}hWt.isMDXComponent=!0;const kWt={toc:[]};function yWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}yWt.isMDXComponent=!0;const fWt={toc:[]};function MWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}MWt.isMDXComponent=!0;const DWt={toc:[]};function _Wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}_Wt.isMDXComponent=!0;const XWt={toc:[]};function wWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}wWt.isMDXComponent=!0;const gWt={toc:[]};function TWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}TWt.isMDXComponent=!0;const xWt={toc:[]};function CWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}CWt.isMDXComponent=!0;const vWt={toc:[]};function LWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LWt.isMDXComponent=!0;const ZWt={toc:[]};function bWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}bWt.isMDXComponent=!0;const NWt={toc:[]};function zWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function WWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}WWt.isMDXComponent=!0;const RWt={toc:[]};function SWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}SWt.isMDXComponent=!0;const IWt={toc:[]};function PWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}PWt.isMDXComponent=!0;const EWt={toc:[]};function BWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BWt.isMDXComponent=!0;const GWt={toc:[]};function OWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}OWt.isMDXComponent=!0;const FWt={toc:[]};function UWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}UWt.isMDXComponent=!0;const qWt={toc:[]};function VWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}VWt.isMDXComponent=!0;const jWt={toc:[]};function QWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}QWt.isMDXComponent=!0;const HWt={toc:[]};function $Wt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$Wt.isMDXComponent=!0;const YWt={toc:[]};function KWt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}KWt.isMDXComponent=!0;const JWt={toc:[]};function tRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}tRt.isMDXComponent=!0;const nRt={toc:[]};function eRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}eRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pRt.isMDXComponent=!0;const rRt={toc:[]};function sRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sRt.isMDXComponent=!0;const cRt={toc:[]};function iRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}iRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}hRt.isMDXComponent=!0;const kRt={toc:[]};function yRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}yRt.isMDXComponent=!0;const fRt={toc:[]};function MRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}MRt.isMDXComponent=!0;const DRt={toc:[]};function _Rt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}_Rt.isMDXComponent=!0;const XRt={toc:[]};function wRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}wRt.isMDXComponent=!0;const gRt={toc:[]};function TRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}TRt.isMDXComponent=!0;const xRt={toc:[]};function CRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}CRt.isMDXComponent=!0;const vRt={toc:[]};function LRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}LRt.isMDXComponent=!0;const ZRt={toc:[]};function bRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}bRt.isMDXComponent=!0;const NRt={toc:[]};function zRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function WRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}WRt.isMDXComponent=!0;const RRt={toc:[]};function SRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}SRt.isMDXComponent=!0;const IRt={toc:[]};function PRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PRt.isMDXComponent=!0;const ERt={toc:[]};function BRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ERt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}BRt.isMDXComponent=!0;const GRt={toc:[]};function ORt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ORt.isMDXComponent=!0;const FRt={toc:[]};function URt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}URt.isMDXComponent=!0;const qRt={toc:[]};function VRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}VRt.isMDXComponent=!0;const jRt={toc:[]};function QRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}QRt.isMDXComponent=!0;const HRt={toc:[]};function $Rt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}$Rt.isMDXComponent=!0;const YRt={toc:[]};function KRt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}KRt.isMDXComponent=!0;const JRt={toc:[]};function tSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}tSt.isMDXComponent=!0;const nSt={toc:[]};function eSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}eSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pSt.isMDXComponent=!0;const rSt={toc:[]};function sSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}sSt.isMDXComponent=!0;const cSt={toc:[]};function iSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}iSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hSt.isMDXComponent=!0;const kSt={toc:[]};function ySt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}ySt.isMDXComponent=!0;const fSt={toc:[]};function MSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}MSt.isMDXComponent=!0;const DSt={toc:[]};function _St(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}_St.isMDXComponent=!0;const XSt={toc:[]};function wSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wSt.isMDXComponent=!0;const gSt={toc:[]};function TSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}TSt.isMDXComponent=!0;const xSt={toc:[]};function CSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}CSt.isMDXComponent=!0;const vSt={toc:[]};function LSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}LSt.isMDXComponent=!0;const ZSt={toc:[]};function bSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}bSt.isMDXComponent=!0;const NSt={toc:[]};function zSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function WSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}WSt.isMDXComponent=!0;const RSt={toc:[]};function SSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}SSt.isMDXComponent=!0;const ISt={toc:[]};function PSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ISt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}PSt.isMDXComponent=!0;const ESt={toc:[]};function BSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ESt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}BSt.isMDXComponent=!0;const GSt={toc:[]};function OSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}OSt.isMDXComponent=!0;const FSt={toc:[]};function USt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}USt.isMDXComponent=!0;const qSt={toc:[]};function VSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}VSt.isMDXComponent=!0;const jSt={toc:[]};function QSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}QSt.isMDXComponent=!0;const HSt={toc:[]};function $St(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$St.isMDXComponent=!0;const YSt={toc:[]};function KSt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}KSt.isMDXComponent=!0;const JSt={toc:[]};function tIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tIt.isMDXComponent=!0;const nIt={toc:[]};function eIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eIt.isMDXComponent=!0;const oIt={toc:[]};function pIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}pIt.isMDXComponent=!0;const rIt={toc:[]};function sIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}sIt.isMDXComponent=!0;const cIt={toc:[]};function iIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}iIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}hIt.isMDXComponent=!0;const kIt={toc:[]};function yIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}yIt.isMDXComponent=!0;const fIt={toc:[]};function MIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}MIt.isMDXComponent=!0;const DIt={toc:[]};function _It(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}_It.isMDXComponent=!0;const XIt={toc:[]};function wIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wIt.isMDXComponent=!0;const gIt={toc:[]};function TIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}TIt.isMDXComponent=!0;const xIt={toc:[]};function CIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}CIt.isMDXComponent=!0;const vIt={toc:[]};function LIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}LIt.isMDXComponent=!0;const ZIt={toc:[]};function bIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}bIt.isMDXComponent=!0;const NIt={toc:[]};function zIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function WIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}WIt.isMDXComponent=!0;const RIt={toc:[]};function SIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}SIt.isMDXComponent=!0;const IIt={toc:[]};function PIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}PIt.isMDXComponent=!0;const EIt={toc:[]};function BIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}BIt.isMDXComponent=!0;const GIt={toc:[]};function OIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}OIt.isMDXComponent=!0;const FIt={toc:[]};function UIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}UIt.isMDXComponent=!0;const qIt={toc:[]};function VIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}VIt.isMDXComponent=!0;const jIt={toc:[]};function QIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}QIt.isMDXComponent=!0;const HIt={toc:[]};function $It(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}$It.isMDXComponent=!0;const YIt={toc:[]};function KIt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}KIt.isMDXComponent=!0;const JIt={toc:[]};function tPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tPt.isMDXComponent=!0;const nPt={toc:[]};function ePt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ePt.isMDXComponent=!0;const oPt={toc:[]};function pPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pPt.isMDXComponent=!0;const rPt={toc:[]};function sPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}sPt.isMDXComponent=!0;const cPt={toc:[]};function iPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}iPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hPt.isMDXComponent=!0;const kPt={toc:[]};function yPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}yPt.isMDXComponent=!0;const fPt={toc:[]};function MPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}MPt.isMDXComponent=!0;const DPt={toc:[]};function _Pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}_Pt.isMDXComponent=!0;const XPt={toc:[]};function wPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wPt.isMDXComponent=!0;const gPt={toc:[]};function TPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}TPt.isMDXComponent=!0;const xPt={toc:[]};function CPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}CPt.isMDXComponent=!0;const vPt={toc:[]};function LPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}LPt.isMDXComponent=!0;const ZPt={toc:[]};function bPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}bPt.isMDXComponent=!0;const NPt={toc:[]};function zPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}zPt.isMDXComponent=!0;const APt={toc:[]};function WPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}WPt.isMDXComponent=!0;const RPt={toc:[]};function SPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}SPt.isMDXComponent=!0;const IPt={toc:[]};function PPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}PPt.isMDXComponent=!0;const EPt={toc:[]};function BPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}BPt.isMDXComponent=!0;const GPt={toc:[]};function OPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}OPt.isMDXComponent=!0;const FPt={toc:[]};function UPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}UPt.isMDXComponent=!0;const qPt={toc:[]};function VPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}VPt.isMDXComponent=!0;const jPt={toc:[]};function QPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}QPt.isMDXComponent=!0;const HPt={toc:[]};function $Pt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}$Pt.isMDXComponent=!0;const YPt={toc:[]};function KPt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}KPt.isMDXComponent=!0;const JPt={toc:[]};function tEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}tEt.isMDXComponent=!0;const nEt={toc:[]};function eEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}eEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pEt.isMDXComponent=!0;const rEt={toc:[]};function sEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}sEt.isMDXComponent=!0;const cEt={toc:[]};function iEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}iEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hEt.isMDXComponent=!0;const kEt={toc:[]};function yEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}yEt.isMDXComponent=!0;const fEt={toc:[]};function MEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}MEt.isMDXComponent=!0;const DEt={toc:[]};function _Et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}_Et.isMDXComponent=!0;const XEt={toc:[]};function wEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wEt.isMDXComponent=!0;const gEt={toc:[]};function TEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}TEt.isMDXComponent=!0;const xEt={toc:[]};function CEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}CEt.isMDXComponent=!0;const vEt={toc:[]};function LEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}LEt.isMDXComponent=!0;const ZEt={toc:[]};function bEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}bEt.isMDXComponent=!0;const NEt={toc:[]};function zEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}zEt.isMDXComponent=!0;const AEt={toc:[]};function WEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}WEt.isMDXComponent=!0;const REt={toc:[]};function SEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},REt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}SEt.isMDXComponent=!0;const IEt={toc:[]};function PEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}PEt.isMDXComponent=!0;const EEt={toc:[]};function BEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}BEt.isMDXComponent=!0;const GEt={toc:[]};function OEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}OEt.isMDXComponent=!0;const FEt={toc:[]};function UEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}UEt.isMDXComponent=!0;const qEt={toc:[]};function VEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}VEt.isMDXComponent=!0;const jEt={toc:[]};function QEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}QEt.isMDXComponent=!0;const HEt={toc:[]};function $Et(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}$Et.isMDXComponent=!0;const YEt={toc:[]};function KEt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}KEt.isMDXComponent=!0;const JEt={toc:[]};function tBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}tBt.isMDXComponent=!0;const nBt={toc:[]};function eBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}eBt.isMDXComponent=!0;const oBt={toc:[]};function pBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pBt.isMDXComponent=!0;const rBt={toc:[]};function sBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}sBt.isMDXComponent=!0;const cBt={toc:[]};function iBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}iBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}hBt.isMDXComponent=!0;const kBt={toc:[]};function yBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}yBt.isMDXComponent=!0;const fBt={toc:[]};function MBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}MBt.isMDXComponent=!0;const DBt={toc:[]};function _Bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_Bt.isMDXComponent=!0;const XBt={toc:[]};function wBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}wBt.isMDXComponent=!0;const gBt={toc:[]};function TBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}TBt.isMDXComponent=!0;const xBt={toc:[]};function CBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}CBt.isMDXComponent=!0;const vBt={toc:[]};function LBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}LBt.isMDXComponent=!0;const ZBt={toc:[]};function bBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}bBt.isMDXComponent=!0;const NBt={toc:[]};function zBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}zBt.isMDXComponent=!0;const ABt={toc:[]};function WBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}WBt.isMDXComponent=!0;const RBt={toc:[]};function SBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}SBt.isMDXComponent=!0;const IBt={toc:[]};function PBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}PBt.isMDXComponent=!0;const EBt={toc:[]};function BBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}BBt.isMDXComponent=!0;const GBt={toc:[]};function OBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}OBt.isMDXComponent=!0;const FBt={toc:[]};function UBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}UBt.isMDXComponent=!0;const qBt={toc:[]};function VBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}VBt.isMDXComponent=!0;const jBt={toc:[]};function QBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}QBt.isMDXComponent=!0;const HBt={toc:[]};function $Bt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}$Bt.isMDXComponent=!0;const YBt={toc:[]};function KBt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}KBt.isMDXComponent=!0;const JBt={toc:[]};function tGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}tGt.isMDXComponent=!0;const nGt={toc:[]};function eGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}eGt.isMDXComponent=!0;const oGt={toc:[]};function pGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pGt.isMDXComponent=!0;const rGt={toc:[]};function sGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}sGt.isMDXComponent=!0;const cGt={toc:[]};function iGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}iGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hGt.isMDXComponent=!0;const kGt={toc:[]};function yGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}yGt.isMDXComponent=!0;const fGt={toc:[]};function MGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}MGt.isMDXComponent=!0;const DGt={toc:[]};function _Gt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}_Gt.isMDXComponent=!0;const XGt={toc:[]};function wGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wGt.isMDXComponent=!0;const gGt={toc:[]};function TGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}TGt.isMDXComponent=!0;const xGt={toc:[]};function CGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}CGt.isMDXComponent=!0;const vGt={toc:[]};function LGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}LGt.isMDXComponent=!0;const ZGt={toc:[]};function bGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bGt.isMDXComponent=!0;const NGt={toc:[]};function zGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function WGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}WGt.isMDXComponent=!0;const RGt={toc:[]};function SGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}SGt.isMDXComponent=!0;const IGt={toc:[]};function PGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}PGt.isMDXComponent=!0;const EGt={toc:[]};function BGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}BGt.isMDXComponent=!0;const GGt={toc:[]};function OGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}OGt.isMDXComponent=!0;const FGt={toc:[]};function UGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}UGt.isMDXComponent=!0;const qGt={toc:[]};function VGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}VGt.isMDXComponent=!0;const jGt={toc:[]};function QGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}QGt.isMDXComponent=!0;const HGt={toc:[]};function $Gt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}$Gt.isMDXComponent=!0;const YGt={toc:[]};function KGt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}KGt.isMDXComponent=!0;const JGt={toc:[]};function tOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}tOt.isMDXComponent=!0;const nOt={toc:[]};function eOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}eOt.isMDXComponent=!0;const oOt={toc:[]};function pOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pOt.isMDXComponent=!0;const rOt={toc:[]};function sOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sOt.isMDXComponent=!0;const cOt={toc:[]};function iOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hOt.isMDXComponent=!0;const kOt={toc:[]};function yOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}yOt.isMDXComponent=!0;const fOt={toc:[]};function MOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}MOt.isMDXComponent=!0;const DOt={toc:[]};function _Ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}_Ot.isMDXComponent=!0;const XOt={toc:[]};function wOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}wOt.isMDXComponent=!0;const gOt={toc:[]};function TOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}TOt.isMDXComponent=!0;const xOt={toc:[]};function COt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}COt.isMDXComponent=!0;const vOt={toc:[]};function LOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LOt.isMDXComponent=!0;const ZOt={toc:[]};function bOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}bOt.isMDXComponent=!0;const NOt={toc:[]};function zOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function WOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}WOt.isMDXComponent=!0;const ROt={toc:[]};function SOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ROt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}SOt.isMDXComponent=!0;const IOt={toc:[]};function POt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}POt.isMDXComponent=!0;const EOt={toc:[]};function BOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}BOt.isMDXComponent=!0;const GOt={toc:[]};function OOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}OOt.isMDXComponent=!0;const FOt={toc:[]};function UOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}UOt.isMDXComponent=!0;const qOt={toc:[]};function VOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}VOt.isMDXComponent=!0;const jOt={toc:[]};function QOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}QOt.isMDXComponent=!0;const HOt={toc:[]};function $Ot(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$Ot.isMDXComponent=!0;const YOt={toc:[]};function KOt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}KOt.isMDXComponent=!0;const JOt={toc:[]};function tFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}tFt.isMDXComponent=!0;const nFt={toc:[]};function eFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}eFt.isMDXComponent=!0;const oFt={toc:[]};function pFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pFt.isMDXComponent=!0;const rFt={toc:[]};function sFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sFt.isMDXComponent=!0;const cFt={toc:[]};function iFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}iFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}hFt.isMDXComponent=!0;const kFt={toc:[]};function yFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}yFt.isMDXComponent=!0;const fFt={toc:[]};function MFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}MFt.isMDXComponent=!0;const DFt={toc:[]};function _Ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}_Ft.isMDXComponent=!0;const XFt={toc:[]};function wFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}wFt.isMDXComponent=!0;const gFt={toc:[]};function TFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}TFt.isMDXComponent=!0;const xFt={toc:[]};function CFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}CFt.isMDXComponent=!0;const vFt={toc:[]};function LFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}LFt.isMDXComponent=!0;const ZFt={toc:[]};function bFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}bFt.isMDXComponent=!0;const NFt={toc:[]};function zFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}zFt.isMDXComponent=!0;const AFt={toc:[]};function WFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}WFt.isMDXComponent=!0;const RFt={toc:[]};function SFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}SFt.isMDXComponent=!0;const IFt={toc:[]};function PFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}PFt.isMDXComponent=!0;const EFt={toc:[]};function BFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}BFt.isMDXComponent=!0;const GFt={toc:[]};function OFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}OFt.isMDXComponent=!0;const FFt={toc:[]};function UFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}UFt.isMDXComponent=!0;const qFt={toc:[]};function VFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}VFt.isMDXComponent=!0;const jFt={toc:[]};function QFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}QFt.isMDXComponent=!0;const HFt={toc:[]};function $Ft(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}$Ft.isMDXComponent=!0;const YFt={toc:[]};function KFt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KFt.isMDXComponent=!0;const JFt={toc:[]};function tUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}tUt.isMDXComponent=!0;const nUt={toc:[]};function eUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eUt.isMDXComponent=!0;const oUt={toc:[]};function pUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pUt.isMDXComponent=!0;const rUt={toc:[]};function sUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}sUt.isMDXComponent=!0;const cUt={toc:[]};function iUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}iUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hUt.isMDXComponent=!0;const kUt={toc:[]};function yUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}yUt.isMDXComponent=!0;const fUt={toc:[]};function MUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}MUt.isMDXComponent=!0;const DUt={toc:[]};function _Ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}_Ut.isMDXComponent=!0;const XUt={toc:[]};function wUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wUt.isMDXComponent=!0;const gUt={toc:[]};function TUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}TUt.isMDXComponent=!0;const xUt={toc:[]};function CUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}CUt.isMDXComponent=!0;const vUt={toc:[]};function LUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LUt.isMDXComponent=!0;const ZUt={toc:[]};function bUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bUt.isMDXComponent=!0;const NUt={toc:[]};function zUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}zUt.isMDXComponent=!0;const AUt={toc:[]};function WUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}WUt.isMDXComponent=!0;const RUt={toc:[]};function SUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}SUt.isMDXComponent=!0;const IUt={toc:[]};function PUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}PUt.isMDXComponent=!0;const EUt={toc:[]};function BUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}BUt.isMDXComponent=!0;const GUt={toc:[]};function OUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}OUt.isMDXComponent=!0;const FUt={toc:[]};function UUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}UUt.isMDXComponent=!0;const qUt={toc:[]};function VUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}VUt.isMDXComponent=!0;const jUt={toc:[]};function QUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}QUt.isMDXComponent=!0;const HUt={toc:[]};function $Ut(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}$Ut.isMDXComponent=!0;const YUt={toc:[]};function KUt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}KUt.isMDXComponent=!0;const JUt={toc:[]};function tqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tqt.isMDXComponent=!0;const nqt={toc:[]};function eqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}eqt.isMDXComponent=!0;const oqt={toc:[]};function pqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pqt.isMDXComponent=!0;const rqt={toc:[]};function sqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sqt.isMDXComponent=!0;const cqt={toc:[]};function iqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}iqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hqt.isMDXComponent=!0;const kqt={toc:[]};function yqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}yqt.isMDXComponent=!0;const fqt={toc:[]};function Mqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Mqt.isMDXComponent=!0;const Dqt={toc:[]};function _qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}_qt.isMDXComponent=!0;const Xqt={toc:[]};function wqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wqt.isMDXComponent=!0;const gqt={toc:[]};function Tqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Tqt.isMDXComponent=!0;const xqt={toc:[]};function Cqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Cqt.isMDXComponent=!0;const vqt={toc:[]};function Lqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Lqt.isMDXComponent=!0;const Zqt={toc:[]};function bqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}bqt.isMDXComponent=!0;const Nqt={toc:[]};function zqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}zqt.isMDXComponent=!0;const Aqt={toc:[]};function Wqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Wqt.isMDXComponent=!0;const Rqt={toc:[]};function Sqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Sqt.isMDXComponent=!0;const Iqt={toc:[]};function Pqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Pqt.isMDXComponent=!0;const Eqt={toc:[]};function Bqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Bqt.isMDXComponent=!0;const Gqt={toc:[]};function Oqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Oqt.isMDXComponent=!0;const Fqt={toc:[]};function Uqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Uqt.isMDXComponent=!0;const qqt={toc:[]};function Vqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Vqt.isMDXComponent=!0;const jqt={toc:[]};function Qqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Qqt.isMDXComponent=!0;const Hqt={toc:[]};function $qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}$qt.isMDXComponent=!0;const Yqt={toc:[]};function Kqt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]};function tVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}tVt.isMDXComponent=!0;const nVt={toc:[]};function eVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}eVt.isMDXComponent=!0;const oVt={toc:[]};function pVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pVt.isMDXComponent=!0;const rVt={toc:[]};function sVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}sVt.isMDXComponent=!0;const cVt={toc:[]};function iVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hVt.isMDXComponent=!0;const kVt={toc:[]};function yVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}yVt.isMDXComponent=!0;const fVt={toc:[]};function MVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}MVt.isMDXComponent=!0;const DVt={toc:[]};function _Vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}_Vt.isMDXComponent=!0;const XVt={toc:[]};function wVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wVt.isMDXComponent=!0;const gVt={toc:[]};function TVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}TVt.isMDXComponent=!0;const xVt={toc:[]};function CVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}CVt.isMDXComponent=!0;const vVt={toc:[]};function LVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}LVt.isMDXComponent=!0;const ZVt={toc:[]};function bVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bVt.isMDXComponent=!0;const NVt={toc:[]};function zVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}zVt.isMDXComponent=!0;const AVt={toc:[]};function WVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}WVt.isMDXComponent=!0;const RVt={toc:[]};function SVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}SVt.isMDXComponent=!0;const IVt={toc:[]};function PVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PVt.isMDXComponent=!0;const EVt={toc:[]};function BVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}BVt.isMDXComponent=!0;const GVt={toc:[]};function OVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}OVt.isMDXComponent=!0;const FVt={toc:[]};function UVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}UVt.isMDXComponent=!0;const qVt={toc:[]};function VVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}VVt.isMDXComponent=!0;const jVt={toc:[]};function QVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}QVt.isMDXComponent=!0;const HVt={toc:[]};function $Vt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}$Vt.isMDXComponent=!0;const YVt={toc:[]};function KVt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}KVt.isMDXComponent=!0;const JVt={toc:[]};function tjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}tjt.isMDXComponent=!0;const njt={toc:[]};function ejt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},njt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ejt.isMDXComponent=!0;const ojt={toc:[]};function pjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ojt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}pjt.isMDXComponent=!0;const rjt={toc:[]};function sjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}sjt.isMDXComponent=!0;const cjt={toc:[]};function ijt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ijt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ajt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ujt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},djt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}hjt.isMDXComponent=!0;const kjt={toc:[]};function yjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}yjt.isMDXComponent=!0;const fjt={toc:[]};function Mjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Mjt.isMDXComponent=!0;const Djt={toc:[]};function _jt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Djt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}_jt.isMDXComponent=!0;const Xjt={toc:[]};function wjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wjt.isMDXComponent=!0;const gjt={toc:[]};function Tjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Tjt.isMDXComponent=!0;const xjt={toc:[]};function Cjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Cjt.isMDXComponent=!0;const vjt={toc:[]};function Ljt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]};function bjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}bjt.isMDXComponent=!0;const Njt={toc:[]};function zjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Njt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}zjt.isMDXComponent=!0;const Ajt={toc:[]};function Wjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ajt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Wjt.isMDXComponent=!0;const Rjt={toc:[]};function Sjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Sjt.isMDXComponent=!0;const Ijt={toc:[]};function Pjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ijt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Pjt.isMDXComponent=!0;const Ejt={toc:[]};function Bjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ejt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Bjt.isMDXComponent=!0;const Gjt={toc:[]};function Ojt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Ojt.isMDXComponent=!0;const Fjt={toc:[]};function Ujt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ujt.isMDXComponent=!0;const qjt={toc:[]};function Vjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Vjt.isMDXComponent=!0;const jjt={toc:[]};function Qjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Qjt.isMDXComponent=!0;const Hjt={toc:[]};function $jt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}$jt.isMDXComponent=!0;const Yjt={toc:[]};function Kjt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]};function tQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}tQt.isMDXComponent=!0;const nQt={toc:[]};function eQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}eQt.isMDXComponent=!0;const oQt={toc:[]};function pQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pQt.isMDXComponent=!0;const rQt={toc:[]};function sQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}sQt.isMDXComponent=!0;const cQt={toc:[]};function iQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}iQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}hQt.isMDXComponent=!0;const kQt={toc:[]};function yQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}yQt.isMDXComponent=!0;const fQt={toc:[]};function MQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}MQt.isMDXComponent=!0;const DQt={toc:[]};function _Qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}_Qt.isMDXComponent=!0;const XQt={toc:[]};function wQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}wQt.isMDXComponent=!0;const gQt={toc:[]};function TQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}TQt.isMDXComponent=!0;const xQt={toc:[]};function CQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}CQt.isMDXComponent=!0;const vQt={toc:[]};function LQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}LQt.isMDXComponent=!0;const ZQt={toc:[]};function bQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}bQt.isMDXComponent=!0;const NQt={toc:[]};function zQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}zQt.isMDXComponent=!0;const AQt={toc:[]};function WQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}WQt.isMDXComponent=!0;const RQt={toc:[]};function SQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}SQt.isMDXComponent=!0;const IQt={toc:[]};function PQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}PQt.isMDXComponent=!0;const EQt={toc:[]};function BQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}BQt.isMDXComponent=!0;const GQt={toc:[]};function OQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}OQt.isMDXComponent=!0;const FQt={toc:[]};function UQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}UQt.isMDXComponent=!0;const qQt={toc:[]};function VQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}VQt.isMDXComponent=!0;const jQt={toc:[]};function QQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}QQt.isMDXComponent=!0;const HQt={toc:[]};function $Qt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}$Qt.isMDXComponent=!0;const YQt={toc:[]};function KQt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}KQt.isMDXComponent=!0;const JQt={toc:[]};function tHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}tHt.isMDXComponent=!0;const nHt={toc:[]};function eHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}eHt.isMDXComponent=!0;const oHt={toc:[]};function pHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pHt.isMDXComponent=!0;const rHt={toc:[]};function sHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}sHt.isMDXComponent=!0;const cHt={toc:[]};function iHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}iHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hHt.isMDXComponent=!0;const kHt={toc:[]};function yHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}yHt.isMDXComponent=!0;const fHt={toc:[]};function MHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MHt.isMDXComponent=!0;const DHt={toc:[]};function _Ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}_Ht.isMDXComponent=!0;const XHt={toc:[]};function wHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}wHt.isMDXComponent=!0;const gHt={toc:[]};function THt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}THt.isMDXComponent=!0;const xHt={toc:[]};function CHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}CHt.isMDXComponent=!0;const vHt={toc:[]};function LHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}LHt.isMDXComponent=!0;const ZHt={toc:[]};function bHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}bHt.isMDXComponent=!0;const NHt={toc:[]};function zHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}zHt.isMDXComponent=!0;const AHt={toc:[]};function WHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}WHt.isMDXComponent=!0;const RHt={toc:[]};function SHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}SHt.isMDXComponent=!0;const IHt={toc:[]};function PHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PHt.isMDXComponent=!0;const EHt={toc:[]};function BHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}BHt.isMDXComponent=!0;const GHt={toc:[]};function OHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}OHt.isMDXComponent=!0;const FHt={toc:[]};function UHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}UHt.isMDXComponent=!0;const qHt={toc:[]};function VHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}VHt.isMDXComponent=!0;const jHt={toc:[]};function QHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}QHt.isMDXComponent=!0;const HHt={toc:[]};function $Ht(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}$Ht.isMDXComponent=!0;const YHt={toc:[]};function KHt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}KHt.isMDXComponent=!0;const JHt={toc:[]};function t$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}t$t.isMDXComponent=!0;const n$t={toc:[]};function e$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}e$t.isMDXComponent=!0;const o$t={toc:[]};function p$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}p$t.isMDXComponent=!0;const r$t={toc:[]};function s$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}s$t.isMDXComponent=!0;const c$t={toc:[]};function i$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}i$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}h$t.isMDXComponent=!0;const k$t={toc:[]};function y$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}y$t.isMDXComponent=!0;const f$t={toc:[]};function M$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}M$t.isMDXComponent=!0;const D$t={toc:[]};function _$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}_$t.isMDXComponent=!0;const X$t={toc:[]};function w$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}w$t.isMDXComponent=!0;const g$t={toc:[]};function T$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}T$t.isMDXComponent=!0;const x$t={toc:[]};function C$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}C$t.isMDXComponent=!0;const v$t={toc:[]};function L$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}L$t.isMDXComponent=!0;const Z$t={toc:[]};function b$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}b$t.isMDXComponent=!0;const N$t={toc:[]};function z$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}z$t.isMDXComponent=!0;const A$t={toc:[]};function W$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}W$t.isMDXComponent=!0;const R$t={toc:[]};function S$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}S$t.isMDXComponent=!0;const I$t={toc:[]};function P$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}P$t.isMDXComponent=!0;const E$t={toc:[]};function B$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}B$t.isMDXComponent=!0;const G$t={toc:[]};function O$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}O$t.isMDXComponent=!0;const F$t={toc:[]};function U$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}U$t.isMDXComponent=!0;const q$t={toc:[]};function V$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}V$t.isMDXComponent=!0;const j$t={toc:[]};function Q$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Q$t.isMDXComponent=!0;const H$t={toc:[]};function $$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}$$t.isMDXComponent=!0;const Y$t={toc:[]};function K$t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}K$t.isMDXComponent=!0;const J$t={toc:[]};function tYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}tYt.isMDXComponent=!0;const nYt={toc:[]};function eYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}eYt.isMDXComponent=!0;const oYt={toc:[]};function pYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}pYt.isMDXComponent=!0;const rYt={toc:[]};function sYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}sYt.isMDXComponent=!0;const cYt={toc:[]};function iYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}iYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}hYt.isMDXComponent=!0;const kYt={toc:[]};function yYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}yYt.isMDXComponent=!0;const fYt={toc:[]};function MYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}MYt.isMDXComponent=!0;const DYt={toc:[]};function _Yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_Yt.isMDXComponent=!0;const XYt={toc:[]};function wYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wYt.isMDXComponent=!0;const gYt={toc:[]};function TYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}TYt.isMDXComponent=!0;const xYt={toc:[]};function CYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}CYt.isMDXComponent=!0;const vYt={toc:[]};function LYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}LYt.isMDXComponent=!0;const ZYt={toc:[]};function bYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}bYt.isMDXComponent=!0;const NYt={toc:[]};function zYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}zYt.isMDXComponent=!0;const AYt={toc:[]};function WYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WYt.isMDXComponent=!0;const RYt={toc:[]};function SYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}SYt.isMDXComponent=!0;const IYt={toc:[]};function PYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}PYt.isMDXComponent=!0;const EYt={toc:[]};function BYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}BYt.isMDXComponent=!0;const GYt={toc:[]};function OYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}OYt.isMDXComponent=!0;const FYt={toc:[]};function UYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}UYt.isMDXComponent=!0;const qYt={toc:[]};function VYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}VYt.isMDXComponent=!0;const jYt={toc:[]};function QYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}QYt.isMDXComponent=!0;const HYt={toc:[]};function $Yt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}$Yt.isMDXComponent=!0;const YYt={toc:[]};function KYt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}KYt.isMDXComponent=!0;const JYt={toc:[]};function tKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}tKt.isMDXComponent=!0;const nKt={toc:[]};function eKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}eKt.isMDXComponent=!0;const oKt={toc:[]};function pKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}pKt.isMDXComponent=!0;const rKt={toc:[]};function sKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}sKt.isMDXComponent=!0;const cKt={toc:[]};function iKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}iKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}hKt.isMDXComponent=!0;const kKt={toc:[]};function yKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}yKt.isMDXComponent=!0;const fKt={toc:[]};function MKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}MKt.isMDXComponent=!0;const DKt={toc:[]};function _Kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}_Kt.isMDXComponent=!0;const XKt={toc:[]};function wKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}wKt.isMDXComponent=!0;const gKt={toc:[]};function TKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}TKt.isMDXComponent=!0;const xKt={toc:[]};function CKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}CKt.isMDXComponent=!0;const vKt={toc:[]};function LKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LKt.isMDXComponent=!0;const ZKt={toc:[]};function bKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bKt.isMDXComponent=!0;const NKt={toc:[]};function zKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}zKt.isMDXComponent=!0;const AKt={toc:[]};function WKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}WKt.isMDXComponent=!0;const RKt={toc:[]};function SKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}SKt.isMDXComponent=!0;const IKt={toc:[]};function PKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}PKt.isMDXComponent=!0;const EKt={toc:[]};function BKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}BKt.isMDXComponent=!0;const GKt={toc:[]};function OKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}OKt.isMDXComponent=!0;const FKt={toc:[]};function UKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}UKt.isMDXComponent=!0;const qKt={toc:[]};function VKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}VKt.isMDXComponent=!0;const jKt={toc:[]};function QKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}QKt.isMDXComponent=!0;const HKt={toc:[]};function $Kt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}$Kt.isMDXComponent=!0;const YKt={toc:[]};function KKt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}KKt.isMDXComponent=!0;const JKt={toc:[]};function tJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}tJt.isMDXComponent=!0;const nJt={toc:[]};function eJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}eJt.isMDXComponent=!0;const oJt={toc:[]};function pJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pJt.isMDXComponent=!0;const rJt={toc:[]};function sJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}sJt.isMDXComponent=!0;const cJt={toc:[]};function iJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}iJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}hJt.isMDXComponent=!0;const kJt={toc:[]};function yJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}yJt.isMDXComponent=!0;const fJt={toc:[]};function MJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}MJt.isMDXComponent=!0;const DJt={toc:[]};function _Jt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}_Jt.isMDXComponent=!0;const XJt={toc:[]};function wJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wJt.isMDXComponent=!0;const gJt={toc:[]};function TJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}TJt.isMDXComponent=!0;const xJt={toc:[]};function CJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}CJt.isMDXComponent=!0;const vJt={toc:[]};function LJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}LJt.isMDXComponent=!0;const ZJt={toc:[]};function bJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}bJt.isMDXComponent=!0;const NJt={toc:[]};function zJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zJt.isMDXComponent=!0;const AJt={toc:[]};function WJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}WJt.isMDXComponent=!0;const RJt={toc:[]};function SJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}SJt.isMDXComponent=!0;const IJt={toc:[]};function PJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}PJt.isMDXComponent=!0;const EJt={toc:[]};function BJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}BJt.isMDXComponent=!0;const GJt={toc:[]};function OJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}OJt.isMDXComponent=!0;const FJt={toc:[]};function UJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}UJt.isMDXComponent=!0;const qJt={toc:[]};function VJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}VJt.isMDXComponent=!0;const jJt={toc:[]};function QJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}QJt.isMDXComponent=!0;const HJt={toc:[]};function $Jt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}$Jt.isMDXComponent=!0;const YJt={toc:[]};function KJt(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}KJt.isMDXComponent=!0;const JJt={toc:[]};function t0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}t0t.isMDXComponent=!0;const n0t={toc:[]};function e0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}e0t.isMDXComponent=!0;const o0t={toc:[]};function p0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}p0t.isMDXComponent=!0;const r0t={toc:[]};function s0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}s0t.isMDXComponent=!0;const c0t={toc:[]};function i0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}i0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}h0t.isMDXComponent=!0;const k0t={toc:[]};function y0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}y0t.isMDXComponent=!0;const f0t={toc:[]};function M0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}M0t.isMDXComponent=!0;const D0t={toc:[]};function _0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}_0t.isMDXComponent=!0;const X0t={toc:[]};function w0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}w0t.isMDXComponent=!0;const g0t={toc:[]};function T0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}T0t.isMDXComponent=!0;const x0t={toc:[]};function C0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}C0t.isMDXComponent=!0;const v0t={toc:[]};function L0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}L0t.isMDXComponent=!0;const Z0t={toc:[]};function b0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}b0t.isMDXComponent=!0;const N0t={toc:[]};function z0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}z0t.isMDXComponent=!0;const A0t={toc:[]};function W0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}W0t.isMDXComponent=!0;const R0t={toc:[]};function S0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}S0t.isMDXComponent=!0;const I0t={toc:[]};function P0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}P0t.isMDXComponent=!0;const E0t={toc:[]};function B0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}B0t.isMDXComponent=!0;const G0t={toc:[]};function O0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}O0t.isMDXComponent=!0;const F0t={toc:[]};function U0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}U0t.isMDXComponent=!0;const q0t={toc:[]};function V0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}V0t.isMDXComponent=!0;const j0t={toc:[]};function Q0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Q0t.isMDXComponent=!0;const H0t={toc:[]};function $0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}$0t.isMDXComponent=!0;const Y0t={toc:[]};function K0t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}K0t.isMDXComponent=!0;const J0t={toc:[]};function t4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}t4t.isMDXComponent=!0;const n4t={toc:[]};function e4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}e4t.isMDXComponent=!0;const o4t={toc:[]};function p4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}p4t.isMDXComponent=!0;const r4t={toc:[]};function s4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}s4t.isMDXComponent=!0;const c4t={toc:[]};function i4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}i4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}h4t.isMDXComponent=!0;const k4t={toc:[]};function y4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}y4t.isMDXComponent=!0;const f4t={toc:[]};function M4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}M4t.isMDXComponent=!0;const D4t={toc:[]};function _4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_4t.isMDXComponent=!0;const X4t={toc:[]};function w4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}w4t.isMDXComponent=!0;const g4t={toc:[]};function T4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}T4t.isMDXComponent=!0;const x4t={toc:[]};function C4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}C4t.isMDXComponent=!0;const v4t={toc:[]};function L4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}L4t.isMDXComponent=!0;const Z4t={toc:[]};function b4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}b4t.isMDXComponent=!0;const N4t={toc:[]};function z4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}z4t.isMDXComponent=!0;const A4t={toc:[]};function W4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}W4t.isMDXComponent=!0;const R4t={toc:[]};function S4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}S4t.isMDXComponent=!0;const I4t={toc:[]};function P4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}P4t.isMDXComponent=!0;const E4t={toc:[]};function B4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}B4t.isMDXComponent=!0;const G4t={toc:[]};function O4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}O4t.isMDXComponent=!0;const F4t={toc:[]};function U4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}U4t.isMDXComponent=!0;const q4t={toc:[]};function V4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}V4t.isMDXComponent=!0;const j4t={toc:[]};function Q4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Q4t.isMDXComponent=!0;const H4t={toc:[]};function $4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$4t.isMDXComponent=!0;const Y4t={toc:[]};function K4t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}K4t.isMDXComponent=!0;const J4t={toc:[]};function t8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}t8t.isMDXComponent=!0;const n8t={toc:[]};function e8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}e8t.isMDXComponent=!0;const o8t={toc:[]};function p8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}p8t.isMDXComponent=!0;const r8t={toc:[]};function s8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}s8t.isMDXComponent=!0;const c8t={toc:[]};function i8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}i8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}h8t.isMDXComponent=!0;const k8t={toc:[]};function y8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}y8t.isMDXComponent=!0;const f8t={toc:[]};function M8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}M8t.isMDXComponent=!0;const D8t={toc:[]};function _8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}_8t.isMDXComponent=!0;const X8t={toc:[]};function w8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}w8t.isMDXComponent=!0;const g8t={toc:[]};function T8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}T8t.isMDXComponent=!0;const x8t={toc:[]};function C8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}C8t.isMDXComponent=!0;const v8t={toc:[]};function L8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}L8t.isMDXComponent=!0;const Z8t={toc:[]};function b8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}b8t.isMDXComponent=!0;const N8t={toc:[]};function z8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}z8t.isMDXComponent=!0;const A8t={toc:[]};function W8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}W8t.isMDXComponent=!0;const R8t={toc:[]};function S8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}S8t.isMDXComponent=!0;const I8t={toc:[]};function P8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}P8t.isMDXComponent=!0;const E8t={toc:[]};function B8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}B8t.isMDXComponent=!0;const G8t={toc:[]};function O8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}O8t.isMDXComponent=!0;const F8t={toc:[]};function U8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}U8t.isMDXComponent=!0;const q8t={toc:[]};function V8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}V8t.isMDXComponent=!0;const j8t={toc:[]};function Q8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Q8t.isMDXComponent=!0;const H8t={toc:[]};function $8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}$8t.isMDXComponent=!0;const Y8t={toc:[]};function K8t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}K8t.isMDXComponent=!0;const J8t={toc:[]};function t3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}t3t.isMDXComponent=!0;const n3t={toc:[]};function e3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}e3t.isMDXComponent=!0;const o3t={toc:[]};function p3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}p3t.isMDXComponent=!0;const r3t={toc:[]};function s3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}s3t.isMDXComponent=!0;const c3t={toc:[]};function i3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}i3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}h3t.isMDXComponent=!0;const k3t={toc:[]};function y3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}y3t.isMDXComponent=!0;const f3t={toc:[]};function M3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}M3t.isMDXComponent=!0;const D3t={toc:[]};function _3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}_3t.isMDXComponent=!0;const X3t={toc:[]};function w3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}w3t.isMDXComponent=!0;const g3t={toc:[]};function T3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}T3t.isMDXComponent=!0;const x3t={toc:[]};function C3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}C3t.isMDXComponent=!0;const v3t={toc:[]};function L3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}L3t.isMDXComponent=!0;const Z3t={toc:[]};function b3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}b3t.isMDXComponent=!0;const N3t={toc:[]};function z3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}z3t.isMDXComponent=!0;const A3t={toc:[]};function W3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}W3t.isMDXComponent=!0;const R3t={toc:[]};function S3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}S3t.isMDXComponent=!0;const I3t={toc:[]};function P3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}P3t.isMDXComponent=!0;const E3t={toc:[]};function B3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}B3t.isMDXComponent=!0;const G3t={toc:[]};function O3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}O3t.isMDXComponent=!0;const F3t={toc:[]};function U3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}U3t.isMDXComponent=!0;const q3t={toc:[]};function V3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}V3t.isMDXComponent=!0;const j3t={toc:[]};function Q3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Q3t.isMDXComponent=!0;const H3t={toc:[]};function $3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}$3t.isMDXComponent=!0;const Y3t={toc:[]};function K3t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}K3t.isMDXComponent=!0;const J3t={toc:[]};function t9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}t9t.isMDXComponent=!0;const n9t={toc:[]};function e9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}e9t.isMDXComponent=!0;const o9t={toc:[]};function p9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}p9t.isMDXComponent=!0;const r9t={toc:[]};function s9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}s9t.isMDXComponent=!0;const c9t={toc:[]};function i9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}i9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}h9t.isMDXComponent=!0;const k9t={toc:[]};function y9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}y9t.isMDXComponent=!0;const f9t={toc:[]};function M9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}M9t.isMDXComponent=!0;const D9t={toc:[]};function _9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}_9t.isMDXComponent=!0;const X9t={toc:[]};function w9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}w9t.isMDXComponent=!0;const g9t={toc:[]};function T9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}T9t.isMDXComponent=!0;const x9t={toc:[]};function C9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}C9t.isMDXComponent=!0;const v9t={toc:[]};function L9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}L9t.isMDXComponent=!0;const Z9t={toc:[]};function b9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}b9t.isMDXComponent=!0;const N9t={toc:[]};function z9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}z9t.isMDXComponent=!0;const A9t={toc:[]};function W9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}W9t.isMDXComponent=!0;const R9t={toc:[]};function S9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}S9t.isMDXComponent=!0;const I9t={toc:[]};function P9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}P9t.isMDXComponent=!0;const E9t={toc:[]};function B9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}B9t.isMDXComponent=!0;const G9t={toc:[]};function O9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}O9t.isMDXComponent=!0;const F9t={toc:[]};function U9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}U9t.isMDXComponent=!0;const q9t={toc:[]};function V9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}V9t.isMDXComponent=!0;const j9t={toc:[]};function Q9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Q9t.isMDXComponent=!0;const H9t={toc:[]};function $9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}$9t.isMDXComponent=!0;const Y9t={toc:[]};function K9t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}K9t.isMDXComponent=!0;const J9t={toc:[]};function t2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}t2t.isMDXComponent=!0;const n2t={toc:[]};function e2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}e2t.isMDXComponent=!0;const o2t={toc:[]};function p2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}p2t.isMDXComponent=!0;const r2t={toc:[]};function s2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}s2t.isMDXComponent=!0;const c2t={toc:[]};function i2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}i2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}h2t.isMDXComponent=!0;const k2t={toc:[]};function y2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}y2t.isMDXComponent=!0;const f2t={toc:[]};function M2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}M2t.isMDXComponent=!0;const D2t={toc:[]};function _2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}_2t.isMDXComponent=!0;const X2t={toc:[]};function w2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}w2t.isMDXComponent=!0;const g2t={toc:[]};function T2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}T2t.isMDXComponent=!0;const x2t={toc:[]};function C2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}C2t.isMDXComponent=!0;const v2t={toc:[]};function L2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}L2t.isMDXComponent=!0;const Z2t={toc:[]};function b2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}b2t.isMDXComponent=!0;const N2t={toc:[]};function z2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}z2t.isMDXComponent=!0;const A2t={toc:[]};function W2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}W2t.isMDXComponent=!0;const R2t={toc:[]};function S2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}S2t.isMDXComponent=!0;const I2t={toc:[]};function P2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}P2t.isMDXComponent=!0;const E2t={toc:[]};function B2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}B2t.isMDXComponent=!0;const G2t={toc:[]};function O2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}O2t.isMDXComponent=!0;const F2t={toc:[]};function U2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}U2t.isMDXComponent=!0;const q2t={toc:[]};function V2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}V2t.isMDXComponent=!0;const j2t={toc:[]};function Q2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Q2t.isMDXComponent=!0;const H2t={toc:[]};function $2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}$2t.isMDXComponent=!0;const Y2t={toc:[]};function K2t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}K2t.isMDXComponent=!0;const J2t={toc:[]};function t1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}t1t.isMDXComponent=!0;const n1t={toc:[]};function e1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}e1t.isMDXComponent=!0;const o1t={toc:[]};function p1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}p1t.isMDXComponent=!0;const r1t={toc:[]};function s1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}s1t.isMDXComponent=!0;const c1t={toc:[]};function i1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}i1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}h1t.isMDXComponent=!0;const k1t={toc:[]};function y1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}y1t.isMDXComponent=!0;const f1t={toc:[]};function M1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}M1t.isMDXComponent=!0;const D1t={toc:[]};function _1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}_1t.isMDXComponent=!0;const X1t={toc:[]};function w1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}w1t.isMDXComponent=!0;const g1t={toc:[]};function T1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}T1t.isMDXComponent=!0;const x1t={toc:[]};function C1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}C1t.isMDXComponent=!0;const v1t={toc:[]};function L1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}L1t.isMDXComponent=!0;const Z1t={toc:[]};function b1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}b1t.isMDXComponent=!0;const N1t={toc:[]};function z1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}z1t.isMDXComponent=!0;const A1t={toc:[]};function W1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}W1t.isMDXComponent=!0;const R1t={toc:[]};function S1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}S1t.isMDXComponent=!0;const I1t={toc:[]};function P1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}P1t.isMDXComponent=!0;const E1t={toc:[]};function B1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}B1t.isMDXComponent=!0;const G1t={toc:[]};function O1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}O1t.isMDXComponent=!0;const F1t={toc:[]};function U1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}U1t.isMDXComponent=!0;const q1t={toc:[]};function V1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}V1t.isMDXComponent=!0;const j1t={toc:[]};function Q1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Q1t.isMDXComponent=!0;const H1t={toc:[]};function $1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}$1t.isMDXComponent=!0;const Y1t={toc:[]};function K1t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}K1t.isMDXComponent=!0;const J1t={toc:[]};function t6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}t6t.isMDXComponent=!0;const n6t={toc:[]};function e6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}e6t.isMDXComponent=!0;const o6t={toc:[]};function p6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}p6t.isMDXComponent=!0;const r6t={toc:[]};function s6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}s6t.isMDXComponent=!0;const c6t={toc:[]};function i6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}i6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}h6t.isMDXComponent=!0;const k6t={toc:[]};function y6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}y6t.isMDXComponent=!0;const f6t={toc:[]};function M6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}M6t.isMDXComponent=!0;const D6t={toc:[]};function _6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}_6t.isMDXComponent=!0;const X6t={toc:[]};function w6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}w6t.isMDXComponent=!0;const g6t={toc:[]};function T6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}T6t.isMDXComponent=!0;const x6t={toc:[]};function C6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}C6t.isMDXComponent=!0;const v6t={toc:[]};function L6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}L6t.isMDXComponent=!0;const Z6t={toc:[]};function b6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}b6t.isMDXComponent=!0;const N6t={toc:[]};function z6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}z6t.isMDXComponent=!0;const A6t={toc:[]};function W6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}W6t.isMDXComponent=!0;const R6t={toc:[]};function S6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}S6t.isMDXComponent=!0;const I6t={toc:[]};function P6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}P6t.isMDXComponent=!0;const E6t={toc:[]};function B6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}B6t.isMDXComponent=!0;const G6t={toc:[]};function O6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}O6t.isMDXComponent=!0;const F6t={toc:[]};function U6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}U6t.isMDXComponent=!0;const q6t={toc:[]};function V6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}V6t.isMDXComponent=!0;const j6t={toc:[]};function Q6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Q6t.isMDXComponent=!0;const H6t={toc:[]};function $6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}$6t.isMDXComponent=!0;const Y6t={toc:[]};function K6t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}K6t.isMDXComponent=!0;const J6t={toc:[]};function t5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}t5t.isMDXComponent=!0;const n5t={toc:[]};function e5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}e5t.isMDXComponent=!0;const o5t={toc:[]};function p5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}p5t.isMDXComponent=!0;const r5t={toc:[]};function s5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}s5t.isMDXComponent=!0;const c5t={toc:[]};function i5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}i5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}h5t.isMDXComponent=!0;const k5t={toc:[]};function y5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}y5t.isMDXComponent=!0;const f5t={toc:[]};function M5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}M5t.isMDXComponent=!0;const D5t={toc:[]};function _5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_5t.isMDXComponent=!0;const X5t={toc:[]};function w5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}w5t.isMDXComponent=!0;const g5t={toc:[]};function T5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}T5t.isMDXComponent=!0;const x5t={toc:[]};function C5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}C5t.isMDXComponent=!0;const v5t={toc:[]};function L5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}L5t.isMDXComponent=!0;const Z5t={toc:[]};function b5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}b5t.isMDXComponent=!0;const N5t={toc:[]};function z5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}z5t.isMDXComponent=!0;const A5t={toc:[]};function W5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}W5t.isMDXComponent=!0;const R5t={toc:[]};function S5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}S5t.isMDXComponent=!0;const I5t={toc:[]};function P5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}P5t.isMDXComponent=!0;const E5t={toc:[]};function B5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}B5t.isMDXComponent=!0;const G5t={toc:[]};function O5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}O5t.isMDXComponent=!0;const F5t={toc:[]};function U5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}U5t.isMDXComponent=!0;const q5t={toc:[]};function V5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}V5t.isMDXComponent=!0;const j5t={toc:[]};function Q5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Q5t.isMDXComponent=!0;const H5t={toc:[]};function $5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}$5t.isMDXComponent=!0;const Y5t={toc:[]};function K5t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}K5t.isMDXComponent=!0;const J5t={toc:[]};function t7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}t7t.isMDXComponent=!0;const n7t={toc:[]};function e7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}e7t.isMDXComponent=!0;const o7t={toc:[]};function p7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}p7t.isMDXComponent=!0;const r7t={toc:[]};function s7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}s7t.isMDXComponent=!0;const c7t={toc:[]};function i7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}i7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}h7t.isMDXComponent=!0;const k7t={toc:[]};function y7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}y7t.isMDXComponent=!0;const f7t={toc:[]};function M7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}M7t.isMDXComponent=!0;const D7t={toc:[]};function _7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}_7t.isMDXComponent=!0;const X7t={toc:[]};function w7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}w7t.isMDXComponent=!0;const g7t={toc:[]};function T7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}T7t.isMDXComponent=!0;const x7t={toc:[]};function C7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}C7t.isMDXComponent=!0;const v7t={toc:[]};function L7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}L7t.isMDXComponent=!0;const Z7t={toc:[]};function b7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}b7t.isMDXComponent=!0;const N7t={toc:[]};function z7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}z7t.isMDXComponent=!0;const A7t={toc:[]};function W7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}W7t.isMDXComponent=!0;const R7t={toc:[]};function S7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}S7t.isMDXComponent=!0;const I7t={toc:[]};function P7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}P7t.isMDXComponent=!0;const E7t={toc:[]};function B7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}B7t.isMDXComponent=!0;const G7t={toc:[]};function O7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}O7t.isMDXComponent=!0;const F7t={toc:[]};function U7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}U7t.isMDXComponent=!0;const q7t={toc:[]};function V7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}V7t.isMDXComponent=!0;const j7t={toc:[]};function Q7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Q7t.isMDXComponent=!0;const H7t={toc:[]};function $7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}$7t.isMDXComponent=!0;const Y7t={toc:[]};function K7t(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}K7t.isMDXComponent=!0;const J7t={toc:[]};function ttn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ttn.isMDXComponent=!0;const ntn={toc:[]};function etn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ntn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}etn.isMDXComponent=!0;const otn={toc:[]};function ptn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},otn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}ptn.isMDXComponent=!0;const rtn={toc:[]};function stn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}stn.isMDXComponent=!0;const ctn={toc:[]};function itn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ctn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}itn.isMDXComponent=!0;const atn={toc:[]};function ltn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},atn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ltn.isMDXComponent=!0;const utn={toc:[]};function mtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},utn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mtn.isMDXComponent=!0;const dtn={toc:[]};function htn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}htn.isMDXComponent=!0;const ktn={toc:[]};function ytn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ktn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ytn.isMDXComponent=!0;const ftn={toc:[]};function Mtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ftn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Mtn.isMDXComponent=!0;const Dtn={toc:[]};function _tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_tn.isMDXComponent=!0;const Xtn={toc:[]};function wtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}wtn.isMDXComponent=!0;const gtn={toc:[]};function Ttn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Ttn.isMDXComponent=!0;const xtn={toc:[]};function Ctn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Ctn.isMDXComponent=!0;const vtn={toc:[]};function Ltn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ltn.isMDXComponent=!0;const Ztn={toc:[]};function btn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ztn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}btn.isMDXComponent=!0;const Ntn={toc:[]};function ztn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ntn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}ztn.isMDXComponent=!0;const Atn={toc:[]};function Wtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Atn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}Wtn.isMDXComponent=!0;const Rtn={toc:[]};function Stn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Stn.isMDXComponent=!0;const Itn={toc:[]};function Ptn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Itn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ptn.isMDXComponent=!0;const Etn={toc:[]};function Btn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Etn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Btn.isMDXComponent=!0;const Gtn={toc:[]};function Otn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Otn.isMDXComponent=!0;const Ftn={toc:[]};function Utn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ftn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Utn.isMDXComponent=!0;const qtn={toc:[]};function Vtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Vtn.isMDXComponent=!0;const jtn={toc:[]};function Qtn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Qtn.isMDXComponent=!0;const Htn={toc:[]};function $tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Htn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}$tn.isMDXComponent=!0;const Ytn={toc:[]};function Ktn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ytn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]};function tnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}tnn.isMDXComponent=!0;const nnn={toc:[]};function enn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}enn.isMDXComponent=!0;const onn={toc:[]};function pnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},onn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}pnn.isMDXComponent=!0;const rnn={toc:[]};function snn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}snn.isMDXComponent=!0;const cnn={toc:[]};function inn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}inn.isMDXComponent=!0;const ann={toc:[]};function lnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ann,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lnn.isMDXComponent=!0;const unn={toc:[]};function mnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}mnn.isMDXComponent=!0;const dnn={toc:[]};function hnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}hnn.isMDXComponent=!0;const knn={toc:[]};function ynn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},knn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ynn.isMDXComponent=!0;const fnn={toc:[]};function Mnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Mnn.isMDXComponent=!0;const Dnn={toc:[]};function _nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_nn.isMDXComponent=!0;const Xnn={toc:[]};function wnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wnn.isMDXComponent=!0;const gnn={toc:[]};function Tnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Tnn.isMDXComponent=!0;const xnn={toc:[]};function Cnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Cnn.isMDXComponent=!0;const vnn={toc:[]};function Lnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Lnn.isMDXComponent=!0;const Znn={toc:[]};function bnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}bnn.isMDXComponent=!0;const Nnn={toc:[]};function znn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}znn.isMDXComponent=!0;const Ann={toc:[]};function Wnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ann,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Wnn.isMDXComponent=!0;const Rnn={toc:[]};function Snn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Snn.isMDXComponent=!0;const Inn={toc:[]};function Pnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Inn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Pnn.isMDXComponent=!0;const Enn={toc:[]};function Bnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Enn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}Bnn.isMDXComponent=!0;const Gnn={toc:[]};function Onn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}Onn.isMDXComponent=!0;const Fnn={toc:[]};function Unn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}Unn.isMDXComponent=!0;const qnn={toc:[]};function Vnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Vnn.isMDXComponent=!0;const jnn={toc:[]};function Qnn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Qnn.isMDXComponent=!0;const Hnn={toc:[]};function $nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}$nn.isMDXComponent=!0;const Ynn={toc:[]};function Knn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ynn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Knn.isMDXComponent=!0;const Jnn={toc:[]};function ten(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ten.isMDXComponent=!0;const nen={toc:[]};function een(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}een.isMDXComponent=!0;const oen={toc:[]};function pen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}pen.isMDXComponent=!0;const ren={toc:[]};function sen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ren,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sen.isMDXComponent=!0;const cen={toc:[]};function ien(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}ien.isMDXComponent=!0;const aen={toc:[]};function len(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}len.isMDXComponent=!0;const uen={toc:[]};function men(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}men.isMDXComponent=!0;const den={toc:[]};function hen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},den,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}hen.isMDXComponent=!0;const ken={toc:[]};function yen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ken,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}yen.isMDXComponent=!0;const fen={toc:[]};function Men(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Men.isMDXComponent=!0;const Den={toc:[]};function _en(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Den,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}_en.isMDXComponent=!0;const Xen={toc:[]};function wen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wen.isMDXComponent=!0;const gen={toc:[]};function Ten(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Ten.isMDXComponent=!0;const xen={toc:[]};function Cen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Cen.isMDXComponent=!0;const ven={toc:[]};function Len(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ven,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Len.isMDXComponent=!0;const Zen={toc:[]};function ben(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}ben.isMDXComponent=!0;const Nen={toc:[]};function zen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}zen.isMDXComponent=!0;const Aen={toc:[]};function Wen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Wen.isMDXComponent=!0;const Ren={toc:[]};function Sen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ren,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Sen.isMDXComponent=!0;const Ien={toc:[]};function Pen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ien,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Pen.isMDXComponent=!0;const Een={toc:[]};function Ben(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Een,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Ben.isMDXComponent=!0;const Gen={toc:[]};function Oen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Oen.isMDXComponent=!0;const Fen={toc:[]};function Uen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Uen.isMDXComponent=!0;const qen={toc:[]};function Ven(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Ven.isMDXComponent=!0;const jen={toc:[]};function Qen(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Qen.isMDXComponent=!0;const Hen={toc:[]};function $en(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}$en.isMDXComponent=!0;const Yen={toc:[]};function Ken(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Ken.isMDXComponent=!0;const Jen={toc:[]};function ton(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ton.isMDXComponent=!0;const non={toc:[]};function eon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},non,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}eon.isMDXComponent=!0;const oon={toc:[]};function pon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}pon.isMDXComponent=!0;const ron={toc:[]};function son(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ron,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}son.isMDXComponent=!0;const con={toc:[]};function ion(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},con,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}ion.isMDXComponent=!0;const aon={toc:[]};function lon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lon.isMDXComponent=!0;const uon={toc:[]};function mon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}mon.isMDXComponent=!0;const don={toc:[]};function hon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},don,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}hon.isMDXComponent=!0;const kon={toc:[]};function yon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}yon.isMDXComponent=!0;const fon={toc:[]};function Mon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Mon.isMDXComponent=!0;const Don={toc:[]};function _on(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Don,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}_on.isMDXComponent=!0;const Xon={toc:[]};function won(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}won.isMDXComponent=!0;const gon={toc:[]};function Ton(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Ton.isMDXComponent=!0;const xon={toc:[]};function Con(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Con.isMDXComponent=!0;const von={toc:[]};function Lon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},von,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Lon.isMDXComponent=!0;const Zon={toc:[]};function bon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}bon.isMDXComponent=!0;const Non={toc:[]};function zon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Non,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}zon.isMDXComponent=!0;const Aon={toc:[]};function Won(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Won.isMDXComponent=!0;const Ron={toc:[]};function Son(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ron,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Son.isMDXComponent=!0;const Ion={toc:[]};function Pon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ion,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Pon.isMDXComponent=!0;const Eon={toc:[]};function Bon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Bon.isMDXComponent=!0;const Gon={toc:[]};function Oon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Oon.isMDXComponent=!0;const Fon={toc:[]};function Uon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Uon.isMDXComponent=!0;const qon={toc:[]};function Von(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Von.isMDXComponent=!0;const jon={toc:[]};function Qon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Qon.isMDXComponent=!0;const Hon={toc:[]};function $on(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}$on.isMDXComponent=!0;const Yon={toc:[]};function Kon(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Kon.isMDXComponent=!0;const Jon={toc:[]};function tpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}tpn.isMDXComponent=!0;const npn={toc:[]};function epn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},npn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}epn.isMDXComponent=!0;const opn={toc:[]};function ppn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ppn.isMDXComponent=!0;const rpn={toc:[]};function spn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}spn.isMDXComponent=!0;const cpn={toc:[]};function ipn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ipn.isMDXComponent=!0;const apn={toc:[]};function lpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}lpn.isMDXComponent=!0;const upn={toc:[]};function mpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}mpn.isMDXComponent=!0;const dpn={toc:[]};function hpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}hpn.isMDXComponent=!0;const kpn={toc:[]};function ypn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ypn.isMDXComponent=!0;const fpn={toc:[]};function Mpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Mpn.isMDXComponent=!0;const Dpn={toc:[]};function _pn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}_pn.isMDXComponent=!0;const Xpn={toc:[]};function wpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}wpn.isMDXComponent=!0;const gpn={toc:[]};function Tpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Tpn.isMDXComponent=!0;const xpn={toc:[]};function Cpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Cpn.isMDXComponent=!0;const vpn={toc:[]};function Lpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Lpn.isMDXComponent=!0;const Zpn={toc:[]};function bpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}bpn.isMDXComponent=!0;const Npn={toc:[]};function zpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}zpn.isMDXComponent=!0;const Apn={toc:[]};function Wpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wpn.isMDXComponent=!0;const Rpn={toc:[]};function Spn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Spn.isMDXComponent=!0;const Ipn={toc:[]};function Ppn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ipn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ppn.isMDXComponent=!0;const Epn={toc:[]};function Bpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Epn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Bpn.isMDXComponent=!0;const Gpn={toc:[]};function Opn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Opn.isMDXComponent=!0;const Fpn={toc:[]};function Upn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Upn.isMDXComponent=!0;const qpn={toc:[]};function Vpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Vpn.isMDXComponent=!0;const jpn={toc:[]};function Qpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Qpn.isMDXComponent=!0;const Hpn={toc:[]};function $pn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}$pn.isMDXComponent=!0;const Ypn={toc:[]};function Kpn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ypn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]};function trn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}trn.isMDXComponent=!0;const nrn={toc:[]};function ern(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ern.isMDXComponent=!0;const orn={toc:[]};function prn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},orn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}prn.isMDXComponent=!0;const rrn={toc:[]};function srn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}srn.isMDXComponent=!0;const crn={toc:[]};function irn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}irn.isMDXComponent=!0;const arn={toc:[]};function lrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},arn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lrn.isMDXComponent=!0;const urn={toc:[]};function mrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}mrn.isMDXComponent=!0;const drn={toc:[]};function hrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}hrn.isMDXComponent=!0;const krn={toc:[]};function yrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},krn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yrn.isMDXComponent=!0;const frn={toc:[]};function Mrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Mrn.isMDXComponent=!0;const Drn={toc:[]};function _rn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_rn.isMDXComponent=!0;const Xrn={toc:[]};function wrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wrn.isMDXComponent=!0;const grn={toc:[]};function Trn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Trn.isMDXComponent=!0;const xrn={toc:[]};function Crn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Crn.isMDXComponent=!0;const vrn={toc:[]};function Lrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lrn.isMDXComponent=!0;const Zrn={toc:[]};function brn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}brn.isMDXComponent=!0;const Nrn={toc:[]};function zrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zrn.isMDXComponent=!0;const Arn={toc:[]};function Wrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Arn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wrn.isMDXComponent=!0;const Rrn={toc:[]};function Srn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Srn.isMDXComponent=!0;const Irn={toc:[]};function Prn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Irn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Prn.isMDXComponent=!0;const Ern={toc:[]};function Brn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ern,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Brn.isMDXComponent=!0;const Grn={toc:[]};function Orn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Grn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Orn.isMDXComponent=!0;const Frn={toc:[]};function Urn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Frn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Urn.isMDXComponent=!0;const qrn={toc:[]};function Vrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Vrn.isMDXComponent=!0;const jrn={toc:[]};function Qrn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Qrn.isMDXComponent=!0;const Hrn={toc:[]};function $rn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}$rn.isMDXComponent=!0;const Yrn={toc:[]};function Krn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Krn.isMDXComponent=!0;const Jrn={toc:[]};function tsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}tsn.isMDXComponent=!0;const nsn={toc:[]};function esn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}esn.isMDXComponent=!0;const osn={toc:[]};function psn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},osn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}psn.isMDXComponent=!0;const rsn={toc:[]};function ssn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ssn.isMDXComponent=!0;const csn={toc:[]};function isn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},csn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}isn.isMDXComponent=!0;const asn={toc:[]};function lsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},asn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lsn.isMDXComponent=!0;const usn={toc:[]};function msn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},usn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}msn.isMDXComponent=!0;const dsn={toc:[]};function hsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}hsn.isMDXComponent=!0;const ksn={toc:[]};function ysn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ksn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ysn.isMDXComponent=!0;const fsn={toc:[]};function Msn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Msn.isMDXComponent=!0;const Dsn={toc:[]};function _sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_sn.isMDXComponent=!0;const Xsn={toc:[]};function wsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wsn.isMDXComponent=!0;const gsn={toc:[]};function Tsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Tsn.isMDXComponent=!0;const xsn={toc:[]};function Csn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Csn.isMDXComponent=!0;const vsn={toc:[]};function Lsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Lsn.isMDXComponent=!0;const Zsn={toc:[]};function bsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}bsn.isMDXComponent=!0;const Nsn={toc:[]};function zsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}zsn.isMDXComponent=!0;const Asn={toc:[]};function Wsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Asn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Wsn.isMDXComponent=!0;const Rsn={toc:[]};function Ssn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ssn.isMDXComponent=!0;const Isn={toc:[]};function Psn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Isn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Psn.isMDXComponent=!0;const Esn={toc:[]};function Bsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Esn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Bsn.isMDXComponent=!0;const Gsn={toc:[]};function Osn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Osn.isMDXComponent=!0;const Fsn={toc:[]};function Usn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Usn.isMDXComponent=!0;const qsn={toc:[]};function Vsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Vsn.isMDXComponent=!0;const jsn={toc:[]};function Qsn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Qsn.isMDXComponent=!0;const Hsn={toc:[]};function $sn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}$sn.isMDXComponent=!0;const Ysn={toc:[]};function Ksn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ysn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Ksn.isMDXComponent=!0;const Jsn={toc:[]};function tcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}tcn.isMDXComponent=!0;const ncn={toc:[]};function ecn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ncn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}ecn.isMDXComponent=!0;const ocn={toc:[]};function pcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ocn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}pcn.isMDXComponent=!0;const rcn={toc:[]};function scn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}scn.isMDXComponent=!0;const ccn={toc:[]};function icn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ccn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}icn.isMDXComponent=!0;const acn={toc:[]};function lcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},acn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lcn.isMDXComponent=!0;const ucn={toc:[]};function mcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ucn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}mcn.isMDXComponent=!0;const dcn={toc:[]};function hcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}hcn.isMDXComponent=!0;const kcn={toc:[]};function ycn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ycn.isMDXComponent=!0;const fcn={toc:[]};function Mcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Mcn.isMDXComponent=!0;const Dcn={toc:[]};function _cn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}_cn.isMDXComponent=!0;const Xcn={toc:[]};function wcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wcn.isMDXComponent=!0;const gcn={toc:[]};function Tcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Tcn.isMDXComponent=!0;const xcn={toc:[]};function Ccn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Ccn.isMDXComponent=!0;const vcn={toc:[]};function Lcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lcn.isMDXComponent=!0;const Zcn={toc:[]};function bcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}bcn.isMDXComponent=!0;const Ncn={toc:[]};function zcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ncn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}zcn.isMDXComponent=!0;const Acn={toc:[]};function Wcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Acn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Wcn.isMDXComponent=!0;const Rcn={toc:[]};function Scn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Scn.isMDXComponent=!0;const Icn={toc:[]};function Pcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Icn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pcn.isMDXComponent=!0;const Ecn={toc:[]};function Bcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ecn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Bcn.isMDXComponent=!0;const Gcn={toc:[]};function Ocn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Ocn.isMDXComponent=!0;const Fcn={toc:[]};function Ucn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Ucn.isMDXComponent=!0;const qcn={toc:[]};function Vcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Vcn.isMDXComponent=!0;const jcn={toc:[]};function Qcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Qcn.isMDXComponent=!0;const Hcn={toc:[]};function $cn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}$cn.isMDXComponent=!0;const Ycn={toc:[]};function Kcn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ycn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Kcn.isMDXComponent=!0;const Jcn={toc:[]};function tin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}tin.isMDXComponent=!0;const nin={toc:[]};function ein(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}ein.isMDXComponent=!0;const oin={toc:[]};function pin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pin.isMDXComponent=!0;const rin={toc:[]};function sin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sin.isMDXComponent=!0;const cin={toc:[]};function iin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}iin.isMDXComponent=!0;const ain={toc:[]};function lin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ain,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lin.isMDXComponent=!0;const uin={toc:[]};function min(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}min.isMDXComponent=!0;const din={toc:[]};function hin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},din,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hin.isMDXComponent=!0;const kin={toc:[]};function yin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}yin.isMDXComponent=!0;const fin={toc:[]};function Min(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Min.isMDXComponent=!0;const Din={toc:[]};function _in(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Din,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}_in.isMDXComponent=!0;const Xin={toc:[]};function win(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}win.isMDXComponent=!0;const gin={toc:[]};function Tin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Tin.isMDXComponent=!0;const xin={toc:[]};function Cin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Cin.isMDXComponent=!0;const vin={toc:[]};function Lin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Lin.isMDXComponent=!0;const Zin={toc:[]};function bin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bin.isMDXComponent=!0;const Nin={toc:[]};function zin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}zin.isMDXComponent=!0;const Ain={toc:[]};function Win(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ain,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Win.isMDXComponent=!0;const Rin={toc:[]};function Sin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Sin.isMDXComponent=!0;const Iin={toc:[]};function Pin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Pin.isMDXComponent=!0;const Ein={toc:[]};function Bin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ein,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Bin.isMDXComponent=!0;const Gin={toc:[]};function Oin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Oin.isMDXComponent=!0;const Fin={toc:[]};function Uin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Uin.isMDXComponent=!0;const qin={toc:[]};function Vin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Vin.isMDXComponent=!0;const jin={toc:[]};function Qin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Qin.isMDXComponent=!0;const Hin={toc:[]};function $in(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}$in.isMDXComponent=!0;const Yin={toc:[]};function Kin(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Kin.isMDXComponent=!0;const Jin={toc:[]};function tan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}tan.isMDXComponent=!0;const nan={toc:[]};function ean(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}ean.isMDXComponent=!0;const oan={toc:[]};function pan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pan.isMDXComponent=!0;const ran={toc:[]};function san(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ran,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}san.isMDXComponent=!0;const can={toc:[]};function ian(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},can,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ian.isMDXComponent=!0;const aan={toc:[]};function lan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lan.isMDXComponent=!0;const uan={toc:[]};function man(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}man.isMDXComponent=!0;const dan={toc:[]};function han(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}han.isMDXComponent=!0;const kan={toc:[]};function yan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}yan.isMDXComponent=!0;const fan={toc:[]};function Man(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Man.isMDXComponent=!0;const Dan={toc:[]};function _an(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}_an.isMDXComponent=!0;const Xan={toc:[]};function wan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wan.isMDXComponent=!0;const gan={toc:[]};function Tan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Tan.isMDXComponent=!0;const xan={toc:[]};function Can(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Can.isMDXComponent=!0;const van={toc:[]};function Lan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},van,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Lan.isMDXComponent=!0;const Zan={toc:[]};function ban(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ban.isMDXComponent=!0;const Nan={toc:[]};function zan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}zan.isMDXComponent=!0;const Aan={toc:[]};function Wan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wan.isMDXComponent=!0;const Ran={toc:[]};function San(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ran,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}San.isMDXComponent=!0;const Ian={toc:[]};function Pan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ian,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Pan.isMDXComponent=!0;const Ean={toc:[]};function Ban(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ean,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Ban.isMDXComponent=!0;const Gan={toc:[]};function Oan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Oan.isMDXComponent=!0;const Fan={toc:[]};function Uan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Uan.isMDXComponent=!0;const qan={toc:[]};function Van(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Van.isMDXComponent=!0;const jan={toc:[]};function Qan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Qan.isMDXComponent=!0;const Han={toc:[]};function $an(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Han,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}$an.isMDXComponent=!0;const Yan={toc:[]};function Kan(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Kan.isMDXComponent=!0;const Jan={toc:[]};function tln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tln.isMDXComponent=!0;const nln={toc:[]};function eln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}eln.isMDXComponent=!0;const oln={toc:[]};function pln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pln.isMDXComponent=!0;const rln={toc:[]};function sln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}sln.isMDXComponent=!0;const cln={toc:[]};function iln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}iln.isMDXComponent=!0;const aln={toc:[]};function lln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lln.isMDXComponent=!0;const uln={toc:[]};function mln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}mln.isMDXComponent=!0;const dln={toc:[]};function hln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}hln.isMDXComponent=!0;const kln={toc:[]};function yln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}yln.isMDXComponent=!0;const fln={toc:[]};function Mln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Mln.isMDXComponent=!0;const Dln={toc:[]};function _ln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}_ln.isMDXComponent=!0;const Xln={toc:[]};function wln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wln.isMDXComponent=!0;const gln={toc:[]};function Tln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Tln.isMDXComponent=!0;const xln={toc:[]};function Cln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Cln.isMDXComponent=!0;const vln={toc:[]};function Lln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition"))}Lln.isMDXComponent=!0;const Zln={toc:[]};function bln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition"))}bln.isMDXComponent=!0;const Nln={toc:[]};function zln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}zln.isMDXComponent=!0;const Aln={toc:[]};function Wln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Wln.isMDXComponent=!0;const Rln={toc:[]};function Sln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Sln.isMDXComponent=!0;const Iln={toc:[]};function Pln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Pln.isMDXComponent=!0;const Eln={toc:[]};function Bln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Bln.isMDXComponent=!0;const Gln={toc:[]};function Oln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Oln.isMDXComponent=!0;const Fln={toc:[]};function Uln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Uln.isMDXComponent=!0;const qln={toc:[]};function Vln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Vln.isMDXComponent=!0;const jln={toc:[]};function Qln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Qln.isMDXComponent=!0;const Hln={toc:[]};function $ln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}$ln.isMDXComponent=!0;const Yln={toc:[]};function Kln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Kln.isMDXComponent=!0;const Jln={toc:[]};function tun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}tun.isMDXComponent=!0;const nun={toc:[]};function eun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}eun.isMDXComponent=!0;const oun={toc:[]};function pun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pun.isMDXComponent=!0;const run={toc:[]};function sun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},run,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}sun.isMDXComponent=!0;const cun={toc:[]};function iun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}iun.isMDXComponent=!0;const aun={toc:[]};function lun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lun.isMDXComponent=!0;const uun={toc:[]};function mun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}mun.isMDXComponent=!0;const dun={toc:[]};function hun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hun.isMDXComponent=!0;const kun={toc:[]};function yun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}yun.isMDXComponent=!0;const fun={toc:[]};function Mun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mun.isMDXComponent=!0;const Dun={toc:[]};function _un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}_un.isMDXComponent=!0;const Xun={toc:[]};function wun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wun.isMDXComponent=!0;const gun={toc:[]};function Tun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Tun.isMDXComponent=!0;const xun={toc:[]};function Cun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}Cun.isMDXComponent=!0;const vun={toc:[]};function Lun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}Lun.isMDXComponent=!0;const Zun={toc:[]};function bun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}bun.isMDXComponent=!0;const Nun={toc:[]};function zun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}zun.isMDXComponent=!0;const Aun={toc:[]};function Wun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wun.isMDXComponent=!0;const Run={toc:[]};function Sun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Run,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Sun.isMDXComponent=!0;const Iun={toc:[]};function Pun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pun.isMDXComponent=!0;const Eun={toc:[]};function Bun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Bun.isMDXComponent=!0;const Gun={toc:[]};function Oun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Oun.isMDXComponent=!0;const Fun={toc:[]};function Uun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}Uun.isMDXComponent=!0;const qun={toc:[]};function Vun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vun.isMDXComponent=!0;const jun={toc:[]};function Qun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Qun.isMDXComponent=!0;const Hun={toc:[]};function $un(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$un.isMDXComponent=!0;const Yun={toc:[]};function Kun(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Kun.isMDXComponent=!0;const Jun={toc:[]};function tmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tmn.isMDXComponent=!0;const nmn={toc:[]};function emn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}emn.isMDXComponent=!0;const omn={toc:[]};function pmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}pmn.isMDXComponent=!0;const rmn={toc:[]};function smn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}smn.isMDXComponent=!0;const cmn={toc:[]};function imn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}imn.isMDXComponent=!0;const amn={toc:[]};function lmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}lmn.isMDXComponent=!0;const umn={toc:[]};function mmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mmn.isMDXComponent=!0;const dmn={toc:[]};function hmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}hmn.isMDXComponent=!0;const kmn={toc:[]};function ymn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ymn.isMDXComponent=!0;const fmn={toc:[]};function Mmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Mmn.isMDXComponent=!0;const Dmn={toc:[]};function _mn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}_mn.isMDXComponent=!0;const Xmn={toc:[]};function wmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}wmn.isMDXComponent=!0;const gmn={toc:[]};function Tmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Tmn.isMDXComponent=!0;const xmn={toc:[]};function Cmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Cmn.isMDXComponent=!0;const vmn={toc:[]};function Lmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lmn.isMDXComponent=!0;const Zmn={toc:[]};function bmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}bmn.isMDXComponent=!0;const Nmn={toc:[]};function zmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}zmn.isMDXComponent=!0;const Amn={toc:[]};function Wmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Wmn.isMDXComponent=!0;const Rmn={toc:[]};function Smn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Smn.isMDXComponent=!0;const Imn={toc:[]};function Pmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Imn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Pmn.isMDXComponent=!0;const Emn={toc:[]};function Bmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Emn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bmn.isMDXComponent=!0;const Gmn={toc:[]};function Omn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Omn.isMDXComponent=!0;const Fmn={toc:[]};function Umn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Umn.isMDXComponent=!0;const qmn={toc:[]};function Vmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Vmn.isMDXComponent=!0;const jmn={toc:[]};function Qmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qmn.isMDXComponent=!0;const Hmn={toc:[]};function $mn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}$mn.isMDXComponent=!0;const Ymn={toc:[]};function Kmn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ymn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Kmn.isMDXComponent=!0;const Jmn={toc:[]};function tdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}tdn.isMDXComponent=!0;const ndn={toc:[]};function edn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ndn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}edn.isMDXComponent=!0;const odn={toc:[]};function pdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pdn.isMDXComponent=!0;const rdn={toc:[]};function sdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sdn.isMDXComponent=!0;const cdn={toc:[]};function idn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}idn.isMDXComponent=!0;const adn={toc:[]};function ldn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ldn.isMDXComponent=!0;const udn={toc:[]};function mdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}mdn.isMDXComponent=!0;const ddn={toc:[]};function hdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}hdn.isMDXComponent=!0;const kdn={toc:[]};function ydn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}ydn.isMDXComponent=!0;const fdn={toc:[]};function Mdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mdn.isMDXComponent=!0;const Ddn={toc:[]};function _dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}_dn.isMDXComponent=!0;const Xdn={toc:[]};function wdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wdn.isMDXComponent=!0;const gdn={toc:[]};function Tdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Tdn.isMDXComponent=!0;const xdn={toc:[]};function Cdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cdn.isMDXComponent=!0;const vdn={toc:[]};function Ldn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ldn.isMDXComponent=!0;const Zdn={toc:[]};function bdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}bdn.isMDXComponent=!0;const Ndn={toc:[]};function zdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}zdn.isMDXComponent=!0;const Adn={toc:[]};function Wdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Wdn.isMDXComponent=!0;const Rdn={toc:[]};function Sdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Sdn.isMDXComponent=!0;const Idn={toc:[]};function Pdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Idn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Pdn.isMDXComponent=!0;const Edn={toc:[]};function Bdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Edn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Bdn.isMDXComponent=!0;const Gdn={toc:[]};function Odn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Odn.isMDXComponent=!0;const Fdn={toc:[]};function Udn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Udn.isMDXComponent=!0;const qdn={toc:[]};function Vdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vdn.isMDXComponent=!0;const jdn={toc:[]};function Qdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Qdn.isMDXComponent=!0;const Hdn={toc:[]};function $dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$dn.isMDXComponent=!0;const Ydn={toc:[]};function Kdn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ydn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Kdn.isMDXComponent=!0;const Jdn={toc:[]};function thn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}thn.isMDXComponent=!0;const nhn={toc:[]};function ehn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}ehn.isMDXComponent=!0;const ohn={toc:[]};function phn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ohn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}phn.isMDXComponent=!0;const rhn={toc:[]};function shn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}shn.isMDXComponent=!0;const chn={toc:[]};function ihn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},chn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ihn.isMDXComponent=!0;const ahn={toc:[]};function lhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ahn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}lhn.isMDXComponent=!0;const uhn={toc:[]};function mhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mhn.isMDXComponent=!0;const dhn={toc:[]};function hhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}hhn.isMDXComponent=!0;const khn={toc:[]};function yhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},khn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yhn.isMDXComponent=!0;const fhn={toc:[]};function Mhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mhn.isMDXComponent=!0;const Dhn={toc:[]};function _hn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_hn.isMDXComponent=!0;const Xhn={toc:[]};function whn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}whn.isMDXComponent=!0;const ghn={toc:[]};function Thn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ghn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Thn.isMDXComponent=!0;const xhn={toc:[]};function Chn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Chn.isMDXComponent=!0;const vhn={toc:[]};function Lhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lhn.isMDXComponent=!0;const Zhn={toc:[]};function bhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}bhn.isMDXComponent=!0;const Nhn={toc:[]};function zhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zhn.isMDXComponent=!0;const Ahn={toc:[]};function Whn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ahn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Whn.isMDXComponent=!0;const Rhn={toc:[]};function Shn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Shn.isMDXComponent=!0;const Ihn={toc:[]};function Phn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ihn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Phn.isMDXComponent=!0;const Ehn={toc:[]};function Bhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ehn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bhn.isMDXComponent=!0;const Ghn={toc:[]};function Ohn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ghn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Ohn.isMDXComponent=!0;const Fhn={toc:[]};function Uhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Uhn.isMDXComponent=!0;const qhn={toc:[]};function Vhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Vhn.isMDXComponent=!0;const jhn={toc:[]};function Qhn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qhn.isMDXComponent=!0;const Hhn={toc:[]};function $hn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}$hn.isMDXComponent=!0;const Yhn={toc:[]};function Khn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Khn.isMDXComponent=!0;const Jhn={toc:[]};function tkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tkn.isMDXComponent=!0;const nkn={toc:[]};function ekn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}ekn.isMDXComponent=!0;const okn={toc:[]};function pkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}pkn.isMDXComponent=!0;const rkn={toc:[]};function skn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}skn.isMDXComponent=!0;const ckn={toc:[]};function ikn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}ikn.isMDXComponent=!0;const akn={toc:[]};function lkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lkn.isMDXComponent=!0;const ukn={toc:[]};function mkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mkn.isMDXComponent=!0;const dkn={toc:[]};function hkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hkn.isMDXComponent=!0;const kkn={toc:[]};function ykn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}ykn.isMDXComponent=!0;const fkn={toc:[]};function Mkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}Mkn.isMDXComponent=!0;const Dkn={toc:[]};function _kn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}_kn.isMDXComponent=!0;const Xkn={toc:[]};function wkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wkn.isMDXComponent=!0;const gkn={toc:[]};function Tkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Tkn.isMDXComponent=!0;const xkn={toc:[]};function Ckn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Ckn.isMDXComponent=!0;const vkn={toc:[]};function Lkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}Lkn.isMDXComponent=!0;const Zkn={toc:[]};function bkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bkn.isMDXComponent=!0;const Nkn={toc:[]};function zkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}zkn.isMDXComponent=!0;const Akn={toc:[]};function Wkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wkn.isMDXComponent=!0;const Rkn={toc:[]};function Skn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Skn.isMDXComponent=!0;const Ikn={toc:[]};function Pkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ikn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Pkn.isMDXComponent=!0;const Ekn={toc:[]};function Bkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ekn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Bkn.isMDXComponent=!0;const Gkn={toc:[]};function Okn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Okn.isMDXComponent=!0;const Fkn={toc:[]};function Ukn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Ukn.isMDXComponent=!0;const qkn={toc:[]};function Vkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Vkn.isMDXComponent=!0;const jkn={toc:[]};function Qkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qkn.isMDXComponent=!0;const Hkn={toc:[]};function $kn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}$kn.isMDXComponent=!0;const Ykn={toc:[]};function Kkn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ykn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]};function tyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tyn.isMDXComponent=!0;const nyn={toc:[]};function eyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eyn.isMDXComponent=!0;const oyn={toc:[]};function pyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pyn.isMDXComponent=!0;const ryn={toc:[]};function syn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}syn.isMDXComponent=!0;const cyn={toc:[]};function iyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}iyn.isMDXComponent=!0;const ayn={toc:[]};function lyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lyn.isMDXComponent=!0;const uyn={toc:[]};function myn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}myn.isMDXComponent=!0;const dyn={toc:[]};function hyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hyn.isMDXComponent=!0;const kyn={toc:[]};function yyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}yyn.isMDXComponent=!0;const fyn={toc:[]};function Myn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Myn.isMDXComponent=!0;const Dyn={toc:[]};function _yn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_yn.isMDXComponent=!0;const Xyn={toc:[]};function wyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wyn.isMDXComponent=!0;const gyn={toc:[]};function Tyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Tyn.isMDXComponent=!0;const xyn={toc:[]};function Cyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cyn.isMDXComponent=!0;const vyn={toc:[]};function Lyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Lyn.isMDXComponent=!0;const Zyn={toc:[]};function byn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}byn.isMDXComponent=!0;const Nyn={toc:[]};function zyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zyn.isMDXComponent=!0;const Ayn={toc:[]};function Wyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Wyn.isMDXComponent=!0;const Ryn={toc:[]};function Syn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ryn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Syn.isMDXComponent=!0;const Iyn={toc:[]};function Pyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Pyn.isMDXComponent=!0;const Eyn={toc:[]};function Byn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Byn.isMDXComponent=!0;const Gyn={toc:[]};function Oyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Oyn.isMDXComponent=!0;const Fyn={toc:[]};function Uyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Uyn.isMDXComponent=!0;const qyn={toc:[]};function Vyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Vyn.isMDXComponent=!0;const jyn={toc:[]};function Qyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qyn.isMDXComponent=!0;const Hyn={toc:[]};function $yn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}$yn.isMDXComponent=!0;const Yyn={toc:[]};function Kyn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kyn.isMDXComponent=!0;const Jyn={toc:[]};function tfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tfn.isMDXComponent=!0;const nfn={toc:[]};function efn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}efn.isMDXComponent=!0;const ofn={toc:[]};function pfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ofn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}pfn.isMDXComponent=!0;const rfn={toc:[]};function sfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}sfn.isMDXComponent=!0;const cfn={toc:[]};function ifn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}ifn.isMDXComponent=!0;const afn={toc:[]};function lfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},afn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}lfn.isMDXComponent=!0;const ufn={toc:[]};function mfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ufn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}mfn.isMDXComponent=!0;const dfn={toc:[]};function hfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}hfn.isMDXComponent=!0;const kfn={toc:[]};function yfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}yfn.isMDXComponent=!0;const ffn={toc:[]};function Mfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ffn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mfn.isMDXComponent=!0;const Dfn={toc:[]};function _fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}_fn.isMDXComponent=!0;const Xfn={toc:[]};function wfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wfn.isMDXComponent=!0;const gfn={toc:[]};function Tfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Tfn.isMDXComponent=!0;const xfn={toc:[]};function Cfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cfn.isMDXComponent=!0;const vfn={toc:[]};function Lfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Lfn.isMDXComponent=!0;const Zfn={toc:[]};function bfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}bfn.isMDXComponent=!0;const Nfn={toc:[]};function zfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}zfn.isMDXComponent=!0;const Afn={toc:[]};function Wfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Afn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wfn.isMDXComponent=!0;const Rfn={toc:[]};function Sfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Sfn.isMDXComponent=!0;const Ifn={toc:[]};function Pfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ifn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pfn.isMDXComponent=!0;const Efn={toc:[]};function Bfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Efn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Bfn.isMDXComponent=!0;const Gfn={toc:[]};function Ofn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Ofn.isMDXComponent=!0;const Ffn={toc:[]};function Ufn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ffn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Ufn.isMDXComponent=!0;const qfn={toc:[]};function Vfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Vfn.isMDXComponent=!0;const jfn={toc:[]};function Qfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Qfn.isMDXComponent=!0;const Hfn={toc:[]};function $fn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}$fn.isMDXComponent=!0;const Yfn={toc:[]};function Kfn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]};function tMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}tMn.isMDXComponent=!0;const nMn={toc:[]};function eMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eMn.isMDXComponent=!0;const oMn={toc:[]};function pMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pMn.isMDXComponent=!0;const rMn={toc:[]};function sMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sMn.isMDXComponent=!0;const cMn={toc:[]};function iMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}iMn.isMDXComponent=!0;const aMn={toc:[]};function lMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lMn.isMDXComponent=!0;const uMn={toc:[]};function mMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mMn.isMDXComponent=!0;const dMn={toc:[]};function hMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hMn.isMDXComponent=!0;const kMn={toc:[]};function yMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}yMn.isMDXComponent=!0;const fMn={toc:[]};function MMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MMn.isMDXComponent=!0;const DMn={toc:[]};function _Mn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}_Mn.isMDXComponent=!0;const XMn={toc:[]};function wMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wMn.isMDXComponent=!0;const gMn={toc:[]};function TMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}TMn.isMDXComponent=!0;const xMn={toc:[]};function CMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CMn.isMDXComponent=!0;const vMn={toc:[]};function LMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}LMn.isMDXComponent=!0;const ZMn={toc:[]};function bMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bMn.isMDXComponent=!0;const NMn={toc:[]};function zMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zMn.isMDXComponent=!0;const AMn={toc:[]};function WMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WMn.isMDXComponent=!0;const RMn={toc:[]};function SMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}SMn.isMDXComponent=!0;const IMn={toc:[]};function PMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PMn.isMDXComponent=!0;const EMn={toc:[]};function BMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}BMn.isMDXComponent=!0;const GMn={toc:[]};function OMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}OMn.isMDXComponent=!0;const FMn={toc:[]};function UMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}UMn.isMDXComponent=!0;const qMn={toc:[]};function VMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}VMn.isMDXComponent=!0;const jMn={toc:[]};function QMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}QMn.isMDXComponent=!0;const HMn={toc:[]};function $Mn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$Mn.isMDXComponent=!0;const YMn={toc:[]};function KMn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KMn.isMDXComponent=!0;const JMn={toc:[]};function tDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tDn.isMDXComponent=!0;const nDn={toc:[]};function eDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}eDn.isMDXComponent=!0;const oDn={toc:[]};function pDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pDn.isMDXComponent=!0;const rDn={toc:[]};function sDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}sDn.isMDXComponent=!0;const cDn={toc:[]};function iDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}iDn.isMDXComponent=!0;const aDn={toc:[]};function lDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}lDn.isMDXComponent=!0;const uDn={toc:[]};function mDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mDn.isMDXComponent=!0;const dDn={toc:[]};function hDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}hDn.isMDXComponent=!0;const kDn={toc:[]};function yDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}yDn.isMDXComponent=!0;const fDn={toc:[]};function MDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}MDn.isMDXComponent=!0;const DDn={toc:[]};function _Dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_Dn.isMDXComponent=!0;const XDn={toc:[]};function wDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wDn.isMDXComponent=!0;const gDn={toc:[]};function TDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TDn.isMDXComponent=!0;const xDn={toc:[]};function CDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}CDn.isMDXComponent=!0;const vDn={toc:[]};function LDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}LDn.isMDXComponent=!0;const ZDn={toc:[]};function bDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}bDn.isMDXComponent=!0;const NDn={toc:[]};function zDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}zDn.isMDXComponent=!0;const ADn={toc:[]};function WDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}WDn.isMDXComponent=!0;const RDn={toc:[]};function SDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}SDn.isMDXComponent=!0;const IDn={toc:[]};function PDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}PDn.isMDXComponent=!0;const EDn={toc:[]};function BDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BDn.isMDXComponent=!0;const GDn={toc:[]};function ODn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ODn.isMDXComponent=!0;const FDn={toc:[]};function UDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UDn.isMDXComponent=!0;const qDn={toc:[]};function VDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}VDn.isMDXComponent=!0;const jDn={toc:[]};function QDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QDn.isMDXComponent=!0;const HDn={toc:[]};function $Dn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}$Dn.isMDXComponent=!0;const YDn={toc:[]};function KDn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KDn.isMDXComponent=!0;const JDn={toc:[]};function t_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}t_n.isMDXComponent=!0;const n_n={toc:[]};function e_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}e_n.isMDXComponent=!0;const o_n={toc:[]};function p_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}p_n.isMDXComponent=!0;const r_n={toc:[]};function s_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}s_n.isMDXComponent=!0;const c_n={toc:[]};function i_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}i_n.isMDXComponent=!0;const a_n={toc:[]};function l_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l_n.isMDXComponent=!0;const u_n={toc:[]};function m_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}m_n.isMDXComponent=!0;const d_n={toc:[]};function h_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}h_n.isMDXComponent=!0;const k_n={toc:[]};function y_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}y_n.isMDXComponent=!0;const f_n={toc:[]};function M_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}M_n.isMDXComponent=!0;const D_n={toc:[]};function __n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}__n.isMDXComponent=!0;const X_n={toc:[]};function w_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w_n.isMDXComponent=!0;const g_n={toc:[]};function T_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}T_n.isMDXComponent=!0;const x_n={toc:[]};function C_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}C_n.isMDXComponent=!0;const v_n={toc:[]};function L_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}L_n.isMDXComponent=!0;const Z_n={toc:[]};function b_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b_n.isMDXComponent=!0;const N_n={toc:[]};function z_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}z_n.isMDXComponent=!0;const A_n={toc:[]};function W_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}W_n.isMDXComponent=!0;const R_n={toc:[]};function S_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}S_n.isMDXComponent=!0;const I_n={toc:[]};function P_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}P_n.isMDXComponent=!0;const E_n={toc:[]};function B_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}B_n.isMDXComponent=!0;const G_n={toc:[]};function O_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}O_n.isMDXComponent=!0;const F_n={toc:[]};function U_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}U_n.isMDXComponent=!0;const q_n={toc:[]};function V_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}V_n.isMDXComponent=!0;const j_n={toc:[]};function Q_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Q_n.isMDXComponent=!0;const H_n={toc:[]};function $_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}$_n.isMDXComponent=!0;const Y_n={toc:[]};function K_n(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}K_n.isMDXComponent=!0;const J_n={toc:[]};function tXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}tXn.isMDXComponent=!0;const nXn={toc:[]};function eXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}eXn.isMDXComponent=!0;const oXn={toc:[]};function pXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pXn.isMDXComponent=!0;const rXn={toc:[]};function sXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}sXn.isMDXComponent=!0;const cXn={toc:[]};function iXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}iXn.isMDXComponent=!0;const aXn={toc:[]};function lXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}lXn.isMDXComponent=!0;const uXn={toc:[]};function mXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mXn.isMDXComponent=!0;const dXn={toc:[]};function hXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}hXn.isMDXComponent=!0;const kXn={toc:[]};function yXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yXn.isMDXComponent=!0;const fXn={toc:[]};function MXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}MXn.isMDXComponent=!0;const DXn={toc:[]};function _Xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}_Xn.isMDXComponent=!0;const XXn={toc:[]};function wXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wXn.isMDXComponent=!0;const gXn={toc:[]};function TXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}TXn.isMDXComponent=!0;const xXn={toc:[]};function CXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}CXn.isMDXComponent=!0;const vXn={toc:[]};function LXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}LXn.isMDXComponent=!0;const ZXn={toc:[]};function bXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}bXn.isMDXComponent=!0;const NXn={toc:[]};function zXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zXn.isMDXComponent=!0;const AXn={toc:[]};function WXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}WXn.isMDXComponent=!0;const RXn={toc:[]};function SXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SXn.isMDXComponent=!0;const IXn={toc:[]};function PXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}PXn.isMDXComponent=!0;const EXn={toc:[]};function BXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BXn.isMDXComponent=!0;const GXn={toc:[]};function OXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}OXn.isMDXComponent=!0;const FXn={toc:[]};function UXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}UXn.isMDXComponent=!0;const qXn={toc:[]};function VXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}VXn.isMDXComponent=!0;const jXn={toc:[]};function QXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QXn.isMDXComponent=!0;const HXn={toc:[]};function $Xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}$Xn.isMDXComponent=!0;const YXn={toc:[]};function KXn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KXn.isMDXComponent=!0;const JXn={toc:[]};function twn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}twn.isMDXComponent=!0;const nwn={toc:[]};function ewn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ewn.isMDXComponent=!0;const own={toc:[]};function pwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},own,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pwn.isMDXComponent=!0;const rwn={toc:[]};function swn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}swn.isMDXComponent=!0;const cwn={toc:[]};function iwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}iwn.isMDXComponent=!0;const awn={toc:[]};function lwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lwn.isMDXComponent=!0;const uwn={toc:[]};function mwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}mwn.isMDXComponent=!0;const dwn={toc:[]};function hwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}hwn.isMDXComponent=!0;const kwn={toc:[]};function ywn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}ywn.isMDXComponent=!0;const fwn={toc:[]};function Mwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Mwn.isMDXComponent=!0;const Dwn={toc:[]};function _wn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}_wn.isMDXComponent=!0;const Xwn={toc:[]};function wwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}wwn.isMDXComponent=!0;const gwn={toc:[]};function Twn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Twn.isMDXComponent=!0;const xwn={toc:[]};function Cwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Cwn.isMDXComponent=!0;const vwn={toc:[]};function Lwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lwn.isMDXComponent=!0;const Zwn={toc:[]};function bwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}bwn.isMDXComponent=!0;const Nwn={toc:[]};function zwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zwn.isMDXComponent=!0;const Awn={toc:[]};function Wwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Wwn.isMDXComponent=!0;const Rwn={toc:[]};function Swn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Swn.isMDXComponent=!0;const Iwn={toc:[]};function Pwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Pwn.isMDXComponent=!0;const Ewn={toc:[]};function Bwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ewn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Bwn.isMDXComponent=!0;const Gwn={toc:[]};function Own(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Own.isMDXComponent=!0;const Fwn={toc:[]};function Uwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}Uwn.isMDXComponent=!0;const qwn={toc:[]};function Vwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vwn.isMDXComponent=!0;const jwn={toc:[]};function Qwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Qwn.isMDXComponent=!0;const Hwn={toc:[]};function $wn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$wn.isMDXComponent=!0;const Ywn={toc:[]};function Kwn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ywn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]};function tgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tgn.isMDXComponent=!0;const ngn={toc:[]};function egn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ngn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}egn.isMDXComponent=!0;const ogn={toc:[]};function pgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pgn.isMDXComponent=!0;const rgn={toc:[]};function sgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}sgn.isMDXComponent=!0;const cgn={toc:[]};function ign(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ign.isMDXComponent=!0;const agn={toc:[]};function lgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lgn.isMDXComponent=!0;const ugn={toc:[]};function mgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mgn.isMDXComponent=!0;const dgn={toc:[]};function hgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}hgn.isMDXComponent=!0;const kgn={toc:[]};function ygn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ygn.isMDXComponent=!0;const fgn={toc:[]};function Mgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}Mgn.isMDXComponent=!0;const Dgn={toc:[]};function _gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_gn.isMDXComponent=!0;const Xgn={toc:[]};function wgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wgn.isMDXComponent=!0;const ggn={toc:[]};function Tgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tgn.isMDXComponent=!0;const xgn={toc:[]};function Cgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Cgn.isMDXComponent=!0;const vgn={toc:[]};function Lgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Lgn.isMDXComponent=!0;const Zgn={toc:[]};function bgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}bgn.isMDXComponent=!0;const Ngn={toc:[]};function zgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zgn.isMDXComponent=!0;const Agn={toc:[]};function Wgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wgn.isMDXComponent=!0;const Rgn={toc:[]};function Sgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sgn.isMDXComponent=!0;const Ign={toc:[]};function Pgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ign,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Pgn.isMDXComponent=!0;const Egn={toc:[]};function Bgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Egn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bgn.isMDXComponent=!0;const Ggn={toc:[]};function Ogn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ggn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Ogn.isMDXComponent=!0;const Fgn={toc:[]};function Ugn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ugn.isMDXComponent=!0;const qgn={toc:[]};function Vgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Vgn.isMDXComponent=!0;const jgn={toc:[]};function Qgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qgn.isMDXComponent=!0;const Hgn={toc:[]};function $gn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}$gn.isMDXComponent=!0;const Ygn={toc:[]};function Kgn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ygn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kgn.isMDXComponent=!0;const Jgn={toc:[]};function tTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}tTn.isMDXComponent=!0;const nTn={toc:[]};function eTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eTn.isMDXComponent=!0;const oTn={toc:[]};function pTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pTn.isMDXComponent=!0;const rTn={toc:[]};function sTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sTn.isMDXComponent=!0;const cTn={toc:[]};function iTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}iTn.isMDXComponent=!0;const aTn={toc:[]};function lTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lTn.isMDXComponent=!0;const uTn={toc:[]};function mTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mTn.isMDXComponent=!0;const dTn={toc:[]};function hTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hTn.isMDXComponent=!0;const kTn={toc:[]};function yTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}yTn.isMDXComponent=!0;const fTn={toc:[]};function MTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MTn.isMDXComponent=!0;const DTn={toc:[]};function _Tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}_Tn.isMDXComponent=!0;const XTn={toc:[]};function wTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}wTn.isMDXComponent=!0;const gTn={toc:[]};function TTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}TTn.isMDXComponent=!0;const xTn={toc:[]};function CTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}CTn.isMDXComponent=!0;const vTn={toc:[]};function LTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}LTn.isMDXComponent=!0;const ZTn={toc:[]};function bTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bTn.isMDXComponent=!0;const NTn={toc:[]};function zTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zTn.isMDXComponent=!0;const ATn={toc:[]};function WTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WTn.isMDXComponent=!0;const RTn={toc:[]};function STn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}STn.isMDXComponent=!0;const ITn={toc:[]};function PTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ITn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}PTn.isMDXComponent=!0;const ETn={toc:[]};function BTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ETn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}BTn.isMDXComponent=!0;const GTn={toc:[]};function OTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}OTn.isMDXComponent=!0;const FTn={toc:[]};function UTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}UTn.isMDXComponent=!0;const qTn={toc:[]};function VTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}VTn.isMDXComponent=!0;const jTn={toc:[]};function QTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}QTn.isMDXComponent=!0;const HTn={toc:[]};function $Tn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}$Tn.isMDXComponent=!0;const YTn={toc:[]};function KTn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}KTn.isMDXComponent=!0;const JTn={toc:[]};function txn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}txn.isMDXComponent=!0;const nxn={toc:[]};function exn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}exn.isMDXComponent=!0;const oxn={toc:[]};function pxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}pxn.isMDXComponent=!0;const rxn={toc:[]};function sxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sxn.isMDXComponent=!0;const cxn={toc:[]};function ixn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ixn.isMDXComponent=!0;const axn={toc:[]};function lxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}lxn.isMDXComponent=!0;const uxn={toc:[]};function mxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}mxn.isMDXComponent=!0;const dxn={toc:[]};function hxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}hxn.isMDXComponent=!0;const kxn={toc:[]};function yxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}yxn.isMDXComponent=!0;const fxn={toc:[]};function Mxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mxn.isMDXComponent=!0;const Dxn={toc:[]};function _xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}_xn.isMDXComponent=!0;const Xxn={toc:[]};function wxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wxn.isMDXComponent=!0;const gxn={toc:[]};function Txn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Txn.isMDXComponent=!0;const xxn={toc:[]};function Cxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Cxn.isMDXComponent=!0;const vxn={toc:[]};function Lxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Lxn.isMDXComponent=!0;const Zxn={toc:[]};function bxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bxn.isMDXComponent=!0;const Nxn={toc:[]};function zxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}zxn.isMDXComponent=!0;const Axn={toc:[]};function Wxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wxn.isMDXComponent=!0;const Rxn={toc:[]};function Sxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Sxn.isMDXComponent=!0;const Ixn={toc:[]};function Pxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ixn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pxn.isMDXComponent=!0;const Exn={toc:[]};function Bxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Exn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bxn.isMDXComponent=!0;const Gxn={toc:[]};function Oxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Oxn.isMDXComponent=!0;const Fxn={toc:[]};function Uxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Uxn.isMDXComponent=!0;const qxn={toc:[]};function Vxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Vxn.isMDXComponent=!0;const jxn={toc:[]};function Qxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Qxn.isMDXComponent=!0;const Hxn={toc:[]};function $xn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$xn.isMDXComponent=!0;const Yxn={toc:[]};function Kxn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Kxn.isMDXComponent=!0;const Jxn={toc:[]};function tCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tCn.isMDXComponent=!0;const nCn={toc:[]};function eCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}eCn.isMDXComponent=!0;const oCn={toc:[]};function pCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pCn.isMDXComponent=!0;const rCn={toc:[]};function sCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}sCn.isMDXComponent=!0;const cCn={toc:[]};function iCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iCn.isMDXComponent=!0;const aCn={toc:[]};function lCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lCn.isMDXComponent=!0;const uCn={toc:[]};function mCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mCn.isMDXComponent=!0;const dCn={toc:[]};function hCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hCn.isMDXComponent=!0;const kCn={toc:[]};function yCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}yCn.isMDXComponent=!0;const fCn={toc:[]};function MCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}MCn.isMDXComponent=!0;const DCn={toc:[]};function _Cn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_Cn.isMDXComponent=!0;const XCn={toc:[]};function wCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wCn.isMDXComponent=!0;const gCn={toc:[]};function TCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TCn.isMDXComponent=!0;const xCn={toc:[]};function CCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}CCn.isMDXComponent=!0;const vCn={toc:[]};function LCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LCn.isMDXComponent=!0;const ZCn={toc:[]};function bCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}bCn.isMDXComponent=!0;const NCn={toc:[]};function zCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}zCn.isMDXComponent=!0;const ACn={toc:[]};function WCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}WCn.isMDXComponent=!0;const RCn={toc:[]};function SCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SCn.isMDXComponent=!0;const ICn={toc:[]};function PCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ICn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}PCn.isMDXComponent=!0;const ECn={toc:[]};function BCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ECn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}BCn.isMDXComponent=!0;const GCn={toc:[]};function OCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}OCn.isMDXComponent=!0;const FCn={toc:[]};function UCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}UCn.isMDXComponent=!0;const qCn={toc:[]};function VCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}VCn.isMDXComponent=!0;const jCn={toc:[]};function QCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}QCn.isMDXComponent=!0;const HCn={toc:[]};function $Cn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}$Cn.isMDXComponent=!0;const YCn={toc:[]};function KCn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}KCn.isMDXComponent=!0;const JCn={toc:[]};function tvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}tvn.isMDXComponent=!0;const nvn={toc:[]};function evn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}evn.isMDXComponent=!0;const ovn={toc:[]};function pvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pvn.isMDXComponent=!0;const rvn={toc:[]};function svn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}svn.isMDXComponent=!0;const cvn={toc:[]};function ivn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ivn.isMDXComponent=!0;const avn={toc:[]};function lvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lvn.isMDXComponent=!0;const uvn={toc:[]};function mvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mvn.isMDXComponent=!0;const dvn={toc:[]};function hvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hvn.isMDXComponent=!0;const kvn={toc:[]};function yvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}yvn.isMDXComponent=!0;const fvn={toc:[]};function Mvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Mvn.isMDXComponent=!0;const Dvn={toc:[]};function _vn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_vn.isMDXComponent=!0;const Xvn={toc:[]};function wvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wvn.isMDXComponent=!0;const gvn={toc:[]};function Tvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tvn.isMDXComponent=!0;const xvn={toc:[]};function Cvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Cvn.isMDXComponent=!0;const vvn={toc:[]};function Lvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default the ",(0,s.kt)("inlineCode",{parentName:"p"},"cornerSharpness")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Lvn.isMDXComponent=!0;const Zvn={toc:[]};function bvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of the corners. ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," must\nbe set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}bvn.isMDXComponent=!0;const Nvn={toc:[]};function zvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zvn.isMDXComponent=!0;const Avn={toc:[]};function Wvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wvn.isMDXComponent=!0;const Rvn={toc:[]};function Svn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Svn.isMDXComponent=!0;const Ivn={toc:[]};function Pvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ivn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Pvn.isMDXComponent=!0;const Evn={toc:[]};function Bvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Evn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smooth corners are drawn continuously by a bez\xecer curves, rather than by a\nquarter circle."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"smoothCorners")," is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", the sharpness of the curve can be\ncontrolled by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."))}Bvn.isMDXComponent=!0;const Gvn={toc:[]};function Ovn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will set the corner drawing method to smooth corners."))}Ovn.isMDXComponent=!0;const Fvn={toc:[]};function Uvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Uvn.isMDXComponent=!0;const qvn={toc:[]};function Vvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Vvn.isMDXComponent=!0;const jvn={toc:[]};function Qvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qvn.isMDXComponent=!0;const Hvn={toc:[]};function $vn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}$vn.isMDXComponent=!0;const Yvn={toc:[]};function Kvn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kvn.isMDXComponent=!0;const Jvn={toc:[]};function tLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tLn.isMDXComponent=!0;const nLn={toc:[]};function eLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}eLn.isMDXComponent=!0;const oLn={toc:[]};function pLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}pLn.isMDXComponent=!0;const rLn={toc:[]};function sLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}sLn.isMDXComponent=!0;const cLn={toc:[]};function iLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}iLn.isMDXComponent=!0;const aLn={toc:[]};function lLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}lLn.isMDXComponent=!0;const uLn={toc:[]};function mLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}mLn.isMDXComponent=!0;const dLn={toc:[]};function hLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}hLn.isMDXComponent=!0;const kLn={toc:[]};function yLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}yLn.isMDXComponent=!0;const fLn={toc:[]};function MLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}MLn.isMDXComponent=!0;const DLn={toc:[]};function _Ln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}_Ln.isMDXComponent=!0;const XLn={toc:[]};function wLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}wLn.isMDXComponent=!0;const gLn={toc:[]};function TLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}TLn.isMDXComponent=!0;const xLn={toc:[]};function CLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}CLn.isMDXComponent=!0;const vLn={toc:[]};function LLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}LLn.isMDXComponent=!0;const ZLn={toc:[]};function bLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}bLn.isMDXComponent=!0;const NLn={toc:[]};function zLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}zLn.isMDXComponent=!0;const ALn={toc:[]};function WLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}WLn.isMDXComponent=!0;const RLn={toc:[]};function SLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}SLn.isMDXComponent=!0;const ILn={toc:[]};function PLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ILn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}PLn.isMDXComponent=!0;const ELn={toc:[]};function BLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ELn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}BLn.isMDXComponent=!0;const GLn={toc:[]};function OLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}OLn.isMDXComponent=!0;const FLn={toc:[]};function ULn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}ULn.isMDXComponent=!0;const qLn={toc:[]};function VLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}VLn.isMDXComponent=!0;const jLn={toc:[]};function QLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}QLn.isMDXComponent=!0;const HLn={toc:[]};function $Ln(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}$Ln.isMDXComponent=!0;const YLn={toc:[]};function KLn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}KLn.isMDXComponent=!0;const JLn={toc:[]};function tZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}tZn.isMDXComponent=!0;const nZn={toc:[]};function eZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}eZn.isMDXComponent=!0;const oZn={toc:[]};function pZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}pZn.isMDXComponent=!0;const rZn={toc:[]};function sZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}sZn.isMDXComponent=!0;const cZn={toc:[]};function iZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}iZn.isMDXComponent=!0;const aZn={toc:[]};function lZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}lZn.isMDXComponent=!0;const uZn={toc:[]};function mZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}mZn.isMDXComponent=!0;const dZn={toc:[]};function hZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}hZn.isMDXComponent=!0;const kZn={toc:[]};function yZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}yZn.isMDXComponent=!0;const fZn={toc:[]};function MZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}MZn.isMDXComponent=!0;const DZn={toc:[]};function _Zn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}_Zn.isMDXComponent=!0;const XZn={toc:[]};function wZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}wZn.isMDXComponent=!0;const gZn={toc:[]};function TZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}TZn.isMDXComponent=!0;const xZn={toc:[]};function CZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}CZn.isMDXComponent=!0;const vZn={toc:[]};function LZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}LZn.isMDXComponent=!0;const ZZn={toc:[]};function bZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}bZn.isMDXComponent=!0;const NZn={toc:[]};function zZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}zZn.isMDXComponent=!0;const AZn={toc:[]};function WZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}WZn.isMDXComponent=!0;const RZn={toc:[]};function SZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}SZn.isMDXComponent=!0;const IZn={toc:[]};function PZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}PZn.isMDXComponent=!0;const EZn={toc:[]};function BZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}BZn.isMDXComponent=!0;const GZn={toc:[]};function OZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}OZn.isMDXComponent=!0;const FZn={toc:[]};function UZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}UZn.isMDXComponent=!0;const qZn={toc:[]};function VZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}VZn.isMDXComponent=!0;const jZn={toc:[]};function QZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}QZn.isMDXComponent=!0;const HZn={toc:[]};function $Zn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}$Zn.isMDXComponent=!0;const YZn={toc:[]};function KZn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZn,e,{components:n,mdxType:"MDXLayout"}))}KZn.isMDXComponent=!0;const JZn={toc:[]};function tbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}tbn.isMDXComponent=!0;const nbn={toc:[]};function ebn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}ebn.isMDXComponent=!0;const obn={toc:[]};function pbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}pbn.isMDXComponent=!0;const rbn={toc:[]};function sbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}sbn.isMDXComponent=!0;const cbn={toc:[]};function ibn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}ibn.isMDXComponent=!0;const abn={toc:[]};function lbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}lbn.isMDXComponent=!0;const ubn={toc:[]};function mbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}mbn.isMDXComponent=!0;const dbn={toc:[]};function hbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}hbn.isMDXComponent=!0;const kbn={toc:[]};function ybn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}ybn.isMDXComponent=!0;const fbn={toc:[]};function Mbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Mbn.isMDXComponent=!0;const Dbn={toc:[]};function _bn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}_bn.isMDXComponent=!0;const Xbn={toc:[]};function wbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}wbn.isMDXComponent=!0;const gbn={toc:[]};function Tbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Tbn.isMDXComponent=!0;const xbn={toc:[]};function Cbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Cbn.isMDXComponent=!0;const vbn={toc:[]};function Lbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Lbn.isMDXComponent=!0;const Zbn={toc:[]};function bbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}bbn.isMDXComponent=!0;const Nbn={toc:[]};function zbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}zbn.isMDXComponent=!0;const Abn={toc:[]};function Wbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}Wbn.isMDXComponent=!0;const Rbn={toc:[]};function Sbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}Sbn.isMDXComponent=!0;const Ibn={toc:[]};function Pbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ibn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}Pbn.isMDXComponent=!0;const Ebn={toc:[]};function Bbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ebn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}Bbn.isMDXComponent=!0;const Gbn={toc:[]};function Obn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}Obn.isMDXComponent=!0;const Fbn={toc:[]};function Ubn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}Ubn.isMDXComponent=!0;const qbn={toc:[]};function Vbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}Vbn.isMDXComponent=!0;const jbn={toc:[]};function Qbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Qbn.isMDXComponent=!0;const Hbn={toc:[]};function $bn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}$bn.isMDXComponent=!0;const Ybn={toc:[]};function Kbn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ybn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}Kbn.isMDXComponent=!0;const Jbn={toc:[]};function tNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}tNn.isMDXComponent=!0;const nNn={toc:[]};function eNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}eNn.isMDXComponent=!0;const oNn={toc:[]};function pNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}pNn.isMDXComponent=!0;const rNn={toc:[]};function sNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}sNn.isMDXComponent=!0;const cNn={toc:[]};function iNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}iNn.isMDXComponent=!0;const aNn={toc:[]};function lNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}lNn.isMDXComponent=!0;const uNn={toc:[]};function mNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}mNn.isMDXComponent=!0;const dNn={toc:[]};function hNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}hNn.isMDXComponent=!0;const kNn={toc:[]};function yNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}yNn.isMDXComponent=!0;const fNn={toc:[]};function MNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}MNn.isMDXComponent=!0;const DNn={toc:[]};function _Nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}_Nn.isMDXComponent=!0;const XNn={toc:[]};function wNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}wNn.isMDXComponent=!0;const gNn={toc:[]};function TNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}TNn.isMDXComponent=!0;const xNn={toc:[]};function CNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}CNn.isMDXComponent=!0;const vNn={toc:[]};function LNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}LNn.isMDXComponent=!0;const ZNn={toc:[]};function bNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}bNn.isMDXComponent=!0;const NNn={toc:[]};function zNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}zNn.isMDXComponent=!0;const ANn={toc:[]};function WNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}WNn.isMDXComponent=!0;const RNn={toc:[]};function SNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}SNn.isMDXComponent=!0;const INn={toc:[]};function PNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},INn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}PNn.isMDXComponent=!0;const ENn={toc:[]};function BNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ENn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}BNn.isMDXComponent=!0;const GNn={toc:[]};function ONn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}ONn.isMDXComponent=!0;const FNn={toc:[]};function UNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}UNn.isMDXComponent=!0;const qNn={toc:[]};function VNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}VNn.isMDXComponent=!0;const jNn={toc:[]};function QNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}QNn.isMDXComponent=!0;const HNn={toc:[]};function $Nn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}$Nn.isMDXComponent=!0;const YNn={toc:[]};function KNn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}KNn.isMDXComponent=!0;const JNn={toc:[]};function tzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}tzn.isMDXComponent=!0;const nzn={toc:[]};function ezn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}ezn.isMDXComponent=!0;const ozn={toc:[]};function pzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}pzn.isMDXComponent=!0;const rzn={toc:[]};function szn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}szn.isMDXComponent=!0;const czn={toc:[]};function izn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}izn.isMDXComponent=!0;const azn={toc:[]};function lzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}lzn.isMDXComponent=!0;const uzn={toc:[]};function mzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}mzn.isMDXComponent=!0;const dzn={toc:[]};function hzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}hzn.isMDXComponent=!0;const kzn={toc:[]};function yzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}yzn.isMDXComponent=!0;const fzn={toc:[]};function Mzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}Mzn.isMDXComponent=!0;const Dzn={toc:[]};function _zn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}_zn.isMDXComponent=!0;const Xzn={toc:[]};function wzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}wzn.isMDXComponent=!0;const gzn={toc:[]};function Tzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}Tzn.isMDXComponent=!0;const xzn={toc:[]};function Czn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}Czn.isMDXComponent=!0;const vzn={toc:[]};function Lzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}Lzn.isMDXComponent=!0;const Zzn={toc:[]};function bzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}bzn.isMDXComponent=!0;const Nzn={toc:[]};function zzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}zzn.isMDXComponent=!0;const Azn={toc:[]};function Wzn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Wzn.isMDXComponent=!0;const Rzn={toc:[]};function Szn(t){let{components:n,...e}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}function Izn(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}Szn.isMDXComponent=!0},9322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(1947),r=e(8698);const s="toggle_S_IX",c="collapsed_wdUB",i="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@preview"===n}))}),[n]),h=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),k=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@defaultValue"===n}))}),[n]),y=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),f=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(s,e&&c),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:i},h.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),k&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,k.content.map((t=>t.text)).join(""))),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:y.contentId})),f&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:f.contentId})))}},1930:(t,n,e)=>{e.d(n,{Z:()=>Ot});var o=e(2784),p=e(7390),r=e(6835),s=e(68),c=e(6277),i=e(8569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,s.s2)();return o.createElement("div",{className:(0,c.Z)(i.Z.codeBlockContent,a.codeBlock,e&&a.highlight,p&&a.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(i.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:i.Z.codeBlockLines,style:d},n)),l&&o.createElement("div",{className:i.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(9318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(a.codeBlockContainer,"language-typescript")},n)}var k=e(9817);function y(t){let{children:n,type:e,to:p,id:r,tooltip:c}=t;const i=(0,s.Ld)(e);return p?o.createElement(k.Z,(0,l.Z)({id:r,to:p,"data-tooltip":c},i),n):o.createElement("span",(0,l.Z)({id:r},i),n)}let f,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[f.None]:a.none,[f.Angle]:a.angle,[f.Curly]:a.curly,[f.Square]:a.square,[f.Parentheses]:a.parentheses};function _(t){let{children:n,type:e,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,c.Z)(a.list,D[e??f.None])},o.createElement("span",{className:(0,c.Z)(a.elements,p!==M.Comma&&a.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:a.element},t)))))}var X=e(8617);function w(t){var n;let{type:e}=t;const p=(0,X.RU)(e.project),r=null==p?void 0:p[e.id],s=e.externalUrl??(0,X.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(y,{to:s,type:s?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(_,{type:f.Angle},e.typeArguments.map(((t,n)=>o.createElement(E,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(y,{type:"keyword"},n.name)}function T(t){let{type:n}=t;return n.elements?o.createElement(_,{type:f.Square},n.elements.map(((t,n)=>o.createElement(E,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function x(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.elementType}),"[]")}function C(t){let{type:n}=t;return o.createElement(_,{type:f.Parentheses,separator:M.Pipe},n.types.map(((t,n)=>o.createElement(E,{key:n,type:t}))))}function v(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(y,{type:p},e)}function L(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,n.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(E,{type:n.targetType}))}function Z(t){let{type:n}=t;const e=(0,X.in)();return o.createElement($,{reflection:e(n.declaration)})}function b(t){let{type:n}=t;return o.createElement(_,{type:f.Parentheses,separator:M.Ampersand},n.types.map(((t,n)=>o.createElement(E,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(E,{key:n,type:e}),"}",o.createElement(y,{type:"string"},p))})),o.createElement(y,{type:"string"},"`"))}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(E,{type:n.queryType}))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(E,{type:n.extendsType})," ? ",o.createElement(E,{type:n.trueType})," : ",o.createElement(E,{type:n.falseType}))}function W(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},n.name))}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(E,{type:n.objectType}),"[",o.createElement(E,{type:n.indexType}),"]")}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},n.operator," "),o.createElement(E,{type:n.target}))}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(_,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},n.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(E,{type:n.parameterType}),"]: ",o.createElement(E,{type:n.templateType}))))}function P(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(E,{type:n.element}))}function E(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return S;case"conditional":return A;case"reflection":return Z;case"query":return z;case"named-tuple-member":return P;case"union":return C;case"intrinsic":return g;case"literal":return v;case"reference":return w;case"predicate":return L;case"tuple":return T;case"array":return x;case"intersection":return b;case"inferred":return W;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function B(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function G(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(E,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},n.defaultValue)))}function O(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),n.varianceModifier&&o.createElement(y,{type:"keyword"},n.varianceModifier," "),o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(E,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(E,{type:n.default})))}function F(t){var n,e;let{reflection:r,flags:s}=t;const c=(0,X.in)(),i="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(B,{flags:s??r.flags,explicitAccessModifier:!i}),r.kind===p.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:r.overwrites.externalUrl??(0,X.Gr)(c(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},r.type.name)):i?"":o.createElement(y,{type:"function"},r.name),!(null==(n=r.typeParameter)||!n.length)&&o.createElement(_,{type:f.Angle},r.typeParameter.map((t=>o.createElement(O,{key:t.id,reflection:c(t)})))),null!=(e=r.parameters)&&e.length?o.createElement(_,{type:f.Parentheses},r.parameters.map((t=>o.createElement(G,{key:t,reflection:c(t)})))):"()",r.type&&o.createElement(o.Fragment,null,i?" => ":": ",o.createElement(E,{type:r.type})))}function U(t){let{reflection:n}=t;return o.createElement(G,{reflection:n})}const q={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function V(t){var n,e,p;let{reflection:r}=t;const s=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:r.flags}),o.createElement(y,{type:"keyword"},q[r.kind]," "),o.createElement(y,{type:"class-name"},r.name),!(null==(n=r.typeParameters)||!n.length)&&o.createElement(_,{type:f.Angle},r.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:s(t)}))))," ",!(null==(e=r.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(_,null,r.extendedTypes.map(((t,n)=>o.createElement(E,{key:n,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(_,null,r.implementedTypes.map(((t,n)=>o.createElement(E,{key:n,type:t}))))))}function j(t){let{reflection:n}=t;const e=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(B,{flags:n.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},n.name),n.typeParameters&&o.createElement(_,{type:f.Angle},n.typeParameters.map((t=>o.createElement(O,{key:t.id,reflection:e(t)}))))," = ",o.createElement(E,{type:n.type}))}function Q(t){let{reflection:n}=t;const e=(0,X.in)();return n.signatures?o.createElement(F,{reflection:n.signatures[0]}):n.children?o.createElement(_,{type:f.Curly},n.children.map((t=>o.createElement($,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function H(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(F,{reflection:p})}function $(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return V;case p.W.Constructor:return F;case p.W.Property:return U;case p.W.Method:return H;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return Q;case p.W.TypeParameter:return O;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return j;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function Y(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${a.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,c.Z)(a.line,"token-line")},n),o.createElement("br",null))}var K=e(9322),J=e(1947);function tt(t){let{parameters:n}=t;const e=(0,X.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(O,{reflection:t})),o.createElement(J.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,X.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(J.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const r=(0,X.in)(),s=(0,o.useMemo)((()=>n.map(r)),[n]),[c,i]=(0,o.useState)(s[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,s.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===c.id,onClick:n.length>1?()=>i(t):void 0},o.createElement(Y,null,o.createElement(F,{reflection:t,flags:e})))))),o.createElement(K.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(nt,{parameters:c.parameters}))}var ot=e(7708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",st="filters_z1iC",ct="icon_ROIU";function it(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",rt)},o.createElement("div",{className:(0,c.Z)("col",st)},o.createElement(it,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var lt=e(3181),ut=e(3851),mt=e(4126),dt=e(2424),ht=e(2244),kt=e(4155);function yt(t){return function(t){var n;return(null==(n=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:n}=t;return!!n&&"object"==typeof n&&"value"in n}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:n.filter(Boolean))??[]}(t).map((t=>{let{props:{value:n,label:e,attributes:o,default:p}}=t;return{value:n,label:e,attributes:o,default:p}}))}function ft(t){const{values:n,children:e}=t;return(0,o.useMemo)((()=>{const t=n??yt(e);return function(t){const n=(0,ht.l)(t,((t,n)=>t.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[n,e])}function Mt(t){let{value:n,tabValues:e}=t;return e.some((t=>t.value===n))}function Dt(t){let{queryString:n=!1,groupId:e}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:n=!1,groupId:e}=t;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const n=new URLSearchParams(p.location.search);n.set(r,t),p.replace({...p.location,search:n.toString()})}),[r,p])]}function _t(t){const{defaultValue:n,queryString:e=!1,groupId:p}=t,r=ft(t),[s,c]=(0,o.useState)((()=>function(t){let{defaultValue:n,tabValues:e}=t;if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!Mt({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=e.find((t=>t.default))??e[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:r}))),[i,a]=Dt({queryString:e,groupId:p}),[l,u]=function(t){let{groupId:n}=t;const e=function(t){return t?`docusaurus.tab.${t}`:null}(n),[p,r]=(0,kt.Nk)(e);return[p,(0,o.useCallback)((t=>{e&&r.set(t)}),[e,r])]}({groupId:p}),m=(()=>{const t=i??l;return Mt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((t=>{if(!Mt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var Xt=e(9741);const wt="tabList_M0Dn",gt="tabItem_ysIP";function Tt(t){let{className:n,block:e,selectedValue:p,selectValue:r,tabValues:s}=t;const i=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const n=t.currentTarget,e=i.indexOf(n),o=s[e].value;o!==p&&(a(n),r(o))},m=t=>{var n;let e=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const n=i.indexOf(t.currentTarget)+1;e=i[n]??i[0];break}case"ArrowLeft":{const n=i.indexOf(t.currentTarget)-1;e=i[n]??i[i.length-1];break}}null==(n=e)||n.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":e},n)},s.map((t=>{let{value:n,label:e,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===n?0:-1,"aria-selected":p===n,key:n,ref:t=>i.push(t),onKeyDown:m,onClick:u},r,{className:(0,c.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===n})}),e??n)})))}function xt(t){let{lazy:n,children:e,selectedValue:p}=t;const r=(Array.isArray(e)?e:[e]).filter(Boolean);if(n){const t=r.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,n)=>(0,o.cloneElement)(t,{key:n,hidden:t.props.value!==p}))))}function Ct(t){const n=_t(t);return o.createElement("div",{className:(0,c.Z)("tabs-container",wt)},o.createElement(Tt,(0,l.Z)({},t,n)),o.createElement(xt,(0,l.Z)({},t,n)))}function vt(t){const n=(0,Xt.Z)();return o.createElement(Ct,(0,l.Z)({key:String(n)},t))}const Lt="tabItem_OMyP";function Zt(t){let{children:n,hidden:e,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,c.Z)(Lt,p),hidden:e},n)}function bt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(Ot,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(Ot,{reflection:t})))))}function Nt(t){let{group:n,project:e}=t;const p=(0,lt.TH)(),r=(0,X.RU)(e),s=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],r=[];for(const s of t.children){const t=n[s];t&&(0,ot.It)(e,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,c))).filter((t=>!!t))),[n,r,c]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const n of i)if(n.anchors.includes(t))return}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:n.title},n.title),i.length>1?o.createElement(vt,{groupId:n.title},i.map((t=>o.createElement(Zt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(bt,{group:t}))))):o.createElement(bt,{group:i[0]}))}function zt(t){var n,e,p,r,s;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=c.sources)||null==(e=n[0])?void 0:e.url},o.createElement(Y,null,o.createElement($,{reflection:c})))),o.createElement(at,{kind:c.kind},o.createElement(K.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),(null==(r=c.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:c.signatures})),null==(s=c.groups)?void 0:s.map((t=>o.createElement(Nt,{group:t,key:t.title,project:c.project}))))}function At(t){var n;let{reflection:e,headless:p}=t;const r=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(ut.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:r,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(w,{type:e.overwrites}))))}function Wt(t){var n,e;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement(Y,null,o.createElement(U,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:p.inheritedFrom}))))}function Rt(t){var n,e,p;let{reflection:r}=t;const s=(0,X.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=r.sources)||null==(e=n[0])?void 0:e.url},o.createElement(Y,null,o.createElement($,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>s[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ot,{key:t.id,reflection:t})))))))}var St=e(8128);function It(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(St.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(at,{kind:e.kind},o.createElement(K.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(Nt,{group:t,key:t.title,project:e.project}))))}const Pt="cardContainer_ybwo",Et="cardTitle_Ehd1",Bt="cardDescription_b6wr";function Gt(t){let{reflection:n}=t;const e=(0,X.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(k.Z,{href:t.href,className:(0,c.Z)("card padding--lg",Pt)},o.createElement("h2",{className:(0,c.Z)("text--truncate",Et)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",Bt)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function Ot(t){let{reflection:n,headless:e=!1}=t;const r=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return Gt;case p.W.Module:return It;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return zt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Wt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Rt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(r,{reflection:n,headless:e})}},7390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,n,e)=>{e.d(n,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:n,lookup:e,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:r}},n)}function s(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function i(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function a(t){if(t)return t.href}},68:(t,n,e)=>{e.d(n,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=e(2784),p=e(822);const r=o.createContext(null);function s(t){let{children:n}=t;const e=(0,p.p)(),s=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(r.Provider,{value:s},n)}function c(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return{className:`token ${t}`,style:n[t]??n.plain}}function i(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return n[t]??n.plain}},7708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(2784),p=e(1263),r=e(9741);const s="api-filters",c=p.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=o.createContext([i,()=>{}]);function l(t){let{children:n}=t;const[e,p]=(0,o.useState)(i),c=(0,r.Z)();return o.createElement(a.Provider,{value:[e,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(a)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!n.inheritedFrom;return!(!t.inherited&&r)}},5192:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>u});var o=e(7896),p=(e(2784),e(876)),r=e(2072),s=e(2665);const c={sidebar_position:10,slug:"/transitions"},i="Transitions",a={unversionedId:"getting-started/transitions",id:"getting-started/transitions",title:"Transitions",description:"Transitions allow you to customize the way scenes transition from one into",source:"@site/docs/getting-started/transitions.mdx",sourceDirName:"getting-started",slug:"/transitions",permalink:"/docs/transitions",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/transitions.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:10,frontMatter:{sidebar_position:10,slug:"/transitions"},sidebar:"docs",previous:{title:"Time Events",permalink:"/docs/time-events"},next:{title:"Logging",permalink:"/docs/logging"}},l={},u=[{value:"Before we start",id:"before-we-start",level:2},{value:"Pre-made transitions",id:"pre-made-transitions",level:2},{value:"<code>slideTransition</code>",id:"slidetransition",level:3},{value:"<code>zoomInTransition</code>",id:"zoomintransition",level:3},{value:"<code>zoomOutTransition</code>",id:"zoomouttransition",level:3},{value:"<code>fadeTransition</code>",id:"fadetransition",level:3},{value:"Custom transitions",id:"custom-transitions",level:2},{value:"Animate when transitioning",id:"animate-when-transitioning",level:2}],m={toc:u};function d(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"transitions"},"Transitions"),(0,p.kt)("p",null,"Transitions allow you to customize the way scenes transition from one into\nanother. A transition is an animation performed at the beginning of the scene.\nIt can modify the context of both the current and the previous scene."),(0,p.kt)("h2",{id:"before-we-start"},"Before we start"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col"},(0,p.kt)("p",null,"Make sure your project contains at least two scenes. In this example, we've\nprepared ",(0,p.kt)("inlineCode",{parentName:"p"},"firstScene.tsx")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"secondScene.tsx"),", and configured our project to\ndisplay one after the other. We'll be setting up our transitions in the second\nscene."),(0,p.kt)("p",null,"Make sure to put something different in both scenes to easier see the\ntransitions.")),(0,p.kt)("div",{className:"col"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre"},"my-animation/\n\u2514\u2500 src/\n   \u251c\u2500 scenes/\n   \u2502  \u251c\u2500 firstScene.tsx\n   \u2502  \u2514\u2500 secondScene.tsx\n   \u2514\u2500 project.ts\n")))),(0,p.kt)("h2",{id:"pre-made-transitions"},"Pre-made transitions"),(0,p.kt)("p",null,"Motion Canvas comes with a set of common transitions in a form of easy-to-use\ngenerators. To use them, ",(0,p.kt)("inlineCode",{parentName:"p"},"yield*")," the transition generator at the beginning of\nthe new scene:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/scenes/secondScene.tsx"',title:'"src/scenes/secondScene.tsx"'},"export default makeScene2D(function* (view) {\n  // set up the scene:\n  view.add(/* your nodes here */);\n\n  // perform a slide transition to the left:\n  yield* slideTransition(Direction.Left);\n\n  // proceed with the animation\n  yield* waitFor(3);\n});\n")),(0,p.kt)(s.Z,{small:!0,name:"transitions",link:"transitions-second",mdxType:"AnimationPlayer"}),(0,p.kt)("admonition",{type:"caution"},(0,p.kt)("p",{parentName:"admonition"},"Make sure to add nodes to the view before yielding the transition generator.\nOtherwise, your scene will remain empty until the transition ends.")),(0,p.kt)("p",null,"All available transitions are listed below:"),(0,p.kt)("h3",{id:"slidetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"slideTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#slideTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomintransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomInTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomInTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomouttransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomOutTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomOutTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"fadetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"fadeTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#fadeTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"custom-transitions"},"Custom transitions"),(0,p.kt)("p",null,"You can use the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/transitions#useTransition"},(0,p.kt)("inlineCode",{parentName:"a"},"useTransition"))," function\nto implement custom transitions. It allows you to specify two callbacks that\nwill modify the contexts of the current and previous scene respectively. The\nvalue it returns is a callback that you need to call once you finish the\ntransition."),(0,p.kt)("p",null,"The transition template looks as follows:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// set up the transition\nconst endTransition = useTransition(\n  currentContext => {\n    // modify the context of the current scene\n  },\n  previousContext => {\n    // modify the context of the previous scene\n  },\n);\n\n// perform animations\n\n// finish the transition\nendTransition();\n")),(0,p.kt)("p",null,"Here's how you could implement a simple slide transition:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export function* slideTransition(\n  direction: Direction = Direction.Top,\n  duration = 0.6,\n): ThreadGenerator {\n  const size = useScene().getSize();\n  const position = size.getOriginOffset(direction).scale(2);\n  const previousPosition = Vector2.createSignal();\n  const currentPosition = Vector2.createSignal(position);\n\n  // set up the transition\n  const endTransition = useTransition(\n    // modify the context of the current scene\n    ctx => ctx.translate(currentPosition.x(), currentPosition.y()),\n    // modify the context of the previous scene\n    ctx => ctx.translate(previousPosition.x(), previousPosition.y()),\n  );\n\n  // perform animations\n  yield* all(\n    previousPosition(position.scale(-1), duration),\n    currentPosition(Vector2.zero, duration),\n  );\n\n  // finish the transition\n  endTransition();\n}\n")),(0,p.kt)("h2",{id:"animate-when-transitioning"},"Animate when transitioning"),(0,p.kt)("p",null,"By default, Motion Canvas will transition to the next scene once the generator\nof the current scene has reached the end. In this case, the scene will freeze\nfor the duration of the transition. You can use the\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#finishScene"},(0,p.kt)("inlineCode",{parentName:"a"},"finishScene"))," function to trigger the transition\nearly, allowing the animation to continue while transitioning:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  yield* animationOne();\n  // trigger the transition early:\n  finishScene();\n  // continue animating:\n  yield* animationTwo();\n});\n")))}d.isMDXComponent=!0}}]);