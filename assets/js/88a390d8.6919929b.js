"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[6076],{30876:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(2784);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=p(t),m=o,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||i;return t?a.createElement(h,l(l({ref:n},d),{},{components:t})):a.createElement(h,l({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,l=new Array(i);l[0]=m;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[u]="string"==typeof e?e:o,l[1]=r;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},82009:(e,n,t)=>{t.d(n,{Z:()=>l});var a=t(2784),o=t(6277);const i="tabItem_OMyP";function l(e){let{children:n,hidden:t,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(i,l),hidden:t},n)}},77336:(e,n,t)=>{t.d(n,{Z:()=>N});var a=t(7896),o=t(2784),i=t(6277),l=t(24126),r=t(53181),s=t(32424),p=t(42244),d=t(24155);function u(e){return function(e){return o.Children.map(e,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:o}}=e;return{value:n,label:t,attributes:a,default:o}}))}function c(e){const{values:n,children:t}=e;return(0,o.useMemo)((()=>{const e=n??u(t);return function(e){const n=(0,p.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function h(e){let{queryString:n=!1,groupId:t}=e;const a=(0,r.k6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,s._X)(i),(0,o.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(a.location.search);n.set(i,e),a.replace({...a.location,search:n.toString()})}),[i,a])]}function k(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,i=c(e),[l,r]=(0,o.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:i}))),[s,p]=h({queryString:t,groupId:a}),[u,k]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,i]=(0,d.Nk)(t);return[a,(0,o.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:a}),f=(()=>{const e=s??u;return m({value:e,tabValues:i})?e:null})();(0,o.useLayoutEffect)((()=>{f&&r(f)}),[f]);return{selectedValue:l,selectValue:(0,o.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);r(e),p(e),k(e)}),[p,k,i]),tabValues:i}}var f=t(89741);const g="tabList_M0Dn",v="tabItem_ysIP";function b(e){let{className:n,block:t,selectedValue:r,selectValue:s,tabValues:p}=e;const d=[],{blockElementScrollPositionUntilNextRender:u}=(0,l.o5)(),c=e=>{const n=e.currentTarget,t=d.indexOf(n),a=p[t].value;a!==r&&(u(n),s(a))},m=e=>{var n;let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=d.indexOf(e.currentTarget)+1;t=d[n]??d[0];break}case"ArrowLeft":{const n=d.indexOf(e.currentTarget)-1;t=d[n]??d[d.length-1];break}}null==(n=t)||n.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},n)},p.map((e=>{let{value:n,label:t,attributes:l}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,key:n,ref:e=>d.push(e),onKeyDown:m,onClick:c},l,{className:(0,i.Z)("tabs__item",v,null==l?void 0:l.className,{"tabs__item--active":r===n})}),t??n)})))}function y(e){let{lazy:n,children:t,selectedValue:a}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===a));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function w(e){const n=k(e);return o.createElement("div",{className:(0,i.Z)("tabs-container",g)},o.createElement(b,(0,a.Z)({},e,n)),o.createElement(y,(0,a.Z)({},e,n)))}function N(e){const n=(0,f.Z)();return o.createElement(w,(0,a.Z)({key:String(n)},e))}},5944:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>p,toc:()=>u});var a=t(7896),o=(t(2784),t(30876)),i=t(77336),l=t(82009);const r={sidebar_position:3,slug:"/spline"},s="Spline",p={unversionedId:"components/spline",id:"components/spline",title:"Spline",description:"The Spline component allows us to draw and animate smooth curves",source:"@site/docs/components/spline.mdx",sourceDirName:"components",slug:"/spline",permalink:"/docs/spline",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/components/spline.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/spline"},sidebar:"docs",previous:{title:"LaTeX",permalink:"/docs/nodes"},next:{title:"Custom Components",permalink:"/docs/custom-components"}},d={},u=[{value:"Defining control points",id:"defining-control-points",level:2},{value:"Using the <code>points</code> property",id:"using-the-points-property",level:3},{value:"Using <code>Knot</code> nodes",id:"using-knot-nodes",level:3},{value:"Mirrored handles",id:"mirrored-handles",level:4},{value:"Broken knots",id:"broken-knots",level:4},{value:"Blending between user handles and calculated handles",id:"blending-between-user-handles-and-calculated-handles",level:4},{value:"Animating splines",id:"animating-splines",level:2},{value:"Drawing splines",id:"drawing-splines",level:3},{value:"Animating the knots of a spline",id:"animating-the-knots-of-a-spline",level:3},{value:"Animating objects along a spline",id:"animating-objects-along-a-spline",level:3}],c={toc:u};function m(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"spline"},"Spline"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d/lib/scenes';\nimport {Spline, Knot} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {waitFor} from '@motion-canvas/core/lib/flow';\n\nexport default makeScene2D(function* (view) {\n  const spline = createRef<Spline>();\n\n  view.add(\n    <Spline ref={spline} lineWidth={4} fill={'#e13238'} closed>\n      <Knot position={[-120, -30]} startHandle={[0, 70]} />\n      <Knot\n        position={[0, -50]}\n        startHandle={[-40, -60]}\n        endHandle={[40, -60]}\n      />\n      <Knot position={[120, -30]} startHandle={[0, -70]} />\n      <Knot position={[0, 100]} startHandle={[5, 0]} />\n    </Spline>,\n  );\n\n  yield* spline().scale(0.9, 0.6).to(1, 0.4);\n});\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,o.kt)("inlineCode",{parentName:"a"},"Spline"))," component allows us to draw and animate smooth curves\nthrough a series of control points."),(0,o.kt)("h2",{id:"defining-control-points"},"Defining control points"),(0,o.kt)("p",null,"In order to draw a spline, we need to specify what its knots are. The ",(0,o.kt)("inlineCode",{parentName:"p"},"Spline"),"\ncomponent provides multiple ways of specifying these control points which we\nwill go through in this section."),(0,o.kt)("h3",{id:"using-the-points-property"},"Using the ",(0,o.kt)("inlineCode",{parentName:"h3"},"points")," property"),(0,o.kt)("p",null,"The easiest way to define a spline's knots is by passing an array of positions\nvia the spline's ",(0,o.kt)("inlineCode",{parentName:"p"},"points")," property. Each point will be treated as the position\nof one of the spline's knots."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  view.add(\n    <Spline\n      lineWidth={6}\n      stroke={'lightseagreen'}\n      points={[\n        [-300, 0],\n        [-150, -100],\n        [150, 100],\n        [300, 0],\n      ]}\n    />,\n  );\n});\n")),(0,o.kt)("p",null,"The result is a curve that smoothly passes through each of the provided points."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Remember to provide a ",(0,o.kt)("inlineCode",{parentName:"p"},"lineWidth")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"stroke")," to the spline as it won't be\nvisible otherwise. Alternatively, you may also specify a ",(0,o.kt)("inlineCode",{parentName:"p"},"fill")," color.")),(0,o.kt)("p",null,"We can alter the shape of the curve by passing a value between ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," to\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"smoothness")," property."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const spline = createRef<Spline>();\n\n  view.add(\n    <Spline\n      ref={spline}\n      lineWidth={6}\n      stroke={'lightseagreen'}\n      smoothness={0.4}\n      points={[\n        [-300, 0],\n        [-150, -100],\n        [150, 100],\n        [300, 0],\n      ]}\n    />,\n  );\n\n  yield* spline().smoothness(0, 1).to(1, 1).to(0.4, 1);\n});\n")),(0,o.kt)("p",null,"While defining the knots in this way is very simple and can be enough for simple\ncurves, there is an important limitation to this method: we cannot alter the\nposition of the knot's handles. Instead, the handles get calculated\nautomatically so that the curve passes smoothly through each point without any\nsharp or sudden turns."),(0,o.kt)("admonition",{title:"Fun fact",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The auto handles are calculated based on the positions of a knot's two\nneighboring knots. A spline that calculates the handle positions of its knots in\nthis way is called a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline"},"Cardinal Spline"),".")),(0,o.kt)("p",null,"Let's look at the second way of defining knots to learn how we can more finely\ncontrol the shape of our spline."),(0,o.kt)("h3",{id:"using-knot-nodes"},"Using ",(0,o.kt)("inlineCode",{parentName:"h3"},"Knot")," nodes"),(0,o.kt)("p",null,"The second way of defining knots is by\u2014fittingly\u2014using the ",(0,o.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},"Knot")," node.\nThe same spline from above can also be written like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  view.add(\n    <Spline lineWidth={6} stroke={'lightseagreen'}>\n      <Knot position={[-300, 0]} />\n      <Knot position={[-150, -100]} />\n      <Knot position={[150, 100]} />\n      <Knot position={[300, 0]} />\n    </Spline>,\n  );\n});\n")),(0,o.kt)("p",null,"As you can see, we get the exact same shape we did when using the ",(0,o.kt)("inlineCode",{parentName:"p"},"points"),"\nproperty. The advantage of defining the knots with ",(0,o.kt)("inlineCode",{parentName:"p"},"Knot")," nodes is that it also\nallows us to control the positions of each knot's handles via the ",(0,o.kt)("inlineCode",{parentName:"p"},"startHandle"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"endHandle")," properties."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  view.add(\n    <Spline lineWidth={6} stroke={'lightseagreen'}>\n      <Knot position={[-300, 0]} />\n      <Knot position={[-150, -100]} endHandle={[-100, 0]} />\n      <Knot position={[150, 100]} startHandle={[100, 0]} />\n      <Knot position={[300, 0]} />\n    </Spline>,\n  );\n});\n")),(0,o.kt)("p",null,"Note that handle positions are relative to the knot's position."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Similar to using the ",(0,o.kt)("inlineCode",{parentName:"p"},"points")," property, if no explicit handles are provided for\na knot, the handles get calculated automatically so that the curve smoothly\npasses through the knot.")),(0,o.kt)("h4",{id:"mirrored-handles"},"Mirrored handles"),(0,o.kt)("p",null,"Handles are mirrored by default. This means that when we provide only one of the\nhandles of a knot, the other one will implicitly be set to a flipped version of\nthe provided handle."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<Knot startHandle={[100, 50]} />\n// Is the same as\n<Knot startHandle={[100, 50]} endHandle={[-100, -50]} />\n")),(0,o.kt)("h4",{id:"broken-knots"},"Broken knots"),(0,o.kt)("p",null,"Providing both ",(0,o.kt)("inlineCode",{parentName:"p"},"startHandle")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"endHandle")," results in a so-called ",(0,o.kt)("strong",{parentName:"p"},"broken\nknot"),". Broken knots are very useful because they allow us to add sharp corners\nto our spline."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  view.add(\n    <Spline lineWidth={16} stroke={'lightseagreen'} closed>\n      <Knot position={[-50, -80]} startHandle={[0, 20]} endHandle={[90, 0]} />\n      <Knot position={[50, 0]} />\n      <Knot position={[-50, 80]} startHandle={[90, 0]} endHandle={[0, -20]} />\n    </Spline>,\n  );\n});\n")),(0,o.kt)("h4",{id:"blending-between-user-handles-and-calculated-handles"},"Blending between user handles and calculated handles"),(0,o.kt)("p",null,"By default, the auto-calculated handles get ignored when at least one of the\n",(0,o.kt)("inlineCode",{parentName:"p"},"startHandle")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"endHandle")," properties is provided. However, it is possible to\nblend between user-provided and auto-calculated handles by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"auto"),"\nproperty."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"{6,13}","{6,13}":!0},"<Spline lineWidth={16} stroke={'lightseagreen'} closed>\n  <Knot\n    position={[-50, -80]}\n    startHandle={[0, 20]}\n    endHandle={[90, 0]}\n    auto={0.5}\n  />\n  <Knot position={[50, 0]} />\n  <Knot\n    position={[-50, 80]}\n    startHandle={[90, 0]}\n    endHandle={[0, -20]}\n    auto={0.5}\n  />\n</Spline>\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"auto")," should be a value between ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," and represents the percentage of\nhow much to blend between the user-provided handles (",(0,o.kt)("inlineCode",{parentName:"p"},"0"),") and auto-calculated\nhandles (",(0,o.kt)("inlineCode",{parentName:"p"},"1"),")."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("inlineCode",{parentName:"p"},"auto")," is a compound signal, which means you can specify ",(0,o.kt)("inlineCode",{parentName:"p"},"startHandleAuto")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"endHandleAuto")," to individually control the blend of each handle."),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"{5-6}","{5-6}":!0},"<Knot\n  position={[0, 0]}\n  startHandle={[-50, -50]}\n  endHandle={[30, 0]}\n  startHandleAuto={0.3}\n  endHandleAuto={0.8}\n/>\n"))),(0,o.kt)("p",null,"Since ",(0,o.kt)("inlineCode",{parentName:"p"},"auto")," is a signal, it can also be animated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const knots: Knot[] = [];\n\n  view.add(\n    <Spline lineWidth={16} stroke={'lightseagreen'} lineJoin={'round'} closed>\n      <Knot\n        ref={makeRef(knots, 0)}\n        position={[-50, -80]}\n        startHandle={[0, 20]}\n        endHandle={[90, 0]}\n      />\n      <Knot position={[50, 0]} />\n      <Knot\n        ref={makeRef(knots, 1)}\n        position={[-50, 80]}\n        startHandle={[90, 0]}\n        endHandle={[0, -20]}\n      />\n    </Spline>,\n  );\n\n  yield* all(...knots.map(knot => knot.auto(1, 1).to(0, 1)));\n});\n")),(0,o.kt)("h2",{id:"animating-splines"},"Animating splines"),(0,o.kt)("p",null,"While animating splines isn't too different from animating any other node, this\nsection aims to illustrate a few of the most common use cases."),(0,o.kt)("h3",{id:"drawing-splines"},"Drawing splines"),(0,o.kt)("p",null,"Similar to the ",(0,o.kt)("a",{parentName:"p",href:"/api/2d/components/Line"},(0,o.kt)("inlineCode",{parentName:"a"},"Line"))," component, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Spline")," node provides ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"end")," signals which allow us to control the segment of the curve that should be\nvisible. Both ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," are values between ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," and represent the\npercentage of the spline's arclength from which to start drawing from."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"{7-8}","{7-8}":!0},"<Spline\n  points={[\n    [-300, 0],\n    [-150, -100],\n    [150, 100],\n  ]}\n  start={0.4}\n  end={0.8}\n/>\n")),(0,o.kt)("p",null,"The example above would draw the spline starting at 40% of the spline's\narclength (",(0,o.kt)("inlineCode",{parentName:"p"},"start={0.4}"),") and draw it up until 80% of the spline's arclength\n(",(0,o.kt)("inlineCode",{parentName:"p"},"end={0.8}"),")."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"When using ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," in conjunction with ",(0,o.kt)("inlineCode",{parentName:"p"},"startOffset")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"endOffset"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," will be relative to the ",(0,o.kt)("em",{parentName:"p"},"remaining")," length of the spline after\ntaking the offset into account.")),(0,o.kt)("p",null,"We can then animate drawing a spline by tweening these properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const spline = createRef<Spline>();\n\n  view.add(\n    <Spline\n      ref={spline}\n      lineWidth={6}\n      stroke={'lightseagreen'}\n      points={[\n        [-300, 0],\n        [-150, -100],\n        [150, 100],\n        [300, 0],\n      ]}\n      end={0}\n    />,\n  );\n\n  yield* spline().end(1, 1.5);\n  yield* spline().start(1, 1.5).to(0.5, 1);\n  yield* spline().end(0.5, 1);\n  yield* all(spline().start(0, 1.5), spline().end(1, 1.5));\n});\n")),(0,o.kt)("h3",{id:"animating-the-knots-of-a-spline"},"Animating the knots of a spline"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Knot"),"s can be animated in much the same way as other components."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Animating a spline's knots is only possible when using the\n",(0,o.kt)("a",{parentName:"p",href:"#using-knot-nodes"},(0,o.kt)("inlineCode",{parentName:"a"},"Knot"))," component, not when using the ",(0,o.kt)("inlineCode",{parentName:"p"},"points")," property.")),(0,o.kt)("p",null,"Below are a few examples of interesting effects that can be achieved by\nanimating different properties of knots."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"You can think of ",(0,o.kt)("inlineCode",{parentName:"p"},"startHandle")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"endHandle")," as being the children of the\nKnot\u2014changing the knot's position, rotation and scale will also transform the\nhandles. The only exceptions are ",(0,o.kt)("inlineCode",{parentName:"p"},"auto")," handles which are unaffected by these\ntransformations.")),(0,o.kt)(i.Z,{mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"position",label:"Position",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const knotPositions: PossibleVector2[] = [\n    [-200, 0],\n    [-100, -80],\n    [0, 80],\n    [100, -80],\n    [200, 0],\n  ];\n  const knots: Knot[] = [];\n\n  view.add(\n    <Spline lineWidth={6} stroke={'lightseagreen'}>\n      {knotPositions.map((pos, i) => (\n        <Knot ref={makeRef(knots, i)} position={pos} />\n      ))}\n    </Spline>,\n  );\n\n  yield* all(\n    knots[1].position.y(80, 1).to(-80, 1),\n    knots[2].position.y(-80, 1).to(80, 1),\n    knots[3].position.y(80, 1).to(-80, 1),\n  );\n});\n"))),(0,o.kt)(l.Z,{value:"rotation",label:"Rotation",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const knot = createRef<Knot>();\n\n  view.add(\n    <Spline lineWidth={6} stroke={'lightseagreen'}>\n      <Knot position={[-100, 30]} />\n      <Knot ref={knot} position={[0, -50]} startHandle={[-70, 0]} />\n      <Knot position={[100, 30]} />\n    </Spline>,\n  );\n\n  yield* knot().rotation(360, 3, linear).to(0, 3);\n});\n"))),(0,o.kt)(l.Z,{value:"scale",label:"Scale",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const knot = createRef<Knot>();\n\n  view.add(\n    <Spline lineWidth={6} stroke={'lightseagreen'}>\n      <Knot position={[-100, 30]} />\n      <Knot ref={knot} position={[0, -50]} startHandle={[-70, 0]} />\n      <Knot position={[100, 30]} />\n    </Spline>,\n  );\n\n  yield* knot().scale(3, 2).to(0.2, 2).to(1, 1);\n});\n")))),(0,o.kt)("h3",{id:"animating-objects-along-a-spline"},"Animating objects along a spline"),(0,o.kt)("p",null,"Splines can be useful to model the path that an object should follow. You can\nuse the ",(0,o.kt)("inlineCode",{parentName:"p"},"getPointAtPercentage")," method to achieve this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"export default makeScene2D(function* (view) {\n  const spline = createRef<Spline>();\n  const progress = createSignal(0);\n\n  view.add(\n    <>\n      <Spline\n        ref={spline}\n        lineWidth={6}\n        stroke={'lightgray'}\n        points={[\n          [-300, 0],\n          [-150, -100],\n          [150, 100],\n          [300, 0],\n        ]}\n      />\n      <Rect\n        size={26}\n        fill={'lightseagreen'}\n        position={() => spline().getPointAtPercentage(progress()).position}\n        rotation={() =>\n          spline().getPointAtPercentage(progress()).tangent.degrees\n        }\n      />,\n    </>,\n  );\n\n  yield* progress(1, 2).to(0, 2);\n});\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"getPointAtPercentage")," method returns a ",(0,o.kt)("a",{parentName:"p",href:"/api/2d/curves/CurvePoint"},(0,o.kt)("inlineCode",{parentName:"a"},"CurvePoint"))," object\nwhich contains the position of the point that sits at the given percentage along\nthe spline's arclength as well as the point's tangent vector."))}m.isMDXComponent=!0}}]);